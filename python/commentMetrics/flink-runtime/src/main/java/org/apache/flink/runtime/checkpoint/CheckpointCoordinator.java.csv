# id;timestamp;commentText;codeText;commentWords;codeWords
CheckpointCoordinator -> public void shutdown();1430297241;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			_			_			timeoutTimer.cancel()__			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_				pending.discard()__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.dispose()__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,timeout,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,dispose,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1431459357;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			LOG.info("Stopping checkpoint coordinator jor job " + job)__			_			_			timer.cancel()__			_			_			if (jobStatusListener != null) {_				jobStatusListener.tell(PoisonPill.getInstance(), ActorRef.noSender())__				jobStatusListener = null__			}_			_			_			if (periodicScheduler != null) {_				periodicScheduler.cancel()__				periodicScheduler = null__			}_			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_				pending.discard()__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.dispose()__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,jor,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,actor,ref,no,sender,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,dispose,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1431459358;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			LOG.info("Stopping checkpoint coordinator for job " + job)__			_			_			timer.cancel()__			_			_			if (jobStatusListener != null) {_				jobStatusListener.tell(PoisonPill.getInstance(), ActorRef.noSender())__				jobStatusListener = null__			}_			_			_			if (periodicScheduler != null) {_				periodicScheduler.cancel()__				periodicScheduler = null__			}_			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_				pending.discard()__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.dispose()__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,actor,ref,no,sender,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,dispose,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1432052753;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			LOG.info("Stopping checkpoint coordinator for job " + job)__			_			_			timer.cancel()__			_			_			if (jobStatusListener != null) {_				jobStatusListener.tell(PoisonPill.getInstance(), ActorRef.noSender())__				jobStatusListener = null__			}_			_			_			if (periodicScheduler != null) {_				periodicScheduler.cancel()__				periodicScheduler = null__			}_			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.discard(userClassLoader, true)__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.dispose(userClassLoader)__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,actor,ref,no,sender,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,dispose,user,class,loader,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1432053122;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			LOG.info("Stopping checkpoint coordinator for job " + job)__			_			_			timer.cancel()__			_			_			if (jobStatusListener != null) {_				jobStatusListener.tell(PoisonPill.getInstance(), ActorRef.noSender())__				jobStatusListener = null__			}_			_			_			if (periodicScheduler != null) {_				periodicScheduler.cancel()__				periodicScheduler = null__			}_			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.discard(userClassLoader, true)__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.discard(userClassLoader)__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,actor,ref,no,sender,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,discard,user,class,loader,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1434095691;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			LOG.info("Stopping checkpoint coordinator for job " + job)__			_			_			timer.cancel()__			_			_			if (jobStatusListener != null) {_				jobStatusListener.tell(PoisonPill.getInstance(), ActorRef.noSender())__				jobStatusListener = null__			}_			_			_			if (periodicScheduler != null) {_				periodicScheduler.cancel()__				periodicScheduler = null__			}_			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.discard(userClassLoader, true)__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.discard(userClassLoader)__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,actor,ref,no,sender,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,discard,user,class,loader,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1435243086;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			LOG.info("Stopping checkpoint coordinator for job " + job)__			_			_			timer.cancel()__			_			_			if (jobStatusListener != null) {_				jobStatusListener.tell(PoisonPill.getInstance(), ActorRef.noSender())__				jobStatusListener = null__			}_			_			_			if (periodicScheduler != null) {_				periodicScheduler.cancel()__				periodicScheduler = null__			}_			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.discard(userClassLoader, true)__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.discard(userClassLoader)__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,actor,ref,no,sender,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,discard,user,class,loader,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1435243086;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			LOG.info("Stopping checkpoint coordinator for job " + job)__			_			_			timer.cancel()__			_			_			if (jobStatusListener != null) {_				jobStatusListener.tell(PoisonPill.getInstance(), ActorRef.noSender())__				jobStatusListener = null__			}_			_			_			if (periodicScheduler != null) {_				periodicScheduler.cancel()__				periodicScheduler = null__			}_			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.discard(userClassLoader, true)__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.discard(userClassLoader)__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,actor,ref,no,sender,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,discard,user,class,loader,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1436802870;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			LOG.info("Stopping checkpoint coordinator for job " + job)__			_			_			timer.cancel()__			_			_			if (jobStatusListener != null) {_				jobStatusListener.tell(PoisonPill.getInstance(), ActorRef.noSender())__				jobStatusListener = null__			}_			_			_			if (periodicScheduler != null) {_				periodicScheduler.cancel()__				periodicScheduler = null__			}_			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.discard(userClassLoader, true)__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.discard(userClassLoader)__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,actor,ref,no,sender,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,discard,user,class,loader,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1437665997;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			LOG.info("Stopping checkpoint coordinator for job " + job)__			_			_			timer.cancel()__			_			_			if (jobStatusListener != null) {_				jobStatusListener.tell(PoisonPill.getInstance())__				jobStatusListener = null__			}_			_			_			if (periodicScheduler != null) {_				periodicScheduler.cancel()__				periodicScheduler = null__			}_			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.discard(userClassLoader, true)__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.discard(userClassLoader)__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,discard,user,class,loader,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1439548490;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			if (shutdown) {_				return__			}_			shutdown = true__			LOG.info("Stopping checkpoint coordinator for job " + job)__			_			_			timer.cancel()__			_			_			if (jobStatusListener != null) {_				jobStatusListener.tell(PoisonPill.getInstance())__				jobStatusListener = null__			}_			_			_			if (periodicScheduler != null) {_				periodicScheduler.cancel()__				periodicScheduler = null__			}_			_			_			for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.discard(userClassLoader, true)__			}_			pendingCheckpoints.clear()__			_			_			for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_				checkpoint.discard(userClassLoader)__			}_			completedCheckpoints.clear()__		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,discard,user,class,loader,completed,checkpoints,clear
CheckpointCoordinator -> public void shutdown();1440611860;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			try {	_				if (shutdown) {_					return__				}_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)__			_				_				timer.cancel()__			_				_				if (jobStatusListener != null) {_					jobStatusListener.tell(PoisonPill.getInstance())__					jobStatusListener = null__				}_			_				_				if (periodicScheduler != null) {_					periodicScheduler.cancel()__					periodicScheduler = null__				}_			_				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader, true)__				}_				pendingCheckpoints.clear()__			_				_				for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_					checkpoint.discard(userClassLoader)__				}_				completedCheckpoints.clear()__			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint cooordniator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,try,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,discard,user,class,loader,completed,checkpoints,clear,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,cooordniator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown();1441011751;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() {_		synchronized (lock) {_			try {	_				if (shutdown) {_					return__				}_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)__			_				_				timer.cancel()__			_				_				if (jobStatusListener != null) {_					jobStatusListener.tell(PoisonPill.getInstance())__					jobStatusListener = null__				}_			_				_				if (periodicScheduler != null) {_					periodicScheduler.cancel()__					periodicScheduler = null__				}_			_				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader, true)__				}_				pendingCheckpoints.clear()__			_				_				for (SuccessfulCheckpoint checkpoint : completedCheckpoints) {_					checkpoint.discard(userClassLoader)__				}_				completedCheckpoints.clear()__			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint cooordniator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,synchronized,lock,try,if,shutdown,return,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,for,successful,checkpoint,checkpoint,completed,checkpoints,checkpoint,discard,user,class,loader,completed,checkpoints,clear,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,cooordniator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1476432306;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1476432429;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1476972861;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1477645452;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1477989375;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1478068461;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1478636134;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1479339295;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1479852017;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1480585463;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1480604127;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1481290933;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1481295943;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1484038132;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1485269495;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1487616195;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1487762095;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1487871589;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1488304750;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1488304933;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1489671806;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1490819573;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1492867556;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus, sharedStateRegistry)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,shared,state,registry,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1492867556;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1493236605;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1493325408;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1493403095;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1493758186;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1495287945;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1495527860;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1499314317;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1499939555;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1500040329;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1501588490;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1501665499;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1502801814;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1502801814;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1508762030;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1509118643;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1509125300;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1515177485;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1516295283;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1516295283;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1516295283;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1516626377;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1517489695;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1517489695;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1517489695;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1517489696;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1518945175;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1519481078;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1524124695;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job {}.", job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1525852381;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job {}.", job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				MasterHooks.close(masterHooks.values(), LOG)__				masterHooks.clear()___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,master,hooks,close,master,hooks,values,log,master,hooks,clear,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1526373862;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job {}.", job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				MasterHooks.close(masterHooks.values(), LOG)__				masterHooks.clear()___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,master,hooks,close,master,hooks,values,log,master,hooks,clear,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1530954608;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job {}.", job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				MasterHooks.close(masterHooks.values(), LOG)__				masterHooks.clear()___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,master,hooks,close,master,hooks,values,log,master,hooks,clear,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1532330237;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job {}.", job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				MasterHooks.close(masterHooks.values(), LOG)__				masterHooks.clear()___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,master,hooks,close,master,hooks,values,log,master,hooks,clear,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1538638779;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job {}.", job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				MasterHooks.close(masterHooks.values(), LOG)__				masterHooks.clear()___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,master,hooks,close,master,hooks,values,log,master,hooks,clear,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1542043996;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job {}.", job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				MasterHooks.close(masterHooks.values(), LOG)__				masterHooks.clear()___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,master,hooks,close,master,hooks,values,log,master,hooks,clear,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void shutdown(JobStatus jobStatus) throws Exception;1542119887;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.;public void shutdown(JobStatus jobStatus) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job {}.", job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				MasterHooks.close(masterHooks.values(), LOG)__				masterHooks.clear()___				_				timer.shutdownNow()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				completedCheckpointStore.shutdown(jobStatus)__				checkpointIdCounter.shutdown(jobStatus)__			}_		}_	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,job,status,job,status,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,master,hooks,close,master,hooks,values,log,master,hooks,clear,timer,shutdown,now,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,completed,checkpoint,store,shutdown,job,status,checkpoint,id,counter,shutdown,job,status
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1478636134;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1479339295;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> private void triggerQueuedRequests();1479852017;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1480585463;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1480604127;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1481290933;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1481295943;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1484038132;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1485269495;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1487616195;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1487762095;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1487871589;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1488304750;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1488304933;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests();1489671806;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1490819573;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1492867556;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1492867556;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1493236605;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1493325408;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1493403095;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1493758186;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1495287945;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1495527860;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1499314317;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1499939555;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1500040329;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1501588490;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1501665499;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1502801814;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1502801814;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1508762030;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1509118643;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1509125300;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1515177485;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1516295283;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1516295283;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1516295283;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1516626377;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1517489695;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1517489695;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1517489695;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1517489696;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1518945175;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1519481078;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1524124695;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1525852381;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1526373862;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1530954608;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1532330237;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1538638779;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1542043996;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> private void triggerQueuedRequests();1542119887;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel(false)__				}_				currentPeriodicTrigger = timer.scheduleAtFixedRate(_						new ScheduledTrigger(),_						0L, baseInterval, TimeUnit.MILLISECONDS)__			}_			else {_				timer.execute(new ScheduledTrigger())__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,if,trigger,request,queued,trigger,request,queued,false,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,false,current,periodic,trigger,timer,schedule,at,fixed,rate,new,scheduled,trigger,0l,base,interval,time,unit,milliseconds,else,timer,execute,new,scheduled,trigger
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation);1519481078;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new CheckpointTriggerException("Failed to trigger savepoint.", triggerResult.getFailureReason())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,checkpoint,trigger,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation);1524124695;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new CheckpointTriggerException("Failed to trigger savepoint.", triggerResult.getFailureReason())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,checkpoint,trigger,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation);1525852381;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new CheckpointTriggerException("Failed to trigger savepoint.", triggerResult.getFailureReason())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,checkpoint,trigger,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation);1526373862;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new CheckpointTriggerException("Failed to trigger savepoint.", triggerResult.getFailureReason())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,checkpoint,trigger,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation);1530954608;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new CheckpointTriggerException("Failed to trigger savepoint.", triggerResult.getFailureReason())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,checkpoint,trigger,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation);1532330237;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new CheckpointTriggerException("Failed to trigger savepoint.", triggerResult.getFailureReason())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,checkpoint,trigger,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation);1538638779;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new CheckpointTriggerException("Failed to trigger savepoint.", triggerResult.getFailureReason())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,checkpoint,trigger,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation);1542043996;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new CheckpointTriggerException("Failed to trigger savepoint.", triggerResult.getFailureReason())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,checkpoint,trigger,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation);1542119887;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new CheckpointTriggerException("Failed to trigger savepoint.", triggerResult.getFailureReason())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,checkpoint,trigger,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1452526243;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1453717703;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1455130319;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1456508638;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1460392581;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}__			_			if (lastTriggeredCheckpoint + minPauseBetweenCheckpoints > timestamp) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				ScheduledTrigger trigger = new ScheduledTrigger()__				timer.scheduleAtFixedRate(trigger, minPauseBetweenCheckpoints, baseInterval)__				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		lastTriggeredCheckpoint = timestamp__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,if,last,triggered,checkpoint,min,pause,between,checkpoints,timestamp,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,scheduled,trigger,trigger,new,scheduled,trigger,timer,schedule,at,fixed,rate,trigger,min,pause,between,checkpoints,base,interval,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,last,triggered,checkpoint,timestamp,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1461666173;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}__			_			if (lastTriggeredCheckpoint + minPauseBetweenCheckpoints > timestamp) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				ScheduledTrigger trigger = new ScheduledTrigger()__				timer.scheduleAtFixedRate(trigger, minPauseBetweenCheckpoints, baseInterval)__				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		lastTriggeredCheckpoint = timestamp__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,if,last,triggered,checkpoint,min,pause,between,checkpoints,timestamp,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,scheduled,trigger,trigger,new,scheduled,trigger,timer,schedule,at,fixed,rate,trigger,min,pause,between,checkpoints,base,interval,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,last,triggered,checkpoint,timestamp,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1465991918;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}__			_			if (lastTriggeredCheckpoint + minPauseBetweenCheckpoints > timestamp) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				ScheduledTrigger trigger = new ScheduledTrigger()__				timer.scheduleAtFixedRate(trigger, minPauseBetweenCheckpoints, baseInterval)__				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		lastTriggeredCheckpoint = timestamp__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,if,last,triggered,checkpoint,min,pause,between,checkpoints,timestamp,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,scheduled,trigger,trigger,new,scheduled,trigger,timer,schedule,at,fixed,rate,trigger,min,pause,between,checkpoints,base,interval,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,last,triggered,checkpoint,timestamp,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1468523508;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}__			_			if (lastTriggeredCheckpoint + minPauseBetweenCheckpoints > timestamp) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				ScheduledTrigger trigger = new ScheduledTrigger()__				timer.scheduleAtFixedRate(trigger, minPauseBetweenCheckpoints, baseInterval)__				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		lastTriggeredCheckpoint = timestamp__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,if,last,triggered,checkpoint,min,pause,between,checkpoints,timestamp,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,scheduled,trigger,trigger,new,scheduled,trigger,timer,schedule,at,fixed,rate,trigger,min,pause,between,checkpoints,base,interval,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,last,triggered,checkpoint,timestamp,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1468854249;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}__			_			if (lastTriggeredCheckpoint + minPauseBetweenCheckpoints > timestamp) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				ScheduledTrigger trigger = new ScheduledTrigger()__				timer.scheduleAtFixedRate(trigger, minPauseBetweenCheckpoints, baseInterval)__				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		lastTriggeredCheckpoint = timestamp__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,if,last,triggered,checkpoint,min,pause,between,checkpoints,timestamp,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,scheduled,trigger,trigger,new,scheduled,trigger,timer,schedule,at,fixed,rate,trigger,min,pause,between,checkpoints,base,interval,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,last,triggered,checkpoint,timestamp,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1469101812;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}__			_			if (lastTriggeredCheckpoint + minPauseBetweenCheckpoints > timestamp) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				ScheduledTrigger trigger = new ScheduledTrigger()__				timer.scheduleAtFixedRate(trigger, minPauseBetweenCheckpoints, baseInterval)__				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		lastTriggeredCheckpoint = timestamp__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,if,last,triggered,checkpoint,min,pause,between,checkpoints,timestamp,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,scheduled,trigger,trigger,new,scheduled,trigger,timer,schedule,at,fixed,rate,trigger,min,pause,between,checkpoints,base,interval,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,last,triggered,checkpoint,timestamp,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1469190400;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}__			_			if (lastTriggeredCheckpoint + minPauseBetweenCheckpoints > timestamp) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				ScheduledTrigger trigger = new ScheduledTrigger()__				timer.scheduleAtFixedRate(trigger, minPauseBetweenCheckpoints, baseInterval)__				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		lastTriggeredCheckpoint = timestamp__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,if,last,triggered,checkpoint,min,pause,between,checkpoints,timestamp,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,scheduled,trigger,trigger,new,scheduled,trigger,timer,schedule,at,fixed,rate,trigger,min,pause,between,checkpoints,base,interval,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,last,triggered,checkpoint,timestamp,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception;1469525443;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param nextCheckpointId The checkpoint ID to use for this checkpoint or <code>-1</code> if_the checkpoint ID counter should be queried.;public boolean triggerCheckpoint(long timestamp, long nextCheckpointId) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}__			_			if (lastTriggeredCheckpoint + minPauseBetweenCheckpoints > timestamp) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				ScheduledTrigger trigger = new ScheduledTrigger()__				timer.scheduleAtFixedRate(trigger, minPauseBetweenCheckpoints, baseInterval)__				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		lastTriggeredCheckpoint = timestamp__		final long checkpointID__		if (nextCheckpointId < 0) {_			try {_				_				_				checkpointID = checkpointIdCounter.getAndIncrement()__			}_			catch (Throwable t) {_				int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__				LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__				return false__			}_		}_		else {_			checkpointID = nextCheckpointId__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							onCancelCheckpoint(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,next,checkpoint,id,the,checkpoint,id,to,use,for,this,checkpoint,or,code,1,code,if,the,checkpoint,id,counter,should,be,queried;public,boolean,trigger,checkpoint,long,timestamp,long,next,checkpoint,id,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,if,last,triggered,checkpoint,min,pause,between,checkpoints,timestamp,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,scheduled,trigger,trigger,new,scheduled,trigger,timer,schedule,at,fixed,rate,trigger,min,pause,between,checkpoints,base,interval,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,last,triggered,checkpoint,timestamp,final,long,checkpoint,id,if,next,checkpoint,id,0,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,else,checkpoint,id,next,checkpoint,id,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1509125300;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1515177485;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1516295283;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1516295283;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1516295283;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1516626377;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1517489695;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1517489695;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1517489695;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1517489696;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1518945175;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1519481078;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} because: {}", checkpointId, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,because,checkpoint,id,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1524124695;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} of job {} because: {}", checkpointId, job, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,of,job,because,checkpoint,id,job,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1525852381;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} of job {} because: {}", checkpointId, job, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,of,job,because,checkpoint,id,job,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1526373862;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} of job {} because: {}", checkpointId, job, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,of,job,because,checkpoint,id,job,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1530954608;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} of job {} because: {}", checkpointId, job, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,of,job,because,checkpoint,id,job,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1532330237;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} of job {} because: {}", checkpointId, job, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,of,job,because,checkpoint,id,job,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1538638779;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		final String reason = (cause != null) ? cause.getMessage() : ""___		LOG.info("Discarding checkpoint {} of job {} because: {}", checkpointId, job, reason)___		pendingCheckpoint.abortDeclined()__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,string,reason,cause,null,cause,get,message,log,info,discarding,checkpoint,of,job,because,checkpoint,id,job,reason,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1542043996;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		LOG.info("Discarding checkpoint {} of job {}.", checkpointId, job, cause)___		if (cause != null) {_			pendingCheckpoint.abortError(cause)__		} else {_			pendingCheckpoint.abortDeclined()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,log,info,discarding,checkpoint,of,job,checkpoint,id,job,cause,if,cause,null,pending,checkpoint,abort,error,cause,else,pending,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause);1542119887;Discards the given pending checkpoint because of the given cause.__@param pendingCheckpoint to discard_@param cause for discarding the checkpoint;private void discardCheckpoint(PendingCheckpoint pendingCheckpoint, @Nullable Throwable cause) {_		assert(Thread.holdsLock(lock))__		Preconditions.checkNotNull(pendingCheckpoint)___		final long checkpointId = pendingCheckpoint.getCheckpointId()___		LOG.info("Discarding checkpoint {} of job {}.", checkpointId, job, cause)___		if (cause == null || cause instanceof CheckpointDeclineException) {_			pendingCheckpoint.abortDeclined()__		} else {_			pendingCheckpoint.abortError(cause)__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		__		boolean haveMoreRecentPending = false__		for (PendingCheckpoint p : pendingCheckpoints.values()) {_			if (!p.isDiscarded() && p.getCheckpointId() >= pendingCheckpoint.getCheckpointId()) {_				haveMoreRecentPending = true__				break__			}_		}__		if (!haveMoreRecentPending) {_			triggerQueuedRequests()__		}_	};discards,the,given,pending,checkpoint,because,of,the,given,cause,param,pending,checkpoint,to,discard,param,cause,for,discarding,the,checkpoint;private,void,discard,checkpoint,pending,checkpoint,pending,checkpoint,nullable,throwable,cause,assert,thread,holds,lock,lock,preconditions,check,not,null,pending,checkpoint,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,log,info,discarding,checkpoint,of,job,checkpoint,id,job,cause,if,cause,null,cause,instanceof,checkpoint,decline,exception,pending,checkpoint,abort,declined,else,pending,checkpoint,abort,error,cause,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,pending,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception;1476432429;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception;1476972861;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception;1477645452;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception;1477989375;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception;1478068461;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception;1478636134;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception;1479339295;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) throws Exception {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1516295283;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job from savepoint {} ({})",_				savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final StreamStateHandle metadataHandle = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, savepointPointer, metadataHandle, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,stream,state,handle,metadata,handle,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,savepoint,pointer,metadata,handle,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1516626377;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job from savepoint {} ({})",_				savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final StreamStateHandle metadataHandle = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, savepointPointer, metadataHandle, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,stream,state,handle,metadata,handle,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,savepoint,pointer,metadata,handle,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1517489695;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job from savepoint {} ({})",_				savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final StreamStateHandle metadataHandle = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, savepointPointer, metadataHandle, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,stream,state,handle,metadata,handle,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,savepoint,pointer,metadata,handle,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1517489695;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job from savepoint {} ({})",_				savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final StreamStateHandle metadataHandle = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, savepointPointer, metadataHandle, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,stream,state,handle,metadata,handle,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,savepoint,pointer,metadata,handle,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1517489695;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job from savepoint {} ({})",_				savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final StreamStateHandle metadataHandle = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, savepointPointer, metadataHandle, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,stream,state,handle,metadata,handle,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,savepoint,pointer,metadata,handle,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1517489696;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job from savepoint {} ({})",_				savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1518945175;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(JobManagerTaskRestore)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job from savepoint {} ({})",_				savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1519481078;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(JobManagerTaskRestore)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job from savepoint {} ({})",_				savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1524124695;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(JobManagerTaskRestore)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job {} from savepoint {} ({})",_				job, savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID of job {} to {}.", job, nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,job,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,of,job,to,job,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1525852381;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(JobManagerTaskRestore)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job {} from savepoint {} ({})",_				job, savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID of job {} to {}.", job, nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,job,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,of,job,to,job,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1526373862;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(JobManagerTaskRestore)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job {} from savepoint {} ({})",_				job, savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID of job {} to {}.", job, nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,job,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,of,job,to,job,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1530954608;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(JobManagerTaskRestore)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job {} from savepoint {} ({})",_				job, savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID of job {} to {}.", job, nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,job,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,of,job,to,job,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1532330237;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(JobManagerTaskRestore)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job {} from savepoint {} ({})",_				job, savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID of job {} to {}.", job, nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,job,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,of,job,to,job,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1538638779;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(JobManagerTaskRestore)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job {} from savepoint {} ({})",_				job, savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID of job {} to {}.", job, nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,job,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,of,job,to,job,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1542043996;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(JobManagerTaskRestore)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job {} from savepoint {} ({})",_				job, savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID of job {} to {}.", job, nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,job,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,of,job,to,job,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPointer, 			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1542119887;Restore the state with given savepoint.__@param savepointPointer The pointer to the savepoint._@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(JobManagerTaskRestore)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPointer,_			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {__		Preconditions.checkNotNull(savepointPointer, "The savepoint path cannot be null.")___		LOG.info("Starting job {} from savepoint {} ({})",_				job, savepointPointer, (allowNonRestored ? "allowing non restored state" : ""))___		final CompletedCheckpointStorageLocation checkpointLocation = checkpointStorage.resolveCheckpoint(savepointPointer)___		_		CompletedCheckpoint savepoint = Checkpoints.loadAndValidateCheckpoint(_				job, tasks, checkpointLocation, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)___		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)___		LOG.info("Reset the checkpoint ID of job {} to {}.", job, nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,pointer,the,pointer,to,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,pointer,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,pointer,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,job,savepoint,pointer,allow,non,restored,allowing,non,restored,state,final,completed,checkpoint,storage,location,checkpoint,location,checkpoint,storage,resolve,checkpoint,savepoint,pointer,completed,checkpoint,savepoint,checkpoints,load,and,validate,checkpoint,job,tasks,checkpoint,location,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,of,job,to,job,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public void triggerCheckpoint() throws Exception;1445293011;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() throws Exception {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,throws,exception,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint() throws Exception;1448353719;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() throws Exception {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,throws,exception,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint() throws Exception;1448353719;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() throws Exception {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,throws,exception,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1452526243;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1453717703;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1455130319;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1456508638;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1460392581;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1461666173;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1465991918;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1468523508;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1468854249;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1469101812;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1469190400;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint);1469525443;Callback on full acknowledgement of a checkpoint. Called in lock scope.;protected void onFullyAcknowledgedCheckpoint(CompletedCheckpoint checkpoint) {_	};callback,on,full,acknowledgement,of,a,checkpoint,called,in,lock,scope;protected,void,on,fully,acknowledged,checkpoint,completed,checkpoint,checkpoint
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1478068461;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, latest, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,latest,allow,non,restored,state,state,assignment,operation,assign,states,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1478636134;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, latest, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,latest,allow,non,restored,state,state,assignment,operation,assign,states,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1479339295;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, latest, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,latest,allow,non,restored,state,state,assignment,operation,assign,states,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1479852017;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, latest, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,latest,allow,non,restored,state,state,assignment,operation,assign,states,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1480585463;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, latest, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,latest,allow,non,restored,state,state,assignment,operation,assign,states,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1480604127;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, latest, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,latest,allow,non,restored,state,state,assignment,operation,assign,states,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1481290933;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, latest, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,latest,allow,non,restored,state,state,assignment,operation,assign,states,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1481295943;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, latest, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,latest,allow,non,restored,state,state,assignment,operation,assign,states,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1484038132;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, latest, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPath())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,latest,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,path,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1485269495;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPath())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,path,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1487616195;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPath())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,path,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1487762095;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPath())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,path,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1487871589;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPath())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,path,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1488304750;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1488304933;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1489671806;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1490819573;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1492867556;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover(sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1492867556;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1493236605;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			__			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)__			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1493325408;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			__			final Map<JobVertexID, TaskState> taskStates = latest.getTaskStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(LOG, tasks, taskStates, allowNonRestoredState)__			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,job,vertex,id,task,state,task,states,latest,get,task,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,log,tasks,task,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1493403095;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1493758186;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover()___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1495287945;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover(sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1495527860;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover(sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1499314317;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover(sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1499939555;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover(sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1500040329;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover(sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1501588490;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover(sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1501665499;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateHandles)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover(sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1502801814;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			completedCheckpointStore.recover(sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,completed,checkpoint,store,recover,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1502801814;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1508762030;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1509118643;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1509125300;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1515177485;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1516295283;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1516295283;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1516295283;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1516626377;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1517489695;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1517489695;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1517489695;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1517489696;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(TaskStateSnapshot)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1518945175;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(JobManagerTaskRestore)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1519481078;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(JobManagerTaskRestore)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry after restore: {}.", sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring from latest valid checkpoint: {}.", latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,after,restore,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,from,latest,valid,checkpoint,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1524124695;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(JobManagerTaskRestore)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry of job {} after restore: {}.", job, sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					return false__				}_			}__			LOG.info("Restoring job {} from latest valid checkpoint: {}.", job, latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,of,job,after,restore,job,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,return,false,log,info,restoring,job,from,latest,valid,checkpoint,job,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1525852381;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(JobManagerTaskRestore)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry of job {} after restore: {}.", job, sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					LOG.debug("Resetting the master hooks.")__					MasterHooks.reset(masterHooks.values(), LOG)___					return false__				}_			}__			LOG.info("Restoring job {} from latest valid checkpoint: {}.", job, latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,of,job,after,restore,job,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,log,debug,resetting,the,master,hooks,master,hooks,reset,master,hooks,values,log,return,false,log,info,restoring,job,from,latest,valid,checkpoint,job,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1526373862;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(JobManagerTaskRestore)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry of job {} after restore: {}.", job, sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					LOG.debug("Resetting the master hooks.")__					MasterHooks.reset(masterHooks.values(), LOG)___					return false__				}_			}__			LOG.info("Restoring job {} from latest valid checkpoint: {}.", job, latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,of,job,after,restore,job,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,log,debug,resetting,the,master,hooks,master,hooks,reset,master,hooks,values,log,return,false,log,info,restoring,job,from,latest,valid,checkpoint,job,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1530954608;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(JobManagerTaskRestore)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry of job {} after restore: {}.", job, sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					LOG.debug("Resetting the master hooks.")__					MasterHooks.reset(masterHooks.values(), LOG)___					return false__				}_			}__			LOG.info("Restoring job {} from latest valid checkpoint: {}.", job, latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,of,job,after,restore,job,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,log,debug,resetting,the,master,hooks,master,hooks,reset,master,hooks,values,log,return,false,log,info,restoring,job,from,latest,valid,checkpoint,job,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1532330237;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(JobManagerTaskRestore)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry of job {} after restore: {}.", job, sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					LOG.debug("Resetting the master hooks.")__					MasterHooks.reset(masterHooks.values(), LOG)___					return false__				}_			}__			LOG.info("Restoring job {} from latest valid checkpoint: {}.", job, latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,of,job,after,restore,job,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,log,debug,resetting,the,master,hooks,master,hooks,reset,master,hooks,values,log,return,false,log,info,restoring,job,from,latest,valid,checkpoint,job,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1538638779;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(JobManagerTaskRestore)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry of job {} after restore: {}.", job, sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					LOG.debug("Resetting the master hooks.")__					MasterHooks.reset(masterHooks.values(), LOG)___					return false__				}_			}__			LOG.info("Restoring job {} from latest valid checkpoint: {}.", job, latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,of,job,after,restore,job,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,log,debug,resetting,the,master,hooks,master,hooks,reset,master,hooks,values,log,return,false,log,info,restoring,job,from,latest,valid,checkpoint,job,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1542043996;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(JobManagerTaskRestore)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry of job {} after restore: {}.", job, sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					LOG.debug("Resetting the master hooks.")__					MasterHooks.reset(masterHooks.values(), LOG)___					return false__				}_			}__			LOG.info("Restoring job {} from latest valid checkpoint: {}.", job, latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,of,job,after,restore,job,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,log,debug,resetting,the,master,hooks,master,hooks,reset,master,hooks,values,log,return,false,log,info,restoring,job,from,latest,valid,checkpoint,job,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public boolean restoreLatestCheckpointedState( 			Map<JobVertexID, ExecutionJobVertex> tasks, 			boolean errorIfNoCheckpoint, 			boolean allowNonRestoredState) throws Exception;1542119887;Restores the latest checkpointed state.__@param tasks Map of job vertices to restore. State for these vertices is_restored via {@link Execution#setInitialState(JobManagerTaskRestore)}._@param errorIfNoCheckpoint Fail if no completed checkpoint is available to_restore from._@param allowNonRestoredState Allow checkpoint state that cannot be mapped_to any job vertex in tasks._@return <code>true</code> if state was restored, <code>false</code> otherwise._@throws IllegalStateException If the CheckpointCoordinator is shut down._@throws IllegalStateException If no completed checkpoint is available and_the <code>failIfNoCheckpoint</code> flag has been set._@throws IllegalStateException If the checkpoint contains state that cannot be_mapped to any job vertex in <code>tasks</code> and the_<code>allowNonRestoredState</code> flag has not been set._@throws IllegalStateException If the max parallelism changed for an operator_that restores state from this checkpoint._@throws IllegalStateException If the parallelism changed for an operator_that restores <i>non-partitioned</i> state from this_checkpoint.;public boolean restoreLatestCheckpointedState(_			Map<JobVertexID, ExecutionJobVertex> tasks,_			boolean errorIfNoCheckpoint,_			boolean allowNonRestoredState) throws Exception {__		synchronized (lock) {_			if (shutdown) {_				throw new IllegalStateException("CheckpointCoordinator is shut down")__			}__			_			_			_			sharedStateRegistry.close()__			sharedStateRegistry = sharedStateRegistryFactory.create(executor)___			_			completedCheckpointStore.recover()___			_			for (CompletedCheckpoint completedCheckpoint : completedCheckpointStore.getAllCheckpoints()) {_				completedCheckpoint.registerSharedStatesAfterRestored(sharedStateRegistry)__			}__			LOG.debug("Status of the shared state registry of job {} after restore: {}.", job, sharedStateRegistry)___			_			CompletedCheckpoint latest = completedCheckpointStore.getLatestCheckpoint()___			if (latest == null) {_				if (errorIfNoCheckpoint) {_					throw new IllegalStateException("No completed checkpoint available")__				} else {_					LOG.debug("Resetting the master hooks.")__					MasterHooks.reset(masterHooks.values(), LOG)___					return false__				}_			}__			LOG.info("Restoring job {} from latest valid checkpoint: {}.", job, latest)___			_			final Map<OperatorID, OperatorState> operatorStates = latest.getOperatorStates()___			StateAssignmentOperation stateAssignmentOperation =_					new StateAssignmentOperation(latest.getCheckpointID(), tasks, operatorStates, allowNonRestoredState)___			stateAssignmentOperation.assignStates()___			__			MasterHooks.restoreMasterHooks(_					masterHooks,_					latest.getMasterHookStates(),_					latest.getCheckpointID(),_					allowNonRestoredState,_					LOG)___			__			if (statsTracker != null) {_				long restoreTimestamp = System.currentTimeMillis()__				RestoredCheckpointStats restored = new RestoredCheckpointStats(_					latest.getCheckpointID(),_					latest.getProperties(),_					restoreTimestamp,_					latest.getExternalPointer())___				statsTracker.reportRestoredCheckpoint(restored)__			}__			return true__		}_	};restores,the,latest,checkpointed,state,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,job,manager,task,restore,param,error,if,no,checkpoint,fail,if,no,completed,checkpoint,is,available,to,restore,from,param,allow,non,restored,state,allow,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,return,code,true,code,if,state,was,restored,code,false,code,otherwise,throws,illegal,state,exception,if,the,checkpoint,coordinator,is,shut,down,throws,illegal,state,exception,if,no,completed,checkpoint,is,available,and,the,code,fail,if,no,checkpoint,code,flag,has,been,set,throws,illegal,state,exception,if,the,checkpoint,contains,state,that,cannot,be,mapped,to,any,job,vertex,in,code,tasks,code,and,the,code,allow,non,restored,state,code,flag,has,not,been,set,throws,illegal,state,exception,if,the,max,parallelism,changed,for,an,operator,that,restores,state,from,this,checkpoint,throws,illegal,state,exception,if,the,parallelism,changed,for,an,operator,that,restores,i,non,partitioned,i,state,from,this,checkpoint;public,boolean,restore,latest,checkpointed,state,map,job,vertex,id,execution,job,vertex,tasks,boolean,error,if,no,checkpoint,boolean,allow,non,restored,state,throws,exception,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,is,shut,down,shared,state,registry,close,shared,state,registry,shared,state,registry,factory,create,executor,completed,checkpoint,store,recover,for,completed,checkpoint,completed,checkpoint,completed,checkpoint,store,get,all,checkpoints,completed,checkpoint,register,shared,states,after,restored,shared,state,registry,log,debug,status,of,the,shared,state,registry,of,job,after,restore,job,shared,state,registry,completed,checkpoint,latest,completed,checkpoint,store,get,latest,checkpoint,if,latest,null,if,error,if,no,checkpoint,throw,new,illegal,state,exception,no,completed,checkpoint,available,else,log,debug,resetting,the,master,hooks,master,hooks,reset,master,hooks,values,log,return,false,log,info,restoring,job,from,latest,valid,checkpoint,job,latest,final,map,operator,id,operator,state,operator,states,latest,get,operator,states,state,assignment,operation,state,assignment,operation,new,state,assignment,operation,latest,get,checkpoint,id,tasks,operator,states,allow,non,restored,state,state,assignment,operation,assign,states,master,hooks,restore,master,hooks,master,hooks,latest,get,master,hook,states,latest,get,checkpoint,id,allow,non,restored,state,log,if,stats,tracker,null,long,restore,timestamp,system,current,time,millis,restored,checkpoint,stats,restored,new,restored,checkpoint,stats,latest,get,checkpoint,id,latest,get,properties,restore,timestamp,latest,get,external,pointer,stats,tracker,report,restored,checkpoint,restored,return,true
CheckpointCoordinator -> public void shutdown() throws Exception;1445293011;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					_					if (periodicScheduler != null) {_						periodicScheduler.cancel()__						periodicScheduler = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_							pending.discard(userClassLoader, true)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint cooordniator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,cooordniator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1448353719;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					_					if (periodicScheduler != null) {_						periodicScheduler.cancel()__						periodicScheduler = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_							pending.discard(userClassLoader, true)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint cooordniator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,cooordniator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1448353719;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					_					if (periodicScheduler != null) {_						periodicScheduler.cancel()__						periodicScheduler = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_							pending.discard(userClassLoader, true)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint cooordniator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,if,periodic,scheduler,null,periodic,scheduler,cancel,periodic,scheduler,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,true,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,cooordniator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1448554589;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false__					_					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1451519127;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1452526243;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()___					onShutdown()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1453717703;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()___					onShutdown()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1455130319;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()___					onShutdown()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1456508638;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()___					onShutdown()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1460392581;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()___					onShutdown()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1461666173;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()___					onShutdown()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1465991918;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()___					onShutdown()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1468523508;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()___					onShutdown()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1468854249;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()___					onShutdown()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1469101812;Shuts down the checkpoint coordinator.__After this method has been called, the coordinator does not accept and further_messages and cannot trigger any further checkpoints.;public void shutdown() throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					checkpointIdCounter.stop()___					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					_					completedCheckpointStore.discardAllCheckpoints()___					onShutdown()__				}_			}_			finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints;public,void,shutdown,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,checkpoint,id,counter,stop,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,completed,checkpoint,store,discard,all,checkpoints,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> public void shutdown() throws Exception;1469190400;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1469525443;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1471453562;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1471454287;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1471601024;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1472061377;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1472061377;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1472066344;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1472663071;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1472663401;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1472663401;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1472663401;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1472663402;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1474649312;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1474905901;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1475231926;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void shutdown() throws Exception;1476094623;Shuts down the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints. All_checkpoint state is discarded.;public void shutdown() throws Exception {_		shutdown(true)__	};shuts,down,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,all,checkpoint,state,is,discarded;public,void,shutdown,throws,exception,shutdown,true
CheckpointCoordinator -> public void triggerCheckpoint();1430297241;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1431459357;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1431459358;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1432052753;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1432053122;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1434095691;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1435243086;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1435243086;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1436802870;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1437665997;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1439548490;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1440611860;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public void triggerCheckpoint();1441011751;Triggers a new checkpoint and uses the current system time as the_checkpoint time.;public void triggerCheckpoint() {_		triggerCheckpoint(System.currentTimeMillis())__	};triggers,a,new,checkpoint,and,uses,the,current,system,time,as,the,checkpoint,time;public,void,trigger,checkpoint,trigger,checkpoint,system,current,time,millis
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp) throws Exception;1445293011;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) throws Exception {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null && ee.getState() == ExecutionState.RUNNING) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,throws,exception,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp) throws Exception;1448353719;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) throws Exception {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null && ee.getState() == ExecutionState.RUNNING) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,throws,exception,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp) throws Exception;1448353719;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) throws Exception {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null && ee.getState() == ExecutionState.RUNNING) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,throws,exception,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1484038132;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1485269495;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1487616195;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1487762095;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1487871589;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1488304750;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1488304933;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1489671806;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1490819573;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1492867556;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1492867556;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1493236605;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1493325408;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1493403095;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1493758186;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1495287945;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1495527860;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1499314317;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1499939555;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1500040329;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1501588490;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1501665499;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1502801814;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1502801814;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1508762030;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1509118643;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1509125300;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1515177485;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1516295283;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1516295283;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1516295283;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1516626377;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1517489695;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1517489695;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1517489695;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1517489696;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1518945175;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1519481078;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1524124695;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1525852381;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1526373862;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1530954608;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1532330237;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1538638779;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1542043996;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker);1542119887;Sets the checkpoint stats tracker.__@param statsTracker The checkpoint stats tracker.;public void setCheckpointStatsTracker(@Nullable CheckpointStatsTracker statsTracker) {_		this.statsTracker = statsTracker__	};sets,the,checkpoint,stats,tracker,param,stats,tracker,the,checkpoint,stats,tracker;public,void,set,checkpoint,stats,tracker,nullable,checkpoint,stats,tracker,stats,tracker,this,stats,tracker,stats,tracker
CheckpointCoordinator -> protected void onShutdown();1452526243;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1453717703;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1455130319;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1456508638;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1460392581;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1461666173;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1465991918;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1468523508;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1468854249;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1469101812;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1469190400;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> protected void onShutdown();1469525443;Callback on shutdown of the coordinator. Called in lock scope.;protected void onShutdown() {_	};callback,on,shutdown,of,the,coordinator,called,in,lock,scope;protected,void,on,shutdown
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1481295943;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1484038132;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,meta,data,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1485269495;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,meta,data,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1487616195;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetaData())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,meta,data,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1487762095;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1487871589;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1488304750;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1488304933;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1489671806;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1490819573;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1492867556;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1492867556;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1493236605;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1493325408;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1493403095;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1493758186;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1495287945;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1495527860;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1499314317;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1499939555;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1500040329;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1501588490;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1501665499;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1502801814;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1502801814;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1508762030;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1509118643;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1509125300;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1515177485;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1516295283;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1516295283;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()__		_		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1516295283;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1516626377;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1517489695;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1517489695;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1517489695;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1517489696;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1518945175;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1519481078;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1524124695;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1525852381;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1526373862;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1530954608;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1532330237;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1538638779;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1542043996;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException;1542119887;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws CheckpointException If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws CheckpointException {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received wrong AcknowledgeCheckpoint message for job {}: {}", job, message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			final PendingCheckpoint checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {__				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState(), message.getCheckpointMetrics())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {_							completePendingCheckpoint(checkpoint)__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}__				return true__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				boolean wasPendingCheckpoint___				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					wasPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					wasPendingCheckpoint = false__				}__				_				discardSubtaskState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___				return wasPendingCheckpoint__			}_		}_	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,checkpoint,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,checkpoint,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,wrong,acknowledge,checkpoint,message,for,job,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,synchronized,lock,if,shutdown,return,false,final,pending,checkpoint,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,message,get,checkpoint,metrics,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,complete,pending,checkpoint,checkpoint,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,true,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,boolean,was,pending,checkpoint,if,recent,pending,checkpoints,contains,checkpoint,id,was,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,was,pending,checkpoint,false,discard,subtask,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,return,was,pending,checkpoint
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1452526243;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1453717703;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1455130319;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1456508638;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1460392581;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1461666173;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1465991918;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1468523508;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1468854249;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1469101812;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1469190400;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> protected void onCancelCheckpoint(long canceledCheckpointId);1469525443;Callback on cancellation of a checkpoint. Called in lock scope.;protected void onCancelCheckpoint(long canceledCheckpointId) {_	};callback,on,cancellation,of,a,checkpoint,called,in,lock,scope;protected,void,on,cancel,checkpoint,long,canceled,checkpoint,id
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1508762030;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1509118643;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1509125300;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1515177485;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1516295283;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1516295283;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1516295283;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1516626377;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1517489695;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1517489695;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1517489695;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1517489696;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1518945175;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1519481078;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1524124695;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1525852381;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1526373862;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1530954608;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1532330237;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1538638779;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1542043996;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean isPeriodicCheckpointingConfigured();1542119887;Returns whether periodic checkpointing has been configured.__@return <code>true</code> if periodic checkpoints have been configured.;public boolean isPeriodicCheckpointingConfigured() {_		return baseInterval != Long.MAX_VALUE__	};returns,whether,periodic,checkpointing,has,been,configured,return,code,true,code,if,periodic,checkpoints,have,been,configured;public,boolean,is,periodic,checkpointing,configured,return,base,interval,long
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1453717703;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1455130319;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1456508638;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1460392581;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1461666173;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1465991918;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1468523508;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1468854249;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1469101812;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				onCancelCheckpoint(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1469190400;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				onCancelCheckpoint(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1469525443;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.discard(userClassLoader)__				rememberRecentCheckpointId(checkpointId)___				onCancelCheckpoint(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,discard,user,class,loader,remember,recent,checkpoint,id,checkpoint,id,on,cancel,checkpoint,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1471453562;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false__				Iterator<Map.Entry<Long, PendingCheckpoint>> entries = pendingCheckpoints.entrySet().iterator()__				while (entries.hasNext()) {_					PendingCheckpoint p = entries.next().getValue()__					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,iterator,map,entry,long,pending,checkpoint,entries,pending,checkpoints,entry,set,iterator,while,entries,has,next,pending,checkpoint,p,entries,next,get,value,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1471454287;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1471601024;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1472061377;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1472061377;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1472066344;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1472663071;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1472663401;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1472663401;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1472663401;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1472663402;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1474649312;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1474905901;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1475231926;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1476094623;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1476432306;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis(), checkpoint.getProps(), checkpoint.getTargetDirectory())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,checkpoint,get,props,checkpoint,get,target,directory,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1476432429;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_					+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis(), checkpoint.getProps(), checkpoint.getTargetDirectory(), checkpoint.isPeriodic())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_					"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,checkpoint,get,props,checkpoint,get,target,directory,checkpoint,is,periodic,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1476972861;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_						+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis(), checkpoint.getProps(), checkpoint.getTargetDirectory(), checkpoint.isPeriodic())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,checkpoint,get,props,checkpoint,get,target,directory,checkpoint,is,periodic,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1477645452;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_						+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis(), checkpoint.getProps(), checkpoint.getTargetDirectory(), checkpoint.isPeriodic())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,checkpoint,get,props,checkpoint,get,target,directory,checkpoint,is,periodic,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1477989375;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_						+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis(), checkpoint.getProps(), checkpoint.getTargetDirectory(), checkpoint.isPeriodic())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,checkpoint,get,props,checkpoint,get,target,directory,checkpoint,is,periodic,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception;1478068461;Receives a {@link DeclineCheckpoint} message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint decline from the task manager__@return Flag indicating whether the declined checkpoint was associated_with a pending checkpoint.;public boolean receiveDeclineMessage(DeclineCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received DeclineCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				LOG.info("Discarding checkpoint " + checkpointId_						+ " because of checkpoint decline from task " + message.getTaskExecutionId())___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				boolean haveMoreRecentPending = false___				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointTimestamp() >= checkpoint.getCheckpointTimestamp()) {_						haveMoreRecentPending = true__						break__					}_				}_				if (!haveMoreRecentPending && !triggerRequestQueued) {_					LOG.info("Triggering new checkpoint because of discarded checkpoint " + checkpointId)__					triggerCheckpoint(System.currentTimeMillis(), checkpoint.getProps(), checkpoint.getTargetDirectory(), checkpoint.isPeriodic())__				} else if (!haveMoreRecentPending) {_					LOG.info("Promoting queued checkpoint request because of discarded checkpoint " + checkpointId)__					triggerQueuedRequests()__				}_			} else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			} else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.info("Received another decline checkpoint message for now expired checkpoint attempt " + checkpointId)__				} else {_					isPendingCheckpoint = false__				}_			}_		}__		return isPendingCheckpoint__	};receives,a,link,decline,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager,return,flag,indicating,whether,the,declined,checkpoint,was,associated,with,a,pending,checkpoint;public,boolean,receive,decline,message,decline,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,decline,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,log,info,discarding,checkpoint,checkpoint,id,because,of,checkpoint,decline,from,task,message,get,task,execution,id,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,timestamp,checkpoint,get,checkpoint,timestamp,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,request,queued,log,info,triggering,new,checkpoint,because,of,discarded,checkpoint,checkpoint,id,trigger,checkpoint,system,current,time,millis,checkpoint,get,props,checkpoint,get,target,directory,checkpoint,is,periodic,else,if,have,more,recent,pending,log,info,promoting,queued,checkpoint,request,because,of,discarded,checkpoint,checkpoint,id,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,info,received,another,decline,checkpoint,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1493236605;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1493325408;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1493403095;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1493758186;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1495287945;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1495527860;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1499314317;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1499939555;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1500040329;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1501588490;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1501665499;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1502801814;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1502801814;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1508762030;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1509118643;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1509125300;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1515177485;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1516295283;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1516295283;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1516295283;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1516626377;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1517489695;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1517489695;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1517489695;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1517489696;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1518945175;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1519481078;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1524124695;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1525852381;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1526373862;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1530954608;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1532330237;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1538638779;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1542043996;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> public boolean addMasterHook(MasterTriggerRestoreHook<?> hook);1542119887;Adds the given master hook to the checkpoint coordinator. This method does nothing, if_the checkpoint coordinator already contained a hook with the same ID (as defined via_{@link MasterTriggerRestoreHook#getIdentifier()}).__@param hook The hook to add._@return True, if the hook was added, false if the checkpoint coordinator already_contained a hook with the same ID.;public boolean addMasterHook(MasterTriggerRestoreHook<?> hook) {_		checkNotNull(hook)___		final String id = hook.getIdentifier()__		checkArgument(!StringUtils.isNullOrWhitespaceOnly(id), "The hook has a null or empty id")___		synchronized (lock) {_			if (!masterHooks.containsKey(id)) {_				masterHooks.put(id, hook)__				return true__			}_			else {_				return false__			}_		}_	};adds,the,given,master,hook,to,the,checkpoint,coordinator,this,method,does,nothing,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id,as,defined,via,link,master,trigger,restore,hook,get,identifier,param,hook,the,hook,to,add,return,true,if,the,hook,was,added,false,if,the,checkpoint,coordinator,already,contained,a,hook,with,the,same,id;public,boolean,add,master,hook,master,trigger,restore,hook,hook,check,not,null,hook,final,string,id,hook,get,identifier,check,argument,string,utils,is,null,or,whitespace,only,id,the,hook,has,a,null,or,empty,id,synchronized,lock,if,master,hooks,contains,key,id,master,hooks,put,id,hook,return,true,else,return,false
CheckpointCoordinator -> private void discardState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final StateObject stateObject);1481295943;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param stateObject to discard asynchronously;private void discardState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final StateObject stateObject) {_		_		if (stateObject != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {_					try {_						stateObject.discardState()__					} catch (Throwable throwable) {_					LOG.warn("Could not properly discard state object of checkpoint {} " +_						"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId,_						throwable)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,state,object,to,discard,asynchronously;private,void,discard,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,state,object,state,object,if,state,object,null,executor,execute,new,runnable,override,public,void,run,try,state,object,discard,state,catch,throwable,throwable,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,throwable
CheckpointCoordinator -> private void discardState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final StateObject stateObject);1484038132;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param stateObject to discard asynchronously;private void discardState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final StateObject stateObject) {_		_		if (stateObject != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {_					try {_						stateObject.discardState()__					} catch (Throwable throwable) {_					LOG.warn("Could not properly discard state object of checkpoint {} " +_						"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId,_						throwable)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,state,object,to,discard,asynchronously;private,void,discard,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,state,object,state,object,if,state,object,null,executor,execute,new,runnable,override,public,void,run,try,state,object,discard,state,catch,throwable,throwable,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,throwable
CheckpointCoordinator -> private void discardState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final StateObject stateObject);1485269495;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param stateObject to discard asynchronously;private void discardState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final StateObject stateObject) {_		_		if (stateObject != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {_					try {_						stateObject.discardState()__					} catch (Throwable throwable) {_					LOG.warn("Could not properly discard state object of checkpoint {} " +_						"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId,_						throwable)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,state,object,to,discard,asynchronously;private,void,discard,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,state,object,state,object,if,state,object,null,executor,execute,new,runnable,override,public,void,run,try,state,object,discard,state,catch,throwable,throwable,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,throwable
CheckpointCoordinator -> private void discardState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final StateObject stateObject);1487616195;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param stateObject to discard asynchronously;private void discardState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final StateObject stateObject) {_		_		if (stateObject != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {_					try {_						stateObject.discardState()__					} catch (Throwable throwable) {_					LOG.warn("Could not properly discard state object of checkpoint {} " +_						"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId,_						throwable)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,state,object,to,discard,asynchronously;private,void,discard,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,state,object,state,object,if,state,object,null,executor,execute,new,runnable,override,public,void,run,try,state,object,discard,state,catch,throwable,throwable,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,throwable
CheckpointCoordinator -> private void discardState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final StateObject stateObject);1487762095;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param stateObject to discard asynchronously;private void discardState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final StateObject stateObject) {_		_		if (stateObject != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {_					try {_						stateObject.discardState()__					} catch (Throwable throwable) {_					LOG.warn("Could not properly discard state object of checkpoint {} " +_						"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId,_						throwable)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,state,object,to,discard,asynchronously;private,void,discard,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,state,object,state,object,if,state,object,null,executor,execute,new,runnable,override,public,void,run,try,state,object,discard,state,catch,throwable,throwable,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,throwable
CheckpointCoordinator -> private void discardState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final StateObject stateObject);1487871589;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param stateObject to discard asynchronously;private void discardState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final StateObject stateObject) {__		if (stateObject != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {_					try {_						stateObject.discardState()__					} catch (Throwable throwable) {_					LOG.warn("Could not properly discard state object of checkpoint {} " +_						"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId,_						throwable)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,state,object,to,discard,asynchronously;private,void,discard,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,state,object,state,object,if,state,object,null,executor,execute,new,runnable,override,public,void,run,try,state,object,discard,state,catch,throwable,throwable,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,throwable
CheckpointCoordinator -> private void discardState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final StateObject stateObject);1488304750;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param stateObject to discard asynchronously;private void discardState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final StateObject stateObject) {__		if (stateObject != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {_					try {_						stateObject.discardState()__					} catch (Throwable throwable) {_					LOG.warn("Could not properly discard state object of checkpoint {} " +_						"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId,_						throwable)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,state,object,to,discard,asynchronously;private,void,discard,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,state,object,state,object,if,state,object,null,executor,execute,new,runnable,override,public,void,run,try,state,object,discard,state,catch,throwable,throwable,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,throwable
CheckpointCoordinator -> private void discardState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final StateObject stateObject);1488304933;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param stateObject to discard asynchronously;private void discardState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final StateObject stateObject) {__		if (stateObject != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {_					try {_						stateObject.discardState()__					} catch (Throwable throwable) {_					LOG.warn("Could not properly discard state object of checkpoint {} " +_						"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId,_						throwable)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,state,object,to,discard,asynchronously;private,void,discard,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,state,object,state,object,if,state,object,null,executor,execute,new,runnable,override,public,void,run,try,state,object,discard,state,catch,throwable,throwable,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,throwable
CheckpointCoordinator -> private void discardState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final StateObject stateObject);1489671806;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param stateObject to discard asynchronously;private void discardState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final StateObject stateObject) {__		if (stateObject != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {_					try {_						stateObject.discardState()__					} catch (Throwable throwable) {_					LOG.warn("Could not properly discard state object of checkpoint {} " +_						"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId,_						throwable)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,state,object,to,discard,asynchronously;private,void,discard,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,state,object,state,object,if,state,object,null,executor,execute,new,runnable,override,public,void,run,try,state,object,discard,state,catch,throwable,throwable,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,throwable
CheckpointCoordinator -> private void discardState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final StateObject stateObject);1490819573;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param stateObject to discard asynchronously;private void discardState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final StateObject stateObject) {__		if (stateObject != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {_					try {_						stateObject.discardState()__					} catch (Throwable throwable) {_					LOG.warn("Could not properly discard state object of checkpoint {} " +_						"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId,_						throwable)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,state,object,to,discard,asynchronously;private,void,discard,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,state,object,state,object,if,state,object,null,executor,execute,new,runnable,override,public,void,run,try,state,object,discard,state,catch,throwable,throwable,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,throwable
CheckpointCoordinator -> public void suspend() throws Exception;1469190400;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1469525443;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1471453562;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1471454287;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1471601024;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1472061377;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1472061377;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1472066344;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1472663071;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1472663401;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1472663401;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1472663401;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1472663402;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1474649312;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1474905901;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1475231926;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public void suspend() throws Exception;1476094623;Suspends the checkpoint coordinator.__<p>After this method has been called, the coordinator does not accept_and further messages and cannot trigger any further checkpoints.__<p>The difference to shutdown is that checkpoint state in the store_and counter is kept around if possible to recover later.;public void suspend() throws Exception {_		shutdown(false)__	};suspends,the,checkpoint,coordinator,p,after,this,method,has,been,called,the,coordinator,does,not,accept,and,further,messages,and,cannot,trigger,any,further,checkpoints,p,the,difference,to,shutdown,is,that,checkpoint,state,in,the,store,and,counter,is,kept,around,if,possible,to,recover,later;public,void,suspend,throws,exception,shutdown,false
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1501588490;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		CompletableFuture<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = new CompletableFuture<>()__			result.completeExceptionally(cause)__			return result__		}__		_		result.whenCompleteAsync(_			(CompletedCheckpoint checkpoint, Throwable throwable) -> {_				if (throwable != null) {_					try {_						SavepointStore.deleteSavepointDirectory(savepointDirectory)__					} catch (Throwable t) {_						LOG.warn("Failed to delete savepoint directory " + savepointDirectory_							+ " after failed savepoint.", t)__					}_				}_			},_			executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,completable,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,new,completable,future,result,complete,exceptionally,cause,return,result,result,when,complete,async,completed,checkpoint,checkpoint,throwable,throwable,if,throwable,null,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,executor,return,result
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1501665499;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		CompletableFuture<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}__		_		result.whenCompleteAsync(_			(CompletedCheckpoint checkpoint, Throwable throwable) -> {_				if (throwable != null) {_					try {_						SavepointStore.deleteSavepointDirectory(savepointDirectory)__					} catch (Throwable t) {_						LOG.warn("Failed to delete savepoint directory " + savepointDirectory_							+ " after failed savepoint.", t)__					}_				}_			},_			executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,completable,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,result,when,complete,async,completed,checkpoint,checkpoint,throwable,throwable,if,throwable,null,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,executor,return,result
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1502801814;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		CompletableFuture<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}__		_		result.whenCompleteAsync(_			(CompletedCheckpoint checkpoint, Throwable throwable) -> {_				if (throwable != null) {_					try {_						SavepointStore.deleteSavepointDirectory(savepointDirectory)__					} catch (Throwable t) {_						LOG.warn("Failed to delete savepoint directory " + savepointDirectory_							+ " after failed savepoint.", t)__					}_				}_			},_			executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,completable,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,result,when,complete,async,completed,checkpoint,checkpoint,throwable,throwable,if,throwable,null,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,executor,return,result
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1502801814;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		CompletableFuture<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}__		_		result.whenCompleteAsync(_			(CompletedCheckpoint checkpoint, Throwable throwable) -> {_				if (throwable != null) {_					try {_						SavepointStore.deleteSavepointDirectory(savepointDirectory)__					} catch (Throwable t) {_						LOG.warn("Failed to delete savepoint directory " + savepointDirectory_							+ " after failed savepoint.", t)__					}_				}_			},_			executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,completable,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,result,when,complete,async,completed,checkpoint,checkpoint,throwable,throwable,if,throwable,null,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,executor,return,result
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1508762030;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		CompletableFuture<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}__		_		result.whenCompleteAsync(_			(CompletedCheckpoint checkpoint, Throwable throwable) -> {_				if (throwable != null) {_					try {_						SavepointStore.deleteSavepointDirectory(savepointDirectory)__					} catch (Throwable t) {_						LOG.warn("Failed to delete savepoint directory " + savepointDirectory_							+ " after failed savepoint.", t)__					}_				}_			},_			executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,completable,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,result,when,complete,async,completed,checkpoint,checkpoint,throwable,throwable,if,throwable,null,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,executor,return,result
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1509118643;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		CompletableFuture<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}__		_		result.whenCompleteAsync(_			(CompletedCheckpoint checkpoint, Throwable throwable) -> {_				if (throwable != null) {_					try {_						SavepointStore.deleteSavepointDirectory(savepointDirectory)__					} catch (Throwable t) {_						LOG.warn("Failed to delete savepoint directory " + savepointDirectory_							+ " after failed savepoint.", t)__					}_				}_			},_			executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,completable,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,result,when,complete,async,completed,checkpoint,checkpoint,throwable,throwable,if,throwable,null,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,executor,return,result
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1509125300;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		CompletableFuture<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}__		_		result.whenCompleteAsync(_			(CompletedCheckpoint checkpoint, Throwable throwable) -> {_				if (throwable != null) {_					try {_						SavepointStore.deleteSavepointDirectory(savepointDirectory)__					} catch (Throwable t) {_						LOG.warn("Failed to delete savepoint directory " + savepointDirectory_							+ " after failed savepoint.", t)__					}_				}_			},_			executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,completable,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,result,when,complete,async,completed,checkpoint,checkpoint,throwable,throwable,if,throwable,null,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,executor,return,result
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1515177485;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		CompletableFuture<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}__		_		result.whenCompleteAsync(_			(CompletedCheckpoint checkpoint, Throwable throwable) -> {_				if (throwable != null) {_					try {_						SavepointStore.deleteSavepointDirectory(savepointDirectory)__					} catch (Throwable t) {_						LOG.warn("Failed to delete savepoint directory " + savepointDirectory_							+ " after failed savepoint.", t)__					}_				}_			},_			executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,completable,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,result,when,complete,async,completed,checkpoint,checkpoint,throwable,throwable,if,throwable,null,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,executor,return,result
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1516295283;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		CompletableFuture<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}__		_		result.whenCompleteAsync(_			(CompletedCheckpoint checkpoint, Throwable throwable) -> {_				if (throwable != null) {_					try {_						SavepointStore.deleteSavepointDirectory(savepointDirectory)__					} catch (Throwable t) {_						LOG.warn("Failed to delete savepoint directory " + savepointDirectory_							+ " after failed savepoint.", t)__					}_				}_			},_			executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,completable,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,result,when,complete,async,completed,checkpoint,checkpoint,throwable,throwable,if,throwable,null,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,executor,return,result
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1516295283;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		CompletableFuture<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}__		_		result.whenCompleteAsync(_			(CompletedCheckpoint checkpoint, Throwable throwable) -> {_				if (throwable != null) {_					try {_						SavepointStore.deleteSavepointDirectory(savepointDirectory)__					} catch (Throwable t) {_						LOG.warn("Failed to delete savepoint directory " + savepointDirectory_							+ " after failed savepoint.", t)__					}_				}_			},_			executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,completable,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,result,when,complete,async,completed,checkpoint,checkpoint,throwable,throwable,if,throwable,null,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,executor,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1461666173;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1465991918;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1468523508;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1468854249;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1469101812;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1469190400;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1469525443;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1471453562;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1471454287;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1471601024;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1472061377;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1472061377;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1472066344;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1472663071;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;protected List<Set<Integer>> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		ArrayList<Set<Integer>> result = new ArrayList<>(parallelism)___		for (int p = 0_ p < parallelism_ p++) {_			HashSet<Integer> keyGroupPartition = new HashSet<>()___			for (int k = p_ k < numberKeyGroups_ k += parallelism) {_				keyGroupPartition.add(k)__			}__			result.add(keyGroupPartition)__		}__		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;protected,list,set,integer,create,key,group,partitions,int,number,key,groups,int,parallelism,array,list,set,integer,result,new,array,list,parallelism,for,int,p,0,p,parallelism,p,hash,set,integer,key,group,partition,new,hash,set,for,int,k,p,k,number,key,groups,k,parallelism,key,group,partition,add,k,result,add,key,group,partition,return,result
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1452526243;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")__						LOG.debug(completed.getStates().toString())___						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,log,debug,completed,get,states,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1453717703;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")__						LOG.debug(completed.getStates().toString())___						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,log,debug,completed,get,states,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1455130319;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")__						LOG.debug(completed.getStates().toString())___						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,log,debug,completed,get,states,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1456508638;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")__						LOG.debug(completed.getStates().toString())___						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,log,debug,completed,get,states,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1460392581;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getState(), message.getStateSize())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")__						LOG.debug(completed.getStates().toString())___						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,log,debug,completed,get,states,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1461666173;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1465991918;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1468523508;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1468854249;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1469101812;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1469190400;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.toCompletedCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,to,completed,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1469525443;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						onFullyAcknowledgedCheckpoint(completed)___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,on,fully,acknowledged,checkpoint,completed,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1471453562;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1471454287;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1471601024;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1472061377;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getTimestamp())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,timestamp,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1472061377;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1472066344;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1472663071;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getState(),_					message.getStateSize(),_					null)) { _					_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,message,get,state,size,null,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1472663401;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getStateHandle(),_					message.getKeyGroupsStateHandle())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,handle,message,get,key,groups,state,handle,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1472663401;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getStateHandle(),_					message.getKeyGroupsStateHandle())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,handle,message,get,key,groups,state,handle,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1472663401;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getStateHandle(),_					message.getKeyGroupsStateHandle())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,handle,message,get,key,groups,state,handle,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1472663402;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getStateHandle(),_					message.getKeyGroupsStateHandle())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,handle,message,get,key,groups,state,handle,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1474649312;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getStateHandle(),_					message.getKeyGroupsStateHandle())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,handle,message,get,key,groups,state,handle,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1474905901;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_					message.getTaskExecutionId(),_					message.getStateHandle(),_					message.getKeyGroupsStateHandle())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry: completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				}_				else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,state,handle,message,get,key,groups,state,handle,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1475231926;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_						message.getTaskExecutionId(),_						message.getCheckpointStateHandles())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				} else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,checkpoint,state,handles,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1476094623;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_						message.getTaskExecutionId(),_						message.getCheckpointStateHandles())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				} else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,checkpoint,state,handles,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1476432306;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_						message.getTaskExecutionId(),_						message.getCheckpointStateHandles())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				} else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,checkpoint,state,handles,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1476432429;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_						message.getTaskExecutionId(),_						message.getCheckpointStateHandles())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				} else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,checkpoint,state,handles,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1476972861;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_						message.getTaskExecutionId(),_						message.getSubtaskState())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				} else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1477645452;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_						message.getTaskExecutionId(),_						message.getSubtaskState())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				} else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ExecutionAttemptID attemptId = ee.getAttemptId()__					NotifyCheckpointComplete notifyMessage = new NotifyCheckpointComplete(job, attemptId, checkpointId, timestamp)__					ev.sendMessageToCurrentExecution(notifyMessage, ee.getAttemptId())__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,execution,attempt,id,attempt,id,ee,get,attempt,id,notify,checkpoint,complete,notify,message,new,notify,checkpoint,complete,job,attempt,id,checkpoint,id,timestamp,ev,send,message,to,current,execution,notify,message,ee,get,attempt,id,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1477989375;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_						message.getTaskExecutionId(),_						message.getSubtaskState())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				} else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ee.notifyCheckpointComplete(checkpointId, timestamp)__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1478068461;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(_						message.getTaskExecutionId(),_						message.getSubtaskState())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				} else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint " + checkpointId_							+ " , task " + message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ee.notifyCheckpointComplete(checkpointId, timestamp)__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,checkpoint,id,task,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1478636134;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				if (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {_					if (checkpoint.isFullyAcknowledged()) {_						completed = checkpoint.finalizeCheckpoint()___						completedCheckpointStore.addCheckpoint(completed)___						LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___						if (LOG.isDebugEnabled()) {_							StringBuilder builder = new StringBuilder()__							for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_								builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__							}__							LOG.debug(builder.toString())__						}__						pendingCheckpoints.remove(checkpointId)__						rememberRecentCheckpointId(checkpointId)___						dropSubsumedCheckpoints(completed.getCheckpointID())___						triggerQueuedRequests()__					}_				} else {_					_					LOG.error("Received duplicate or invalid acknowledge message for checkpoint {} , task {}",_							checkpointId, message.getTaskExecutionId())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt " + checkpointId)__				}_				else {_					isPendingCheckpoint = false__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ee.notifyCheckpointComplete(checkpointId, timestamp)__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,if,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,else,log,error,received,duplicate,or,invalid,acknowledge,message,for,checkpoint,task,checkpoint,id,message,get,task,execution,id,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,is,pending,checkpoint,false,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1479339295;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {_					case SUCCESS:_						if (checkpoint.isFullyAcknowledged()) {_							completed = checkpoint.finalizeCheckpoint()___							completedCheckpointStore.addCheckpoint(completed)___							LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___							if (LOG.isDebugEnabled()) {_								StringBuilder builder = new StringBuilder()__								for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_									builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__								}__								LOG.debug(builder.toString())__							}__							pendingCheckpoints.remove(checkpointId)__							rememberRecentCheckpointId(checkpointId)___							dropSubsumedCheckpoints(completed.getCheckpointID())___							triggerQueuedRequests()__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						try {_							message.getSubtaskState().discardState()__						} catch (Exception e) {_							LOG.warn("Could not properly discard state for checkpoint {} of task {} of job {}.",_								message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e)__						}_						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						try {_							message.getSubtaskState().discardState()__						} catch (Exception e) {_							LOG.warn("Could not properly discard state for checkpoint {} of task {} of job {}.",_								message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e)__						}_				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {}.", checkpointId)__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {}.", checkpointId)__					isPendingCheckpoint = false__				}__				try {_					_					message.getSubtaskState().discardState()__				} catch (Exception e) {_					LOG.warn("Could not properly discard state for checkpoint {} of task {} of job {}.",_						message.getCheckpointId(), message.getTaskExecutionId(), message.getJob(), e)__				}_			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ee.notifyCheckpointComplete(checkpointId, timestamp)__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,case,success,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,try,message,get,subtask,state,discard,state,catch,exception,e,log,warn,could,not,properly,discard,state,for,checkpoint,of,task,of,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,e,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,try,message,get,subtask,state,discard,state,catch,exception,e,log,warn,could,not,properly,discard,state,for,checkpoint,of,task,of,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,e,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,log,debug,received,message,for,an,unknown,checkpoint,checkpoint,id,is,pending,checkpoint,false,try,message,get,subtask,state,discard,state,catch,exception,e,log,warn,could,not,properly,discard,state,for,checkpoint,of,task,of,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,e,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1479852017;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {_					case SUCCESS:_						if (checkpoint.isFullyAcknowledged()) {_							completed = checkpoint.finalizeCheckpoint()___							completedCheckpointStore.addCheckpoint(completed)___							LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___							if (LOG.isDebugEnabled()) {_								StringBuilder builder = new StringBuilder()__								for (Map.Entry<JobVertexID, TaskState> entry : completed.getTaskStates().entrySet()) {_									builder.append("JobVertexID: ").append(entry.getKey()).append(" {").append(entry.getValue()).append("}")__								}__								LOG.debug(builder.toString())__							}__							pendingCheckpoints.remove(checkpointId)__							rememberRecentCheckpointId(checkpointId)___							dropSubsumedCheckpoints(completed.getCheckpointID())___							triggerQueuedRequests()__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getSubtaskState())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {}.", checkpointId)__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {}.", checkpointId)__					isPendingCheckpoint = false__				}__				_				discardState(message.getSubtaskState())__			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ee.notifyCheckpointComplete(checkpointId, timestamp)__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,case,success,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,for,map,entry,job,vertex,id,task,state,entry,completed,get,task,states,entry,set,builder,append,job,vertex,id,append,entry,get,key,append,append,entry,get,value,append,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,subtask,state,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,log,debug,received,message,for,an,unknown,checkpoint,checkpoint,id,is,pending,checkpoint,false,discard,state,message,get,subtask,state,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1480585463;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {_					case SUCCESS:_						if (checkpoint.isFullyAcknowledged()) {_							completed = checkpoint.finalizeCheckpoint()___							completedCheckpointStore.addCheckpoint(completed)___							LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___							if (LOG.isDebugEnabled()) {_								StringBuilder builder = new StringBuilder()__								builder.append("Checkpoint state: ")__								for (TaskState state : completed.getTaskStates().values()) {_									builder.append(state)__									builder.append(", ")__								}_								_								builder.delete(builder.length() - 2, builder.length())___								LOG.debug(builder.toString())__							}__							pendingCheckpoints.remove(checkpointId)__							rememberRecentCheckpointId(checkpointId)___							dropSubsumedCheckpoints(completed.getCheckpointID())___							triggerQueuedRequests()__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getSubtaskState())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {}.", checkpointId)__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {}.", checkpointId)__					isPendingCheckpoint = false__				}__				_				discardState(message.getSubtaskState())__			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ee.notifyCheckpointComplete(checkpointId, timestamp)__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,case,success,if,checkpoint,is,fully,acknowledged,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,get,task,states,values,builder,append,state,builder,append,builder,delete,builder,length,2,builder,length,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,subtask,state,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,log,debug,received,message,for,an,unknown,checkpoint,checkpoint,id,is,pending,checkpoint,false,discard,state,message,get,subtask,state,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1480604127;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}_		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {_					case SUCCESS:_						if (checkpoint.isFullyAcknowledged()) {__							_							_							lastCheckpointCompletionNanos = System.nanoTime()___							_							completed = checkpoint.finalizeCheckpoint()__							completedCheckpointStore.addCheckpoint(completed)___							LOG.info("Completed checkpoint " + checkpointId + " (in " +_								completed.getDuration() + " ms)")___							if (LOG.isDebugEnabled()) {_								StringBuilder builder = new StringBuilder()__								builder.append("Checkpoint state: ")__								for (TaskState state : completed.getTaskStates().values()) {_									builder.append(state)__									builder.append(", ")__								}_								_								builder.delete(builder.length() - 2, builder.length())___								LOG.debug(builder.toString())__							}__							pendingCheckpoints.remove(checkpointId)__							rememberRecentCheckpointId(checkpointId)___							dropSubsumedCheckpoints(completed.getCheckpointID())___							triggerQueuedRequests()__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getSubtaskState())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {}.", checkpointId)__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {}.", checkpointId)__					isPendingCheckpoint = false__				}__				_				discardState(message.getSubtaskState())__			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ee.notifyCheckpointComplete(checkpointId, timestamp)__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,case,success,if,checkpoint,is,fully,acknowledged,last,checkpoint,completion,nanos,system,nano,time,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,checkpoint,id,in,completed,get,duration,ms,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,get,task,states,values,builder,append,state,builder,append,builder,delete,builder,length,2,builder,length,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,subtask,state,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,checkpoint,id,else,log,debug,received,message,for,an,unknown,checkpoint,checkpoint,id,is,pending,checkpoint,false,discard,state,message,get,subtask,state,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception;1481290933;Receives an AcknowledgeCheckpoint message and returns whether the_message was associated with a pending checkpoint.__@param message Checkpoint ack from the task manager__@return Flag indicating whether the ack'd checkpoint was associated_with a pending checkpoint.__@throws Exception If the checkpoint cannot be added to the completed checkpoint store.;public boolean receiveAcknowledgeMessage(AcknowledgeCheckpoint message) throws Exception {_		if (shutdown || message == null) {_			return false__		}__		if (!job.equals(message.getJob())) {_			LOG.error("Received AcknowledgeCheckpoint message for wrong job: {}", message)__			return false__		}__		final long checkpointId = message.getCheckpointId()___		CompletedCheckpoint completed = null__		PendingCheckpoint checkpoint___		_		_		boolean isPendingCheckpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return false__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				isPendingCheckpoint = true___				switch (checkpoint.acknowledgeTask(message.getTaskExecutionId(), message.getSubtaskState())) {_					case SUCCESS:_						LOG.debug("Received acknowledge message for checkpoint {} from task {} of job {}.",_							checkpointId, message.getTaskExecutionId(), message.getJob())___						if (checkpoint.isFullyAcknowledged()) {__							_							_							lastCheckpointCompletionNanos = System.nanoTime()___							_							completed = checkpoint.finalizeCheckpoint()__							completedCheckpointStore.addCheckpoint(completed)___							LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_								completed.getStateSize(), completed.getDuration())___							if (LOG.isDebugEnabled()) {_								StringBuilder builder = new StringBuilder()__								builder.append("Checkpoint state: ")__								for (TaskState state : completed.getTaskStates().values()) {_									builder.append(state)__									builder.append(", ")__								}_								_								builder.delete(builder.length() - 2, builder.length())___								LOG.debug(builder.toString())__							}__							pendingCheckpoints.remove(checkpointId)__							rememberRecentCheckpointId(checkpointId)___							dropSubsumedCheckpoints(completed.getCheckpointID())___							triggerQueuedRequests()__						}_						break__					case DUPLICATE:_						LOG.debug("Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())__						break__					case UNKNOWN:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_								"because the task's execution attempt id was unknown. Discarding " +_								"the state handle to avoid lingering state.", message.getCheckpointId(),_							message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())___						break__					case DISCARDED:_						LOG.warn("Could not acknowledge the checkpoint {} for task {} of job {}, " +_							"because the pending checkpoint had been discarded. Discarding the " +_								"state handle tp avoid lingering state.",_							message.getCheckpointId(), message.getTaskExecutionId(), message.getJob())___						discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else {_				_				if (recentPendingCheckpoints.contains(checkpointId)) {_					isPendingCheckpoint = true__					LOG.warn("Received late message for now expired checkpoint attempt {} from " +_						"{} of job {}.", checkpointId, message.getTaskExecutionId(), message.getJob())__				}_				else {_					LOG.debug("Received message for an unknown checkpoint {} from {} of job {}.",_						checkpointId, message.getTaskExecutionId(), message.getJob())__					isPendingCheckpoint = false__				}__				_				discardState(message.getJob(), message.getTaskExecutionId(), message.getCheckpointId(), message.getSubtaskState())__			}_		}__		_		_		if (completed != null) {_			final long timestamp = completed.getTimestamp()___			for (ExecutionVertex ev : tasksToCommitTo) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ee.notifyCheckpointComplete(checkpointId, timestamp)__				}_			}__			statsTracker.onCompletedCheckpoint(completed)__		}__		return isPendingCheckpoint__	};receives,an,acknowledge,checkpoint,message,and,returns,whether,the,message,was,associated,with,a,pending,checkpoint,param,message,checkpoint,ack,from,the,task,manager,return,flag,indicating,whether,the,ack,d,checkpoint,was,associated,with,a,pending,checkpoint,throws,exception,if,the,checkpoint,cannot,be,added,to,the,completed,checkpoint,store;public,boolean,receive,acknowledge,message,acknowledge,checkpoint,message,throws,exception,if,shutdown,message,null,return,false,if,job,equals,message,get,job,log,error,received,acknowledge,checkpoint,message,for,wrong,job,message,return,false,final,long,checkpoint,id,message,get,checkpoint,id,completed,checkpoint,completed,null,pending,checkpoint,checkpoint,boolean,is,pending,checkpoint,synchronized,lock,if,shutdown,return,false,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,is,pending,checkpoint,true,switch,checkpoint,acknowledge,task,message,get,task,execution,id,message,get,subtask,state,case,success,log,debug,received,acknowledge,message,for,checkpoint,from,task,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,if,checkpoint,is,fully,acknowledged,last,checkpoint,completion,nanos,system,nano,time,completed,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,get,state,size,completed,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,get,task,states,values,builder,append,state,builder,append,builder,delete,builder,length,2,builder,length,log,debug,builder,to,string,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,completed,get,checkpoint,id,trigger,queued,requests,break,case,duplicate,log,debug,received,a,duplicate,acknowledge,message,for,checkpoint,task,job,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,break,case,unknown,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,task,s,execution,attempt,id,was,unknown,discarding,the,state,handle,to,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,break,case,discarded,log,warn,could,not,acknowledge,the,checkpoint,for,task,of,job,because,the,pending,checkpoint,had,been,discarded,discarding,the,state,handle,tp,avoid,lingering,state,message,get,checkpoint,id,message,get,task,execution,id,message,get,job,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,recent,pending,checkpoints,contains,checkpoint,id,is,pending,checkpoint,true,log,warn,received,late,message,for,now,expired,checkpoint,attempt,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,else,log,debug,received,message,for,an,unknown,checkpoint,from,of,job,checkpoint,id,message,get,task,execution,id,message,get,job,is,pending,checkpoint,false,discard,state,message,get,job,message,get,task,execution,id,message,get,checkpoint,id,message,get,subtask,state,if,completed,null,final,long,timestamp,completed,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp,stats,tracker,on,completed,checkpoint,completed,return,is,pending,checkpoint
CheckpointCoordinator -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1472663401;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if(intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
CheckpointCoordinator -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1472663401;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if(intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
CheckpointCoordinator -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1472663402;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if(intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
CheckpointCoordinator -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1474649312;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if(intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
CheckpointCoordinator -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1474905901;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if(intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
CheckpointCoordinator -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1475231926;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
CheckpointCoordinator -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1476094623;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
CheckpointCoordinator -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1476432306;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
CheckpointCoordinator -> public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles( 			Collection<KeyGroupsStateHandle> allKeyGroupsHandles, 			KeyGroupRange subtaskKeyGroupIds);1476432429;Determine the subset of {@link KeyGroupsStateHandle KeyGroupsStateHandles} with correct_key group index for the given subtask {@link KeyGroupRange}.__<p>This is publicly visible to be used in tests.;public static List<KeyGroupsStateHandle> getKeyGroupsStateHandles(_			Collection<KeyGroupsStateHandle> allKeyGroupsHandles,_			KeyGroupRange subtaskKeyGroupIds) {__		List<KeyGroupsStateHandle> subtaskKeyGroupStates = new ArrayList<>()___		for (KeyGroupsStateHandle storedKeyGroup : allKeyGroupsHandles) {_			KeyGroupsStateHandle intersection = storedKeyGroup.getKeyGroupIntersection(subtaskKeyGroupIds)__			if (intersection.getNumberOfKeyGroups() > 0) {_				subtaskKeyGroupStates.add(intersection)__			}_		}_		return subtaskKeyGroupStates__	};determine,the,subset,of,link,key,groups,state,handle,key,groups,state,handles,with,correct,key,group,index,for,the,given,subtask,link,key,group,range,p,this,is,publicly,visible,to,be,used,in,tests;public,static,list,key,groups,state,handle,get,key,groups,state,handles,collection,key,groups,state,handle,all,key,groups,handles,key,group,range,subtask,key,group,ids,list,key,groups,state,handle,subtask,key,group,states,new,array,list,for,key,groups,state,handle,stored,key,group,all,key,groups,handles,key,groups,state,handle,intersection,stored,key,group,get,key,group,intersection,subtask,key,group,ids,if,intersection,get,number,of,key,groups,0,subtask,key,group,states,add,intersection,return,subtask,key,group,states
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1502801814;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1502801814;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1508762030;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1509118643;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1509125300;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1515177485;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1516295283;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1516295283;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1516295283;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1516626377;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1517489695;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1517489695;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1517489695;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1517489696;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1518945175;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1519481078;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1524124695;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1525852381;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1526373862;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1530954608;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1532330237;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1538638779;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1542043996;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final TaskStateSnapshot subtaskState);1542119887;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final TaskStateSnapshot subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,task,state,snapshot,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1448554589;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}_			_			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}_	_		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		_		_		final long checkpointID__		try {_			_			_			checkpointID = checkpointIdCounter.getAndIncrement()__		}_		catch (Throwable t) {_			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			return false__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}__		_		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}_				_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}_			_			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,long,checkpoint,id,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1451519127;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		_		synchronized (lock) {_			_			if (shutdown) {_				return false__			}__			_			if (triggerRequestQueued) {_				LOG.warn("Trying to trigger another checkpoint while one was queued already")__				return false__			}__			_			if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_				triggerRequestQueued = true__				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__					currentPeriodicTrigger = null__				}_				return false__			}_		}__		_		_		ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__		for (int i = 0_ i < tasksToTrigger.length_ i++) {_			Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__			if (ee != null && ee.getState() == ExecutionState.RUNNING) {_				triggerIDs[i] = ee.getAttemptId()__			} else {_				LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_						tasksToTrigger[i].getSimpleName())__				return false__			}_		}__		_		_		Map<ExecutionAttemptID, ExecutionVertex> ackTasks = new HashMap<>(tasksToWaitFor.length)___		for (ExecutionVertex ev : tasksToWaitFor) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ackTasks.put(ee.getAttemptId(), ev)__			} else {_				LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_						ev.getSimpleName())__				return false__			}_		}__		__		final long checkpointID__		try {_			_			_			checkpointID = checkpointIdCounter.getAndIncrement()__		}_		catch (Throwable t) {_			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			return false__		}__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)___		final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___		_		TimerTask canceller = new TimerTask() {_			@Override_			public void run() {_				try {_					synchronized (lock) {_						_						_						if (!checkpoint.isDiscarded()) {_							LOG.info("Checkpoint " + checkpointID + " expired before completing.")___							checkpoint.discard(userClassLoader)__							pendingCheckpoints.remove(checkpointID)__							rememberRecentCheckpointId(checkpointID)___							triggerQueuedRequests()__						}_					}_				}_				catch (Throwable t) {_					LOG.error("Exception while handling checkpoint timeout", t)__				}_			}_		}___		try {_			_			synchronized (lock) {_				_				_				_				_				_				if (shutdown) {_					return false__				}_				else if (triggerRequestQueued) {_					LOG.warn("Trying to trigger another checkpoint while one was queued already")__					return false__				}_				else if (pendingCheckpoints.size() >= maxConcurrentCheckpointAttempts) {_					triggerRequestQueued = true__					if (currentPeriodicTrigger != null) {_						currentPeriodicTrigger.cancel()__						currentPeriodicTrigger = null__					}_					return false__				}__				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}_			__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}__			numUnsuccessfulCheckpointsTriggers = 0__			return true__		}_		catch (Throwable t) {_			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}__			int numUnsuccessful = ++numUnsuccessfulCheckpointsTriggers__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			if (!checkpoint.isDiscarded()) {_				checkpoint.discard(userClassLoader)__			}_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,synchronized,lock,if,shutdown,return,false,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,long,checkpoint,id,try,checkpoint,id,checkpoint,id,counter,get,and,increment,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,return,false,log,info,triggering,checkpoint,checkpoint,id,timestamp,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,trigger,queued,requests,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,try,synchronized,lock,if,shutdown,return,false,else,if,trigger,request,queued,log,warn,trying,to,trigger,another,checkpoint,while,one,was,queued,already,return,false,else,if,pending,checkpoints,size,max,concurrent,checkpoint,attempts,trigger,request,queued,true,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,null,return,false,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,0,return,true,catch,throwable,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,if,checkpoint,is,discarded,checkpoint,discard,user,class,loader,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1452526243;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1453717703;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1455130319;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1456508638;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1460392581;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1461666173;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1465991918;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1468523508;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1468854249;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1469101812;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1469190400;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1469525443;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, -1)__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,1
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1471453562;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1471454287;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1471601024;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1472061377;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1472061377;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1472066344;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1472663071;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1472663401;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1472663401;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1472663401;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1472663402;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1474649312;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1474905901;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1475231926;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1476094623;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, CheckpointProperties.forStandardCheckpoint()).isSuccess()__	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,for,standard,checkpoint,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp) throws Exception;1476432306;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp) throws Exception {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,throws,exception,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,success
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1492867556;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint, sharedStateRegistry)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)__		_		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,shared,state,registry,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1492867556;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)__		_		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1493236605;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)__		_		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1493325408;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)__		_		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1493403095;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)__		_		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1493758186;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)__		_		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1495287945;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)__		_		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1495527860;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)__		_		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1499314317;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)__		_		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1499939555;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)__		_		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1500040329;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		savepoint.registerSharedStatesAfterRestored(sharedStateRegistry)__		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,savepoint,register,shared,states,after,restored,shared,state,registry,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1501588490;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		savepoint.registerSharedStatesAfterRestored(sharedStateRegistry)__		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,savepoint,register,shared,states,after,restored,shared,state,registry,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1501665499;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateHandles)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		savepoint.registerSharedStatesAfterRestored(sharedStateRegistry)__		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,handles,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,savepoint,register,shared,states,after,restored,shared,state,registry,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1502801814;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		savepoint.registerSharedStatesAfterRestored(sharedStateRegistry)__		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,savepoint,register,shared,states,after,restored,shared,state,registry,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1502801814;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1508762030;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1509118643;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1509125300;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1515177485;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1516295283;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> public boolean restoreSavepoint( 			String savepointPath,  			boolean allowNonRestored, 			Map<JobVertexID, ExecutionJobVertex> tasks, 			ClassLoader userClassLoader) throws Exception;1516295283;Restore the state with given savepoint__@param savepointPath    Location of the savepoint_@param allowNonRestored True if allowing checkpoint state that cannot be_mapped to any job vertex in tasks._@param tasks            Map of job vertices to restore. State for these_vertices is restored via_{@link Execution#setInitialState(TaskStateSnapshot)}._@param userClassLoader  The class loader to resolve serialized classes in_legacy savepoint versions.;public boolean restoreSavepoint(_			String savepointPath, _			boolean allowNonRestored,_			Map<JobVertexID, ExecutionJobVertex> tasks,_			ClassLoader userClassLoader) throws Exception {_		_		Preconditions.checkNotNull(savepointPath, "The savepoint path cannot be null.")__		_		LOG.info("Starting job from savepoint {} ({})", _				savepointPath, (allowNonRestored ? "allowing non restored state" : ""))___		_		CompletedCheckpoint savepoint = SavepointLoader.loadAndValidateSavepoint(_				job, tasks, savepointPath, userClassLoader, allowNonRestored)___		completedCheckpointStore.addCheckpoint(savepoint)__		_		_		long nextCheckpointId = savepoint.getCheckpointID() + 1__		checkpointIdCounter.setCount(nextCheckpointId)__		_		LOG.info("Reset the checkpoint ID to {}.", nextCheckpointId)___		return restoreLatestCheckpointedState(tasks, true, allowNonRestored)__	};restore,the,state,with,given,savepoint,param,savepoint,path,location,of,the,savepoint,param,allow,non,restored,true,if,allowing,checkpoint,state,that,cannot,be,mapped,to,any,job,vertex,in,tasks,param,tasks,map,of,job,vertices,to,restore,state,for,these,vertices,is,restored,via,link,execution,set,initial,state,task,state,snapshot,param,user,class,loader,the,class,loader,to,resolve,serialized,classes,in,legacy,savepoint,versions;public,boolean,restore,savepoint,string,savepoint,path,boolean,allow,non,restored,map,job,vertex,id,execution,job,vertex,tasks,class,loader,user,class,loader,throws,exception,preconditions,check,not,null,savepoint,path,the,savepoint,path,cannot,be,null,log,info,starting,job,from,savepoint,savepoint,path,allow,non,restored,allowing,non,restored,state,completed,checkpoint,savepoint,savepoint,loader,load,and,validate,savepoint,job,tasks,savepoint,path,user,class,loader,allow,non,restored,completed,checkpoint,store,add,checkpoint,savepoint,long,next,checkpoint,id,savepoint,get,checkpoint,id,1,checkpoint,id,counter,set,count,next,checkpoint,id,log,info,reset,the,checkpoint,id,to,next,checkpoint,id,return,restore,latest,checkpointed,state,tasks,true,allow,non,restored
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1492867556;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1493236605;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1493325408;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1493403095;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1493758186;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1495287945;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1495527860;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1499314317;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1499939555;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1500040329;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1501588490;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void discardSubtaskState( 			final JobID jobId, 			final ExecutionAttemptID executionAttemptID, 			final long checkpointId, 			final SubtaskState subtaskState);1501665499;Discards the given state object asynchronously belonging to the given job, execution attempt_id and checkpoint id.__@param jobId identifying the job to which the state object belongs_@param executionAttemptID identifying the task to which the state object belongs_@param checkpointId of the state object_@param subtaskState to discard asynchronously;private void discardSubtaskState(_			final JobID jobId,_			final ExecutionAttemptID executionAttemptID,_			final long checkpointId,_			final SubtaskState subtaskState) {__		if (subtaskState != null) {_			executor.execute(new Runnable() {_				@Override_				public void run() {__					try {_						subtaskState.discardState()__					} catch (Throwable t2) {_						LOG.warn("Could not properly discard state object of checkpoint {} " +_							"belonging to task {} of job {}.", checkpointId, executionAttemptID, jobId, t2)__					}_				}_			})__		}_	};discards,the,given,state,object,asynchronously,belonging,to,the,given,job,execution,attempt,id,and,checkpoint,id,param,job,id,identifying,the,job,to,which,the,state,object,belongs,param,execution,attempt,id,identifying,the,task,to,which,the,state,object,belongs,param,checkpoint,id,of,the,state,object,param,subtask,state,to,discard,asynchronously;private,void,discard,subtask,state,final,job,id,job,id,final,execution,attempt,id,execution,attempt,id,final,long,checkpoint,id,final,subtask,state,subtask,state,if,subtask,state,null,executor,execute,new,runnable,override,public,void,run,try,subtask,state,discard,state,catch,throwable,t2,log,warn,could,not,properly,discard,state,object,of,checkpoint,belonging,to,task,of,job,checkpoint,id,execution,attempt,id,job,id,t2
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1469190400;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					if (shutdownStoreAndCounter) {_						completedCheckpointStore.shutdown()__						checkpointIdCounter.shutdown()__					} else {_						completedCheckpointStore.suspend()__						checkpointIdCounter.suspend()__					}__					onShutdown()__				}_			} finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1469525443;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.discard(userClassLoader)__					}_					pendingCheckpoints.clear()___					if (shutdownStoreAndCounter) {_						completedCheckpointStore.shutdown()__						checkpointIdCounter.shutdown()__					} else {_						completedCheckpointStore.suspend()__						checkpointIdCounter.suspend()__					}__					onShutdown()__				}_			} finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,discard,user,class,loader,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend,on,shutdown,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1471453562;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			try {_				if (!shutdown) {_					shutdown = true__					LOG.info("Stopping checkpoint coordinator for job " + job)___					periodicScheduling = false__					triggerRequestQueued = false___					_					timer.cancel()___					_					if (jobStatusListener != null) {_						jobStatusListener.tell(PoisonPill.getInstance())__						jobStatusListener = null__					}__					_					for (PendingCheckpoint pending : pendingCheckpoints.values()) {_						pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__					}_					pendingCheckpoints.clear()___					if (shutdownStoreAndCounter) {_						completedCheckpointStore.shutdown()__						checkpointIdCounter.shutdown()__					} else {_						completedCheckpointStore.suspend()__						checkpointIdCounter.suspend()__					}_				}_			} finally {_				_				_				if (shutdownHook != null && shutdownHook != Thread.currentThread()) {_					try {_						Runtime.getRuntime().removeShutdownHook(shutdownHook)__					}_					catch (IllegalStateException ignored) {_						_					}_					catch (Throwable t) {_						LOG.warn("Error unregistering checkpoint coordinator shutdown hook.", t)__					}_				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,try,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend,finally,if,shutdown,hook,null,shutdown,hook,thread,current,thread,try,runtime,get,runtime,remove,shutdown,hook,shutdown,hook,catch,illegal,state,exception,ignored,catch,throwable,t,log,warn,error,unregistering,checkpoint,coordinator,shutdown,hook,t
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1471454287;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				if (jobStatusListener != null) {_					jobStatusListener.tell(PoisonPill.getInstance())__					jobStatusListener = null__				}__				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1471601024;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				if (jobStatusListener != null) {_					jobStatusListener.tell(PoisonPill.getInstance())__					jobStatusListener = null__				}__				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1472061377;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				if (jobStatusListener != null) {_					jobStatusListener.tell(PoisonPill.getInstance())__					jobStatusListener = null__				}__				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1472061377;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				if (jobStatusListener != null) {_					jobStatusListener.tell(PoisonPill.getInstance())__					jobStatusListener = null__				}__				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,if,job,status,listener,null,job,status,listener,tell,poison,pill,get,instance,job,status,listener,null,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1472066344;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1472663071;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1472663401;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1472663401;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1472663401;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1472663402;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1474649312;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1474905901;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1475231926;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> private void shutdown(boolean shutdownStoreAndCounter) throws Exception;1476094623;Shuts down the checkpoint coordinator.__@param shutdownStoreAndCounter Depending on this flag the checkpoint_state services are shut down or suspended.;private void shutdown(boolean shutdownStoreAndCounter) throws Exception {_		synchronized (lock) {_			if (!shutdown) {_				shutdown = true__				LOG.info("Stopping checkpoint coordinator for job " + job)___				periodicScheduling = false__				triggerRequestQueued = false___				_				timer.cancel()___				_				for (PendingCheckpoint pending : pendingCheckpoints.values()) {_					pending.abortError(new Exception("Checkpoint Coordinator is shutting down"))__				}_				pendingCheckpoints.clear()___				if (shutdownStoreAndCounter) {_					completedCheckpointStore.shutdown()__					checkpointIdCounter.shutdown()__				} else {_					completedCheckpointStore.suspend()__					checkpointIdCounter.suspend()__				}_			}_		}_	};shuts,down,the,checkpoint,coordinator,param,shutdown,store,and,counter,depending,on,this,flag,the,checkpoint,state,services,are,shut,down,or,suspended;private,void,shutdown,boolean,shutdown,store,and,counter,throws,exception,synchronized,lock,if,shutdown,shutdown,true,log,info,stopping,checkpoint,coordinator,for,job,job,periodic,scheduling,false,trigger,request,queued,false,timer,cancel,for,pending,checkpoint,pending,pending,checkpoints,values,pending,abort,error,new,exception,checkpoint,coordinator,is,shutting,down,pending,checkpoints,clear,if,shutdown,store,and,counter,completed,checkpoint,store,shutdown,checkpoint,id,counter,shutdown,else,completed,checkpoint,store,suspend,checkpoint,id,counter,suspend
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1476432306;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			Future<CompletedCheckpoint> failed = FlinkCompletableFuture.completedExceptionally(cause)__			return failed__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,future,completed,checkpoint,failed,flink,completable,future,completed,exceptionally,cause,return,failed
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1476432429;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			Future<CompletedCheckpoint> failed = FlinkCompletableFuture.completedExceptionally(cause)__			return failed__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,future,completed,checkpoint,failed,flink,completable,future,completed,exceptionally,cause,return,failed
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1476972861;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			Future<CompletedCheckpoint> failed = FlinkCompletableFuture.completedExceptionally(cause)__			return failed__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,future,completed,checkpoint,failed,flink,completable,future,completed,exceptionally,cause,return,failed
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1477645452;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			Future<CompletedCheckpoint> failed = FlinkCompletableFuture.completedExceptionally(cause)__			return failed__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,future,completed,checkpoint,failed,flink,completable,future,completed,exceptionally,cause,return,failed
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1477989375;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			Future<CompletedCheckpoint> failed = FlinkCompletableFuture.completedExceptionally(cause)__			return failed__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,future,completed,checkpoint,failed,flink,completable,future,completed,exceptionally,cause,return,failed
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1478068461;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			Future<CompletedCheckpoint> failed = FlinkCompletableFuture.completedExceptionally(cause)__			return failed__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,future,completed,checkpoint,failed,flink,completable,future,completed,exceptionally,cause,return,failed
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1478636134;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1479339295;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1479852017;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1480585463;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1480604127;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1481290933;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1481295943;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1484038132;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1485269495;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1487616195;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1487762095;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()__		CheckpointTriggerResult result = triggerCheckpoint(timestamp, props, targetDirectory, false)___		if (result.isSuccess()) {_			return result.getPendingCheckpoint().getCompletionFuture()__		}_		else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + result.getFailureReason().message())__			return FlinkCompletableFuture.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,checkpoint,trigger,result,result,trigger,checkpoint,timestamp,props,target,directory,false,if,result,is,success,return,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,result,get,failure,reason,message,return,flink,completable,future,completed,exceptionally,cause
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1487871589;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1488304750;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1488304933;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1489671806;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1490819573;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1492867556;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1492867556;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1493236605;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1493325408;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1493403095;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1493758186;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1495287945;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1495527860;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1499314317;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1499939555;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception;1500040329;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetDirectory Target directory for the savepoint._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public Future<CompletedCheckpoint> triggerSavepoint(long timestamp, String targetDirectory) throws Exception {_		checkNotNull(targetDirectory, "Savepoint target directory")___		CheckpointProperties props = CheckpointProperties.forStandardSavepoint()___		_		final String savepointDirectory = SavepointStore_			.createSavepointDirectory(targetDirectory, job)___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			savepointDirectory,_			false)___		Future<CompletedCheckpoint> result___		if (triggerResult.isSuccess()) {_			result = triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			result = FlinkCompletableFuture.completedExceptionally(cause)__		}__		_		result.exceptionallyAsync(new ApplyFunction<Throwable, Void>() {_			@Override_			public Void apply(Throwable value) {_				try {_					SavepointStore.deleteSavepointDirectory(savepointDirectory)__				} catch (Throwable t) {_					LOG.warn("Failed to delete savepoint directory " + savepointDirectory_						+ " after failed savepoint.", t)__				}__				return null__			}_		}, executor)___		return result__	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,directory,target,directory,for,the,savepoint,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,future,completed,checkpoint,trigger,savepoint,long,timestamp,string,target,directory,throws,exception,check,not,null,target,directory,savepoint,target,directory,checkpoint,properties,props,checkpoint,properties,for,standard,savepoint,final,string,savepoint,directory,savepoint,store,create,savepoint,directory,target,directory,job,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,savepoint,directory,false,future,completed,checkpoint,result,if,trigger,result,is,success,result,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,result,flink,completable,future,completed,exceptionally,cause,result,exceptionally,async,new,apply,function,throwable,void,override,public,void,apply,throwable,value,try,savepoint,store,delete,savepoint,directory,savepoint,directory,catch,throwable,t,log,warn,failed,to,delete,savepoint,directory,savepoint,directory,after,failed,savepoint,t,return,null,executor,return,result
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation) throws Exception;1516295283;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) throws Exception {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,throws,exception,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation) throws Exception;1516626377;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) throws Exception {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,throws,exception,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation) throws Exception;1517489695;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) throws Exception {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,throws,exception,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation) throws Exception;1517489695;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) throws Exception {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,throws,exception,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation) throws Exception;1517489695;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) throws Exception {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,throws,exception,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation) throws Exception;1517489696;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) throws Exception {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,throws,exception,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public CompletableFuture<CompletedCheckpoint> triggerSavepoint( 			long timestamp, 			@Nullable String targetLocation) throws Exception;1518945175;Triggers a savepoint with the given savepoint directory as a target.__@param timestamp The timestamp for the savepoint._@param targetLocation Target location for the savepoint, optional. If null, the_state backend's configured default will be used._@return A future to the completed checkpoint_@throws IllegalStateException If no savepoint directory has been_specified and no default savepoint directory has been_configured_@throws Exception             Failures during triggering are forwarded;public CompletableFuture<CompletedCheckpoint> triggerSavepoint(_			long timestamp,_			@Nullable String targetLocation) throws Exception {__		CheckpointProperties props = CheckpointProperties.forSavepoint()___		CheckpointTriggerResult triggerResult = triggerCheckpoint(_			timestamp,_			props,_			targetLocation,_			false)___		if (triggerResult.isSuccess()) {_			return triggerResult.getPendingCheckpoint().getCompletionFuture()__		} else {_			Throwable cause = new Exception("Failed to trigger savepoint: " + triggerResult.getFailureReason().message())__			return FutureUtils.completedExceptionally(cause)__		}_	};triggers,a,savepoint,with,the,given,savepoint,directory,as,a,target,param,timestamp,the,timestamp,for,the,savepoint,param,target,location,target,location,for,the,savepoint,optional,if,null,the,state,backend,s,configured,default,will,be,used,return,a,future,to,the,completed,checkpoint,throws,illegal,state,exception,if,no,savepoint,directory,has,been,specified,and,no,default,savepoint,directory,has,been,configured,throws,exception,failures,during,triggering,are,forwarded;public,completable,future,completed,checkpoint,trigger,savepoint,long,timestamp,nullable,string,target,location,throws,exception,checkpoint,properties,props,checkpoint,properties,for,savepoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,props,target,location,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,savepoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1479852017;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1480585463;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1480604127;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1481290933;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1481295943;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1484038132;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1485269495;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1487616195;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1487762095;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1487871589;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1488304750;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1488304933;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1489671806;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1490819573;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1492867556;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1492867556;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1493236605;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1493325408;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1493403095;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1493758186;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1495287945;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1495527860;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1499314317;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1499939555;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1500040329;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1501588490;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1501665499;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1502801814;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1502801814;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1508762030;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1509118643;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1509125300;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1515177485;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1516295283;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1516295283;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1516295283;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1516626377;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1517489695;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1517489695;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1517489695;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1517489696;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1518945175;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1519481078;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1524124695;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1525852381;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1526373862;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1530954608;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1532330237;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1538638779;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1542043996;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(long timestamp, boolean isPeriodic);1542119887;Triggers a new standard checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint._@param isPeriodic Flag indicating whether this triggered checkpoint is_periodic. If this flag is true, but the periodic scheduler is disabled,_the checkpoint will be declined._@return <code>true</code> if triggering the checkpoint succeeded.;public boolean triggerCheckpoint(long timestamp, boolean isPeriodic) {_		return triggerCheckpoint(timestamp, checkpointProperties, null, isPeriodic).isSuccess()__	};triggers,a,new,standard,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint,param,is,periodic,flag,indicating,whether,this,triggered,checkpoint,is,periodic,if,this,flag,is,true,but,the,periodic,scheduler,is,disabled,the,checkpoint,will,be,declined,return,code,true,code,if,triggering,the,checkpoint,succeeded;public,boolean,trigger,checkpoint,long,timestamp,boolean,is,periodic,return,trigger,checkpoint,timestamp,checkpoint,properties,null,is,periodic,is,success
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1430297241;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								checkpoint.discard()__								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timeoutTimer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timeout,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1431459357;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								checkpoint.discard()__								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1431459358;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								checkpoint.discard()__								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				pendingCheckpoints.remove(checkpointID)__			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoints,remove,checkpoint,id,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1432052753;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1432053122;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1434095691;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1435243086;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1435243086;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1436802870;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1437665997;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1439548490;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null && ee.getState() == ExecutionState.RUNNING) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1440611860;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null && ee.getState() == ExecutionState.RUNNING) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> public boolean triggerCheckpoint(final long timestamp);1441011751;Triggers a new checkpoint and uses the given timestamp as the checkpoint_timestamp.__@param timestamp The timestamp for the checkpoint.;public boolean triggerCheckpoint(final long timestamp) {_		if (shutdown) {_			LOG.error("Cannot trigger checkpoint, checkpoint coordinator has been shutdown.")__			return false__		}_		_		final long checkpointID = checkpointIdCounter.getAndIncrement()__		LOG.info("Triggering checkpoint " + checkpointID + " @ " + timestamp)__		_		try {_			_			_			ExecutionAttemptID[] triggerIDs = new ExecutionAttemptID[tasksToTrigger.length]__			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				Execution ee = tasksToTrigger[i].getCurrentExecutionAttempt()__				if (ee != null && ee.getState() == ExecutionState.RUNNING) {_					triggerIDs[i] = ee.getAttemptId()__				} else {_					LOG.info("Checkpoint triggering task {} is not being executed at the moment. Aborting checkpoint.",_							tasksToTrigger[i].getSimpleName())__					return false__				}_			}__			_			_			Map<ExecutionAttemptID, ExecutionVertex> ackTasks =_								new HashMap<ExecutionAttemptID, ExecutionVertex>(tasksToWaitFor.length)___			for (ExecutionVertex ev : tasksToWaitFor) {_				Execution ee = ev.getCurrentExecutionAttempt()__				if (ee != null) {_					ackTasks.put(ee.getAttemptId(), ev)__				} else {_					LOG.info("Checkpoint acknowledging task {} is not being executed at the moment. Aborting checkpoint.",_							ev.getSimpleName())__					return false__				}_			}_			_			_			final PendingCheckpoint checkpoint = new PendingCheckpoint(job, checkpointID, timestamp, ackTasks)___			_			TimerTask canceller = new TimerTask() {_				@Override_				public void run() {_					try {_						synchronized (lock) {_							_							_							if (!checkpoint.isDiscarded()) {_								LOG.info("Checkpoint " + checkpointID + " expired before completing.")__								_								checkpoint.discard(userClassLoader, true)__								_								pendingCheckpoints.remove(checkpointID)__								rememberRecentCheckpointId(checkpointID)__							}_						}_					}_					catch (Throwable t) {_						LOG.error("Exception while handling checkpoint timeout", t)__					}_				}_			}__			_			synchronized (lock) {_				if (shutdown) {_					throw new IllegalStateException("Checkpoint coordinator has been shutdown.")__				}_				pendingCheckpoints.put(checkpointID, checkpoint)__				timer.schedule(canceller, checkpointTimeout)__			}__			_			for (int i = 0_ i < tasksToTrigger.length_ i++) {_				ExecutionAttemptID id = triggerIDs[i]__				TriggerCheckpoint message = new TriggerCheckpoint(job, id, checkpointID, timestamp)__				tasksToTrigger[i].sendMessageToCurrentExecution(message, id)__			}_			_			numUnsuccessfulCheckpointsTriggers.set(0)__			return true__		}_		catch (Throwable t) {_			int numUnsuccessful = numUnsuccessfulCheckpointsTriggers.incrementAndGet()__			LOG.warn("Failed to trigger checkpoint (" + numUnsuccessful + " consecutive failed attempts so far)", t)__			_			synchronized (lock) {_				PendingCheckpoint checkpoint = pendingCheckpoints.remove(checkpointID)__				if (checkpoint != null && !checkpoint.isDiscarded()) {_					checkpoint.discard(userClassLoader, true)__				}_			}_			_			return false__		}_	};triggers,a,new,checkpoint,and,uses,the,given,timestamp,as,the,checkpoint,timestamp,param,timestamp,the,timestamp,for,the,checkpoint;public,boolean,trigger,checkpoint,final,long,timestamp,if,shutdown,log,error,cannot,trigger,checkpoint,checkpoint,coordinator,has,been,shutdown,return,false,final,long,checkpoint,id,checkpoint,id,counter,get,and,increment,log,info,triggering,checkpoint,checkpoint,id,timestamp,try,execution,attempt,id,trigger,ids,new,execution,attempt,id,tasks,to,trigger,length,for,int,i,0,i,tasks,to,trigger,length,i,execution,ee,tasks,to,trigger,i,get,current,execution,attempt,if,ee,null,ee,get,state,execution,state,running,trigger,ids,i,ee,get,attempt,id,else,log,info,checkpoint,triggering,task,is,not,being,executed,at,the,moment,aborting,checkpoint,tasks,to,trigger,i,get,simple,name,return,false,map,execution,attempt,id,execution,vertex,ack,tasks,new,hash,map,execution,attempt,id,execution,vertex,tasks,to,wait,for,length,for,execution,vertex,ev,tasks,to,wait,for,execution,ee,ev,get,current,execution,attempt,if,ee,null,ack,tasks,put,ee,get,attempt,id,ev,else,log,info,checkpoint,acknowledging,task,is,not,being,executed,at,the,moment,aborting,checkpoint,ev,get,simple,name,return,false,final,pending,checkpoint,checkpoint,new,pending,checkpoint,job,checkpoint,id,timestamp,ack,tasks,timer,task,canceller,new,timer,task,override,public,void,run,try,synchronized,lock,if,checkpoint,is,discarded,log,info,checkpoint,checkpoint,id,expired,before,completing,checkpoint,discard,user,class,loader,true,pending,checkpoints,remove,checkpoint,id,remember,recent,checkpoint,id,checkpoint,id,catch,throwable,t,log,error,exception,while,handling,checkpoint,timeout,t,synchronized,lock,if,shutdown,throw,new,illegal,state,exception,checkpoint,coordinator,has,been,shutdown,pending,checkpoints,put,checkpoint,id,checkpoint,timer,schedule,canceller,checkpoint,timeout,for,int,i,0,i,tasks,to,trigger,length,i,execution,attempt,id,id,trigger,ids,i,trigger,checkpoint,message,new,trigger,checkpoint,job,id,checkpoint,id,timestamp,tasks,to,trigger,i,send,message,to,current,execution,message,id,num,unsuccessful,checkpoints,triggers,set,0,return,true,catch,throwable,t,int,num,unsuccessful,num,unsuccessful,checkpoints,triggers,increment,and,get,log,warn,failed,to,trigger,checkpoint,num,unsuccessful,consecutive,failed,attempts,so,far,t,synchronized,lock,pending,checkpoint,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,checkpoint,discard,user,class,loader,true,return,false
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1448554589;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger_ _				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1451519127;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1452526243;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1453717703;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1455130319;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1456508638;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1460392581;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1461666173;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1465991918;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1468523508;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1468854249;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1469101812;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1469190400;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1469525443;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1471453562;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1471454287;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1471601024;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1472061377;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1472061377;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1472066344;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1472663071;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1472663401;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1472663401;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1472663401;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1472663402;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1474649312;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1474905901;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1475231926;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1476094623;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1476432306;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1476432429;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1476972861;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1477645452;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1477989375;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1478068461;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1478636134;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> private void triggerQueuedRequests() throws Exception;1479339295;Triggers the queued request, if there is one.__<p>NOTE: The caller of this method must hold the lock when invoking the method!;private void triggerQueuedRequests() throws Exception {_		if (triggerRequestQueued) {_			triggerRequestQueued = false___			_			_			ScheduledTrigger trigger = new ScheduledTrigger()__			if (periodicScheduling) {_				if (currentPeriodicTrigger != null) {_					currentPeriodicTrigger.cancel()__				}_				currentPeriodicTrigger = trigger__				timer.scheduleAtFixedRate(trigger, 0L, baseInterval)__			}_			else {_				timer.schedule(trigger, 0L)__			}_		}_	};triggers,the,queued,request,if,there,is,one,p,note,the,caller,of,this,method,must,hold,the,lock,when,invoking,the,method;private,void,trigger,queued,requests,throws,exception,if,trigger,request,queued,trigger,request,queued,false,scheduled,trigger,trigger,new,scheduled,trigger,if,periodic,scheduling,if,current,periodic,trigger,null,current,periodic,trigger,cancel,current,periodic,trigger,trigger,timer,schedule,at,fixed,rate,trigger,0l,base,interval,else,timer,schedule,trigger,0l
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1493236605;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1493325408;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1493403095;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1493758186;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1495287945;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1495527860;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1499314317;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1499939555;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1500040329;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1501588490;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1501665499;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1502801814;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1502801814;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1508762030;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1509118643;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1509125300;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1515177485;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1516295283;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1516295283;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1516295283;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1516626377;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1517489695;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1517489695;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1517489695;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1517489696;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1518945175;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1519481078;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1524124695;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1525852381;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1526373862;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1530954608;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1532330237;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1538638779;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1542043996;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public int getNumberOfRegisteredMasterHooks();1542119887;Gets the number of currently register master hooks.;public int getNumberOfRegisteredMasterHooks() {_		synchronized (lock) {_			return masterHooks.size()__		}_	};gets,the,number,of,currently,register,master,hooks;public,int,get,number,of,registered,master,hooks,synchronized,lock,return,master,hooks,size
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1479852017;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1480585463;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1480604127;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1481290933;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1481295943;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1484038132;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1485269495;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1487616195;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1487762095;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1487871589;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1488304750;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1488304933;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1489671806;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1490819573;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1492867556;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1492867556;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1493236605;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1493325408;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1493403095;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1493758186;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1495287945;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1495527860;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1499314317;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1499939555;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1500040329;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1501588490;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1501665499;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1502801814;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1502801814;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1508762030;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1509118643;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.get(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Discarding checkpoint {} because of checkpoint decline from task {} : {}",_						checkpointId, message.getTaskExecutionId(), reason)___				pendingCheckpoints.remove(checkpointId)__				checkpoint.abortDeclined()__				rememberRecentCheckpointId(checkpointId)___				_				_				__				boolean haveMoreRecentPending = false__				for (PendingCheckpoint p : pendingCheckpoints.values()) {_					if (!p.isDiscarded() && p.getCheckpointId() >= checkpoint.getCheckpointId()) {_						haveMoreRecentPending = true__						break__					}_				}__				if (!haveMoreRecentPending) {_					triggerQueuedRequests()__				}_			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,get,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,discarding,checkpoint,because,of,checkpoint,decline,from,task,checkpoint,id,message,get,task,execution,id,reason,pending,checkpoints,remove,checkpoint,id,checkpoint,abort,declined,remember,recent,checkpoint,id,checkpoint,id,boolean,have,more,recent,pending,false,for,pending,checkpoint,p,pending,checkpoints,values,if,p,is,discarded,p,get,checkpoint,id,checkpoint,get,checkpoint,id,have,more,recent,pending,true,break,if,have,more,recent,pending,trigger,queued,requests,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1509125300;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1515177485;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1516295283;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1516295283;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}_		_		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1516295283;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1516626377;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1517489695;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1517489695;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1517489695;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1517489696;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1518945175;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1519481078;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {}.", checkpointId, message.getTaskExecutionId())__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} : {}",_							checkpointId, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} : {}",_							checkpointId, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,checkpoint,id,message,get,task,execution,id,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,checkpoint,id,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,checkpoint,id,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1524124695;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {} of job {}.", checkpointId, message.getTaskExecutionId(), job)__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,of,job,checkpoint,id,message,get,task,execution,id,job,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,of,job,checkpoint,id,job,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,of,job,checkpoint,id,job,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1525852381;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {} of job {}.", checkpointId, message.getTaskExecutionId(), job)__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,of,job,checkpoint,id,message,get,task,execution,id,job,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,of,job,checkpoint,id,job,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,of,job,checkpoint,id,job,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1526373862;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {} of job {}.", checkpointId, message.getTaskExecutionId(), job)__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,of,job,checkpoint,id,message,get,task,execution,id,job,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,of,job,checkpoint,id,job,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,of,job,checkpoint,id,job,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1530954608;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {} of job {}.", checkpointId, message.getTaskExecutionId(), job)__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,of,job,checkpoint,id,message,get,task,execution,id,job,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,of,job,checkpoint,id,job,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,of,job,checkpoint,id,job,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1532330237;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {} of job {}.", checkpointId, message.getTaskExecutionId(), job)__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,of,job,checkpoint,id,message,get,task,execution,id,job,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,of,job,checkpoint,id,job,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,of,job,checkpoint,id,job,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1538638779;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {} of job {}.", checkpointId, message.getTaskExecutionId(), job)__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,of,job,checkpoint,id,message,get,task,execution,id,job,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,of,job,checkpoint,id,job,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,of,job,checkpoint,id,job,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1542043996;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {} of job {}.", checkpointId, message.getTaskExecutionId(), job)__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,of,job,checkpoint,id,message,get,task,execution,id,job,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,of,job,checkpoint,id,job,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,of,job,checkpoint,id,job,reason
CheckpointCoordinator -> public void receiveDeclineMessage(DeclineCheckpoint message);1542119887;Receives a {@link DeclineCheckpoint} message for a pending checkpoint.__@param message Checkpoint decline from the task manager;public void receiveDeclineMessage(DeclineCheckpoint message) {_		if (shutdown || message == null) {_			return__		}_		if (!job.equals(message.getJob())) {_			throw new IllegalArgumentException("Received DeclineCheckpoint message for job " +_				message.getJob() + " while this coordinator handles job " + job)__		}__		final long checkpointId = message.getCheckpointId()__		final String reason = (message.getReason() != null ? message.getReason().getMessage() : "")___		PendingCheckpoint checkpoint___		synchronized (lock) {_			_			_			if (shutdown) {_				return__			}__			checkpoint = pendingCheckpoints.remove(checkpointId)___			if (checkpoint != null && !checkpoint.isDiscarded()) {_				LOG.info("Decline checkpoint {} by task {} of job {}.", checkpointId, message.getTaskExecutionId(), job)__				discardCheckpoint(checkpoint, message.getReason())__			}_			else if (checkpoint != null) {_				_				throw new IllegalStateException(_						"Received message for discarded but non-removed checkpoint " + checkpointId)__			}_			else if (LOG.isDebugEnabled()) {_				if (recentPendingCheckpoints.contains(checkpointId)) {_					_					LOG.debug("Received another decline message for now expired checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				} else {_					_					LOG.debug("Received decline message for unknown (too old?) checkpoint attempt {} of job {} : {}",_							checkpointId, job, reason)__				}_			}_		}_	};receives,a,link,decline,checkpoint,message,for,a,pending,checkpoint,param,message,checkpoint,decline,from,the,task,manager;public,void,receive,decline,message,decline,checkpoint,message,if,shutdown,message,null,return,if,job,equals,message,get,job,throw,new,illegal,argument,exception,received,decline,checkpoint,message,for,job,message,get,job,while,this,coordinator,handles,job,job,final,long,checkpoint,id,message,get,checkpoint,id,final,string,reason,message,get,reason,null,message,get,reason,get,message,pending,checkpoint,checkpoint,synchronized,lock,if,shutdown,return,checkpoint,pending,checkpoints,remove,checkpoint,id,if,checkpoint,null,checkpoint,is,discarded,log,info,decline,checkpoint,by,task,of,job,checkpoint,id,message,get,task,execution,id,job,discard,checkpoint,checkpoint,message,get,reason,else,if,checkpoint,null,throw,new,illegal,state,exception,received,message,for,discarded,but,non,removed,checkpoint,checkpoint,id,else,if,log,is,debug,enabled,if,recent,pending,checkpoints,contains,checkpoint,id,log,debug,received,another,decline,message,for,now,expired,checkpoint,attempt,of,job,checkpoint,id,job,reason,else,log,debug,received,decline,message,for,unknown,too,old,checkpoint,attempt,of,job,checkpoint,id,job,reason
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1501588490;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case FULL_CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					CompletableFuture<CompletedCheckpoint> failedResult = new CompletableFuture<>()__					failedResult.completeExceptionally(cause)__					return failedResult__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,completable,future,completed,checkpoint,failed,result,new,completable,future,failed,result,complete,exceptionally,cause,return,failed,result,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1501665499;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case FULL_CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1502801814;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case FULL_CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1502801814;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case FULL_CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1508762030;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case FULL_CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1509118643;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1509125300;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1515177485;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1516295283;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1516295283;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, checkpointDirectory, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,checkpoint,directory,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1516295283;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, null, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,null,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> @VisibleForTesting 	@Internal 	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception;1516626377;Test method to trigger a checkpoint/savepoint.__@param timestamp The timestamp for the checkpoint._@param options The checkpoint options._@return A future to the completed checkpoint;@VisibleForTesting_	@Internal_	public CompletableFuture<CompletedCheckpoint> triggerCheckpoint(long timestamp, CheckpointOptions options) throws Exception {_		switch (options.getCheckpointType()) {_			case SAVEPOINT:_				return triggerSavepoint(timestamp, options.getTargetLocation())___			case CHECKPOINT:_				CheckpointTriggerResult triggerResult =_					triggerCheckpoint(timestamp, checkpointProperties, null, false)___				if (triggerResult.isSuccess()) {_					return triggerResult.getPendingCheckpoint().getCompletionFuture()__				} else {_					Throwable cause = new Exception("Failed to trigger checkpoint: " + triggerResult.getFailureReason().message())__					return FutureUtils.completedExceptionally(cause)__				}__			default:_				throw new IllegalArgumentException("Unknown checkpoint type: " + options.getCheckpointType())__		}_	};test,method,to,trigger,a,checkpoint,savepoint,param,timestamp,the,timestamp,for,the,checkpoint,param,options,the,checkpoint,options,return,a,future,to,the,completed,checkpoint;visible,for,testing,internal,public,completable,future,completed,checkpoint,trigger,checkpoint,long,timestamp,checkpoint,options,options,throws,exception,switch,options,get,checkpoint,type,case,savepoint,return,trigger,savepoint,timestamp,options,get,target,location,case,checkpoint,checkpoint,trigger,result,trigger,result,trigger,checkpoint,timestamp,checkpoint,properties,null,false,if,trigger,result,is,success,return,trigger,result,get,pending,checkpoint,get,completion,future,else,throwable,cause,new,exception,failed,to,trigger,checkpoint,trigger,result,get,failure,reason,message,return,future,utils,completed,exceptionally,cause,default,throw,new,illegal,argument,exception,unknown,checkpoint,type,options,get,checkpoint,type
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1481295943;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		CompletedCheckpoint completedCheckpoint = null___		try {_			completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()___			completedCheckpointStore.addCheckpoint(completedCheckpoint)___			rememberRecentCheckpointId(checkpointId)__			dropSubsumedCheckpoints(checkpointId)__		} catch (Exception exception) {_			_			if (!pendingCheckpoint.isDiscarded()) {_				pendingCheckpoint.abortError(exception)__			}__			if (completedCheckpoint != null) {_				_				final CompletedCheckpoint cc = completedCheckpoint___				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							cc.discard()__						} catch (Exception nestedException) {_							LOG.warn("Could not properly discard completed checkpoint {}.", cc.getCheckpointID(), nestedException)__						}_					}_				})__			}__			throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.delete(builder.length() - 2, builder.length())___			LOG.debug(builder.toString())__		}__		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}__		statsTracker.onCompletedCheckpoint(completedCheckpoint)__	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,completed,checkpoint,completed,checkpoint,null,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,checkpoint,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,catch,exception,exception,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,exception,if,completed,checkpoint,null,final,completed,checkpoint,cc,completed,checkpoint,executor,execute,new,runnable,override,public,void,run,try,cc,discard,catch,exception,nested,exception,log,warn,could,not,properly,discard,completed,checkpoint,cc,get,checkpoint,id,nested,exception,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,delete,builder,length,2,builder,length,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp,stats,tracker,on,completed,checkpoint,completed,checkpoint
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1484038132;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		CompletedCheckpoint completedCheckpoint = null___		try {_			completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()___			completedCheckpointStore.addCheckpoint(completedCheckpoint)___			rememberRecentCheckpointId(checkpointId)__			dropSubsumedCheckpoints(checkpointId)__		} catch (Exception exception) {_			_			if (!pendingCheckpoint.isDiscarded()) {_				pendingCheckpoint.abortError(exception)__			}__			if (completedCheckpoint != null) {_				_				final CompletedCheckpoint cc = completedCheckpoint___				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							cc.discard()__						} catch (Exception nestedException) {_							LOG.warn("Could not properly discard completed checkpoint {}.", cc.getCheckpointID(), nestedException)__						}_					}_				})__			}__			throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.delete(builder.length() - 2, builder.length())___			LOG.debug(builder.toString())__		}__		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,completed,checkpoint,completed,checkpoint,null,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,checkpoint,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,catch,exception,exception,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,exception,if,completed,checkpoint,null,final,completed,checkpoint,cc,completed,checkpoint,executor,execute,new,runnable,override,public,void,run,try,cc,discard,catch,exception,nested,exception,log,warn,could,not,properly,discard,completed,checkpoint,cc,get,checkpoint,id,nested,exception,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,delete,builder,length,2,builder,length,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1485269495;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		CompletedCheckpoint completedCheckpoint = null___		try {_			completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()___			completedCheckpointStore.addCheckpoint(completedCheckpoint)___			rememberRecentCheckpointId(checkpointId)__			dropSubsumedCheckpoints(checkpointId)__		} catch (Exception exception) {_			_			if (!pendingCheckpoint.isDiscarded()) {_				pendingCheckpoint.abortError(exception)__			}__			if (completedCheckpoint != null) {_				_				final CompletedCheckpoint cc = completedCheckpoint___				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							cc.discard()__						} catch (Exception nestedException) {_							LOG.warn("Could not properly discard completed checkpoint {}.", cc.getCheckpointID(), nestedException)__						}_					}_				})__			}__			throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.delete(builder.length() - 2, builder.length())___			LOG.debug(builder.toString())__		}__		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,completed,checkpoint,completed,checkpoint,null,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,checkpoint,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,catch,exception,exception,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,exception,if,completed,checkpoint,null,final,completed,checkpoint,cc,completed,checkpoint,executor,execute,new,runnable,override,public,void,run,try,cc,discard,catch,exception,nested,exception,log,warn,could,not,properly,discard,completed,checkpoint,cc,get,checkpoint,id,nested,exception,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,delete,builder,length,2,builder,length,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1487616195;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		CompletedCheckpoint completedCheckpoint = null___		try {_			completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()___			completedCheckpointStore.addCheckpoint(completedCheckpoint)___			rememberRecentCheckpointId(checkpointId)__			dropSubsumedCheckpoints(checkpointId)__		} catch (Exception exception) {_			_			if (!pendingCheckpoint.isDiscarded()) {_				pendingCheckpoint.abortError(exception)__			}__			if (completedCheckpoint != null) {_				_				final CompletedCheckpoint cc = completedCheckpoint___				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							cc.discard()__						} catch (Exception nestedException) {_							LOG.warn("Could not properly discard completed checkpoint {}.", cc.getCheckpointID(), nestedException)__						}_					}_				})__			}__			throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.delete(builder.length() - 2, builder.length())___			LOG.debug(builder.toString())__		}__		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,completed,checkpoint,completed,checkpoint,null,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,checkpoint,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,catch,exception,exception,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,exception,if,completed,checkpoint,null,final,completed,checkpoint,cc,completed,checkpoint,executor,execute,new,runnable,override,public,void,run,try,cc,discard,catch,exception,nested,exception,log,warn,could,not,properly,discard,completed,checkpoint,cc,get,checkpoint,id,nested,exception,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,delete,builder,length,2,builder,length,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1487762095;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		CompletedCheckpoint completedCheckpoint = null___		try {_			completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()___			completedCheckpointStore.addCheckpoint(completedCheckpoint)___			rememberRecentCheckpointId(checkpointId)__			dropSubsumedCheckpoints(checkpointId)__		} catch (Exception exception) {_			_			if (!pendingCheckpoint.isDiscarded()) {_				pendingCheckpoint.abortError(exception)__			}__			if (completedCheckpoint != null) {_				_				final CompletedCheckpoint cc = completedCheckpoint___				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							cc.discard()__						} catch (Exception nestedException) {_							LOG.warn("Could not properly discard completed checkpoint {}.", cc.getCheckpointID(), nestedException)__						}_					}_				})__			}__			throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.delete(builder.length() - 2, builder.length())___			LOG.debug(builder.toString())__		}__		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,completed,checkpoint,completed,checkpoint,null,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,checkpoint,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,catch,exception,exception,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,exception,if,completed,checkpoint,null,final,completed,checkpoint,cc,completed,checkpoint,executor,execute,new,runnable,override,public,void,run,try,cc,discard,catch,exception,nested,exception,log,warn,could,not,properly,discard,completed,checkpoint,cc,get,checkpoint,id,nested,exception,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,delete,builder,length,2,builder,length,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1487871589;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		CompletedCheckpoint completedCheckpoint = null___		try {_			completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()___			completedCheckpointStore.addCheckpoint(completedCheckpoint)___			rememberRecentCheckpointId(checkpointId)__			dropSubsumedCheckpoints(checkpointId)__		} catch (Exception exception) {_			_			if (!pendingCheckpoint.isDiscarded()) {_				pendingCheckpoint.abortError(exception)__			}__			if (completedCheckpoint != null) {_				_				final CompletedCheckpoint cc = completedCheckpoint___				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							cc.discard()__						} catch (Exception nestedException) {_							LOG.warn("Could not properly discard completed checkpoint {}.", cc.getCheckpointID(), nestedException)__						}_					}_				})__			}__			throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.delete(builder.length() - 2, builder.length())___			LOG.debug(builder.toString())__		}__		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,completed,checkpoint,completed,checkpoint,null,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,completed,checkpoint,store,add,checkpoint,completed,checkpoint,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,catch,exception,exception,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,exception,if,completed,checkpoint,null,final,completed,checkpoint,cc,completed,checkpoint,executor,execute,new,runnable,override,public,void,run,try,cc,discard,catch,exception,nested,exception,log,warn,could,not,properly,discard,completed,checkpoint,cc,get,checkpoint,id,nested,exception,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,delete,builder,length,2,builder,length,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1488304750;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		CompletedCheckpoint completedCheckpoint = null___		try {_			_			if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__			} else {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__			}__			completedCheckpointStore.addCheckpoint(completedCheckpoint)___			rememberRecentCheckpointId(checkpointId)__			dropSubsumedCheckpoints(checkpointId)__		}_		catch (Exception exception) {_			_			if (!pendingCheckpoint.isDiscarded()) {_				pendingCheckpoint.abortError(exception)__			}__			if (completedCheckpoint != null) {_				_				final CompletedCheckpoint cc = completedCheckpoint___				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							cc.discard()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", cc.getCheckpointID(), t)__						}_					}_				})__			}__			throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,completed,checkpoint,completed,checkpoint,null,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,completed,checkpoint,store,add,checkpoint,completed,checkpoint,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,catch,exception,exception,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,exception,if,completed,checkpoint,null,final,completed,checkpoint,cc,completed,checkpoint,executor,execute,new,runnable,override,public,void,run,try,cc,discard,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,cc,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1488304933;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		CompletedCheckpoint completedCheckpoint = null___		try {_			_			if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__			} else {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__			}__			completedCheckpointStore.addCheckpoint(completedCheckpoint)___			rememberRecentCheckpointId(checkpointId)__			dropSubsumedCheckpoints(checkpointId)__		}_		catch (Exception exception) {_			_			if (!pendingCheckpoint.isDiscarded()) {_				pendingCheckpoint.abortError(exception)__			}__			if (completedCheckpoint != null) {_				_				final CompletedCheckpoint cc = completedCheckpoint___				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							cc.discard()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", cc.getCheckpointID(), t)__						}_					}_				})__			}__			throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,completed,checkpoint,completed,checkpoint,null,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,completed,checkpoint,store,add,checkpoint,completed,checkpoint,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,catch,exception,exception,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,exception,if,completed,checkpoint,null,final,completed,checkpoint,cc,completed,checkpoint,executor,execute,new,runnable,override,public,void,run,try,cc,discard,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,cc,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1489671806;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		CompletedCheckpoint completedCheckpoint = null___		try {_			_			if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__			} else {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__			}__			completedCheckpointStore.addCheckpoint(completedCheckpoint)___			rememberRecentCheckpointId(checkpointId)__			dropSubsumedCheckpoints(checkpointId)__		}_		catch (Exception exception) {_			_			if (!pendingCheckpoint.isDiscarded()) {_				pendingCheckpoint.abortError(exception)__			}__			if (completedCheckpoint != null) {_				_				final CompletedCheckpoint cc = completedCheckpoint___				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							cc.discard()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", cc.getCheckpointID(), t)__						}_					}_				})__			}__			throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,completed,checkpoint,completed,checkpoint,null,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,completed,checkpoint,store,add,checkpoint,completed,checkpoint,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,catch,exception,exception,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,exception,if,completed,checkpoint,null,final,completed,checkpoint,cc,completed,checkpoint,executor,execute,new,runnable,override,public,void,run,try,cc,discard,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,cc,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1490819573;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		CompletedCheckpoint completedCheckpoint = null___		try {_			_			if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__			} else {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__			}__			completedCheckpointStore.addCheckpoint(completedCheckpoint)___			rememberRecentCheckpointId(checkpointId)__			dropSubsumedCheckpoints(checkpointId)__		}_		catch (Exception exception) {_			_			if (!pendingCheckpoint.isDiscarded()) {_				pendingCheckpoint.abortError(exception)__			}__			if (completedCheckpoint != null) {_				_				final CompletedCheckpoint cc = completedCheckpoint___				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							cc.discard()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", cc.getCheckpointID(), t)__						}_					}_				})__			}__			throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,completed,checkpoint,completed,checkpoint,null,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,completed,checkpoint,store,add,checkpoint,completed,checkpoint,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,catch,exception,exception,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,exception,if,completed,checkpoint,null,final,completed,checkpoint,cc,completed,checkpoint,executor,execute,new,runnable,override,public,void,run,try,cc,discard,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,cc,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1492867556;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)__	_			try {_				completedCheckpointStore.addCheckpoint(completedCheckpoint, sharedStateRegistry)__			} catch (Exception exception) {_				_				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							completedCheckpoint.discardOnFail()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__						}_					}_				})__				_				throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)__		_		_		dropSubsumedCheckpoints(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,shared,state,registry,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,fail,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1492867556;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			try {_				completedCheckpointStore.addCheckpoint(completedCheckpoint)__			} catch (Exception exception) {_				_				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							completedCheckpoint.discardOnFailedStoring()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__						}_					}_				})__				_				throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)__		_		_		dropSubsumedCheckpoints(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1493236605;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			try {_				completedCheckpointStore.addCheckpoint(completedCheckpoint)__			} catch (Exception exception) {_				_				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							completedCheckpoint.discardOnFailedStoring()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__						}_					}_				})__				_				throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)__		_		_		dropSubsumedCheckpoints(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1493325408;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			try {_				completedCheckpointStore.addCheckpoint(completedCheckpoint)__			} catch (Exception exception) {_				_				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							completedCheckpoint.discardOnFailedStoring()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__						}_					}_				})__				_				throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)__		_		_		dropSubsumedCheckpoints(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (TaskState state : completedCheckpoint.getTaskStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,task,state,state,completed,checkpoint,get,task,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1493403095;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			try {_				completedCheckpointStore.addCheckpoint(completedCheckpoint)__			} catch (Exception exception) {_				_				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							completedCheckpoint.discardOnFailedStoring()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__						}_					}_				})__				_				throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)__		_		_		dropSubsumedCheckpoints(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1493758186;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			try {_				completedCheckpointStore.addCheckpoint(completedCheckpoint)__			} catch (Exception exception) {_				_				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							completedCheckpoint.discardOnFailedStoring()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__						}_					}_				})__				_				throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)__		_		_		dropSubsumedCheckpoints(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1495287945;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			try {_				completedCheckpointStore.addCheckpoint(completedCheckpoint)__			} catch (Exception exception) {_				_				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							completedCheckpoint.discardOnFailedStoring()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__						}_					}_				})__				_				throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)__		_		_		dropSubsumedCheckpoints(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1495527860;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1499314317;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1499939555;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1500040329;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1501588490;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1501665499;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1502801814;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1502801814;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1508762030;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1509118643;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}_	_				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}_	_			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}_		_		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1509125300;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1515177485;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1516295283;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1516295283;Try to complete the given pending checkpoint.__Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				_				if (pendingCheckpoint.getProps().externalizeCheckpoint()) {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointExternalized()__				} else {_					completedCheckpoint = pendingCheckpoint.finalizeCheckpointNonExternalized()__				}_			} catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,if,pending,checkpoint,get,props,externalize,checkpoint,completed,checkpoint,pending,checkpoint,finalize,checkpoint,externalized,else,completed,checkpoint,pending,checkpoint,finalize,checkpoint,non,externalized,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1516295283;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1516626377;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1517489695;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1517489695;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1517489695;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1517489696;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1518945175;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1519481078;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} ({} bytes in {} ms).", checkpointId,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,bytes,in,ms,checkpoint,id,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1524124695;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {} of job {}.", completedCheckpoint.getCheckpointID(), job, t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} for job {} ({} bytes in {} ms).", checkpointId, job,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,of,job,completed,checkpoint,get,checkpoint,id,job,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,for,job,bytes,in,ms,checkpoint,id,job,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1525852381;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {} of job {}.", completedCheckpoint.getCheckpointID(), job, t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} for job {} ({} bytes in {} ms).", checkpointId, job,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,of,job,completed,checkpoint,get,checkpoint,id,job,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,for,job,bytes,in,ms,checkpoint,id,job,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1526373862;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {} of job {}.", completedCheckpoint.getCheckpointID(), job, t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} for job {} ({} bytes in {} ms).", checkpointId, job,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,of,job,completed,checkpoint,get,checkpoint,id,job,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,for,job,bytes,in,ms,checkpoint,id,job,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1530954608;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {} of job {}.", completedCheckpoint.getCheckpointID(), job, t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} for job {} ({} bytes in {} ms).", checkpointId, job,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,of,job,completed,checkpoint,get,checkpoint,id,job,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,for,job,bytes,in,ms,checkpoint,id,job,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1532330237;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			_			if (!completedCheckpoint.getProperties().isSavepoint()) {_				try {_					completedCheckpointStore.addCheckpoint(completedCheckpoint)__				} catch (Exception exception) {_					_					executor.execute(new Runnable() {_						@Override_						public void run() {_							try {_								completedCheckpoint.discardOnFailedStoring()__							} catch (Throwable t) {_								LOG.warn("Could not properly discard completed checkpoint {} of job {}.", completedCheckpoint.getCheckpointID(), job, t)__							}_						}_					})___					throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__				}__				_				dropSubsumedCheckpoints(checkpointId)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} for job {} ({} bytes in {} ms).", checkpointId, job,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,if,completed,checkpoint,get,properties,is,savepoint,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,of,job,completed,checkpoint,get,checkpoint,id,job,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,drop,subsumed,checkpoints,checkpoint,id,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,for,job,bytes,in,ms,checkpoint,id,job,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1538638779;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			try {_				completedCheckpointStore.addCheckpoint(completedCheckpoint)__			} catch (Exception exception) {_				_				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							completedCheckpoint.discardOnFailedStoring()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__						}_					}_				})___				throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		dropSubsumedCheckpoints(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} for job {} ({} bytes in {} ms).", checkpointId, job,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,for,job,bytes,in,ms,checkpoint,id,job,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1542043996;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			try {_				completedCheckpointStore.addCheckpoint(completedCheckpoint)__			} catch (Exception exception) {_				_				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							completedCheckpoint.discardOnFailedStoring()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__						}_					}_				})___				throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		dropSubsumedCheckpoints(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} for job {} ({} bytes in {} ms).", checkpointId, job,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,for,job,bytes,in,ms,checkpoint,id,job,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException;1542119887;Try to complete the given pending checkpoint.__<p>Important: This method should only be called in the checkpoint lock scope.__@param pendingCheckpoint to complete_@throws CheckpointException if the completion failed;private void completePendingCheckpoint(PendingCheckpoint pendingCheckpoint) throws CheckpointException {_		final long checkpointId = pendingCheckpoint.getCheckpointId()__		final CompletedCheckpoint completedCheckpoint___		_		Map<OperatorID, OperatorState> operatorStates = pendingCheckpoint.getOperatorStates()__		sharedStateRegistry.registerAll(operatorStates.values())___		try {_			try {_				completedCheckpoint = pendingCheckpoint.finalizeCheckpoint()__			}_			catch (Exception e1) {_				_				if (!pendingCheckpoint.isDiscarded()) {_					pendingCheckpoint.abortError(e1)__				}__				throw new CheckpointException("Could not finalize the pending checkpoint " + checkpointId + '.', e1)__			}__			_			Preconditions.checkState(pendingCheckpoint.isDiscarded() && completedCheckpoint != null)___			try {_				completedCheckpointStore.addCheckpoint(completedCheckpoint)__			} catch (Exception exception) {_				_				executor.execute(new Runnable() {_					@Override_					public void run() {_						try {_							completedCheckpoint.discardOnFailedStoring()__						} catch (Throwable t) {_							LOG.warn("Could not properly discard completed checkpoint {}.", completedCheckpoint.getCheckpointID(), t)__						}_					}_				})___				throw new CheckpointException("Could not complete the pending checkpoint " + checkpointId + '.', exception)__			}_		} finally {_			pendingCheckpoints.remove(checkpointId)___			triggerQueuedRequests()__		}__		rememberRecentCheckpointId(checkpointId)___		_		dropSubsumedCheckpoints(checkpointId)___		_		_		lastCheckpointCompletionNanos = System.nanoTime()___		LOG.info("Completed checkpoint {} for job {} ({} bytes in {} ms).", checkpointId, job,_			completedCheckpoint.getStateSize(), completedCheckpoint.getDuration())___		if (LOG.isDebugEnabled()) {_			StringBuilder builder = new StringBuilder()__			builder.append("Checkpoint state: ")__			for (OperatorState state : completedCheckpoint.getOperatorStates().values()) {_				builder.append(state)__				builder.append(", ")__			}_			_			builder.setLength(builder.length() - 2)___			LOG.debug(builder.toString())__		}__		_		final long timestamp = completedCheckpoint.getTimestamp()___		for (ExecutionVertex ev : tasksToCommitTo) {_			Execution ee = ev.getCurrentExecutionAttempt()__			if (ee != null) {_				ee.notifyCheckpointComplete(checkpointId, timestamp)__			}_		}_	};try,to,complete,the,given,pending,checkpoint,p,important,this,method,should,only,be,called,in,the,checkpoint,lock,scope,param,pending,checkpoint,to,complete,throws,checkpoint,exception,if,the,completion,failed;private,void,complete,pending,checkpoint,pending,checkpoint,pending,checkpoint,throws,checkpoint,exception,final,long,checkpoint,id,pending,checkpoint,get,checkpoint,id,final,completed,checkpoint,completed,checkpoint,map,operator,id,operator,state,operator,states,pending,checkpoint,get,operator,states,shared,state,registry,register,all,operator,states,values,try,try,completed,checkpoint,pending,checkpoint,finalize,checkpoint,catch,exception,e1,if,pending,checkpoint,is,discarded,pending,checkpoint,abort,error,e1,throw,new,checkpoint,exception,could,not,finalize,the,pending,checkpoint,checkpoint,id,e1,preconditions,check,state,pending,checkpoint,is,discarded,completed,checkpoint,null,try,completed,checkpoint,store,add,checkpoint,completed,checkpoint,catch,exception,exception,executor,execute,new,runnable,override,public,void,run,try,completed,checkpoint,discard,on,failed,storing,catch,throwable,t,log,warn,could,not,properly,discard,completed,checkpoint,completed,checkpoint,get,checkpoint,id,t,throw,new,checkpoint,exception,could,not,complete,the,pending,checkpoint,checkpoint,id,exception,finally,pending,checkpoints,remove,checkpoint,id,trigger,queued,requests,remember,recent,checkpoint,id,checkpoint,id,drop,subsumed,checkpoints,checkpoint,id,last,checkpoint,completion,nanos,system,nano,time,log,info,completed,checkpoint,for,job,bytes,in,ms,checkpoint,id,job,completed,checkpoint,get,state,size,completed,checkpoint,get,duration,if,log,is,debug,enabled,string,builder,builder,new,string,builder,builder,append,checkpoint,state,for,operator,state,state,completed,checkpoint,get,operator,states,values,builder,append,state,builder,append,builder,set,length,builder,length,2,log,debug,builder,to,string,final,long,timestamp,completed,checkpoint,get,timestamp,for,execution,vertex,ev,tasks,to,commit,to,execution,ee,ev,get,current,execution,attempt,if,ee,null,ee,notify,checkpoint,complete,checkpoint,id,timestamp
CheckpointCoordinator -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1472663401;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)__		int start = 0__		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRange.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,int,start,0,for,int,i,0,i,parallelism,i,result,add,key,group,range,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
CheckpointCoordinator -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1472663401;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)__		int start = 0__		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRange.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,int,start,0,for,int,i,0,i,parallelism,i,result,add,key,group,range,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
CheckpointCoordinator -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1472663401;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)__		int start = 0__		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,int,start,0,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
CheckpointCoordinator -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1472663402;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)__		int start = 0__		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,int,start,0,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
CheckpointCoordinator -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1474649312;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)__		int start = 0__		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,int,start,0,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
CheckpointCoordinator -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1474905901;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)__		int start = 0__		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,int,start,0,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
CheckpointCoordinator -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1475231926;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
CheckpointCoordinator -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1476094623;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
CheckpointCoordinator -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1476432306;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
CheckpointCoordinator -> public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism);1476432429;Groups the available set of key groups into key group partitions. A key group partition is_the set of key groups which is assigned to the same task. Each set of the returned list_constitutes a key group partition.__<b>IMPORTANT</b>: The assignment of key groups to partitions has to be in sync with the_KeyGroupStreamPartitioner.__@param numberKeyGroups Number of available key groups (indexed from 0 to numberKeyGroups - 1)_@param parallelism Parallelism to generate the key group partitioning for_@return List of key group partitions;public static List<KeyGroupRange> createKeyGroupPartitions(int numberKeyGroups, int parallelism) {_		Preconditions.checkArgument(numberKeyGroups >= parallelism)__		List<KeyGroupRange> result = new ArrayList<>(parallelism)___		for (int i = 0_ i < parallelism_ ++i) {_			result.add(KeyGroupRangeAssignment.computeKeyGroupRangeForOperatorIndex(numberKeyGroups, parallelism, i))__		}_		return result__	};groups,the,available,set,of,key,groups,into,key,group,partitions,a,key,group,partition,is,the,set,of,key,groups,which,is,assigned,to,the,same,task,each,set,of,the,returned,list,constitutes,a,key,group,partition,b,important,b,the,assignment,of,key,groups,to,partitions,has,to,be,in,sync,with,the,key,group,stream,partitioner,param,number,key,groups,number,of,available,key,groups,indexed,from,0,to,number,key,groups,1,param,parallelism,parallelism,to,generate,the,key,group,partitioning,for,return,list,of,key,group,partitions;public,static,list,key,group,range,create,key,group,partitions,int,number,key,groups,int,parallelism,preconditions,check,argument,number,key,groups,parallelism,list,key,group,range,result,new,array,list,parallelism,for,int,i,0,i,parallelism,i,result,add,key,group,range,assignment,compute,key,group,range,for,operator,index,number,key,groups,parallelism,i,return,result
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1509125300;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unaknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unaknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1515177485;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1516295283;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1516295283;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1516295283;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1516626377;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1517489695;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1517489695;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1517489695;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1517489696;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1518945175;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1519481078;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1524124695;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1525852381;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1526373862;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1530954608;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1532330237;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1538638779;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1542043996;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
CheckpointCoordinator -> public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause);1542119887;Fails all pending checkpoints which have not been acknowledged by the given execution_attempt id.__@param executionAttemptId for which to discard unacknowledged pending checkpoints_@param cause of the failure;public void failUnacknowledgedPendingCheckpointsFor(ExecutionAttemptID executionAttemptId, Throwable cause) {_		synchronized (lock) {_			Iterator<PendingCheckpoint> pendingCheckpointIterator = pendingCheckpoints.values().iterator()___			while (pendingCheckpointIterator.hasNext()) {_				final PendingCheckpoint pendingCheckpoint = pendingCheckpointIterator.next()___				if (!pendingCheckpoint.isAcknowledgedBy(executionAttemptId)) {_					pendingCheckpointIterator.remove()__					discardCheckpoint(pendingCheckpoint, cause)__				}_			}_		}_	};fails,all,pending,checkpoints,which,have,not,been,acknowledged,by,the,given,execution,attempt,id,param,execution,attempt,id,for,which,to,discard,unacknowledged,pending,checkpoints,param,cause,of,the,failure;public,void,fail,unacknowledged,pending,checkpoints,for,execution,attempt,id,execution,attempt,id,throwable,cause,synchronized,lock,iterator,pending,checkpoint,pending,checkpoint,iterator,pending,checkpoints,values,iterator,while,pending,checkpoint,iterator,has,next,final,pending,checkpoint,pending,checkpoint,pending,checkpoint,iterator,next,if,pending,checkpoint,is,acknowledged,by,execution,attempt,id,pending,checkpoint,iterator,remove,discard,checkpoint,pending,checkpoint,cause
