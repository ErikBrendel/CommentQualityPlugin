# id;timestamp;commentText;codeText;commentWords;codeWords
NestedMapsStateTable -> private int indexToOffset(int index);1488534675;Translates a key-group id to the internal array offset.;private int indexToOffset(int index) {_		return index - keyGroupOffset__	};translates,a,key,group,id,to,the,internal,array,offset;private,int,index,to,offset,int,index,return,index,key,group,offset
NestedMapsStateTable -> private int indexToOffset(int index);1494180263;Translates a key-group id to the internal array offset.;private int indexToOffset(int index) {_		return index - keyGroupOffset__	};translates,a,key,group,id,to,the,internal,array,offset;private,int,index,to,offset,int,index,return,index,key,group,offset
NestedMapsStateTable -> private int indexToOffset(int index);1497273707;Translates a key-group id to the internal array offset.;private int indexToOffset(int index) {_		return index - keyGroupOffset__	};translates,a,key,group,id,to,the,internal,array,offset;private,int,index,to,offset,int,index,return,index,key,group,offset
NestedMapsStateTable -> private int indexToOffset(int index);1501836962;Translates a key-group id to the internal array offset.;private int indexToOffset(int index) {_		return index - keyGroupOffset__	};translates,a,key,group,id,to,the,internal,array,offset;private,int,index,to,offset,int,index,return,index,key,group,offset
NestedMapsStateTable -> private int indexToOffset(int index);1505385570;Translates a key-group id to the internal array offset.;private int indexToOffset(int index) {_		return index - keyGroupOffset__	};translates,a,key,group,id,to,the,internal,array,offset;private,int,index,to,offset,int,index,return,index,key,group,offset
NestedMapsStateTable -> private int indexToOffset(int index);1528721286;Translates a key-group id to the internal array offset.;private int indexToOffset(int index) {_		return index - keyGroupOffset__	};translates,a,key,group,id,to,the,internal,array,offset;private,int,index,to,offset,int,index,return,index,key,group,offset
NestedMapsStateTable -> private int indexToOffset(int index);1528883776;Translates a key-group id to the internal array offset.;private int indexToOffset(int index) {_		return index - keyGroupOffset__	};translates,a,key,group,id,to,the,internal,array,offset;private,int,index,to,offset,int,index,return,index,key,group,offset
NestedMapsStateTable -> private int indexToOffset(int index);1533313087;Translates a key-group id to the internal array offset.;private int indexToOffset(int index) {_		return index - keyGroupOffset__	};translates,a,key,group,id,to,the,internal,array,offset;private,int,index,to,offset,int,index,return,index,key,group,offset
NestedMapsStateTable -> private int indexToOffset(int index);1538063092;Translates a key-group id to the internal array offset.;private int indexToOffset(int index) {_		return index - keyGroupOffset__	};translates,a,key,group,id,to,the,internal,array,offset;private,int,index,to,offset,int,index,return,index,key,group,offset
NestedMapsStateTable -> private int indexToOffset(int index);1545062987;Translates a key-group id to the internal array offset.;private int indexToOffset(int index) {_		return index - keyGroupOffset__	};translates,a,key,group,id,to,the,internal,array,offset;private,int,index,to,offset,int,index,return,index,key,group,offset
NestedMapsStateTable -> NestedMapsStateTableSnapshot -> @Override 		public void writeMappingsInKeyGroup(DataOutputView dov, int keyGroupId) throws IOException;1488534675;Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and_{@link CopyOnWriteStateTable}._<p>_{@link NestedMapsStateTable} could naturally support a kind of_prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each_mapping). We might implement support for different formats later (tailored towards different state table_implementations).;@Override_		public void writeMappingsInKeyGroup(DataOutputView dov, int keyGroupId) throws IOException {_			final Map<N, Map<K, S>> keyGroupMap = owningStateTable.getMapForKeyGroup(keyGroupId)__			if (null != keyGroupMap) {_				TypeSerializer<K> keySerializer = owningStateTable.keyContext.getKeySerializer()__				TypeSerializer<N> namespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer()__				TypeSerializer<S> stateSerializer = owningStateTable.metaInfo.getStateSerializer()__				dov.writeInt(countMappingsInKeyGroup(keyGroupMap))__				for (Map.Entry<N, Map<K, S>> namespaceEntry : keyGroupMap.entrySet()) {_					final N namespace = namespaceEntry.getKey()__					final Map<K, S> namespaceMap = namespaceEntry.getValue()___					for (Map.Entry<K, S> keyEntry : namespaceMap.entrySet()) {_						namespaceSerializer.serialize(namespace, dov)__						keySerializer.serialize(keyEntry.getKey(), dov)__						stateSerializer.serialize(keyEntry.getValue(), dov)__					}_				}_			} else {_				dov.writeInt(0)__			}_		};implementation,note,we,currently,chose,the,same,format,between,link,nested,maps,state,table,and,link,copy,on,write,state,table,p,link,nested,maps,state,table,could,naturally,support,a,kind,of,prefix,compressed,format,grouping,by,namespace,writing,the,namespace,only,once,per,group,instead,for,each,mapping,we,might,implement,support,for,different,formats,later,tailored,towards,different,state,table,implementations;override,public,void,write,mappings,in,key,group,data,output,view,dov,int,key,group,id,throws,ioexception,final,map,n,map,k,s,key,group,map,owning,state,table,get,map,for,key,group,key,group,id,if,null,key,group,map,type,serializer,k,key,serializer,owning,state,table,key,context,get,key,serializer,type,serializer,n,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,type,serializer,s,state,serializer,owning,state,table,meta,info,get,state,serializer,dov,write,int,count,mappings,in,key,group,key,group,map,for,map,entry,n,map,k,s,namespace,entry,key,group,map,entry,set,final,n,namespace,namespace,entry,get,key,final,map,k,s,namespace,map,namespace,entry,get,value,for,map,entry,k,s,key,entry,namespace,map,entry,set,namespace,serializer,serialize,namespace,dov,key,serializer,serialize,key,entry,get,key,dov,state,serializer,serialize,key,entry,get,value,dov,else,dov,write,int,0
NestedMapsStateTable -> NestedMapsStateTableSnapshot -> @Override 		public void writeMappingsInKeyGroup(DataOutputView dov, int keyGroupId) throws IOException;1494180263;Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and_{@link CopyOnWriteStateTable}._<p>_{@link NestedMapsStateTable} could naturally support a kind of_prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each_mapping). We might implement support for different formats later (tailored towards different state table_implementations).;@Override_		public void writeMappingsInKeyGroup(DataOutputView dov, int keyGroupId) throws IOException {_			final Map<N, Map<K, S>> keyGroupMap = owningStateTable.getMapForKeyGroup(keyGroupId)__			if (null != keyGroupMap) {_				TypeSerializer<K> keySerializer = owningStateTable.keyContext.getKeySerializer()__				TypeSerializer<N> namespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer()__				TypeSerializer<S> stateSerializer = owningStateTable.metaInfo.getStateSerializer()__				dov.writeInt(countMappingsInKeyGroup(keyGroupMap))__				for (Map.Entry<N, Map<K, S>> namespaceEntry : keyGroupMap.entrySet()) {_					final N namespace = namespaceEntry.getKey()__					final Map<K, S> namespaceMap = namespaceEntry.getValue()___					for (Map.Entry<K, S> keyEntry : namespaceMap.entrySet()) {_						namespaceSerializer.serialize(namespace, dov)__						keySerializer.serialize(keyEntry.getKey(), dov)__						stateSerializer.serialize(keyEntry.getValue(), dov)__					}_				}_			} else {_				dov.writeInt(0)__			}_		};implementation,note,we,currently,chose,the,same,format,between,link,nested,maps,state,table,and,link,copy,on,write,state,table,p,link,nested,maps,state,table,could,naturally,support,a,kind,of,prefix,compressed,format,grouping,by,namespace,writing,the,namespace,only,once,per,group,instead,for,each,mapping,we,might,implement,support,for,different,formats,later,tailored,towards,different,state,table,implementations;override,public,void,write,mappings,in,key,group,data,output,view,dov,int,key,group,id,throws,ioexception,final,map,n,map,k,s,key,group,map,owning,state,table,get,map,for,key,group,key,group,id,if,null,key,group,map,type,serializer,k,key,serializer,owning,state,table,key,context,get,key,serializer,type,serializer,n,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,type,serializer,s,state,serializer,owning,state,table,meta,info,get,state,serializer,dov,write,int,count,mappings,in,key,group,key,group,map,for,map,entry,n,map,k,s,namespace,entry,key,group,map,entry,set,final,n,namespace,namespace,entry,get,key,final,map,k,s,namespace,map,namespace,entry,get,value,for,map,entry,k,s,key,entry,namespace,map,entry,set,namespace,serializer,serialize,namespace,dov,key,serializer,serialize,key,entry,get,key,dov,state,serializer,serialize,key,entry,get,value,dov,else,dov,write,int,0
NestedMapsStateTable -> NestedMapsStateTableSnapshot -> @Override 		public void writeMappingsInKeyGroup(DataOutputView dov, int keyGroupId) throws IOException;1497273707;Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and_{@link CopyOnWriteStateTable}._<p>_{@link NestedMapsStateTable} could naturally support a kind of_prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each_mapping). We might implement support for different formats later (tailored towards different state table_implementations).;@Override_		public void writeMappingsInKeyGroup(DataOutputView dov, int keyGroupId) throws IOException {_			final Map<N, Map<K, S>> keyGroupMap = owningStateTable.getMapForKeyGroup(keyGroupId)__			if (null != keyGroupMap) {_				TypeSerializer<K> keySerializer = owningStateTable.keyContext.getKeySerializer()__				TypeSerializer<N> namespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer()__				TypeSerializer<S> stateSerializer = owningStateTable.metaInfo.getStateSerializer()__				dov.writeInt(countMappingsInKeyGroup(keyGroupMap))__				for (Map.Entry<N, Map<K, S>> namespaceEntry : keyGroupMap.entrySet()) {_					final N namespace = namespaceEntry.getKey()__					final Map<K, S> namespaceMap = namespaceEntry.getValue()___					for (Map.Entry<K, S> keyEntry : namespaceMap.entrySet()) {_						namespaceSerializer.serialize(namespace, dov)__						keySerializer.serialize(keyEntry.getKey(), dov)__						stateSerializer.serialize(keyEntry.getValue(), dov)__					}_				}_			} else {_				dov.writeInt(0)__			}_		};implementation,note,we,currently,chose,the,same,format,between,link,nested,maps,state,table,and,link,copy,on,write,state,table,p,link,nested,maps,state,table,could,naturally,support,a,kind,of,prefix,compressed,format,grouping,by,namespace,writing,the,namespace,only,once,per,group,instead,for,each,mapping,we,might,implement,support,for,different,formats,later,tailored,towards,different,state,table,implementations;override,public,void,write,mappings,in,key,group,data,output,view,dov,int,key,group,id,throws,ioexception,final,map,n,map,k,s,key,group,map,owning,state,table,get,map,for,key,group,key,group,id,if,null,key,group,map,type,serializer,k,key,serializer,owning,state,table,key,context,get,key,serializer,type,serializer,n,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,type,serializer,s,state,serializer,owning,state,table,meta,info,get,state,serializer,dov,write,int,count,mappings,in,key,group,key,group,map,for,map,entry,n,map,k,s,namespace,entry,key,group,map,entry,set,final,n,namespace,namespace,entry,get,key,final,map,k,s,namespace,map,namespace,entry,get,value,for,map,entry,k,s,key,entry,namespace,map,entry,set,namespace,serializer,serialize,namespace,dov,key,serializer,serialize,key,entry,get,key,dov,state,serializer,serialize,key,entry,get,value,dov,else,dov,write,int,0
NestedMapsStateTable -> NestedMapsStateTableSnapshot -> @Override 		public void writeMappingsInKeyGroup(DataOutputView dov, int keyGroupId) throws IOException;1501836962;Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and_{@link CopyOnWriteStateTable}._<p>_{@link NestedMapsStateTable} could naturally support a kind of_prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each_mapping). We might implement support for different formats later (tailored towards different state table_implementations).;@Override_		public void writeMappingsInKeyGroup(DataOutputView dov, int keyGroupId) throws IOException {_			final Map<N, Map<K, S>> keyGroupMap = owningStateTable.getMapForKeyGroup(keyGroupId)__			if (null != keyGroupMap) {_				TypeSerializer<K> keySerializer = owningStateTable.keyContext.getKeySerializer()__				TypeSerializer<N> namespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer()__				TypeSerializer<S> stateSerializer = owningStateTable.metaInfo.getStateSerializer()__				dov.writeInt(countMappingsInKeyGroup(keyGroupMap))__				for (Map.Entry<N, Map<K, S>> namespaceEntry : keyGroupMap.entrySet()) {_					final N namespace = namespaceEntry.getKey()__					final Map<K, S> namespaceMap = namespaceEntry.getValue()___					for (Map.Entry<K, S> keyEntry : namespaceMap.entrySet()) {_						namespaceSerializer.serialize(namespace, dov)__						keySerializer.serialize(keyEntry.getKey(), dov)__						stateSerializer.serialize(keyEntry.getValue(), dov)__					}_				}_			} else {_				dov.writeInt(0)__			}_		};implementation,note,we,currently,chose,the,same,format,between,link,nested,maps,state,table,and,link,copy,on,write,state,table,p,link,nested,maps,state,table,could,naturally,support,a,kind,of,prefix,compressed,format,grouping,by,namespace,writing,the,namespace,only,once,per,group,instead,for,each,mapping,we,might,implement,support,for,different,formats,later,tailored,towards,different,state,table,implementations;override,public,void,write,mappings,in,key,group,data,output,view,dov,int,key,group,id,throws,ioexception,final,map,n,map,k,s,key,group,map,owning,state,table,get,map,for,key,group,key,group,id,if,null,key,group,map,type,serializer,k,key,serializer,owning,state,table,key,context,get,key,serializer,type,serializer,n,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,type,serializer,s,state,serializer,owning,state,table,meta,info,get,state,serializer,dov,write,int,count,mappings,in,key,group,key,group,map,for,map,entry,n,map,k,s,namespace,entry,key,group,map,entry,set,final,n,namespace,namespace,entry,get,key,final,map,k,s,namespace,map,namespace,entry,get,value,for,map,entry,k,s,key,entry,namespace,map,entry,set,namespace,serializer,serialize,namespace,dov,key,serializer,serialize,key,entry,get,key,dov,state,serializer,serialize,key,entry,get,value,dov,else,dov,write,int,0
NestedMapsStateTable -> NestedMapsStateTableSnapshot -> @Override 		public void writeMappingsInKeyGroup(DataOutputView dov, int keyGroupId) throws IOException;1505385570;Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and_{@link CopyOnWriteStateTable}._<p>_{@link NestedMapsStateTable} could naturally support a kind of_prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each_mapping). We might implement support for different formats later (tailored towards different state table_implementations).;@Override_		public void writeMappingsInKeyGroup(DataOutputView dov, int keyGroupId) throws IOException {_			final Map<N, Map<K, S>> keyGroupMap = owningStateTable.getMapForKeyGroup(keyGroupId)__			if (null != keyGroupMap) {_				TypeSerializer<K> keySerializer = owningStateTable.keyContext.getKeySerializer()__				TypeSerializer<N> namespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer()__				TypeSerializer<S> stateSerializer = owningStateTable.metaInfo.getStateSerializer()__				dov.writeInt(countMappingsInKeyGroup(keyGroupMap))__				for (Map.Entry<N, Map<K, S>> namespaceEntry : keyGroupMap.entrySet()) {_					final N namespace = namespaceEntry.getKey()__					final Map<K, S> namespaceMap = namespaceEntry.getValue()___					for (Map.Entry<K, S> keyEntry : namespaceMap.entrySet()) {_						namespaceSerializer.serialize(namespace, dov)__						keySerializer.serialize(keyEntry.getKey(), dov)__						stateSerializer.serialize(keyEntry.getValue(), dov)__					}_				}_			} else {_				dov.writeInt(0)__			}_		};implementation,note,we,currently,chose,the,same,format,between,link,nested,maps,state,table,and,link,copy,on,write,state,table,p,link,nested,maps,state,table,could,naturally,support,a,kind,of,prefix,compressed,format,grouping,by,namespace,writing,the,namespace,only,once,per,group,instead,for,each,mapping,we,might,implement,support,for,different,formats,later,tailored,towards,different,state,table,implementations;override,public,void,write,mappings,in,key,group,data,output,view,dov,int,key,group,id,throws,ioexception,final,map,n,map,k,s,key,group,map,owning,state,table,get,map,for,key,group,key,group,id,if,null,key,group,map,type,serializer,k,key,serializer,owning,state,table,key,context,get,key,serializer,type,serializer,n,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,type,serializer,s,state,serializer,owning,state,table,meta,info,get,state,serializer,dov,write,int,count,mappings,in,key,group,key,group,map,for,map,entry,n,map,k,s,namespace,entry,key,group,map,entry,set,final,n,namespace,namespace,entry,get,key,final,map,k,s,namespace,map,namespace,entry,get,value,for,map,entry,k,s,key,entry,namespace,map,entry,set,namespace,serializer,serialize,namespace,dov,key,serializer,serialize,key,entry,get,key,dov,state,serializer,serialize,key,entry,get,value,dov,else,dov,write,int,0
NestedMapsStateTable -> public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1494180263;Creates a new {@link NestedMapsStateTable} for the given key context and meta info.__@param keyContext the key context._@param metaInfo the meta information for this state table.;public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		super(keyContext, metaInfo)__		this.keyGroupOffset = keyContext.getKeyGroupRange().getStartKeyGroup()___		@SuppressWarnings("unchecked")_		Map<N, Map<K, S>>[] state = (Map<N, Map<K, S>>[]) new Map[keyContext.getNumberOfKeyGroups()]__		this.state = state__	};creates,a,new,link,nested,maps,state,table,for,the,given,key,context,and,meta,info,param,key,context,the,key,context,param,meta,info,the,meta,information,for,this,state,table;public,nested,maps,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,super,key,context,meta,info,this,key,group,offset,key,context,get,key,group,range,get,start,key,group,suppress,warnings,unchecked,map,n,map,k,s,state,map,n,map,k,s,new,map,key,context,get,number,of,key,groups,this,state,state
NestedMapsStateTable -> public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1497273707;Creates a new {@link NestedMapsStateTable} for the given key context and meta info.__@param keyContext the key context._@param metaInfo the meta information for this state table.;public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		super(keyContext, metaInfo)__		this.keyGroupOffset = keyContext.getKeyGroupRange().getStartKeyGroup()___		@SuppressWarnings("unchecked")_		Map<N, Map<K, S>>[] state = (Map<N, Map<K, S>>[]) new Map[keyContext.getKeyGroupRange().getNumberOfKeyGroups()]__		this.state = state__	};creates,a,new,link,nested,maps,state,table,for,the,given,key,context,and,meta,info,param,key,context,the,key,context,param,meta,info,the,meta,information,for,this,state,table;public,nested,maps,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,super,key,context,meta,info,this,key,group,offset,key,context,get,key,group,range,get,start,key,group,suppress,warnings,unchecked,map,n,map,k,s,state,map,n,map,k,s,new,map,key,context,get,key,group,range,get,number,of,key,groups,this,state,state
NestedMapsStateTable -> public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1501836962;Creates a new {@link NestedMapsStateTable} for the given key context and meta info.__@param keyContext the key context._@param metaInfo the meta information for this state table.;public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		super(keyContext, metaInfo)__		this.keyGroupOffset = keyContext.getKeyGroupRange().getStartKeyGroup()___		@SuppressWarnings("unchecked")_		Map<N, Map<K, S>>[] state = (Map<N, Map<K, S>>[]) new Map[keyContext.getKeyGroupRange().getNumberOfKeyGroups()]__		this.state = state__	};creates,a,new,link,nested,maps,state,table,for,the,given,key,context,and,meta,info,param,key,context,the,key,context,param,meta,info,the,meta,information,for,this,state,table;public,nested,maps,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,super,key,context,meta,info,this,key,group,offset,key,context,get,key,group,range,get,start,key,group,suppress,warnings,unchecked,map,n,map,k,s,state,map,n,map,k,s,new,map,key,context,get,key,group,range,get,number,of,key,groups,this,state,state
NestedMapsStateTable -> public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1505385570;Creates a new {@link NestedMapsStateTable} for the given key context and meta info.__@param keyContext the key context._@param metaInfo the meta information for this state table.;public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		super(keyContext, metaInfo)__		this.keyGroupOffset = keyContext.getKeyGroupRange().getStartKeyGroup()___		@SuppressWarnings("unchecked")_		Map<N, Map<K, S>>[] state = (Map<N, Map<K, S>>[]) new Map[keyContext.getKeyGroupRange().getNumberOfKeyGroups()]__		this.state = state__	};creates,a,new,link,nested,maps,state,table,for,the,given,key,context,and,meta,info,param,key,context,the,key,context,param,meta,info,the,meta,information,for,this,state,table;public,nested,maps,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,super,key,context,meta,info,this,key,group,offset,key,context,get,key,group,range,get,start,key,group,suppress,warnings,unchecked,map,n,map,k,s,state,map,n,map,k,s,new,map,key,context,get,key,group,range,get,number,of,key,groups,this,state,state
NestedMapsStateTable -> public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo);1528721286;Creates a new {@link NestedMapsStateTable} for the given key context and meta info.__@param keyContext the key context._@param metaInfo the meta information for this state table.;public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyedBackendStateMetaInfo<N, S> metaInfo) {_		super(keyContext, metaInfo)__		this.keyGroupOffset = keyContext.getKeyGroupRange().getStartKeyGroup()___		@SuppressWarnings("unchecked")_		Map<N, Map<K, S>>[] state = (Map<N, Map<K, S>>[]) new Map[keyContext.getKeyGroupRange().getNumberOfKeyGroups()]__		this.state = state__	};creates,a,new,link,nested,maps,state,table,for,the,given,key,context,and,meta,info,param,key,context,the,key,context,param,meta,info,the,meta,information,for,this,state,table;public,nested,maps,state,table,internal,key,context,k,key,context,registered,keyed,backend,state,meta,info,n,s,meta,info,super,key,context,meta,info,this,key,group,offset,key,context,get,key,group,range,get,start,key,group,suppress,warnings,unchecked,map,n,map,k,s,state,map,n,map,k,s,new,map,key,context,get,key,group,range,get,number,of,key,groups,this,state,state
NestedMapsStateTable -> @VisibleForTesting 	public Map<N, Map<K, S>>[] getState();1488534675;Returns the internal data structure.;@VisibleForTesting_	public Map<N, Map<K, S>>[] getState() {_		return state__	};returns,the,internal,data,structure;visible,for,testing,public,map,n,map,k,s,get,state,return,state
NestedMapsStateTable -> @VisibleForTesting 	public Map<N, Map<K, S>>[] getState();1494180263;Returns the internal data structure.;@VisibleForTesting_	public Map<N, Map<K, S>>[] getState() {_		return state__	};returns,the,internal,data,structure;visible,for,testing,public,map,n,map,k,s,get,state,return,state
NestedMapsStateTable -> @VisibleForTesting 	public Map<N, Map<K, S>>[] getState();1497273707;Returns the internal data structure.;@VisibleForTesting_	public Map<N, Map<K, S>>[] getState() {_		return state__	};returns,the,internal,data,structure;visible,for,testing,public,map,n,map,k,s,get,state,return,state
NestedMapsStateTable -> @VisibleForTesting 	public Map<N, Map<K, S>>[] getState();1501836962;Returns the internal data structure.;@VisibleForTesting_	public Map<N, Map<K, S>>[] getState() {_		return state__	};returns,the,internal,data,structure;visible,for,testing,public,map,n,map,k,s,get,state,return,state
NestedMapsStateTable -> @VisibleForTesting 	public Map<N, Map<K, S>>[] getState();1505385570;Returns the internal data structure.;@VisibleForTesting_	public Map<N, Map<K, S>>[] getState() {_		return state__	};returns,the,internal,data,structure;visible,for,testing,public,map,n,map,k,s,get,state,return,state
NestedMapsStateTable -> @VisibleForTesting 	public Map<N, Map<K, S>>[] getState();1528721286;Returns the internal data structure.;@VisibleForTesting_	public Map<N, Map<K, S>>[] getState() {_		return state__	};returns,the,internal,data,structure;visible,for,testing,public,map,n,map,k,s,get,state,return,state
NestedMapsStateTable -> @VisibleForTesting 	public Map<N, Map<K, S>>[] getState();1528883776;Returns the internal data structure.;@VisibleForTesting_	public Map<N, Map<K, S>>[] getState() {_		return state__	};returns,the,internal,data,structure;visible,for,testing,public,map,n,map,k,s,get,state,return,state
NestedMapsStateTable -> @VisibleForTesting 	public Map<N, Map<K, S>>[] getState();1533313087;Returns the internal data structure.;@VisibleForTesting_	public Map<N, Map<K, S>>[] getState() {_		return state__	};returns,the,internal,data,structure;visible,for,testing,public,map,n,map,k,s,get,state,return,state
NestedMapsStateTable -> @VisibleForTesting 	public Map<N, Map<K, S>>[] getState();1538063092;Returns the internal data structure.;@VisibleForTesting_	public Map<N, Map<K, S>>[] getState() {_		return state__	};returns,the,internal,data,structure;visible,for,testing,public,map,n,map,k,s,get,state,return,state
NestedMapsStateTable -> @VisibleForTesting 	public Map<N, Map<K, S>>[] getState();1545062987;Returns the internal data structure.;@VisibleForTesting_	public Map<N, Map<K, S>>[] getState() {_		return state__	};returns,the,internal,data,structure;visible,for,testing,public,map,n,map,k,s,get,state,return,state
NestedMapsStateTable -> private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map);1488534675;Sets the given map for the given key-group.;private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {_		try {_			state[indexToOffset(keyGroupId)] = map__		} catch (ArrayIndexOutOfBoundsException e) {_			throw new IllegalArgumentException("Key group index out of range of key group range [" +_					keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").")__		}_	};sets,the,given,map,for,the,given,key,group;private,void,set,map,for,key,group,int,key,group,id,map,n,map,k,s,map,try,state,index,to,offset,key,group,id,map,catch,array,index,out,of,bounds,exception,e,throw,new,illegal,argument,exception,key,group,index,out,of,range,of,key,group,range,key,group,offset,key,group,offset,state,length
NestedMapsStateTable -> private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map);1494180263;Sets the given map for the given key-group.;private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {_		try {_			state[indexToOffset(keyGroupId)] = map__		} catch (ArrayIndexOutOfBoundsException e) {_			throw new IllegalArgumentException("Key group index out of range of key group range [" +_					keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").")__		}_	};sets,the,given,map,for,the,given,key,group;private,void,set,map,for,key,group,int,key,group,id,map,n,map,k,s,map,try,state,index,to,offset,key,group,id,map,catch,array,index,out,of,bounds,exception,e,throw,new,illegal,argument,exception,key,group,index,out,of,range,of,key,group,range,key,group,offset,key,group,offset,state,length
NestedMapsStateTable -> private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map);1497273707;Sets the given map for the given key-group.;private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {_		try {_			state[indexToOffset(keyGroupId)] = map__		} catch (ArrayIndexOutOfBoundsException e) {_			throw new IllegalArgumentException("Key group index out of range of key group range [" +_					keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").")__		}_	};sets,the,given,map,for,the,given,key,group;private,void,set,map,for,key,group,int,key,group,id,map,n,map,k,s,map,try,state,index,to,offset,key,group,id,map,catch,array,index,out,of,bounds,exception,e,throw,new,illegal,argument,exception,key,group,index,out,of,range,of,key,group,range,key,group,offset,key,group,offset,state,length
NestedMapsStateTable -> private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map);1501836962;Sets the given map for the given key-group.;private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {_		try {_			state[indexToOffset(keyGroupId)] = map__		} catch (ArrayIndexOutOfBoundsException e) {_			throw new IllegalArgumentException("Key group index " + keyGroupId + " is out of range of key group " +_				"range [" + keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").")__		}_	};sets,the,given,map,for,the,given,key,group;private,void,set,map,for,key,group,int,key,group,id,map,n,map,k,s,map,try,state,index,to,offset,key,group,id,map,catch,array,index,out,of,bounds,exception,e,throw,new,illegal,argument,exception,key,group,index,key,group,id,is,out,of,range,of,key,group,range,key,group,offset,key,group,offset,state,length
NestedMapsStateTable -> private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map);1505385570;Sets the given map for the given key-group.;private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {_		try {_			state[indexToOffset(keyGroupId)] = map__		} catch (ArrayIndexOutOfBoundsException e) {_			throw new IllegalArgumentException("Key group index " + keyGroupId + " is out of range of key group " +_				"range [" + keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").")__		}_	};sets,the,given,map,for,the,given,key,group;private,void,set,map,for,key,group,int,key,group,id,map,n,map,k,s,map,try,state,index,to,offset,key,group,id,map,catch,array,index,out,of,bounds,exception,e,throw,new,illegal,argument,exception,key,group,index,key,group,id,is,out,of,range,of,key,group,range,key,group,offset,key,group,offset,state,length
NestedMapsStateTable -> private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map);1528721286;Sets the given map for the given key-group.;private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {_		try {_			state[indexToOffset(keyGroupId)] = map__		} catch (ArrayIndexOutOfBoundsException e) {_			throw new IllegalArgumentException("Key group index " + keyGroupId + " is out of range of key group " +_				"range [" + keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").")__		}_	};sets,the,given,map,for,the,given,key,group;private,void,set,map,for,key,group,int,key,group,id,map,n,map,k,s,map,try,state,index,to,offset,key,group,id,map,catch,array,index,out,of,bounds,exception,e,throw,new,illegal,argument,exception,key,group,index,key,group,id,is,out,of,range,of,key,group,range,key,group,offset,key,group,offset,state,length
NestedMapsStateTable -> private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map);1528883776;Sets the given map for the given key-group.;private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {_		try {_			state[indexToOffset(keyGroupId)] = map__		} catch (ArrayIndexOutOfBoundsException e) {_			throw new IllegalArgumentException("Key group index " + keyGroupId + " is out of range of key group " +_				"range [" + keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").")__		}_	};sets,the,given,map,for,the,given,key,group;private,void,set,map,for,key,group,int,key,group,id,map,n,map,k,s,map,try,state,index,to,offset,key,group,id,map,catch,array,index,out,of,bounds,exception,e,throw,new,illegal,argument,exception,key,group,index,key,group,id,is,out,of,range,of,key,group,range,key,group,offset,key,group,offset,state,length
NestedMapsStateTable -> private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map);1533313087;Sets the given map for the given key-group.;private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {_		try {_			state[indexToOffset(keyGroupId)] = map__		} catch (ArrayIndexOutOfBoundsException e) {_			throw new IllegalArgumentException("Key group index " + keyGroupId + " is out of range of key group " +_				"range [" + keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").")__		}_	};sets,the,given,map,for,the,given,key,group;private,void,set,map,for,key,group,int,key,group,id,map,n,map,k,s,map,try,state,index,to,offset,key,group,id,map,catch,array,index,out,of,bounds,exception,e,throw,new,illegal,argument,exception,key,group,index,key,group,id,is,out,of,range,of,key,group,range,key,group,offset,key,group,offset,state,length
NestedMapsStateTable -> private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map);1538063092;Sets the given map for the given key-group.;private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {_		try {_			state[indexToOffset(keyGroupId)] = map__		} catch (ArrayIndexOutOfBoundsException e) {_			throw new IllegalArgumentException("Key group index " + keyGroupId + " is out of range of key group " +_				"range [" + keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").")__		}_	};sets,the,given,map,for,the,given,key,group;private,void,set,map,for,key,group,int,key,group,id,map,n,map,k,s,map,try,state,index,to,offset,key,group,id,map,catch,array,index,out,of,bounds,exception,e,throw,new,illegal,argument,exception,key,group,index,key,group,id,is,out,of,range,of,key,group,range,key,group,offset,key,group,offset,state,length
NestedMapsStateTable -> private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map);1545062987;Sets the given map for the given key-group.;private void setMapForKeyGroup(int keyGroupId, Map<N, Map<K, S>> map) {_		try {_			state[indexToOffset(keyGroupId)] = map__		} catch (ArrayIndexOutOfBoundsException e) {_			throw new IllegalArgumentException("Key group index " + keyGroupId + " is out of range of key group " +_				"range [" + keyGroupOffset + ", " + (keyGroupOffset + state.length) + ").")__		}_	};sets,the,given,map,for,the,given,key,group;private,void,set,map,for,key,group,int,key,group,id,map,n,map,k,s,map,try,state,index,to,offset,key,group,id,map,catch,array,index,out,of,bounds,exception,e,throw,new,illegal,argument,exception,key,group,index,key,group,id,is,out,of,range,of,key,group,range,key,group,offset,key,group,offset,state,length
NestedMapsStateTable -> NestedMapsStateTableSnapshot -> @Override 		public void writeStateInKeyGroup(@Nonnull DataOutputView dov, int keyGroupId) throws IOException;1528883776;Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and_{@link CopyOnWriteStateTable}._<p>_{@link NestedMapsStateTable} could naturally support a kind of_prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each_mapping). We might implement support for different formats later (tailored towards different state table_implementations).;@Override_		public void writeStateInKeyGroup(@Nonnull DataOutputView dov, int keyGroupId) throws IOException {_			final Map<N, Map<K, S>> keyGroupMap = owningStateTable.getMapForKeyGroup(keyGroupId)__			if (null != keyGroupMap) {_				TypeSerializer<K> keySerializer = owningStateTable.keyContext.getKeySerializer()__				TypeSerializer<N> namespaceSerializer = owningStateTable.metaInfo.getNamespaceSerializer()__				TypeSerializer<S> stateSerializer = owningStateTable.metaInfo.getStateSerializer()__				dov.writeInt(countMappingsInKeyGroup(keyGroupMap))__				for (Map.Entry<N, Map<K, S>> namespaceEntry : keyGroupMap.entrySet()) {_					final N namespace = namespaceEntry.getKey()__					final Map<K, S> namespaceMap = namespaceEntry.getValue()___					for (Map.Entry<K, S> keyEntry : namespaceMap.entrySet()) {_						namespaceSerializer.serialize(namespace, dov)__						keySerializer.serialize(keyEntry.getKey(), dov)__						stateSerializer.serialize(keyEntry.getValue(), dov)__					}_				}_			} else {_				dov.writeInt(0)__			}_		};implementation,note,we,currently,chose,the,same,format,between,link,nested,maps,state,table,and,link,copy,on,write,state,table,p,link,nested,maps,state,table,could,naturally,support,a,kind,of,prefix,compressed,format,grouping,by,namespace,writing,the,namespace,only,once,per,group,instead,for,each,mapping,we,might,implement,support,for,different,formats,later,tailored,towards,different,state,table,implementations;override,public,void,write,state,in,key,group,nonnull,data,output,view,dov,int,key,group,id,throws,ioexception,final,map,n,map,k,s,key,group,map,owning,state,table,get,map,for,key,group,key,group,id,if,null,key,group,map,type,serializer,k,key,serializer,owning,state,table,key,context,get,key,serializer,type,serializer,n,namespace,serializer,owning,state,table,meta,info,get,namespace,serializer,type,serializer,s,state,serializer,owning,state,table,meta,info,get,state,serializer,dov,write,int,count,mappings,in,key,group,key,group,map,for,map,entry,n,map,k,s,namespace,entry,key,group,map,entry,set,final,n,namespace,namespace,entry,get,key,final,map,k,s,namespace,map,namespace,entry,get,value,for,map,entry,k,s,key,entry,namespace,map,entry,set,namespace,serializer,serialize,namespace,dov,key,serializer,serialize,key,entry,get,key,dov,state,serializer,serialize,key,entry,get,value,dov,else,dov,write,int,0
NestedMapsStateTable -> NestedMapsStateTableSnapshot -> @Override 		public void writeStateInKeyGroup(@Nonnull DataOutputView dov, int keyGroupId) throws IOException;1533313087;Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and_{@link CopyOnWriteStateTable}.__<p>{@link NestedMapsStateTable} could naturally support a kind of_prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each_mapping). We might implement support for different formats later (tailored towards different state table_implementations).;@Override_		public void writeStateInKeyGroup(@Nonnull DataOutputView dov, int keyGroupId) throws IOException {_			final Map<N, Map<K, S>> keyGroupMap = owningStateTable.getMapForKeyGroup(keyGroupId)__			if (null != keyGroupMap) {_				Map<N, Map<K, S>> filteredMappings = filterMappingsInKeyGroupIfNeeded(keyGroupMap)__				dov.writeInt(countMappingsInKeyGroup(filteredMappings))__				for (Map.Entry<N, Map<K, S>> namespaceEntry : filteredMappings.entrySet()) {_					final N namespace = namespaceEntry.getKey()__					final Map<K, S> namespaceMap = namespaceEntry.getValue()__					for (Map.Entry<K, S> keyEntry : namespaceMap.entrySet()) {_						writeElement(namespace, keyEntry, dov)__					}_				}_			} else {_				dov.writeInt(0)__			}_		};implementation,note,we,currently,chose,the,same,format,between,link,nested,maps,state,table,and,link,copy,on,write,state,table,p,link,nested,maps,state,table,could,naturally,support,a,kind,of,prefix,compressed,format,grouping,by,namespace,writing,the,namespace,only,once,per,group,instead,for,each,mapping,we,might,implement,support,for,different,formats,later,tailored,towards,different,state,table,implementations;override,public,void,write,state,in,key,group,nonnull,data,output,view,dov,int,key,group,id,throws,ioexception,final,map,n,map,k,s,key,group,map,owning,state,table,get,map,for,key,group,key,group,id,if,null,key,group,map,map,n,map,k,s,filtered,mappings,filter,mappings,in,key,group,if,needed,key,group,map,dov,write,int,count,mappings,in,key,group,filtered,mappings,for,map,entry,n,map,k,s,namespace,entry,filtered,mappings,entry,set,final,n,namespace,namespace,entry,get,key,final,map,k,s,namespace,map,namespace,entry,get,value,for,map,entry,k,s,key,entry,namespace,map,entry,set,write,element,namespace,key,entry,dov,else,dov,write,int,0
NestedMapsStateTable -> NestedMapsStateTableSnapshot -> @Override 		public void writeStateInKeyGroup(@Nonnull DataOutputView dov, int keyGroupId) throws IOException;1538063092;Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and_{@link CopyOnWriteStateTable}.__<p>{@link NestedMapsStateTable} could naturally support a kind of_prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each_mapping). We might implement support for different formats later (tailored towards different state table_implementations).;@Override_		public void writeStateInKeyGroup(@Nonnull DataOutputView dov, int keyGroupId) throws IOException {_			final Map<N, Map<K, S>> keyGroupMap = owningStateTable.getMapForKeyGroup(keyGroupId)__			if (null != keyGroupMap) {_				Map<N, Map<K, S>> filteredMappings = filterMappingsInKeyGroupIfNeeded(keyGroupMap)__				dov.writeInt(countMappingsInKeyGroup(filteredMappings))__				for (Map.Entry<N, Map<K, S>> namespaceEntry : filteredMappings.entrySet()) {_					final N namespace = namespaceEntry.getKey()__					final Map<K, S> namespaceMap = namespaceEntry.getValue()__					for (Map.Entry<K, S> keyEntry : namespaceMap.entrySet()) {_						writeElement(namespace, keyEntry, dov)__					}_				}_			} else {_				dov.writeInt(0)__			}_		};implementation,note,we,currently,chose,the,same,format,between,link,nested,maps,state,table,and,link,copy,on,write,state,table,p,link,nested,maps,state,table,could,naturally,support,a,kind,of,prefix,compressed,format,grouping,by,namespace,writing,the,namespace,only,once,per,group,instead,for,each,mapping,we,might,implement,support,for,different,formats,later,tailored,towards,different,state,table,implementations;override,public,void,write,state,in,key,group,nonnull,data,output,view,dov,int,key,group,id,throws,ioexception,final,map,n,map,k,s,key,group,map,owning,state,table,get,map,for,key,group,key,group,id,if,null,key,group,map,map,n,map,k,s,filtered,mappings,filter,mappings,in,key,group,if,needed,key,group,map,dov,write,int,count,mappings,in,key,group,filtered,mappings,for,map,entry,n,map,k,s,namespace,entry,filtered,mappings,entry,set,final,n,namespace,namespace,entry,get,key,final,map,k,s,namespace,map,namespace,entry,get,value,for,map,entry,k,s,key,entry,namespace,map,entry,set,write,element,namespace,key,entry,dov,else,dov,write,int,0
NestedMapsStateTable -> NestedMapsStateTableSnapshot -> @Override 		public void writeStateInKeyGroup(@Nonnull DataOutputView dov, int keyGroupId) throws IOException;1545062987;Implementation note: we currently chose the same format between {@link NestedMapsStateTable} and_{@link CopyOnWriteStateTable}.__<p>{@link NestedMapsStateTable} could naturally support a kind of_prefix-compressed format (grouping by namespace, writing the namespace only once per group instead for each_mapping). We might implement support for different formats later (tailored towards different state table_implementations).;@Override_		public void writeStateInKeyGroup(@Nonnull DataOutputView dov, int keyGroupId) throws IOException {_			final Map<N, Map<K, S>> keyGroupMap = owningStateTable.getMapForKeyGroup(keyGroupId)__			if (null != keyGroupMap) {_				Map<N, Map<K, S>> filteredMappings = filterMappingsInKeyGroupIfNeeded(keyGroupMap)__				dov.writeInt(countMappingsInKeyGroup(filteredMappings))__				for (Map.Entry<N, Map<K, S>> namespaceEntry : filteredMappings.entrySet()) {_					final N namespace = namespaceEntry.getKey()__					final Map<K, S> namespaceMap = namespaceEntry.getValue()__					for (Map.Entry<K, S> keyEntry : namespaceMap.entrySet()) {_						writeElement(namespace, keyEntry, dov)__					}_				}_			} else {_				dov.writeInt(0)__			}_		};implementation,note,we,currently,chose,the,same,format,between,link,nested,maps,state,table,and,link,copy,on,write,state,table,p,link,nested,maps,state,table,could,naturally,support,a,kind,of,prefix,compressed,format,grouping,by,namespace,writing,the,namespace,only,once,per,group,instead,for,each,mapping,we,might,implement,support,for,different,formats,later,tailored,towards,different,state,table,implementations;override,public,void,write,state,in,key,group,nonnull,data,output,view,dov,int,key,group,id,throws,ioexception,final,map,n,map,k,s,key,group,map,owning,state,table,get,map,for,key,group,key,group,id,if,null,key,group,map,map,n,map,k,s,filtered,mappings,filter,mappings,in,key,group,if,needed,key,group,map,dov,write,int,count,mappings,in,key,group,filtered,mappings,for,map,entry,n,map,k,s,namespace,entry,filtered,mappings,entry,set,final,n,namespace,namespace,entry,get,key,final,map,k,s,namespace,map,namespace,entry,get,value,for,map,entry,k,s,key,entry,namespace,map,entry,set,write,element,namespace,key,entry,dov,else,dov,write,int,0
NestedMapsStateTable -> public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo);1528883776;Creates a new {@link NestedMapsStateTable} for the given key context and meta info.__@param keyContext the key context._@param metaInfo the meta information for this state table.;public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo) {_		super(keyContext, metaInfo)__		this.keyGroupOffset = keyContext.getKeyGroupRange().getStartKeyGroup()___		@SuppressWarnings("unchecked")_		Map<N, Map<K, S>>[] state = (Map<N, Map<K, S>>[]) new Map[keyContext.getKeyGroupRange().getNumberOfKeyGroups()]__		this.state = state__	};creates,a,new,link,nested,maps,state,table,for,the,given,key,context,and,meta,info,param,key,context,the,key,context,param,meta,info,the,meta,information,for,this,state,table;public,nested,maps,state,table,internal,key,context,k,key,context,registered,key,value,state,backend,meta,info,n,s,meta,info,super,key,context,meta,info,this,key,group,offset,key,context,get,key,group,range,get,start,key,group,suppress,warnings,unchecked,map,n,map,k,s,state,map,n,map,k,s,new,map,key,context,get,key,group,range,get,number,of,key,groups,this,state,state
NestedMapsStateTable -> public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo);1533313087;Creates a new {@link NestedMapsStateTable} for the given key context and meta info.__@param keyContext the key context._@param metaInfo the meta information for this state table.;public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo) {_		super(keyContext, metaInfo)__		this.keyGroupOffset = keyContext.getKeyGroupRange().getStartKeyGroup()___		@SuppressWarnings("unchecked")_		Map<N, Map<K, S>>[] state = (Map<N, Map<K, S>>[]) new Map[keyContext.getKeyGroupRange().getNumberOfKeyGroups()]__		this.state = state__	};creates,a,new,link,nested,maps,state,table,for,the,given,key,context,and,meta,info,param,key,context,the,key,context,param,meta,info,the,meta,information,for,this,state,table;public,nested,maps,state,table,internal,key,context,k,key,context,registered,key,value,state,backend,meta,info,n,s,meta,info,super,key,context,meta,info,this,key,group,offset,key,context,get,key,group,range,get,start,key,group,suppress,warnings,unchecked,map,n,map,k,s,state,map,n,map,k,s,new,map,key,context,get,key,group,range,get,number,of,key,groups,this,state,state
NestedMapsStateTable -> public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo);1538063092;Creates a new {@link NestedMapsStateTable} for the given key context and meta info.__@param keyContext the key context._@param metaInfo the meta information for this state table.;public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo) {_		super(keyContext, metaInfo)__		this.keyGroupOffset = keyContext.getKeyGroupRange().getStartKeyGroup()___		@SuppressWarnings("unchecked")_		Map<N, Map<K, S>>[] state = (Map<N, Map<K, S>>[]) new Map[keyContext.getKeyGroupRange().getNumberOfKeyGroups()]__		this.state = state__	};creates,a,new,link,nested,maps,state,table,for,the,given,key,context,and,meta,info,param,key,context,the,key,context,param,meta,info,the,meta,information,for,this,state,table;public,nested,maps,state,table,internal,key,context,k,key,context,registered,key,value,state,backend,meta,info,n,s,meta,info,super,key,context,meta,info,this,key,group,offset,key,context,get,key,group,range,get,start,key,group,suppress,warnings,unchecked,map,n,map,k,s,state,map,n,map,k,s,new,map,key,context,get,key,group,range,get,number,of,key,groups,this,state,state
NestedMapsStateTable -> public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo);1545062987;Creates a new {@link NestedMapsStateTable} for the given key context and meta info.__@param keyContext the key context._@param metaInfo the meta information for this state table.;public NestedMapsStateTable(InternalKeyContext<K> keyContext, RegisteredKeyValueStateBackendMetaInfo<N, S> metaInfo) {_		super(keyContext, metaInfo)__		this.keyGroupOffset = keyContext.getKeyGroupRange().getStartKeyGroup()___		@SuppressWarnings("unchecked")_		Map<N, Map<K, S>>[] state = (Map<N, Map<K, S>>[]) new Map[keyContext.getKeyGroupRange().getNumberOfKeyGroups()]__		this.state = state__	};creates,a,new,link,nested,maps,state,table,for,the,given,key,context,and,meta,info,param,key,context,the,key,context,param,meta,info,the,meta,information,for,this,state,table;public,nested,maps,state,table,internal,key,context,k,key,context,registered,key,value,state,backend,meta,info,n,s,meta,info,super,key,context,meta,info,this,key,group,offset,key,context,get,key,group,range,get,start,key,group,suppress,warnings,unchecked,map,n,map,k,s,state,map,n,map,k,s,new,map,key,context,get,key,group,range,get,number,of,key,groups,this,state,state
