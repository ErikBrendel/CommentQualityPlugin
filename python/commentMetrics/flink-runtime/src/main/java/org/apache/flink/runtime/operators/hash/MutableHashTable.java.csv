# id;timestamp;commentText;codeText;commentWords;codeWords
MutableHashTable -> protected void releaseTable();1405024514;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1405090423;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1409911022;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1411473593;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1412164980;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1415702894;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1418570573;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1420654570;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1426697080;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1433417242;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1436281304;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1438803435;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1438874079;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (int i = 0_ i < this.buckets.length_ i++) {_				this.availableMemory.add(this.buckets[i])__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,int,i,0,i,this,buckets,length,i,this,available,memory,add,this,buckets,i,this,buckets,null
MutableHashTable -> protected void releaseTable();1438877580;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> protected void releaseTable();1440607697;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> protected void releaseTable();1441195975;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> protected void releaseTable();1443528421;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> protected void releaseTable();1445427423;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> protected void releaseTable();1453866659;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> protected void releaseTable();1456186698;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> protected void releaseTable();1456186722;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> protected void releaseTable();1460472696;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> protected void releaseTable();1460741894;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> protected void releaseTable();1468441547;Releases the table (the array of buckets) and returns the occupied memory segments to the list of free segments.;protected void releaseTable() {_		_		this.numBuckets = 0__		_		if (this.buckets != null) {_			for (MemorySegment bucket : this.buckets) {_				this.availableMemory.add(bucket)__			}_			this.buckets = null__		}_	};releases,the,table,the,array,of,buckets,and,returns,the,occupied,memory,segments,to,the,list,of,free,segments;protected,void,release,table,this,num,buckets,0,if,this,buckets,null,for,memory,segment,bucket,this,buckets,this,available,memory,add,bucket,this,buckets,null
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1438874079;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.__@param bucketInSegmentPos_@param bucket_@param p;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter,param,bucket,in,segment,pos,param,bucket,param,p;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1438877580;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.__@param bucketInSegmentPos_@param bucket_@param p;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter,param,bucket,in,segment,pos,param,bucket,param,p;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1440607697;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1441195975;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count <= 0) {_			return__		}__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,0,return,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1443528421;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count <= 0) {_			return__		}__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,0,return,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1445427423;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count <= 0) {_			return__		}__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,0,return,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1453866659;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count <= 0) {_			return__		}__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,0,return,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1456186698;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count <= 0) {_			return__		}__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,0,return,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1456186722;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count <= 0) {_			return__		}__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,0,return,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1460472696;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count <= 0) {_			return__		}__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,0,return,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1460741894;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count <= 0) {_			return__		}__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,0,return,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p);1468441547;Set all the bucket memory except bucket header as the bit set of bloom filter, and use hash code of build records_to build bloom filter.;final void buildBloomFilterForBucket(int bucketInSegmentPos, MemorySegment bucket, HashPartition<BT, PT> p) {_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count <= 0) {_			return__		}__		int[] hashCodes = new int[count]__		_		for (int i = 0_ i < count_ i++) {_			hashCodes[i] = bucket.getInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + i * HASH_CODE_LEN)__		}_		this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__		for (int hashCode : hashCodes) {_			this.bloomFilter.addHash(hashCode)__		}_		buildBloomFilterForExtraOverflowSegments(bucketInSegmentPos, bucket, p)__	};set,all,the,bucket,memory,except,bucket,header,as,the,bit,set,of,bloom,filter,and,use,hash,code,of,build,records,to,build,bloom,filter;final,void,build,bloom,filter,for,bucket,int,bucket,in,segment,pos,memory,segment,bucket,hash,partition,bt,pt,p,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,0,return,int,hash,codes,new,int,count,for,int,i,0,i,count,i,hash,codes,i,bucket,get,int,bucket,in,segment,pos,i,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,for,int,hash,code,hash,codes,this,bloom,filter,add,hash,hash,code,build,bloom,filter,for,extra,overflow,segments,bucket,in,segment,pos,bucket,p
MutableHashTable -> final MemorySegment getNextBuffer();1405024514;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains._@throws IOException Thrown, if the thread is interrupted while grabbing the next buffer. The I/O_exception replaces the <tt>InterruptedException</tt> to consolidate the exception_signatures.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains,throws,ioexception,thrown,if,the,thread,is,interrupted,while,grabbing,the,next,buffer,the,i,o,exception,replaces,the,tt,interrupted,exception,tt,to,consolidate,the,exception,signatures;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1405090423;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains._@throws IOException Thrown, if the thread is interrupted while grabbing the next buffer. The I/O_exception replaces the <tt>InterruptedException</tt> to consolidate the exception_signatures.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains,throws,ioexception,thrown,if,the,thread,is,interrupted,while,grabbing,the,next,buffer,the,i,o,exception,replaces,the,tt,interrupted,exception,tt,to,consolidate,the,exception,signatures;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1409911022;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains._@throws IOException Thrown, if the thread is interrupted while grabbing the next buffer. The I/O_exception replaces the <tt>InterruptedException</tt> to consolidate the exception_signatures.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains,throws,ioexception,thrown,if,the,thread,is,interrupted,while,grabbing,the,next,buffer,the,i,o,exception,replaces,the,tt,interrupted,exception,tt,to,consolidate,the,exception,signatures;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1411473593;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains._@throws IOException Thrown, if the thread is interrupted while grabbing the next buffer. The I/O_exception replaces the <tt>InterruptedException</tt> to consolidate the exception_signatures.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains,throws,ioexception,thrown,if,the,thread,is,interrupted,while,grabbing,the,next,buffer,the,i,o,exception,replaces,the,tt,interrupted,exception,tt,to,consolidate,the,exception,signatures;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1412164980;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains._@throws IOException Thrown, if the thread is interrupted while grabbing the next buffer. The I/O_exception replaces the <tt>InterruptedException</tt> to consolidate the exception_signatures.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains,throws,ioexception,thrown,if,the,thread,is,interrupted,while,grabbing,the,next,buffer,the,i,o,exception,replaces,the,tt,interrupted,exception,tt,to,consolidate,the,exception,signatures;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1415702894;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains._@throws IOException Thrown, if the thread is interrupted while grabbing the next buffer. The I/O_exception replaces the <tt>InterruptedException</tt> to consolidate the exception_signatures.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains,throws,ioexception,thrown,if,the,thread,is,interrupted,while,grabbing,the,next,buffer,the,i,o,exception,replaces,the,tt,interrupted,exception,tt,to,consolidate,the,exception,signatures;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1418570573;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1420654570;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1426697080;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1433417242;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1436281304;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1438803435;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1438874079;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1438877580;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff = null__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1440607697;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1441195975;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1443528421;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1445427423;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1453866659;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1456186698;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1456186722;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1460472696;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1460741894;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> final MemorySegment getNextBuffer();1468441547;Gets the next buffer to be used with the hash-table, either for an in-memory partition, or for the_table buckets. This method returns <tt>null</tt>, if no more buffer is available. Spilling a partition_may free new buffers then.__@return The next buffer to be used by the hash-table, or null, if no buffer remains.;final MemorySegment getNextBuffer() {_		_		int s = this.availableMemory.size()__		if (s > 0) {_			return this.availableMemory.remove(s-1)__		}_		_		_		if (this.writeBehindBuffersAvailable > 0) {_			_			MemorySegment toReturn__			try {_				toReturn = this.writeBehindBuffers.take()__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hybrid Hash Join was interrupted while taking a buffer.")__			}_			this.writeBehindBuffersAvailable--__			_			_			MemorySegment currBuff__			while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_				this.availableMemory.add(currBuff)__				this.writeBehindBuffersAvailable--__			}_			return toReturn__		} else {_			_			return null__		}_	};gets,the,next,buffer,to,be,used,with,the,hash,table,either,for,an,in,memory,partition,or,for,the,table,buckets,this,method,returns,tt,null,tt,if,no,more,buffer,is,available,spilling,a,partition,may,free,new,buffers,then,return,the,next,buffer,to,be,used,by,the,hash,table,or,null,if,no,buffer,remains;final,memory,segment,get,next,buffer,int,s,this,available,memory,size,if,s,0,return,this,available,memory,remove,s,1,if,this,write,behind,buffers,available,0,memory,segment,to,return,try,to,return,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hybrid,hash,join,was,interrupted,while,taking,a,buffer,this,write,behind,buffers,available,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,to,return,else,return,null
MutableHashTable -> public static final int getNumWriteBehindBuffers(int numBuffers);1405024514;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static final int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,final,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static final int getNumWriteBehindBuffers(int numBuffers);1405090423;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static final int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,final,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static final int getNumWriteBehindBuffers(int numBuffers);1409911022;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static final int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,final,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static final int getNumWriteBehindBuffers(int numBuffers);1411473593;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static final int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,final,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static final int getNumWriteBehindBuffers(int numBuffers);1412164980;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static final int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,final,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static final int getNumWriteBehindBuffers(int numBuffers);1415702894;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static final int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,final,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static final int getNumWriteBehindBuffers(int numBuffers);1418570573;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static final int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,final,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static final int getNumWriteBehindBuffers(int numBuffers);1420654570;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static final int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,final,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static final int getNumWriteBehindBuffers(int numBuffers);1426697080;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static final int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,final,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static final int getNumWriteBehindBuffers(int numBuffers);1433417242;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static final int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,final,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> @Override 	public MemorySegment nextSegment();1440607697;This is the method called by the partitions to request memory to serialize records._It automatically spills partitions, if memory runs out.__@return The next available memory segment.;@Override_	public MemorySegment nextSegment() {_		final MemorySegment seg = getNextBuffer()__		if (seg != null) {_			return seg__		} else {_			try {_				spillPartition()__			} catch (IOException ioex) {_				throw new RuntimeException("Error spilling Hash Join Partition" + (ioex.getMessage() == null ?_					"." : ": " + ioex.getMessage()), ioex)__			}_			_			MemorySegment fromSpill = getNextBuffer()__			if (fromSpill == null) {_				throw new RuntimeException("BUG in Hybrid Hash Join: Spilling did not free a buffer.")__			} else {_				return fromSpill__			}_		}_	};this,is,the,method,called,by,the,partitions,to,request,memory,to,serialize,records,it,automatically,spills,partitions,if,memory,runs,out,return,the,next,available,memory,segment;override,public,memory,segment,next,segment,final,memory,segment,seg,get,next,buffer,if,seg,null,return,seg,else,try,spill,partition,catch,ioexception,ioex,throw,new,runtime,exception,error,spilling,hash,join,partition,ioex,get,message,null,ioex,get,message,ioex,memory,segment,from,spill,get,next,buffer,if,from,spill,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,spilling,did,not,free,a,buffer,else,return,from,spill
MutableHashTable -> @Override 	public MemorySegment nextSegment();1441195975;This is the method called by the partitions to request memory to serialize records._It automatically spills partitions, if memory runs out.__@return The next available memory segment.;@Override_	public MemorySegment nextSegment() {_		final MemorySegment seg = getNextBuffer()__		if (seg != null) {_			return seg__		} else {_			try {_				spillPartition()__			} catch (IOException ioex) {_				throw new RuntimeException("Error spilling Hash Join Partition" + (ioex.getMessage() == null ?_					"." : ": " + ioex.getMessage()), ioex)__			}_			_			MemorySegment fromSpill = getNextBuffer()__			if (fromSpill == null) {_				throw new RuntimeException("BUG in Hybrid Hash Join: Spilling did not free a buffer.")__			} else {_				return fromSpill__			}_		}_	};this,is,the,method,called,by,the,partitions,to,request,memory,to,serialize,records,it,automatically,spills,partitions,if,memory,runs,out,return,the,next,available,memory,segment;override,public,memory,segment,next,segment,final,memory,segment,seg,get,next,buffer,if,seg,null,return,seg,else,try,spill,partition,catch,ioexception,ioex,throw,new,runtime,exception,error,spilling,hash,join,partition,ioex,get,message,null,ioex,get,message,ioex,memory,segment,from,spill,get,next,buffer,if,from,spill,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,spilling,did,not,free,a,buffer,else,return,from,spill
MutableHashTable -> @Override 	public MemorySegment nextSegment();1443528421;This is the method called by the partitions to request memory to serialize records._It automatically spills partitions, if memory runs out.__@return The next available memory segment.;@Override_	public MemorySegment nextSegment() {_		final MemorySegment seg = getNextBuffer()__		if (seg != null) {_			return seg__		} else {_			try {_				spillPartition()__			} catch (IOException ioex) {_				throw new RuntimeException("Error spilling Hash Join Partition" + (ioex.getMessage() == null ?_					"." : ": " + ioex.getMessage()), ioex)__			}_			_			MemorySegment fromSpill = getNextBuffer()__			if (fromSpill == null) {_				throw new RuntimeException("BUG in Hybrid Hash Join: Spilling did not free a buffer.")__			} else {_				return fromSpill__			}_		}_	};this,is,the,method,called,by,the,partitions,to,request,memory,to,serialize,records,it,automatically,spills,partitions,if,memory,runs,out,return,the,next,available,memory,segment;override,public,memory,segment,next,segment,final,memory,segment,seg,get,next,buffer,if,seg,null,return,seg,else,try,spill,partition,catch,ioexception,ioex,throw,new,runtime,exception,error,spilling,hash,join,partition,ioex,get,message,null,ioex,get,message,ioex,memory,segment,from,spill,get,next,buffer,if,from,spill,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,spilling,did,not,free,a,buffer,else,return,from,spill
MutableHashTable -> @Override 	public MemorySegment nextSegment();1445427423;This is the method called by the partitions to request memory to serialize records._It automatically spills partitions, if memory runs out.__@return The next available memory segment.;@Override_	public MemorySegment nextSegment() {_		final MemorySegment seg = getNextBuffer()__		if (seg != null) {_			return seg__		} else {_			try {_				spillPartition()__			} catch (IOException ioex) {_				throw new RuntimeException("Error spilling Hash Join Partition" + (ioex.getMessage() == null ?_					"." : ": " + ioex.getMessage()), ioex)__			}_			_			MemorySegment fromSpill = getNextBuffer()__			if (fromSpill == null) {_				throw new RuntimeException("BUG in Hybrid Hash Join: Spilling did not free a buffer.")__			} else {_				return fromSpill__			}_		}_	};this,is,the,method,called,by,the,partitions,to,request,memory,to,serialize,records,it,automatically,spills,partitions,if,memory,runs,out,return,the,next,available,memory,segment;override,public,memory,segment,next,segment,final,memory,segment,seg,get,next,buffer,if,seg,null,return,seg,else,try,spill,partition,catch,ioexception,ioex,throw,new,runtime,exception,error,spilling,hash,join,partition,ioex,get,message,null,ioex,get,message,ioex,memory,segment,from,spill,get,next,buffer,if,from,spill,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,spilling,did,not,free,a,buffer,else,return,from,spill
MutableHashTable -> @Override 	public MemorySegment nextSegment();1453866659;This is the method called by the partitions to request memory to serialize records._It automatically spills partitions, if memory runs out.__@return The next available memory segment.;@Override_	public MemorySegment nextSegment() {_		final MemorySegment seg = getNextBuffer()__		if (seg != null) {_			return seg__		} else {_			try {_				spillPartition()__			} catch (IOException ioex) {_				throw new RuntimeException("Error spilling Hash Join Partition" + (ioex.getMessage() == null ?_					"." : ": " + ioex.getMessage()), ioex)__			}_			_			MemorySegment fromSpill = getNextBuffer()__			if (fromSpill == null) {_				throw new RuntimeException("BUG in Hybrid Hash Join: Spilling did not free a buffer.")__			} else {_				return fromSpill__			}_		}_	};this,is,the,method,called,by,the,partitions,to,request,memory,to,serialize,records,it,automatically,spills,partitions,if,memory,runs,out,return,the,next,available,memory,segment;override,public,memory,segment,next,segment,final,memory,segment,seg,get,next,buffer,if,seg,null,return,seg,else,try,spill,partition,catch,ioexception,ioex,throw,new,runtime,exception,error,spilling,hash,join,partition,ioex,get,message,null,ioex,get,message,ioex,memory,segment,from,spill,get,next,buffer,if,from,spill,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,spilling,did,not,free,a,buffer,else,return,from,spill
MutableHashTable -> @Override 	public MemorySegment nextSegment();1456186698;This is the method called by the partitions to request memory to serialize records._It automatically spills partitions, if memory runs out.__@return The next available memory segment.;@Override_	public MemorySegment nextSegment() {_		final MemorySegment seg = getNextBuffer()__		if (seg != null) {_			return seg__		} else {_			try {_				spillPartition()__			} catch (IOException ioex) {_				throw new RuntimeException("Error spilling Hash Join Partition" + (ioex.getMessage() == null ?_					"." : ": " + ioex.getMessage()), ioex)__			}_			_			MemorySegment fromSpill = getNextBuffer()__			if (fromSpill == null) {_				throw new RuntimeException("BUG in Hybrid Hash Join: Spilling did not free a buffer.")__			} else {_				return fromSpill__			}_		}_	};this,is,the,method,called,by,the,partitions,to,request,memory,to,serialize,records,it,automatically,spills,partitions,if,memory,runs,out,return,the,next,available,memory,segment;override,public,memory,segment,next,segment,final,memory,segment,seg,get,next,buffer,if,seg,null,return,seg,else,try,spill,partition,catch,ioexception,ioex,throw,new,runtime,exception,error,spilling,hash,join,partition,ioex,get,message,null,ioex,get,message,ioex,memory,segment,from,spill,get,next,buffer,if,from,spill,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,spilling,did,not,free,a,buffer,else,return,from,spill
MutableHashTable -> @Override 	public MemorySegment nextSegment();1456186722;This is the method called by the partitions to request memory to serialize records._It automatically spills partitions, if memory runs out.__@return The next available memory segment.;@Override_	public MemorySegment nextSegment() {_		final MemorySegment seg = getNextBuffer()__		if (seg != null) {_			return seg__		} else {_			try {_				spillPartition()__			} catch (IOException ioex) {_				throw new RuntimeException("Error spilling Hash Join Partition" + (ioex.getMessage() == null ?_					"." : ": " + ioex.getMessage()), ioex)__			}_			_			MemorySegment fromSpill = getNextBuffer()__			if (fromSpill == null) {_				throw new RuntimeException("BUG in Hybrid Hash Join: Spilling did not free a buffer.")__			} else {_				return fromSpill__			}_		}_	};this,is,the,method,called,by,the,partitions,to,request,memory,to,serialize,records,it,automatically,spills,partitions,if,memory,runs,out,return,the,next,available,memory,segment;override,public,memory,segment,next,segment,final,memory,segment,seg,get,next,buffer,if,seg,null,return,seg,else,try,spill,partition,catch,ioexception,ioex,throw,new,runtime,exception,error,spilling,hash,join,partition,ioex,get,message,null,ioex,get,message,ioex,memory,segment,from,spill,get,next,buffer,if,from,spill,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,spilling,did,not,free,a,buffer,else,return,from,spill
MutableHashTable -> @Override 	public MemorySegment nextSegment();1460472696;This is the method called by the partitions to request memory to serialize records._It automatically spills partitions, if memory runs out.__@return The next available memory segment.;@Override_	public MemorySegment nextSegment() {_		final MemorySegment seg = getNextBuffer()__		if (seg != null) {_			return seg__		} else {_			try {_				spillPartition()__			} catch (IOException ioex) {_				throw new RuntimeException("Error spilling Hash Join Partition" + (ioex.getMessage() == null ?_					"." : ": " + ioex.getMessage()), ioex)__			}_			_			MemorySegment fromSpill = getNextBuffer()__			if (fromSpill == null) {_				throw new RuntimeException("BUG in Hybrid Hash Join: Spilling did not free a buffer.")__			} else {_				return fromSpill__			}_		}_	};this,is,the,method,called,by,the,partitions,to,request,memory,to,serialize,records,it,automatically,spills,partitions,if,memory,runs,out,return,the,next,available,memory,segment;override,public,memory,segment,next,segment,final,memory,segment,seg,get,next,buffer,if,seg,null,return,seg,else,try,spill,partition,catch,ioexception,ioex,throw,new,runtime,exception,error,spilling,hash,join,partition,ioex,get,message,null,ioex,get,message,ioex,memory,segment,from,spill,get,next,buffer,if,from,spill,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,spilling,did,not,free,a,buffer,else,return,from,spill
MutableHashTable -> @Override 	public MemorySegment nextSegment();1460741894;This is the method called by the partitions to request memory to serialize records._It automatically spills partitions, if memory runs out.__@return The next available memory segment.;@Override_	public MemorySegment nextSegment() {_		final MemorySegment seg = getNextBuffer()__		if (seg != null) {_			return seg__		} else {_			try {_				spillPartition()__			} catch (IOException ioex) {_				throw new RuntimeException("Error spilling Hash Join Partition" + (ioex.getMessage() == null ?_					"." : ": " + ioex.getMessage()), ioex)__			}_			_			MemorySegment fromSpill = getNextBuffer()__			if (fromSpill == null) {_				throw new RuntimeException("BUG in Hybrid Hash Join: Spilling did not free a buffer.")__			} else {_				return fromSpill__			}_		}_	};this,is,the,method,called,by,the,partitions,to,request,memory,to,serialize,records,it,automatically,spills,partitions,if,memory,runs,out,return,the,next,available,memory,segment;override,public,memory,segment,next,segment,final,memory,segment,seg,get,next,buffer,if,seg,null,return,seg,else,try,spill,partition,catch,ioexception,ioex,throw,new,runtime,exception,error,spilling,hash,join,partition,ioex,get,message,null,ioex,get,message,ioex,memory,segment,from,spill,get,next,buffer,if,from,spill,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,spilling,did,not,free,a,buffer,else,return,from,spill
MutableHashTable -> @Override 	public MemorySegment nextSegment();1468441547;This is the method called by the partitions to request memory to serialize records._It automatically spills partitions, if memory runs out.__@return The next available memory segment.;@Override_	public MemorySegment nextSegment() {_		final MemorySegment seg = getNextBuffer()__		if (seg != null) {_			return seg__		} else {_			try {_				spillPartition()__			} catch (IOException ioex) {_				throw new RuntimeException("Error spilling Hash Join Partition" + (ioex.getMessage() == null ?_					"." : ": " + ioex.getMessage()), ioex)__			}_			_			MemorySegment fromSpill = getNextBuffer()__			if (fromSpill == null) {_				throw new RuntimeException("BUG in Hybrid Hash Join: Spilling did not free a buffer.")__			} else {_				return fromSpill__			}_		}_	};this,is,the,method,called,by,the,partitions,to,request,memory,to,serialize,records,it,automatically,spills,partitions,if,memory,runs,out,return,the,next,available,memory,segment;override,public,memory,segment,next,segment,final,memory,segment,seg,get,next,buffer,if,seg,null,return,seg,else,try,spill,partition,catch,ioexception,ioex,throw,new,runtime,exception,error,spilling,hash,join,partition,ioex,get,message,null,ioex,get,message,ioex,memory,segment,from,spill,get,next,buffer,if,from,spill,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,spilling,did,not,free,a,buffer,else,return,from,spill
MutableHashTable -> public PT getCurrentProbeRecord();1405024514;@return;public PT getCurrentProbeRecord() {_		return this.probeIterator.getCurrent()__	};return;public,pt,get,current,probe,record,return,this,probe,iterator,get,current
MutableHashTable -> public PT getCurrentProbeRecord();1405090423;@return;public PT getCurrentProbeRecord() {_		return this.probeIterator.getCurrent()__	};return;public,pt,get,current,probe,record,return,this,probe,iterator,get,current
MutableHashTable -> public PT getCurrentProbeRecord();1409911022;@return;public PT getCurrentProbeRecord() {_		return this.probeIterator.getCurrent()__	};return;public,pt,get,current,probe,record,return,this,probe,iterator,get,current
MutableHashTable -> public PT getCurrentProbeRecord();1411473593;@return;public PT getCurrentProbeRecord() {_		return this.probeIterator.getCurrent()__	};return;public,pt,get,current,probe,record,return,this,probe,iterator,get,current
MutableHashTable -> public static final byte assignPartition(int bucket, byte numPartitions);1405024514;Assigns a partition to a bucket.__@param bucket_@param numPartitions_@return The hash code for the integer.;public static final byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,param,num,partitions,return,the,hash,code,for,the,integer;public,static,final,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static final byte assignPartition(int bucket, byte numPartitions);1405090423;Assigns a partition to a bucket.__@param bucket_@param numPartitions_@return The hash code for the integer.;public static final byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,param,num,partitions,return,the,hash,code,for,the,integer;public,static,final,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static final byte assignPartition(int bucket, byte numPartitions);1409911022;Assigns a partition to a bucket.__@param bucket_@param numPartitions_@return The hash code for the integer.;public static final byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,param,num,partitions,return,the,hash,code,for,the,integer;public,static,final,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static final byte assignPartition(int bucket, byte numPartitions);1411473593;Assigns a partition to a bucket.__@param bucket_@param numPartitions_@return The hash code for the integer.;public static final byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,param,num,partitions,return,the,hash,code,for,the,integer;public,static,final,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static final byte assignPartition(int bucket, byte numPartitions);1412164980;Assigns a partition to a bucket.__@param bucket_@param numPartitions_@return The hash code for the integer.;public static final byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,param,num,partitions,return,the,hash,code,for,the,integer;public,static,final,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static final byte assignPartition(int bucket, byte numPartitions);1415702894;Assigns a partition to a bucket.__@param bucket_@param numPartitions_@return The hash code for the integer.;public static final byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,param,num,partitions,return,the,hash,code,for,the,integer;public,static,final,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static final byte assignPartition(int bucket, byte numPartitions);1418570573;Assigns a partition to a bucket.__@param bucket_@param numPartitions_@return The hash code for the integer.;public static final byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,param,num,partitions,return,the,hash,code,for,the,integer;public,static,final,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static final byte assignPartition(int bucket, byte numPartitions);1420654570;Assigns a partition to a bucket.__@param bucket_@param numPartitions_@return The hash code for the integer.;public static final byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,param,num,partitions,return,the,hash,code,for,the,integer;public,static,final,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static final byte assignPartition(int bucket, byte numPartitions);1426697080;Assigns a partition to a bucket.__@param bucket_@param numPartitions_@return The hash code for the integer.;public static final byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,param,num,partitions,return,the,hash,code,for,the,integer;public,static,final,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static final byte assignPartition(int bucket, byte numPartitions);1433417242;Assigns a partition to a bucket.__@param bucket_@param numPartitions_@return The hash code for the integer.;public static final byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,param,num,partitions,return,the,hash,code,for,the,integer;public,static,final,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1436281304;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1438803435;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1438874079;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1438877580;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1440607697;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1441195975;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1443528421;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1445427423;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1453866659;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1456186698;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1456186722;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1460472696;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1460741894;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static int getPartitioningFanOutNoEstimates(int numBuffers);1468441547;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public HashBucketIterator<BT, PT> getBuildSideIterator();1405024514;@return;public HashBucketIterator<BT, PT> getBuildSideIterator() {_		return this.bucketIterator__	};return;public,hash,bucket,iterator,bt,pt,get,build,side,iterator,return,this,bucket,iterator
MutableHashTable -> public HashBucketIterator<BT, PT> getBuildSideIterator();1405090423;@return;public HashBucketIterator<BT, PT> getBuildSideIterator() {_		return this.bucketIterator__	};return;public,hash,bucket,iterator,bt,pt,get,build,side,iterator,return,this,bucket,iterator
MutableHashTable -> public HashBucketIterator<BT, PT> getBuildSideIterator();1409911022;@return;public HashBucketIterator<BT, PT> getBuildSideIterator() {_		return this.bucketIterator__	};return;public,hash,bucket,iterator,bt,pt,get,build,side,iterator,return,this,bucket,iterator
MutableHashTable -> public HashBucketIterator<BT, PT> getBuildSideIterator();1411473593;@return;public HashBucketIterator<BT, PT> getBuildSideIterator() {_		return this.bucketIterator__	};return;public,hash,bucket,iterator,bt,pt,get,build,side,iterator,return,this,bucket,iterator
MutableHashTable -> public void close();1405024514;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted
MutableHashTable -> public void close();1405090423;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted
MutableHashTable -> public void close();1409911022;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted
MutableHashTable -> public void close();1411473593;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted
MutableHashTable -> public void close();1412164980;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted
MutableHashTable -> public void close();1415702894;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted
MutableHashTable -> public void close();1418570573;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted
MutableHashTable -> public void close();1420654570;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted
MutableHashTable -> public void close();1426697080;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted
MutableHashTable -> public void close();1433417242;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1436281304;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1438803435;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1438874079;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1438877580;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1440607697;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1441195975;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1443528421;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1445427423;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1453866659;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1456186698;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1456186722;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1460472696;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1460741894;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> public void close();1468441547;Closes the hash table. This effectively releases all internal structures and closes all_open files and removes them. The call to this method is valid both as a cleanup after the_complete inputs were properly processed, and as an cancellation call, which cleans up_all resources that are currently held by the hash join.;public void close() {_		_		if (!this.closed.compareAndSet(false, true)) {_			return__		}_		_		_		this.bucketIterator = null__		this.probeIterator = null__		_		_		releaseTable()__		_		_		clearPartitions()__		_		_		if (this.currentSpilledProbeSide != null) {_			try {_				this.currentSpilledProbeSide.closeAndDelete()__			}_			catch (Throwable t) {_				LOG.warn("Could not close and delete the temp file for the current spilled partition probe side.", t)__			}_		}_		_		_		for (int i = 0_ i < this.partitionsPending.size()_ i++) {_			final HashPartition<BT, PT> p = this.partitionsPending.get(i)__			p.clearAllMemory(this.availableMemory)__		}_		_		_		for (int i = 0_ i < this.numWriteBehindBuffers + this.writeBehindBuffersAvailable_ i++) {_			try {_				this.availableMemory.add(this.writeBehindBuffers.take())__			}_			catch (InterruptedException iex) {_				throw new RuntimeException("Hashtable closing was interrupted")__			}_		}_		this.writeBehindBuffersAvailable = 0__	};closes,the,hash,table,this,effectively,releases,all,internal,structures,and,closes,all,open,files,and,removes,them,the,call,to,this,method,is,valid,both,as,a,cleanup,after,the,complete,inputs,were,properly,processed,and,as,an,cancellation,call,which,cleans,up,all,resources,that,are,currently,held,by,the,hash,join;public,void,close,if,this,closed,compare,and,set,false,true,return,this,bucket,iterator,null,this,probe,iterator,null,release,table,clear,partitions,if,this,current,spilled,probe,side,null,try,this,current,spilled,probe,side,close,and,delete,catch,throwable,t,log,warn,could,not,close,and,delete,the,temp,file,for,the,current,spilled,partition,probe,side,t,for,int,i,0,i,this,partitions,pending,size,i,final,hash,partition,bt,pt,p,this,partitions,pending,get,i,p,clear,all,memory,this,available,memory,for,int,i,0,i,this,num,write,behind,buffers,this,write,behind,buffers,available,i,try,this,available,memory,add,this,write,behind,buffers,take,catch,interrupted,exception,iex,throw,new,runtime,exception,hashtable,closing,was,interrupted,this,write,behind,buffers,available,0
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1405024514;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1405090423;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1409911022;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1411473593;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1412164980;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1415702894;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1418570573;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1420654570;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1426697080;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1433417242;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1436281304;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1438803435;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1438874079;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1438877580;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1440607697;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1441195975;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1443528421;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1445427423;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1453866659;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1456186698;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1456186722;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1460472696;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1460741894;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel);1468441547;Returns a new inMemoryPartition object._This is required as a plug for ReOpenableMutableHashTable.;protected HashPartition<BT, PT> getNewInMemoryPartition(int number, int recursionLevel) {_		return new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_				number, recursionLevel, this.availableMemory.remove(this.availableMemory.size() - 1),_				this, this.segmentSize)__	};returns,a,new,in,memory,partition,object,this,is,required,as,a,plug,for,re,openable,mutable,hash,table;protected,hash,partition,bt,pt,get,new,in,memory,partition,int,number,int,recursion,level,return,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,number,recursion,level,this,available,memory,remove,this,available,memory,size,1,this,this,segment,size
MutableHashTable -> protected void initTable(int numBuckets, byte numPartitions);1405024514;@param numBuckets_@param numPartitions_@return;protected void initTable(int numBuckets, byte numPartitions) {_		final int bucketsPerSegment = this.bucketsPerSegmentMask + 1__		final int numSegs = (numBuckets >>> this.bucketsPerSegmentBits) + ( (numBuckets & this.bucketsPerSegmentMask) == 0 ? 0 : 1)__		final MemorySegment[] table = new MemorySegment[numSegs]__		_		ensureNumBuffersReturned(numSegs)__		_		_		for (int i = 0, bucket = 0_ i < numSegs && bucket < numBuckets_ i++) {_			final MemorySegment seg = getNextBuffer()__			_			_			for (int k = 0_ k < bucketsPerSegment && bucket < numBuckets_ k++, bucket++) {_				final int bucketOffset = k * HASH_BUCKET_SIZE_	_				_				_				final byte partition = assignPartition(bucket, numPartitions)__				_				_				seg.put(bucketOffset + HEADER_PARTITION_OFFSET, partition)__				seg.put(bucketOffset + HEADER_STATUS_OFFSET, BUCKET_STATUS_IN_MEMORY)__				seg.putShort(bucketOffset + HEADER_COUNT_OFFSET, (short) 0)__				seg.putLong(bucketOffset + HEADER_FORWARD_OFFSET, BUCKET_FORWARD_POINTER_NOT_SET)__			}_			_			table[i] = seg__		}_		this.buckets = table__		this.numBuckets = numBuckets__	};param,num,buckets,param,num,partitions,return;protected,void,init,table,int,num,buckets,byte,num,partitions,final,int,buckets,per,segment,this,buckets,per,segment,mask,1,final,int,num,segs,num,buckets,this,buckets,per,segment,bits,num,buckets,this,buckets,per,segment,mask,0,0,1,final,memory,segment,table,new,memory,segment,num,segs,ensure,num,buffers,returned,num,segs,for,int,i,0,bucket,0,i,num,segs,bucket,num,buckets,i,final,memory,segment,seg,get,next,buffer,for,int,k,0,k,buckets,per,segment,bucket,num,buckets,k,bucket,final,int,bucket,offset,k,final,byte,partition,assign,partition,bucket,num,partitions,seg,put,bucket,offset,partition,seg,put,bucket,offset,seg,put,short,bucket,offset,short,0,seg,put,long,bucket,offset,table,i,seg,this,buckets,table,this,num,buckets,num,buckets
MutableHashTable -> protected void initTable(int numBuckets, byte numPartitions);1405090423;@param numBuckets_@param numPartitions_@return;protected void initTable(int numBuckets, byte numPartitions) {_		final int bucketsPerSegment = this.bucketsPerSegmentMask + 1__		final int numSegs = (numBuckets >>> this.bucketsPerSegmentBits) + ( (numBuckets & this.bucketsPerSegmentMask) == 0 ? 0 : 1)__		final MemorySegment[] table = new MemorySegment[numSegs]__		_		ensureNumBuffersReturned(numSegs)__		_		_		for (int i = 0, bucket = 0_ i < numSegs && bucket < numBuckets_ i++) {_			final MemorySegment seg = getNextBuffer()__			_			_			for (int k = 0_ k < bucketsPerSegment && bucket < numBuckets_ k++, bucket++) {_				final int bucketOffset = k * HASH_BUCKET_SIZE_	_				_				_				final byte partition = assignPartition(bucket, numPartitions)__				_				_				seg.put(bucketOffset + HEADER_PARTITION_OFFSET, partition)__				seg.put(bucketOffset + HEADER_STATUS_OFFSET, BUCKET_STATUS_IN_MEMORY)__				seg.putShort(bucketOffset + HEADER_COUNT_OFFSET, (short) 0)__				seg.putLong(bucketOffset + HEADER_FORWARD_OFFSET, BUCKET_FORWARD_POINTER_NOT_SET)__			}_			_			table[i] = seg__		}_		this.buckets = table__		this.numBuckets = numBuckets__	};param,num,buckets,param,num,partitions,return;protected,void,init,table,int,num,buckets,byte,num,partitions,final,int,buckets,per,segment,this,buckets,per,segment,mask,1,final,int,num,segs,num,buckets,this,buckets,per,segment,bits,num,buckets,this,buckets,per,segment,mask,0,0,1,final,memory,segment,table,new,memory,segment,num,segs,ensure,num,buffers,returned,num,segs,for,int,i,0,bucket,0,i,num,segs,bucket,num,buckets,i,final,memory,segment,seg,get,next,buffer,for,int,k,0,k,buckets,per,segment,bucket,num,buckets,k,bucket,final,int,bucket,offset,k,final,byte,partition,assign,partition,bucket,num,partitions,seg,put,bucket,offset,partition,seg,put,bucket,offset,seg,put,short,bucket,offset,short,0,seg,put,long,bucket,offset,table,i,seg,this,buckets,table,this,num,buckets,num,buckets
MutableHashTable -> protected void initTable(int numBuckets, byte numPartitions);1409911022;@param numBuckets_@param numPartitions_@return;protected void initTable(int numBuckets, byte numPartitions) {_		final int bucketsPerSegment = this.bucketsPerSegmentMask + 1__		final int numSegs = (numBuckets >>> this.bucketsPerSegmentBits) + ( (numBuckets & this.bucketsPerSegmentMask) == 0 ? 0 : 1)__		final MemorySegment[] table = new MemorySegment[numSegs]__		_		ensureNumBuffersReturned(numSegs)__		_		_		for (int i = 0, bucket = 0_ i < numSegs && bucket < numBuckets_ i++) {_			final MemorySegment seg = getNextBuffer()__			_			_			for (int k = 0_ k < bucketsPerSegment && bucket < numBuckets_ k++, bucket++) {_				final int bucketOffset = k * HASH_BUCKET_SIZE_	_				_				_				final byte partition = assignPartition(bucket, numPartitions)__				_				_				seg.put(bucketOffset + HEADER_PARTITION_OFFSET, partition)__				seg.put(bucketOffset + HEADER_STATUS_OFFSET, BUCKET_STATUS_IN_MEMORY)__				seg.putShort(bucketOffset + HEADER_COUNT_OFFSET, (short) 0)__				seg.putLong(bucketOffset + HEADER_FORWARD_OFFSET, BUCKET_FORWARD_POINTER_NOT_SET)__			}_			_			table[i] = seg__		}_		this.buckets = table__		this.numBuckets = numBuckets__	};param,num,buckets,param,num,partitions,return;protected,void,init,table,int,num,buckets,byte,num,partitions,final,int,buckets,per,segment,this,buckets,per,segment,mask,1,final,int,num,segs,num,buckets,this,buckets,per,segment,bits,num,buckets,this,buckets,per,segment,mask,0,0,1,final,memory,segment,table,new,memory,segment,num,segs,ensure,num,buffers,returned,num,segs,for,int,i,0,bucket,0,i,num,segs,bucket,num,buckets,i,final,memory,segment,seg,get,next,buffer,for,int,k,0,k,buckets,per,segment,bucket,num,buckets,k,bucket,final,int,bucket,offset,k,final,byte,partition,assign,partition,bucket,num,partitions,seg,put,bucket,offset,partition,seg,put,bucket,offset,seg,put,short,bucket,offset,short,0,seg,put,long,bucket,offset,table,i,seg,this,buckets,table,this,num,buckets,num,buckets
MutableHashTable -> protected void initTable(int numBuckets, byte numPartitions);1411473593;@param numBuckets_@param numPartitions_@return;protected void initTable(int numBuckets, byte numPartitions) {_		final int bucketsPerSegment = this.bucketsPerSegmentMask + 1__		final int numSegs = (numBuckets >>> this.bucketsPerSegmentBits) + ( (numBuckets & this.bucketsPerSegmentMask) == 0 ? 0 : 1)__		final MemorySegment[] table = new MemorySegment[numSegs]__		_		ensureNumBuffersReturned(numSegs)__		_		_		for (int i = 0, bucket = 0_ i < numSegs && bucket < numBuckets_ i++) {_			final MemorySegment seg = getNextBuffer()__			_			_			for (int k = 0_ k < bucketsPerSegment && bucket < numBuckets_ k++, bucket++) {_				final int bucketOffset = k * HASH_BUCKET_SIZE_	_				_				_				final byte partition = assignPartition(bucket, numPartitions)__				_				_				seg.put(bucketOffset + HEADER_PARTITION_OFFSET, partition)__				seg.put(bucketOffset + HEADER_STATUS_OFFSET, BUCKET_STATUS_IN_MEMORY)__				seg.putShort(bucketOffset + HEADER_COUNT_OFFSET, (short) 0)__				seg.putLong(bucketOffset + HEADER_FORWARD_OFFSET, BUCKET_FORWARD_POINTER_NOT_SET)__			}_			_			table[i] = seg__		}_		this.buckets = table__		this.numBuckets = numBuckets__	};param,num,buckets,param,num,partitions,return;protected,void,init,table,int,num,buckets,byte,num,partitions,final,int,buckets,per,segment,this,buckets,per,segment,mask,1,final,int,num,segs,num,buckets,this,buckets,per,segment,bits,num,buckets,this,buckets,per,segment,mask,0,0,1,final,memory,segment,table,new,memory,segment,num,segs,ensure,num,buffers,returned,num,segs,for,int,i,0,bucket,0,i,num,segs,bucket,num,buckets,i,final,memory,segment,seg,get,next,buffer,for,int,k,0,k,buckets,per,segment,bucket,num,buckets,k,bucket,final,int,bucket,offset,k,final,byte,partition,assign,partition,bucket,num,partitions,seg,put,bucket,offset,partition,seg,put,bucket,offset,seg,put,short,bucket,offset,short,0,seg,put,long,bucket,offset,table,i,seg,this,buckets,table,this,num,buckets,num,buckets
MutableHashTable -> public boolean nextRecord() throws IOException;1405024514;@return_@throws IOException;public boolean nextRecord() throws IOException {_		_		final boolean probeProcessing = processProbeIter()__		if(probeProcessing) {_			return true__		}_		return prepareNextPartition()__	};return,throws,ioexception;public,boolean,next,record,throws,ioexception,final,boolean,probe,processing,process,probe,iter,if,probe,processing,return,true,return,prepare,next,partition
MutableHashTable -> public boolean nextRecord() throws IOException;1405090423;@return_@throws IOException;public boolean nextRecord() throws IOException {_		_		final boolean probeProcessing = processProbeIter()__		if(probeProcessing) {_			return true__		}_		return prepareNextPartition()__	};return,throws,ioexception;public,boolean,next,record,throws,ioexception,final,boolean,probe,processing,process,probe,iter,if,probe,processing,return,true,return,prepare,next,partition
MutableHashTable -> public boolean nextRecord() throws IOException;1409911022;@return_@throws IOException;public boolean nextRecord() throws IOException {_		_		final boolean probeProcessing = processProbeIter()__		if(probeProcessing) {_			return true__		}_		return prepareNextPartition()__	};return,throws,ioexception;public,boolean,next,record,throws,ioexception,final,boolean,probe,processing,process,probe,iter,if,probe,processing,return,true,return,prepare,next,partition
MutableHashTable -> public boolean nextRecord() throws IOException;1411473593;@return_@throws IOException;public boolean nextRecord() throws IOException {_		_		final boolean probeProcessing = processProbeIter()__		if(probeProcessing) {_			return true__		}_		return prepareNextPartition()__	};return,throws,ioexception;public,boolean,next,record,throws,ioexception,final,boolean,probe,processing,process,probe,iter,if,probe,processing,return,true,return,prepare,next,partition
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1405024514;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1405090423;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1409911022;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1411473593;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1412164980;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1415702894;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1418570573;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1420654570;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1426697080;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1433417242;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1436281304;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1438803435;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1438874079;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		} else {_			byte status = bucket.get(bucketInSegmentPos + HEADER_STATUS_OFFSET)__			if (status == BUCKET_STATUS_IN_FILTER) {_				_				_				this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__				this.bloomFilter.addHash(hashCode)__			}_		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer,else,byte,status,bucket,get,bucket,in,segment,pos,if,status,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,this,bloom,filter,add,hash,hash,code
MutableHashTable -> protected final void insertIntoTable(final BT record, final int hashCode) throws IOException;1438877580;@param record_@param hashCode_@throws IOException;protected final void insertIntoTable(final BT record, final int hashCode) throws IOException {_		final int posHashCode = hashCode % this.numBuckets__		_		_		final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__		final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__		final MemorySegment bucket = this.buckets[bucketArrayPos]__		_		_		final int partitionNumber = bucket.get(bucketInSegmentPos + HEADER_PARTITION_OFFSET)__		_		_		if (partitionNumber < 0 || partitionNumber >= this.partitionsBeingBuilt.size()) {_			throw new RuntimeException("Error: Hash structures in Hash-Join are corrupt. Invalid partition number for bucket.")__		}_		final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__		_		_		_		long pointer = p.insertIntoBuildBuffer(record)__		if (pointer != -1) {_			_			insertBucketEntry(p, bucket, bucketInSegmentPos, hashCode, pointer)__		} else {_			byte status = bucket.get(bucketInSegmentPos + HEADER_STATUS_OFFSET)__			if (status == BUCKET_STATUS_IN_FILTER) {_				_				_				this.bloomFilter.setBitsLocation(bucket, bucketInSegmentPos + BUCKET_HEADER_LENGTH)__				this.bloomFilter.addHash(hashCode)__			}_		}_	};param,record,param,hash,code,throws,ioexception;protected,final,void,insert,into,table,final,bt,record,final,int,hash,code,throws,ioexception,final,int,pos,hash,code,hash,code,this,num,buckets,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,final,int,partition,number,bucket,get,bucket,in,segment,pos,if,partition,number,0,partition,number,this,partitions,being,built,size,throw,new,runtime,exception,error,hash,structures,in,hash,join,are,corrupt,invalid,partition,number,for,bucket,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,long,pointer,p,insert,into,build,buffer,record,if,pointer,1,insert,bucket,entry,p,bucket,bucket,in,segment,pos,hash,code,pointer,else,byte,status,bucket,get,bucket,in,segment,pos,if,status,this,bloom,filter,set,bits,location,bucket,bucket,in,segment,pos,this,bloom,filter,add,hash,hash,code
MutableHashTable -> protected int spillPartition() throws IOException;1405024514;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1405090423;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1409911022;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1411473593;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1412164980;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1415702894;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1418570573;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1420654570;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1426697080;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1433417242;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1436281304;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1438803435;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1438874079;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		boolean enableBloomFilter = GlobalConfiguration.getBoolean(_			ConfigConstants.HASHJOIN_ENABLE_BLOOMFILTER, ConfigConstants.DEAFULT_HASHJOIN_ENABLE_BLOOMFILTER)__		if (enableBloomFilter) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,boolean,enable,bloom,filter,global,configuration,get,boolean,config,constants,config,constants,if,enable,bloom,filter,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1438877580;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff = null__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,null,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1440607697;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1441195975;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getBuildSideBlockCount() > largestNumBlocks) {_				largestNumBlocks = p.getBuildSideBlockCount()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,build,side,block,count,largest,num,blocks,largest,num,blocks,p,get,build,side,block,count,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1443528421;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getNumOccupiedMemorySegments() > largestNumBlocks) {_				largestNumBlocks = p.getNumOccupiedMemorySegments()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,num,occupied,memory,segments,largest,num,blocks,largest,num,blocks,p,get,num,occupied,memory,segments,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1445427423;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getNumOccupiedMemorySegments() > largestNumBlocks) {_				largestNumBlocks = p.getNumOccupiedMemorySegments()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,num,occupied,memory,segments,largest,num,blocks,largest,num,blocks,p,get,num,occupied,memory,segments,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1453866659;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getNumOccupiedMemorySegments() > largestNumBlocks) {_				largestNumBlocks = p.getNumOccupiedMemorySegments()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,num,occupied,memory,segments,largest,num,blocks,largest,num,blocks,p,get,num,occupied,memory,segments,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1456186698;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getNumOccupiedMemorySegments() > largestNumBlocks) {_				largestNumBlocks = p.getNumOccupiedMemorySegments()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,num,occupied,memory,segments,largest,num,blocks,largest,num,blocks,p,get,num,occupied,memory,segments,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1456186722;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getNumOccupiedMemorySegments() > largestNumBlocks) {_				largestNumBlocks = p.getNumOccupiedMemorySegments()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,num,occupied,memory,segments,largest,num,blocks,largest,num,blocks,p,get,num,occupied,memory,segments,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1460472696;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getNumOccupiedMemorySegments() > largestNumBlocks) {_				largestNumBlocks = p.getNumOccupiedMemorySegments()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,num,occupied,memory,segments,largest,num,blocks,largest,num,blocks,p,get,num,occupied,memory,segments,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1460741894;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getNumOccupiedMemorySegments() > largestNumBlocks) {_				largestNumBlocks = p.getNumOccupiedMemorySegments()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,num,occupied,memory,segments,largest,num,blocks,largest,num,blocks,p,get,num,occupied,memory,segments,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> protected int spillPartition() throws IOException;1468441547;Selects a partition and spills it. The number of the spilled partition is returned.__@return The number of the spilled partition.;protected int spillPartition() throws IOException {_		_		ArrayList<HashPartition<BT, PT>> partitions = this.partitionsBeingBuilt__		int largestNumBlocks = 0__		int largestPartNum = -1__		_		for (int i = 0_ i < partitions.size()_ i++) {_			HashPartition<BT, PT> p = partitions.get(i)__			if (p.isInMemory() && p.getNumOccupiedMemorySegments() > largestNumBlocks) {_				largestNumBlocks = p.getNumOccupiedMemorySegments()__				largestPartNum = i__			}_		}_		final HashPartition<BT, PT> p = partitions.get(largestPartNum)__		_		if (useBloomFilters) {_			buildBloomFilterForBucketsInPartition(largestPartNum, p)__		}_		_		_		int numBuffersFreed = p.spillPartition(this.availableMemory, this.ioManager, _										this.currentEnumerator.next(), this.writeBehindBuffers)__		this.writeBehindBuffersAvailable += numBuffersFreed__		_		MemorySegment currBuff__		while (this.writeBehindBuffersAvailable > 0 && (currBuff = this.writeBehindBuffers.poll()) != null) {_			this.availableMemory.add(currBuff)__			this.writeBehindBuffersAvailable--__		}_		return largestPartNum__	};selects,a,partition,and,spills,it,the,number,of,the,spilled,partition,is,returned,return,the,number,of,the,spilled,partition;protected,int,spill,partition,throws,ioexception,array,list,hash,partition,bt,pt,partitions,this,partitions,being,built,int,largest,num,blocks,0,int,largest,part,num,1,for,int,i,0,i,partitions,size,i,hash,partition,bt,pt,p,partitions,get,i,if,p,is,in,memory,p,get,num,occupied,memory,segments,largest,num,blocks,largest,num,blocks,p,get,num,occupied,memory,segments,largest,part,num,i,final,hash,partition,bt,pt,p,partitions,get,largest,part,num,if,use,bloom,filters,build,bloom,filter,for,buckets,in,partition,largest,part,num,p,int,num,buffers,freed,p,spill,partition,this,available,memory,this,io,manager,this,current,enumerator,next,this,write,behind,buffers,this,write,behind,buffers,available,num,buffers,freed,memory,segment,curr,buff,while,this,write,behind,buffers,available,0,curr,buff,this,write,behind,buffers,poll,null,this,available,memory,add,curr,buff,this,write,behind,buffers,available,return,largest,part,num
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextOnHeapBucket();1453866659;Loop to make sure that it would move to next on heap bucket, return true while move to a on heap bucket,_return false if there is no more bucket.;private boolean moveToNextOnHeapBucket() {_			while (!moveToNextBucket()) {_				if (scanCount >= totalBucketNumber) {_					return false__				}_			}_			return true__		};loop,to,make,sure,that,it,would,move,to,next,on,heap,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,if,there,is,no,more,bucket;private,boolean,move,to,next,on,heap,bucket,while,move,to,next,bucket,if,scan,count,total,bucket,number,return,false,return,true
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextOnHeapBucket();1456186698;Loop to make sure that it would move to next on heap bucket, return true while move to a on heap bucket,_return false if there is no more bucket.;private boolean moveToNextOnHeapBucket() {_			while (!moveToNextBucket()) {_				if (scanCount >= totalBucketNumber) {_					return false__				}_			}_			return true__		};loop,to,make,sure,that,it,would,move,to,next,on,heap,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,if,there,is,no,more,bucket;private,boolean,move,to,next,on,heap,bucket,while,move,to,next,bucket,if,scan,count,total,bucket,number,return,false,return,true
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextOnHeapBucket();1456186722;Loop to make sure that it would move to next on heap bucket, return true while move to a on heap bucket,_return false if there is no more bucket.;private boolean moveToNextOnHeapBucket() {_			while (!moveToNextBucket()) {_				if (scanCount >= totalBucketNumber) {_					return false__				}_			}_			return true__		};loop,to,make,sure,that,it,would,move,to,next,on,heap,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,if,there,is,no,more,bucket;private,boolean,move,to,next,on,heap,bucket,while,move,to,next,bucket,if,scan,count,total,bucket,number,return,false,return,true
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextOnHeapBucket();1460472696;Loop to make sure that it would move to next on heap bucket, return true while move to a on heap bucket,_return false if there is no more bucket.;private boolean moveToNextOnHeapBucket() {_			while (!moveToNextBucket()) {_				if (scanCount >= totalBucketNumber) {_					return false__				}_			}_			return true__		};loop,to,make,sure,that,it,would,move,to,next,on,heap,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,if,there,is,no,more,bucket;private,boolean,move,to,next,on,heap,bucket,while,move,to,next,bucket,if,scan,count,total,bucket,number,return,false,return,true
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextOnHeapBucket();1460741894;Loop to make sure that it would move to next on heap bucket, return true while move to a on heap bucket,_return false if there is no more bucket.;private boolean moveToNextOnHeapBucket() {_			while (!moveToNextBucket()) {_				if (scanCount >= totalBucketNumber) {_					return false__				}_			}_			return true__		};loop,to,make,sure,that,it,would,move,to,next,on,heap,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,if,there,is,no,more,bucket;private,boolean,move,to,next,on,heap,bucket,while,move,to,next,bucket,if,scan,count,total,bucket,number,return,false,return,true
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextOnHeapBucket();1468441547;Loop to make sure that it would move to next on heap bucket, return true while move to a on heap bucket,_return false if there is no more bucket.;private boolean moveToNextOnHeapBucket() {_			while (!moveToNextBucket()) {_				if (scanCount >= totalBucketNumber) {_					return false__				}_			}_			return true__		};loop,to,make,sure,that,it,would,move,to,next,on,heap,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,if,there,is,no,more,bucket;private,boolean,move,to,next,on,heap,bucket,while,move,to,next,bucket,if,scan,count,total,bucket,number,return,false,return,true
MutableHashTable -> public static final int getPartitioningFanOutNoEstimates(int numBuffers);1405024514;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static final int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,final,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static final int getPartitioningFanOutNoEstimates(int numBuffers);1405090423;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static final int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,final,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static final int getPartitioningFanOutNoEstimates(int numBuffers);1409911022;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static final int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,final,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static final int getPartitioningFanOutNoEstimates(int numBuffers);1411473593;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static final int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,final,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static final int getPartitioningFanOutNoEstimates(int numBuffers);1412164980;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static final int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,final,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static final int getPartitioningFanOutNoEstimates(int numBuffers);1415702894;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static final int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,final,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static final int getPartitioningFanOutNoEstimates(int numBuffers);1418570573;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static final int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,final,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static final int getPartitioningFanOutNoEstimates(int numBuffers);1420654570;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static final int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,final,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static final int getPartitioningFanOutNoEstimates(int numBuffers);1426697080;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static final int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,final,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> public static final int getPartitioningFanOutNoEstimates(int numBuffers);1433417242;Gets the number of partitions to be used for an initial hash-table, when no estimates are_available._<p>_The current logic makes sure that there are always between 10 and 127 partitions, and close_to 0.1 of the number of buffers.__@param numBuffers The number of buffers available._@return The number of partitions to use.;public static final int getPartitioningFanOutNoEstimates(int numBuffers) {_		return Math.max(10, Math.min(numBuffers / 10, MAX_NUM_PARTITIONS))__	};gets,the,number,of,partitions,to,be,used,for,an,initial,hash,table,when,no,estimates,are,available,p,the,current,logic,makes,sure,that,there,are,always,between,10,and,127,partitions,and,close,to,0,1,of,the,number,of,buffers,param,num,buffers,the,number,of,buffers,available,return,the,number,of,partitions,to,use;public,static,final,int,get,partitioning,fan,out,no,estimates,int,num,buffers,return,math,max,10,math,min,num,buffers,10
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1405024514;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1405090423;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1409911022;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1411473593;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1412164980;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1415702894;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1418570573;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1420654570;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1426697080;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1433417242;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1436281304;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1438803435;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1438874079;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> protected void createPartitions(int numPartitions, int recursionLevel);1438877580;@param numPartitions;protected void createPartitions(int numPartitions, int recursionLevel) {_		_		ensureNumBuffersReturned(numPartitions)__		_		this.currentEnumerator = this.ioManager.createChannelEnumerator()__		_		this.partitionsBeingBuilt.clear()__		for (int i = 0_ i < numPartitions_ i++) {_			HashPartition<BT, PT> p = getNewInMemoryPartition(i, recursionLevel)__			this.partitionsBeingBuilt.add(p)__		}_	};param,num,partitions;protected,void,create,partitions,int,num,partitions,int,recursion,level,ensure,num,buffers,returned,num,partitions,this,current,enumerator,this,io,manager,create,channel,enumerator,this,partitions,being,built,clear,for,int,i,0,i,num,partitions,i,hash,partition,bt,pt,p,get,new,in,memory,partition,i,recursion,level,this,partitions,being,built,add,p
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1436281304;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1438803435;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1438874079;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1438877580;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1440607697;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1441195975;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1443528421;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1445427423;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1453866659;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1456186698;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1456186722;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1460472696;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1460741894;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> public static int getNumWriteBehindBuffers(int numBuffers);1468441547;Determines the number of buffers to be used for asynchronous write behind. It is currently_computed as the logarithm of the number of buffers to the base 4, rounded up, minus 2._The upper limit for the number of write behind buffers is however set to six.__@param numBuffers The number of available buffers._@return The number;public static int getNumWriteBehindBuffers(int numBuffers) {_		int numIOBufs = (int) (Math.log(numBuffers) / Math.log(4) - 1.5)__		return numIOBufs > 6 ? 6 : numIOBufs__	};determines,the,number,of,buffers,to,be,used,for,asynchronous,write,behind,it,is,currently,computed,as,the,logarithm,of,the,number,of,buffers,to,the,base,4,rounded,up,minus,2,the,upper,limit,for,the,number,of,write,behind,buffers,is,however,set,to,six,param,num,buffers,the,number,of,available,buffers,return,the,number;public,static,int,get,num,write,behind,buffers,int,num,buffers,int,num,iobufs,int,math,log,num,buffers,math,log,4,1,5,return,num,iobufs,6,6,num,iobufs
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1436281304;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1438803435;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1438874079;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1438877580;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1440607697;Creates the initial hash table. This method sets up partitions, hash index, and inserts_the data from the given iterator.__@param input The iterator with the build side data._@throws IOException Thrown, if an element could not be fetched and deserialized from_the iterator, or if serialization fails.;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};creates,the,initial,hash,table,this,method,sets,up,partitions,hash,index,and,inserts,the,data,from,the,given,iterator,param,input,the,iterator,with,the,build,side,data,throws,ioexception,thrown,if,an,element,could,not,be,fetched,and,deserialized,from,the,iterator,or,if,serialization,fails;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1441195975;Creates the initial hash table. This method sets up partitions, hash index, and inserts_the data from the given iterator.__@param input The iterator with the build side data._@throws IOException Thrown, if an element could not be fetched and deserialized from_the iterator, or if serialization fails.;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};creates,the,initial,hash,table,this,method,sets,up,partitions,hash,index,and,inserts,the,data,from,the,given,iterator,param,input,the,iterator,with,the,build,side,data,throws,ioexception,thrown,if,an,element,could,not,be,fetched,and,deserialized,from,the,iterator,or,if,serialization,fails;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1443528421;Creates the initial hash table. This method sets up partitions, hash index, and inserts_the data from the given iterator.__@param input The iterator with the build side data._@throws IOException Thrown, if an element could not be fetched and deserialized from_the iterator, or if serialization fails.;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};creates,the,initial,hash,table,this,method,sets,up,partitions,hash,index,and,inserts,the,data,from,the,given,iterator,param,input,the,iterator,with,the,build,side,data,throws,ioexception,thrown,if,an,element,could,not,be,fetched,and,deserialized,from,the,iterator,or,if,serialization,fails;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1445427423;Creates the initial hash table. This method sets up partitions, hash index, and inserts_the data from the given iterator.__@param input The iterator with the build side data._@throws IOException Thrown, if an element could not be fetched and deserialized from_the iterator, or if serialization fails.;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};creates,the,initial,hash,table,this,method,sets,up,partitions,hash,index,and,inserts,the,data,from,the,given,iterator,param,input,the,iterator,with,the,build,side,data,throws,ioexception,thrown,if,an,element,could,not,be,fetched,and,deserialized,from,the,iterator,or,if,serialization,fails;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1453866659;Creates the initial hash table. This method sets up partitions, hash index, and inserts_the data from the given iterator.__@param input The iterator with the build side data._@throws IOException Thrown, if an element could not be fetched and deserialized from_the iterator, or if serialization fails.;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};creates,the,initial,hash,table,this,method,sets,up,partitions,hash,index,and,inserts,the,data,from,the,given,iterator,param,input,the,iterator,with,the,build,side,data,throws,ioexception,thrown,if,an,element,could,not,be,fetched,and,deserialized,from,the,iterator,or,if,serialization,fails;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1456186698;Creates the initial hash table. This method sets up partitions, hash index, and inserts_the data from the given iterator.__@param input The iterator with the build side data._@throws IOException Thrown, if an element could not be fetched and deserialized from_the iterator, or if serialization fails.;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};creates,the,initial,hash,table,this,method,sets,up,partitions,hash,index,and,inserts,the,data,from,the,given,iterator,param,input,the,iterator,with,the,build,side,data,throws,ioexception,thrown,if,an,element,could,not,be,fetched,and,deserialized,from,the,iterator,or,if,serialization,fails;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1456186722;Creates the initial hash table. This method sets up partitions, hash index, and inserts_the data from the given iterator.__@param input The iterator with the build side data._@throws IOException Thrown, if an element could not be fetched and deserialized from_the iterator, or if serialization fails.;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};creates,the,initial,hash,table,this,method,sets,up,partitions,hash,index,and,inserts,the,data,from,the,given,iterator,param,input,the,iterator,with,the,build,side,data,throws,ioexception,thrown,if,an,element,could,not,be,fetched,and,deserialized,from,the,iterator,or,if,serialization,fails;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1460472696;Creates the initial hash table. This method sets up partitions, hash index, and inserts_the data from the given iterator.__@param input The iterator with the build side data._@throws IOException Thrown, if an element could not be fetched and deserialized from_the iterator, or if serialization fails.;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};creates,the,initial,hash,table,this,method,sets,up,partitions,hash,index,and,inserts,the,data,from,the,given,iterator,param,input,the,iterator,with,the,build,side,data,throws,ioexception,thrown,if,an,element,could,not,be,fetched,and,deserialized,from,the,iterator,or,if,serialization,fails;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1460741894;Creates the initial hash table. This method sets up partitions, hash index, and inserts_the data from the given iterator.__@param input The iterator with the build side data._@throws IOException Thrown, if an element could not be fetched and deserialized from_the iterator, or if serialization fails.;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};creates,the,initial,hash,table,this,method,sets,up,partitions,hash,index,and,inserts,the,data,from,the,given,iterator,param,input,the,iterator,with,the,build,side,data,throws,ioexception,thrown,if,an,element,could,not,be,fetched,and,deserialized,from,the,iterator,or,if,serialization,fails;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException;1468441547;Creates the initial hash table. This method sets up partitions, hash index, and inserts_the data from the given iterator.__@param input The iterator with the build side data._@throws IOException Thrown, if an element could not be fetched and deserialized from_the iterator, or if serialization fails.;protected void buildInitialTable(final MutableObjectIterator<BT> input) throws IOException {_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};creates,the,initial,hash,table,this,method,sets,up,partitions,hash,index,and,inserts,the,data,from,the,given,iterator,param,input,the,iterator,with,the,build,side,data,throws,ioexception,thrown,if,an,element,could,not,be,fetched,and,deserialized,from,the,iterator,or,if,serialization,fails;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) 	throws IOException;1405024514;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input)_	throws IOException_	{_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) 	throws IOException;1405090423;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input)_	throws IOException_	{_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) 	throws IOException;1409911022;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input)_	throws IOException_	{_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) 	throws IOException;1411473593;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input)_	throws IOException_	{_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) 	throws IOException;1412164980;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input)_	throws IOException_	{_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) 	throws IOException;1415702894;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input)_	throws IOException_	{_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) 	throws IOException;1418570573;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input)_	throws IOException_	{_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) 	throws IOException;1420654570;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input)_	throws IOException_	{_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) 	throws IOException;1426697080;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input)_	throws IOException_	{_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildInitialTable(final MutableObjectIterator<BT> input) 	throws IOException;1433417242;@param input_@throws IOException;protected void buildInitialTable(final MutableObjectIterator<BT> input)_	throws IOException_	{_		_		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size())__		if (partitionFanOut > MAX_NUM_PARTITIONS) {_			throw new RuntimeException("Hash join partitions estimate exeeds maximum number of partitions.")_ _		}_		createPartitions(partitionFanOut, 0)__		_		_		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, _			partitionFanOut, this.avgRecordLen)__		initTable(numBuckets, (byte) partitionFanOut)__		_		final TypeComparator<BT> buildTypeComparator = this.buildSideComparator__		BT record = this.buildSideSerializer.createInstance()___		_		while (this.running && ((record = input.next(record)) != null)) {_			final int hashCode = hash(buildTypeComparator.hash(record), 0)__			insertIntoTable(record, hashCode)__		}_		_		if (!this.running) {_			return__		}__		_		for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_			HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			p.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__		}_	};param,input,throws,ioexception;protected,void,build,initial,table,final,mutable,object,iterator,bt,input,throws,ioexception,final,int,partition,fan,out,get,partitioning,fan,out,no,estimates,this,available,memory,size,if,partition,fan,out,throw,new,runtime,exception,hash,join,partitions,estimate,exeeds,maximum,number,of,partitions,create,partitions,partition,fan,out,0,final,int,num,buckets,get,initial,table,size,this,available,memory,size,this,segment,size,partition,fan,out,this,avg,record,len,init,table,num,buckets,byte,partition,fan,out,final,type,comparator,bt,build,type,comparator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,this,running,record,input,next,record,null,final,int,hash,code,hash,build,type,comparator,hash,record,0,insert,into,table,record,hash,code,if,this,running,return,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,p,this,partitions,being,built,get,i,p,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1405024514;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = (int) (((long) totalBuffersAvailable) * RECORD_TABLE_BYTES / _					(avgRecordLenPartition + RECORD_OVERHEAD_BYTES))__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,int,long,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1405090423;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = (int) (((long) totalBuffersAvailable) * RECORD_TABLE_BYTES / _					(avgRecordLenPartition + RECORD_OVERHEAD_BYTES))__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,int,long,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1409911022;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = (int) (((long) totalBuffersAvailable) * RECORD_TABLE_BYTES / _					(avgRecordLenPartition + RECORD_OVERHEAD_BYTES))__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,int,long,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1411473593;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = (int) (((long) totalBuffersAvailable) * RECORD_TABLE_BYTES / _					(avgRecordLenPartition + RECORD_OVERHEAD_BYTES))__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,int,long,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1412164980;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = (int) (((long) totalBuffersAvailable) * RECORD_TABLE_BYTES / _					(avgRecordLenPartition + RECORD_OVERHEAD_BYTES))__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,int,long,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1415702894;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = (int) (((long) totalBuffersAvailable) * RECORD_TABLE_BYTES / _					(avgRecordLenPartition + RECORD_OVERHEAD_BYTES))__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,int,long,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1418570573;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = (int) (((long) totalBuffersAvailable) * RECORD_TABLE_BYTES / _					(avgRecordLenPartition + RECORD_OVERHEAD_BYTES))__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,int,long,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1420654570;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = (int) (((long) totalBuffersAvailable) * RECORD_TABLE_BYTES / _					(avgRecordLenPartition + RECORD_OVERHEAD_BYTES))__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,int,long,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1426697080;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = (int) (((long) totalBuffersAvailable) * RECORD_TABLE_BYTES / _					(avgRecordLenPartition + RECORD_OVERHEAD_BYTES))__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader<MemorySegment> inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,int,long,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,memory,segment,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1433417242;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = (int) (((long) totalBuffersAvailable) * RECORD_TABLE_BYTES / _					(avgRecordLenPartition + RECORD_OVERHEAD_BYTES))__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader<MemorySegment> inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,int,long,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,memory,segment,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1436281304;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = getInitialTableSize(totalBuffersAvailable, this.segmentSize,_					getPartitioningFanOutNoEstimates(totalBuffersAvailable), avgRecordLenPartition)__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader<MemorySegment> inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,get,initial,table,size,total,buffers,available,this,segment,size,get,partitioning,fan,out,no,estimates,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,memory,segment,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1438803435;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = getInitialTableSize(totalBuffersAvailable, this.segmentSize,_					getPartitioningFanOutNoEstimates(totalBuffersAvailable), avgRecordLenPartition)__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader<MemorySegment> inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}__			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,get,initial,table,size,total,buffers,available,this,segment,size,get,partitioning,fan,out,no,estimates,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,memory,segment,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1438874079;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = getInitialTableSize(totalBuffersAvailable, this.segmentSize,_					getPartitioningFanOutNoEstimates(totalBuffersAvailable), avgRecordLenPartition)__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader<MemorySegment> inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}_			_			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,get,initial,table,size,total,buffers,available,this,segment,size,get,partitioning,fan,out,no,estimates,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,memory,segment,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException;1438877580;@param p_@throws IOException;protected void buildTableFromSpilledPartition(final HashPartition<BT, PT> p) throws IOException {_		_		final int nextRecursionLevel = p.getRecursionLevel() + 1__		if (nextRecursionLevel > MAX_RECURSION_DEPTH) {_			throw new RuntimeException("Hash join exceeded maximum number of recursions, without reducing "_				+ "partitions enough to be memory resident. Probably cause: Too many duplicate keys.")__		}_		_		_		_		_		_		_		_		_		final int totalBuffersAvailable = this.availableMemory.size() + this.writeBehindBuffersAvailable__		if (totalBuffersAvailable != this.totalNumBuffers - this.numWriteBehindBuffers) {_			throw new RuntimeException("Hash Join bug in memory management: Memory buffers leaked.")__		}_		_		long numBuckets = (p.getBuildSideRecordCount() * RECORD_TABLE_BYTES) / (HASH_BUCKET_SIZE - BUCKET_HEADER_LENGTH) + 1__		_		_		_		final long totalBuffersNeeded = (numBuckets * 2) / (this.bucketsPerSegmentMask + 1) + p.getBuildSideBlockCount() + 1__		_		if (totalBuffersNeeded < totalBuffersAvailable) {_			_			ensureNumBuffersReturned(p.getBuildSideBlockCount())__			_			_			final BulkBlockChannelReader reader = this.ioManager.createBulkBlockChannelReader(p.getBuildSideChannel().getChannelID(), _				this.availableMemory, p.getBuildSideBlockCount())__			_			if (keepBuildSidePartitions && p.recursionLevel == 0) {_				reader.close()_ _			} else {_				reader.closeAndDelete()__			}_			_			final List<MemorySegment> partitionBuffers = reader.getFullSegments()__			final HashPartition<BT, PT> newPart = new HashPartition<BT, PT>(this.buildSideSerializer, this.probeSideSerializer,_					0, nextRecursionLevel, partitionBuffers, p.getBuildSideRecordCount(), this.segmentSize, p.getLastSegmentLimit())__			_			this.partitionsBeingBuilt.add(newPart)__			_			_			initTable((int) numBuckets, (byte) 1)__			_			_			final HashPartition<BT, PT>.PartitionIterator pIter = newPart.getPartitionIterator(this.buildSideComparator)__			BT record = this.buildSideSerializer.createInstance()__			_			while ((record = pIter.next(record)) != null) {_				final int hashCode = hash(pIter.getCurrentHashCode(), nextRecursionLevel)__				final int posHashCode = hashCode % this.numBuckets__				final long pointer = pIter.getPointer()__				_				_				final int bucketArrayPos = posHashCode >> this.bucketsPerSegmentBits__				final int bucketInSegmentPos = (posHashCode & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__				final MemorySegment bucket = this.buckets[bucketArrayPos]__				_				insertBucketEntry(newPart, bucket, bucketInSegmentPos, hashCode, pointer)__			}_		}_		else {_			_			final int avgRecordLenPartition = (int) (((long) p.getBuildSideBlockCount()) * _					this.segmentSize / p.getBuildSideRecordCount())__			_			final int bucketCount = getInitialTableSize(totalBuffersAvailable, this.segmentSize,_					getPartitioningFanOutNoEstimates(totalBuffersAvailable), avgRecordLenPartition)__			_			_			final int splits = (int) (totalBuffersNeeded / totalBuffersAvailable) + 1__			final int partitionFanOut = Math.min(10 * splits , MAX_NUM_PARTITIONS)__			_			createPartitions(partitionFanOut, nextRecursionLevel)__			_			_			initTable(bucketCount, (byte) partitionFanOut)__			_			_			_			final List<MemorySegment> segments = new ArrayList<MemorySegment>(2)__			segments.add(getNextBuffer())__			segments.add(getNextBuffer())__			_			final BlockChannelReader<MemorySegment> inReader = this.ioManager.createBlockChannelReader(p.getBuildSideChannel().getChannelID())__			final ChannelReaderInputView inView = new HeaderlessChannelReaderInputView(inReader, segments,_						p.getBuildSideBlockCount(), p.getLastSegmentLimit(), false)__			final ChannelReaderInputViewIterator<BT> inIter = new ChannelReaderInputViewIterator<BT>(inView, _					this.availableMemory, this.buildSideSerializer)__			final TypeComparator<BT> btComparator = this.buildSideComparator__			BT rec = this.buildSideSerializer.createInstance()__			while ((rec = inIter.next(rec)) != null)_			{	_				final int hashCode = hash(btComparator.hash(rec), nextRecursionLevel)__				insertIntoTable(rec, hashCode)__			}_			_			_			for (int i = 0_ i < this.partitionsBeingBuilt.size()_ i++) {_				HashPartition<BT, PT> part = this.partitionsBeingBuilt.get(i)__				part.finalizeBuildPhase(this.ioManager, this.currentEnumerator, this.writeBehindBuffers)__			}_		}_	};param,p,throws,ioexception;protected,void,build,table,from,spilled,partition,final,hash,partition,bt,pt,p,throws,ioexception,final,int,next,recursion,level,p,get,recursion,level,1,if,next,recursion,level,throw,new,runtime,exception,hash,join,exceeded,maximum,number,of,recursions,without,reducing,partitions,enough,to,be,memory,resident,probably,cause,too,many,duplicate,keys,final,int,total,buffers,available,this,available,memory,size,this,write,behind,buffers,available,if,total,buffers,available,this,total,num,buffers,this,num,write,behind,buffers,throw,new,runtime,exception,hash,join,bug,in,memory,management,memory,buffers,leaked,long,num,buckets,p,get,build,side,record,count,1,final,long,total,buffers,needed,num,buckets,2,this,buckets,per,segment,mask,1,p,get,build,side,block,count,1,if,total,buffers,needed,total,buffers,available,ensure,num,buffers,returned,p,get,build,side,block,count,final,bulk,block,channel,reader,reader,this,io,manager,create,bulk,block,channel,reader,p,get,build,side,channel,get,channel,id,this,available,memory,p,get,build,side,block,count,if,keep,build,side,partitions,p,recursion,level,0,reader,close,else,reader,close,and,delete,final,list,memory,segment,partition,buffers,reader,get,full,segments,final,hash,partition,bt,pt,new,part,new,hash,partition,bt,pt,this,build,side,serializer,this,probe,side,serializer,0,next,recursion,level,partition,buffers,p,get,build,side,record,count,this,segment,size,p,get,last,segment,limit,this,partitions,being,built,add,new,part,init,table,int,num,buckets,byte,1,final,hash,partition,bt,pt,partition,iterator,p,iter,new,part,get,partition,iterator,this,build,side,comparator,bt,record,this,build,side,serializer,create,instance,while,record,p,iter,next,record,null,final,int,hash,code,hash,p,iter,get,current,hash,code,next,recursion,level,final,int,pos,hash,code,hash,code,this,num,buckets,final,long,pointer,p,iter,get,pointer,final,int,bucket,array,pos,pos,hash,code,this,buckets,per,segment,bits,final,int,bucket,in,segment,pos,pos,hash,code,this,buckets,per,segment,mask,final,memory,segment,bucket,this,buckets,bucket,array,pos,insert,bucket,entry,new,part,bucket,bucket,in,segment,pos,hash,code,pointer,else,final,int,avg,record,len,partition,int,long,p,get,build,side,block,count,this,segment,size,p,get,build,side,record,count,final,int,bucket,count,get,initial,table,size,total,buffers,available,this,segment,size,get,partitioning,fan,out,no,estimates,total,buffers,available,avg,record,len,partition,final,int,splits,int,total,buffers,needed,total,buffers,available,1,final,int,partition,fan,out,math,min,10,splits,create,partitions,partition,fan,out,next,recursion,level,init,table,bucket,count,byte,partition,fan,out,final,list,memory,segment,segments,new,array,list,memory,segment,2,segments,add,get,next,buffer,segments,add,get,next,buffer,final,block,channel,reader,memory,segment,in,reader,this,io,manager,create,block,channel,reader,p,get,build,side,channel,get,channel,id,final,channel,reader,input,view,in,view,new,headerless,channel,reader,input,view,in,reader,segments,p,get,build,side,block,count,p,get,last,segment,limit,false,final,channel,reader,input,view,iterator,bt,in,iter,new,channel,reader,input,view,iterator,bt,in,view,this,available,memory,this,build,side,serializer,final,type,comparator,bt,bt,comparator,this,build,side,comparator,bt,rec,this,build,side,serializer,create,instance,while,rec,in,iter,next,rec,null,final,int,hash,code,hash,bt,comparator,hash,rec,next,recursion,level,insert,into,table,rec,hash,code,for,int,i,0,i,this,partitions,being,built,size,i,hash,partition,bt,pt,part,this,partitions,being,built,get,i,part,finalize,build,phase,this,io,manager,this,current,enumerator,this,write,behind,buffers
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1405024514;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1405090423;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1409911022;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1411473593;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1412164980;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1415702894;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1418570573;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1420654570;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1426697080;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1433417242;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1436281304;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1438803435;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1438874079;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1438877580;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1440607697;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1441195975;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1443528421;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1445427423;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1453866659;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1456186698;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1456186722;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1460472696;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1460741894;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> final void ensureNumBuffersReturned(final int minRequiredAvailable);1468441547;This method makes sure that at least a certain number of memory segments is in the list of free segments._Free memory can be in the list of free segments, or in the return-queue where segments used to write behind are_put. The number of segments that are in that return-queue, but are actually reclaimable is tracked. This method_makes sure at least a certain number of buffers is reclaimed.__@param minRequiredAvailable The minimum number of buffers that needs to be reclaimed.;final void ensureNumBuffersReturned(final int minRequiredAvailable) {_		if (minRequiredAvailable > this.availableMemory.size() + this.writeBehindBuffersAvailable) {_			throw new IllegalArgumentException("More buffers requested available than totally available.")__		}_		_		try {_			while (this.availableMemory.size() < minRequiredAvailable) {_				this.availableMemory.add(this.writeBehindBuffers.take())__				this.writeBehindBuffersAvailable--__			}_		}_		catch (InterruptedException iex) {_			throw new RuntimeException("Hash Join was interrupted.")__		}_	};this,method,makes,sure,that,at,least,a,certain,number,of,memory,segments,is,in,the,list,of,free,segments,free,memory,can,be,in,the,list,of,free,segments,or,in,the,return,queue,where,segments,used,to,write,behind,are,put,the,number,of,segments,that,are,in,that,return,queue,but,are,actually,reclaimable,is,tracked,this,method,makes,sure,at,least,a,certain,number,of,buffers,is,reclaimed,param,min,required,available,the,minimum,number,of,buffers,that,needs,to,be,reclaimed;final,void,ensure,num,buffers,returned,final,int,min,required,available,if,min,required,available,this,available,memory,size,this,write,behind,buffers,available,throw,new,illegal,argument,exception,more,buffers,requested,available,than,totally,available,try,while,this,available,memory,size,min,required,available,this,available,memory,add,this,write,behind,buffers,take,this,write,behind,buffers,available,catch,interrupted,exception,iex,throw,new,runtime,exception,hash,join,was,interrupted
MutableHashTable -> protected void clearPartitions();1405024514;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1405090423;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1409911022;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1411473593;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1412164980;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1415702894;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1418570573;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1420654570;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1426697080;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1433417242;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1436281304;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1438803435;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1438874079;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1438877580;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1440607697;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1441195975;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1443528421;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1445427423;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1453866659;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1456186698;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1456186722;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1460472696;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1460741894;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> protected void clearPartitions();1468441547;This method clears all partitions currently residing (partially) in memory. It releases all memory_and deletes all spilled partitions._<p>_This method is intended for a hard cleanup in the case that the join is aborted.;protected void clearPartitions() {_		for (int i = this.partitionsBeingBuilt.size() - 1_ i >= 0_ --i) {_			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i)__			try {_				p.clearAllMemory(this.availableMemory)__			} catch (Exception e) {_				LOG.error("Error during partition cleanup.", e)__			}_		}_		this.partitionsBeingBuilt.clear()__	};this,method,clears,all,partitions,currently,residing,partially,in,memory,it,releases,all,memory,and,deletes,all,spilled,partitions,p,this,method,is,intended,for,a,hard,cleanup,in,the,case,that,the,join,is,aborted;protected,void,clear,partitions,for,int,i,this,partitions,being,built,size,1,i,0,i,final,hash,partition,bt,pt,p,this,partitions,being,built,get,i,try,p,clear,all,memory,this,available,memory,catch,exception,e,log,error,error,during,partition,cleanup,e,this,partitions,being,built,clear
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1405024514;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1405090423;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1409911022;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1411473593;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1412164980;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1415702894;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1418570573;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1420654570;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1426697080;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1433417242;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1436281304;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1438803435;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1438874079;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1438877580;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i)_		{_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1440607697;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i) {_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1441195975;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i) {_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1443528421;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i) {_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 	throws IOException;1445427423;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_	throws IOException_	{_		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i) {_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 		throws IOException;1453866659;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide Build side input._@param probeSide Probe side input._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_		throws IOException {__		open(buildSide, probeSide, false)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,open,build,side,probe,side,false
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 		throws IOException;1456186698;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide Build side input._@param probeSide Probe side input._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_		throws IOException {__		open(buildSide, probeSide, false)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,open,build,side,probe,side,false
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 		throws IOException;1456186722;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide Build side input._@param probeSide Probe side input._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_		throws IOException {__		open(buildSide, probeSide, false)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,open,build,side,probe,side,false
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 		throws IOException;1460472696;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide Build side input._@param probeSide Probe side input._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_		throws IOException {__		open(buildSide, probeSide, false)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,open,build,side,probe,side,false
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 		throws IOException;1460741894;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide Build side input._@param probeSide Probe side input._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_		throws IOException {__		open(buildSide, probeSide, false)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,open,build,side,probe,side,false
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide) 		throws IOException;1468441547;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide Build side input._@param probeSide Probe side input._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide, final MutableObjectIterator<PT> probeSide)_		throws IOException {__		open(buildSide, probeSide, false)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,throws,ioexception,open,build,side,probe,side,false
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1436281304;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1438803435;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1438874079;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1438877580;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1440607697;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1441195975;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1443528421;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1445427423;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1453866659;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1456186698;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1456186722;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1460472696;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1460741894;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> public static byte assignPartition(int bucket, byte numPartitions);1468441547;Assigns a partition to a bucket.__@param bucket The bucket to get the partition for._@param numPartitions The number of partitions._@return The partition for the bucket.;public static byte assignPartition(int bucket, byte numPartitions) {_		return (byte) (bucket % numPartitions)__	};assigns,a,partition,to,a,bucket,param,bucket,the,bucket,to,get,the,partition,for,param,num,partitions,the,number,of,partitions,return,the,partition,for,the,bucket;public,static,byte,assign,partition,int,bucket,byte,num,partitions,return,byte,bucket,num,partitions
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1405024514;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1405090423;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1409911022;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1411473593;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1412164980;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1415702894;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1418570573;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1420654570;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1426697080;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1433417242;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1436281304;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) (originalForwardPointer & 0xffffffff)__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,0xffffffff,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1438803435;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) originalForwardPointer__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1438874079;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) originalForwardPointer__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket,  			final int bucketInSegmentPos, final int hashCode, final long pointer) 	throws IOException;1438877580;@param p_@param bucket_@param bucketInSegmentPos_@param hashCode_@param pointer_@throws IOException;final void insertBucketEntry(final HashPartition<BT, PT> p, final MemorySegment bucket, _			final int bucketInSegmentPos, final int hashCode, final long pointer)_	throws IOException_	{_		_		final int count = bucket.getShort(bucketInSegmentPos + HEADER_COUNT_OFFSET)__		if (count < NUM_ENTRIES_PER_BUCKET)_		{_			_			bucket.putInt(bucketInSegmentPos + BUCKET_HEADER_LENGTH + (count * HASH_CODE_LEN), hashCode)_	_			bucket.putLong(bucketInSegmentPos + BUCKET_POINTER_START_OFFSET + (count * POINTER_LEN), pointer)_ _			bucket.putShort(bucketInSegmentPos + HEADER_COUNT_OFFSET, (short) (count + 1))_ _		}_		else {_			_			final long originalForwardPointer = bucket.getLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET)__			final long forwardForNewBucket__			_			if (originalForwardPointer != BUCKET_FORWARD_POINTER_NOT_SET) {_				_				_				final int overflowSegNum = (int) (originalForwardPointer >>> 32)__				final int segOffset = (int) originalForwardPointer__				final MemorySegment seg = p.overflowSegments[overflowSegNum]__				_				final short obCount = seg.getShort(segOffset + HEADER_COUNT_OFFSET)__				_				_				if (obCount < NUM_ENTRIES_PER_BUCKET) {_					_					seg.putInt(segOffset + BUCKET_HEADER_LENGTH + (obCount * HASH_CODE_LEN), hashCode)_	_					seg.putLong(segOffset + BUCKET_POINTER_START_OFFSET + (obCount * POINTER_LEN), pointer)_ _					seg.putShort(segOffset + HEADER_COUNT_OFFSET, (short) (obCount + 1))_ _					return__				}_				else {_					_					_					forwardForNewBucket = originalForwardPointer__				}_			}_			else {_				_				forwardForNewBucket = BUCKET_FORWARD_POINTER_NOT_SET__			}_			_			_			MemorySegment overflowSeg__			final int overflowBucketNum__			final int overflowBucketOffset__			_			_			_			if (p.nextOverflowBucket == 0) {_				_				overflowSeg = getNextBuffer()__				if (overflowSeg == null) {_					_					final int spilledPart = spillPartition()__					if (spilledPart == p.getPartitionNumber()) {_						_						return__					}_					overflowSeg = getNextBuffer()__					if (overflowSeg == null) {_						throw new RuntimeException("Bug in HybridHashJoin: No memory became available after spilling a partition.")__					}_				}_				overflowBucketOffset = 0__				overflowBucketNum = p.numOverflowSegments__				_				_				if (p.overflowSegments.length <= p.numOverflowSegments) {_					MemorySegment[] newSegsArray = new MemorySegment[p.overflowSegments.length * 2]__					System.arraycopy(p.overflowSegments, 0, newSegsArray, 0, p.overflowSegments.length)__					p.overflowSegments = newSegsArray__				}_				p.overflowSegments[p.numOverflowSegments] = overflowSeg__				p.numOverflowSegments++__			}_			else {_				_				overflowBucketNum = p.numOverflowSegments - 1__				overflowSeg = p.overflowSegments[overflowBucketNum]__				overflowBucketOffset = p.nextOverflowBucket << NUM_INTRA_BUCKET_BITS__			}_			_			_			_			p.nextOverflowBucket = (p.nextOverflowBucket == this.bucketsPerSegmentMask ? 0 : p.nextOverflowBucket + 1)__			_			_			_			_			overflowSeg.putLong(overflowBucketOffset + HEADER_FORWARD_OFFSET, forwardForNewBucket)__			final long pointerToNewBucket = (((long) overflowBucketNum) << 32) | ((long) overflowBucketOffset)__			bucket.putLong(bucketInSegmentPos + HEADER_FORWARD_OFFSET, pointerToNewBucket)__			_			_			overflowSeg.putInt(overflowBucketOffset + BUCKET_HEADER_LENGTH, hashCode)_	_			overflowSeg.putLong(overflowBucketOffset + BUCKET_POINTER_START_OFFSET, pointer)_ _			_			_			overflowSeg.putShort(overflowBucketOffset + HEADER_COUNT_OFFSET, (short) 1)_ _		}_	};param,p,param,bucket,param,bucket,in,segment,pos,param,hash,code,param,pointer,throws,ioexception;final,void,insert,bucket,entry,final,hash,partition,bt,pt,p,final,memory,segment,bucket,final,int,bucket,in,segment,pos,final,int,hash,code,final,long,pointer,throws,ioexception,final,int,count,bucket,get,short,bucket,in,segment,pos,if,count,bucket,put,int,bucket,in,segment,pos,count,hash,code,bucket,put,long,bucket,in,segment,pos,count,pointer,bucket,put,short,bucket,in,segment,pos,short,count,1,else,final,long,original,forward,pointer,bucket,get,long,bucket,in,segment,pos,final,long,forward,for,new,bucket,if,original,forward,pointer,final,int,overflow,seg,num,int,original,forward,pointer,32,final,int,seg,offset,int,original,forward,pointer,final,memory,segment,seg,p,overflow,segments,overflow,seg,num,final,short,ob,count,seg,get,short,seg,offset,if,ob,count,seg,put,int,seg,offset,ob,count,hash,code,seg,put,long,seg,offset,ob,count,pointer,seg,put,short,seg,offset,short,ob,count,1,return,else,forward,for,new,bucket,original,forward,pointer,else,forward,for,new,bucket,memory,segment,overflow,seg,final,int,overflow,bucket,num,final,int,overflow,bucket,offset,if,p,next,overflow,bucket,0,overflow,seg,get,next,buffer,if,overflow,seg,null,final,int,spilled,part,spill,partition,if,spilled,part,p,get,partition,number,return,overflow,seg,get,next,buffer,if,overflow,seg,null,throw,new,runtime,exception,bug,in,hybrid,hash,join,no,memory,became,available,after,spilling,a,partition,overflow,bucket,offset,0,overflow,bucket,num,p,num,overflow,segments,if,p,overflow,segments,length,p,num,overflow,segments,memory,segment,new,segs,array,new,memory,segment,p,overflow,segments,length,2,system,arraycopy,p,overflow,segments,0,new,segs,array,0,p,overflow,segments,length,p,overflow,segments,new,segs,array,p,overflow,segments,p,num,overflow,segments,overflow,seg,p,num,overflow,segments,else,overflow,bucket,num,p,num,overflow,segments,1,overflow,seg,p,overflow,segments,overflow,bucket,num,overflow,bucket,offset,p,next,overflow,bucket,p,next,overflow,bucket,p,next,overflow,bucket,this,buckets,per,segment,mask,0,p,next,overflow,bucket,1,overflow,seg,put,long,overflow,bucket,offset,forward,for,new,bucket,final,long,pointer,to,new,bucket,long,overflow,bucket,num,32,long,overflow,bucket,offset,bucket,put,long,bucket,in,segment,pos,pointer,to,new,bucket,overflow,seg,put,int,overflow,bucket,offset,hash,code,overflow,seg,put,long,overflow,bucket,offset,pointer,overflow,seg,put,short,overflow,bucket,offset,short,1
MutableHashTable -> public static final int hash(int code, int level);1405024514;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1405090423;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1409911022;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1411473593;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1412164980;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1415702894;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1418570573;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1420654570;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1426697080;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1433417242;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1436281304;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1438803435;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1438874079;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static final int hash(int code, int level);1438877580;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static final int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,final,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static int hash(int code, int level);1440607697;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static int hash(int code, int level);1441195975;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static int hash(int code, int level);1443528421;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static int hash(int code, int level);1445427423;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static int hash(int code, int level);1453866659;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static int hash(int code, int level);1456186698;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static int hash(int code, int level);1456186722;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static int hash(int code, int level);1460472696;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static int hash(int code, int level);1460741894;This function hashes an integer value. It is adapted from Bob Jenkins' website_<a href="http://www.burtleburtle.net/bob/hash/integer.html">http://www.burtleburtle.net/bob/hash/integer.html</a>._The hash function has the <i>full avalanche</i> property, meaning that every bit of the value to be hashed_affects every bit of the hash value.__@param code The integer to be hashed._@return The hash code for the integer.;public static int hash(int code, int level) {_		final int rotation = level * 11__		_		code = (code << rotation) | (code >>> -rotation)___		code = (code + 0x7ed55d16) + (code << 12)__		code = (code ^ 0xc761c23c) ^ (code >>> 19)__		code = (code + 0x165667b1) + (code << 5)__		code = (code + 0xd3a2646c) ^ (code << 9)__		code = (code + 0xfd7046c5) + (code << 3)__		code = (code ^ 0xb55a4f09) ^ (code >>> 16)__		return code >= 0 ? code : -(code + 1)__	};this,function,hashes,an,integer,value,it,is,adapted,from,bob,jenkins,website,a,href,http,www,burtleburtle,net,bob,hash,integer,html,http,www,burtleburtle,net,bob,hash,integer,html,a,the,hash,function,has,the,i,full,avalanche,i,property,meaning,that,every,bit,of,the,value,to,be,hashed,affects,every,bit,of,the,hash,value,param,code,the,integer,to,be,hashed,return,the,hash,code,for,the,integer;public,static,int,hash,int,code,int,level,final,int,rotation,level,11,code,code,rotation,code,rotation,code,code,0x7ed55d16,code,12,code,code,0xc761c23c,code,19,code,code,0x165667b1,code,5,code,code,0xd3a2646c,code,9,code,code,0xfd7046c5,code,3,code,code,0xb55a4f09,code,16,return,code,0,code,code,1
MutableHashTable -> public static int hash(int code, int level);1468441547;The level parameter is needed so that we can have different hash functions when we recursively apply_the partitioning, so that the working set eventually fits into memory.;public static int hash(int code, int level) {_		final int rotation = level * 11___		code = Integer.rotateLeft(code, rotation)___		return MathUtils.jenkinsHash(code)__	};the,level,parameter,is,needed,so,that,we,can,have,different,hash,functions,when,we,recursively,apply,the,partitioning,so,that,the,working,set,eventually,fits,into,memory;public,static,int,hash,int,code,int,level,final,int,rotation,level,11,code,integer,rotate,left,code,rotation,return,math,utils,jenkins,hash,code
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide, 		boolean buildOuterJoin) throws IOException;1453866659;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide      Build side input._@param probeSide      Probe side input._@param buildOuterJoin Whether outer join on build side._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide,_		boolean buildOuterJoin) throws IOException {__		this.buildSideOuterJoin = buildOuterJoin___		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i) {_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator, probedSet, buildOuterJoin)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,param,build,outer,join,whether,outer,join,on,build,side,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,boolean,build,outer,join,throws,ioexception,this,build,side,outer,join,build,outer,join,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator,probed,set,build,outer,join
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide, 		boolean buildOuterJoin) throws IOException;1456186698;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide      Build side input._@param probeSide      Probe side input._@param buildOuterJoin Whether outer join on build side._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide,_		boolean buildOuterJoin) throws IOException {__		this.buildSideOuterJoin = buildOuterJoin___		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i) {_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator, probedSet, buildOuterJoin)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,param,build,outer,join,whether,outer,join,on,build,side,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,boolean,build,outer,join,throws,ioexception,this,build,side,outer,join,build,outer,join,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator,probed,set,build,outer,join
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide, 		boolean buildOuterJoin) throws IOException;1456186722;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide      Build side input._@param probeSide      Probe side input._@param buildOuterJoin Whether outer join on build side._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide,_		boolean buildOuterJoin) throws IOException {__		this.buildSideOuterJoin = buildOuterJoin___		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i) {_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator, probedSet, buildOuterJoin)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,param,build,outer,join,whether,outer,join,on,build,side,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,boolean,build,outer,join,throws,ioexception,this,build,side,outer,join,build,outer,join,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator,probed,set,build,outer,join
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide, 		boolean buildOuterJoin) throws IOException;1460472696;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide      Build side input._@param probeSide      Probe side input._@param buildOuterJoin Whether outer join on build side._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide,_		boolean buildOuterJoin) throws IOException {__		this.buildSideOuterJoin = buildOuterJoin___		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i) {_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator, probedSet, buildOuterJoin)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,param,build,outer,join,whether,outer,join,on,build,side,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,boolean,build,outer,join,throws,ioexception,this,build,side,outer,join,build,outer,join,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator,probed,set,build,outer,join
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide, 		boolean buildOuterJoin) throws IOException;1460741894;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide      Build side input._@param probeSide      Probe side input._@param buildOuterJoin Whether outer join on build side._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide,_		boolean buildOuterJoin) throws IOException {__		this.buildSideOuterJoin = buildOuterJoin___		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i) {_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator, probedSet, buildOuterJoin)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,param,build,outer,join,whether,outer,join,on,build,side,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,boolean,build,outer,join,throws,ioexception,this,build,side,outer,join,build,outer,join,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator,probed,set,build,outer,join
MutableHashTable -> public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide, 		boolean buildOuterJoin) throws IOException;1468441547;Opens the hash join. This method reads the build-side input and constructs the initial_hash table, gradually spilling partitions that do not fit into memory.__@param buildSide      Build side input._@param probeSide      Probe side input._@param buildOuterJoin Whether outer join on build side._@throws IOException Thrown, if an I/O problem occurs while spilling a partition.;public void open(final MutableObjectIterator<BT> buildSide,	final MutableObjectIterator<PT> probeSide,_		boolean buildOuterJoin) throws IOException {__		this.buildSideOuterJoin = buildOuterJoin___		_		if (!this.closed.compareAndSet(true, false)) {_			throw new IllegalStateException("Hash Join cannot be opened, because it is currently not closed.")__		}_		_		_		for (int i = this.numWriteBehindBuffers_ i > 0_ --i) {_			this.writeBehindBuffers.add(this.availableMemory.remove(this.availableMemory.size() - 1))__		}_		_		this.currentRecursionDepth = 0__		buildInitialTable(buildSide)__		_		_		this.probeIterator = new ProbeIterator<PT>(probeSide, this.probeSideSerializer.createInstance())__		_		_		this.bucketIterator = new HashBucketIterator<BT, PT>(this.buildSideSerializer, this.recordComparator, probedSet, buildOuterJoin)__	};opens,the,hash,join,this,method,reads,the,build,side,input,and,constructs,the,initial,hash,table,gradually,spilling,partitions,that,do,not,fit,into,memory,param,build,side,build,side,input,param,probe,side,probe,side,input,param,build,outer,join,whether,outer,join,on,build,side,throws,ioexception,thrown,if,an,i,o,problem,occurs,while,spilling,a,partition;public,void,open,final,mutable,object,iterator,bt,build,side,final,mutable,object,iterator,pt,probe,side,boolean,build,outer,join,throws,ioexception,this,build,side,outer,join,build,outer,join,if,this,closed,compare,and,set,true,false,throw,new,illegal,state,exception,hash,join,cannot,be,opened,because,it,is,currently,not,closed,for,int,i,this,num,write,behind,buffers,i,0,i,this,write,behind,buffers,add,this,available,memory,remove,this,available,memory,size,1,this,current,recursion,depth,0,build,initial,table,build,side,this,probe,iterator,new,probe,iterator,pt,probe,side,this,probe,side,serializer,create,instance,this,bucket,iterator,new,hash,bucket,iterator,bt,pt,this,build,side,serializer,this,record,comparator,probed,set,build,outer,join
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextBucket();1453866659;Move to next bucket, return true while move to a on heap bucket, return false while move to a spilled bucket_or there is no more bucket.;private boolean moveToNextBucket() {_			scanCount++__			if (scanCount > totalBucketNumber - 1) {_				return false__			}_			_			final int bucketArrayPos = scanCount >> this.bucketsPerSegmentBits__			final int currentBucketInSegmentOffset = (scanCount & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__			MemorySegment currentBucket = this.buckets[bucketArrayPos]__			final int partitionNumber = currentBucket.get(currentBucketInSegmentOffset + HEADER_PARTITION_OFFSET)__			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__			if (p.isInMemory()) {_				setBucket(currentBucket, p.overflowSegments, p, currentBucketInSegmentOffset)__				return true__			} else {_				return false__			}_		};move,to,next,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,while,move,to,a,spilled,bucket,or,there,is,no,more,bucket;private,boolean,move,to,next,bucket,scan,count,if,scan,count,total,bucket,number,1,return,false,final,int,bucket,array,pos,scan,count,this,buckets,per,segment,bits,final,int,current,bucket,in,segment,offset,scan,count,this,buckets,per,segment,mask,memory,segment,current,bucket,this,buckets,bucket,array,pos,final,int,partition,number,current,bucket,get,current,bucket,in,segment,offset,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,if,p,is,in,memory,set,bucket,current,bucket,p,overflow,segments,p,current,bucket,in,segment,offset,return,true,else,return,false
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextBucket();1456186698;Move to next bucket, return true while move to a on heap bucket, return false while move to a spilled bucket_or there is no more bucket.;private boolean moveToNextBucket() {_			scanCount++__			if (scanCount > totalBucketNumber - 1) {_				return false__			}_			_			final int bucketArrayPos = scanCount >> this.bucketsPerSegmentBits__			final int currentBucketInSegmentOffset = (scanCount & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__			MemorySegment currentBucket = this.buckets[bucketArrayPos]__			final int partitionNumber = currentBucket.get(currentBucketInSegmentOffset + HEADER_PARTITION_OFFSET)__			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__			if (p.isInMemory()) {_				setBucket(currentBucket, p.overflowSegments, p, currentBucketInSegmentOffset)__				return true__			} else {_				return false__			}_		};move,to,next,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,while,move,to,a,spilled,bucket,or,there,is,no,more,bucket;private,boolean,move,to,next,bucket,scan,count,if,scan,count,total,bucket,number,1,return,false,final,int,bucket,array,pos,scan,count,this,buckets,per,segment,bits,final,int,current,bucket,in,segment,offset,scan,count,this,buckets,per,segment,mask,memory,segment,current,bucket,this,buckets,bucket,array,pos,final,int,partition,number,current,bucket,get,current,bucket,in,segment,offset,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,if,p,is,in,memory,set,bucket,current,bucket,p,overflow,segments,p,current,bucket,in,segment,offset,return,true,else,return,false
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextBucket();1456186722;Move to next bucket, return true while move to a on heap bucket, return false while move to a spilled bucket_or there is no more bucket.;private boolean moveToNextBucket() {_			scanCount++__			if (scanCount > totalBucketNumber - 1) {_				return false__			}_			_			final int bucketArrayPos = scanCount >> this.bucketsPerSegmentBits__			final int currentBucketInSegmentOffset = (scanCount & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__			MemorySegment currentBucket = this.buckets[bucketArrayPos]__			final int partitionNumber = currentBucket.get(currentBucketInSegmentOffset + HEADER_PARTITION_OFFSET)__			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__			if (p.isInMemory()) {_				setBucket(currentBucket, p.overflowSegments, p, currentBucketInSegmentOffset)__				return true__			} else {_				return false__			}_		};move,to,next,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,while,move,to,a,spilled,bucket,or,there,is,no,more,bucket;private,boolean,move,to,next,bucket,scan,count,if,scan,count,total,bucket,number,1,return,false,final,int,bucket,array,pos,scan,count,this,buckets,per,segment,bits,final,int,current,bucket,in,segment,offset,scan,count,this,buckets,per,segment,mask,memory,segment,current,bucket,this,buckets,bucket,array,pos,final,int,partition,number,current,bucket,get,current,bucket,in,segment,offset,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,if,p,is,in,memory,set,bucket,current,bucket,p,overflow,segments,p,current,bucket,in,segment,offset,return,true,else,return,false
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextBucket();1460472696;Move to next bucket, return true while move to a on heap bucket, return false while move to a spilled bucket_or there is no more bucket.;private boolean moveToNextBucket() {_			scanCount++__			if (scanCount > totalBucketNumber - 1) {_				return false__			}_			_			final int bucketArrayPos = scanCount >> this.bucketsPerSegmentBits__			final int currentBucketInSegmentOffset = (scanCount & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__			MemorySegment currentBucket = this.buckets[bucketArrayPos]__			final int partitionNumber = currentBucket.get(currentBucketInSegmentOffset + HEADER_PARTITION_OFFSET)__			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__			if (p.isInMemory()) {_				setBucket(currentBucket, p.overflowSegments, p, currentBucketInSegmentOffset)__				return true__			} else {_				return false__			}_		};move,to,next,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,while,move,to,a,spilled,bucket,or,there,is,no,more,bucket;private,boolean,move,to,next,bucket,scan,count,if,scan,count,total,bucket,number,1,return,false,final,int,bucket,array,pos,scan,count,this,buckets,per,segment,bits,final,int,current,bucket,in,segment,offset,scan,count,this,buckets,per,segment,mask,memory,segment,current,bucket,this,buckets,bucket,array,pos,final,int,partition,number,current,bucket,get,current,bucket,in,segment,offset,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,if,p,is,in,memory,set,bucket,current,bucket,p,overflow,segments,p,current,bucket,in,segment,offset,return,true,else,return,false
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextBucket();1460741894;Move to next bucket, return true while move to a on heap bucket, return false while move to a spilled bucket_or there is no more bucket.;private boolean moveToNextBucket() {_			scanCount++__			if (scanCount > totalBucketNumber - 1) {_				return false__			}_			_			final int bucketArrayPos = scanCount >> this.bucketsPerSegmentBits__			final int currentBucketInSegmentOffset = (scanCount & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__			MemorySegment currentBucket = this.buckets[bucketArrayPos]__			final int partitionNumber = currentBucket.get(currentBucketInSegmentOffset + HEADER_PARTITION_OFFSET)__			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__			if (p.isInMemory()) {_				setBucket(currentBucket, p.overflowSegments, p, currentBucketInSegmentOffset)__				return true__			} else {_				return false__			}_		};move,to,next,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,while,move,to,a,spilled,bucket,or,there,is,no,more,bucket;private,boolean,move,to,next,bucket,scan,count,if,scan,count,total,bucket,number,1,return,false,final,int,bucket,array,pos,scan,count,this,buckets,per,segment,bits,final,int,current,bucket,in,segment,offset,scan,count,this,buckets,per,segment,mask,memory,segment,current,bucket,this,buckets,bucket,array,pos,final,int,partition,number,current,bucket,get,current,bucket,in,segment,offset,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,if,p,is,in,memory,set,bucket,current,bucket,p,overflow,segments,p,current,bucket,in,segment,offset,return,true,else,return,false
MutableHashTable -> UnmatchedBuildIterator -> private boolean moveToNextBucket();1468441547;Move to next bucket, return true while move to a on heap bucket, return false while move to a spilled bucket_or there is no more bucket.;private boolean moveToNextBucket() {_			scanCount++__			if (scanCount > totalBucketNumber - 1) {_				return false__			}_			_			final int bucketArrayPos = scanCount >> this.bucketsPerSegmentBits__			final int currentBucketInSegmentOffset = (scanCount & this.bucketsPerSegmentMask) << NUM_INTRA_BUCKET_BITS__			MemorySegment currentBucket = this.buckets[bucketArrayPos]__			final int partitionNumber = currentBucket.get(currentBucketInSegmentOffset + HEADER_PARTITION_OFFSET)__			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(partitionNumber)__			if (p.isInMemory()) {_				setBucket(currentBucket, p.overflowSegments, p, currentBucketInSegmentOffset)__				return true__			} else {_				return false__			}_		};move,to,next,bucket,return,true,while,move,to,a,on,heap,bucket,return,false,while,move,to,a,spilled,bucket,or,there,is,no,more,bucket;private,boolean,move,to,next,bucket,scan,count,if,scan,count,total,bucket,number,1,return,false,final,int,bucket,array,pos,scan,count,this,buckets,per,segment,bits,final,int,current,bucket,in,segment,offset,scan,count,this,buckets,per,segment,mask,memory,segment,current,bucket,this,buckets,bucket,array,pos,final,int,partition,number,current,bucket,get,current,bucket,in,segment,offset,final,hash,partition,bt,pt,p,this,partitions,being,built,get,partition,number,if,p,is,in,memory,set,bucket,current,bucket,p,overflow,segments,p,current,bucket,in,segment,offset,return,true,else,return,false
