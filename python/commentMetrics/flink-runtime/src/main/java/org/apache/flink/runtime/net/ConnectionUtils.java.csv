# id;timestamp;commentText;codeText;commentWords;codeWords
ConnectionUtils -> private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy, 														InetSocketAddress targetAddress, 														boolean logging) throws IOException;1447771086;Try to find a local address which allows as to connect to the targetAddress using the given_strategy__@param strategy Depending on the strategy, the method will enumerate all interfaces, trying to connect_to the target address_@param targetAddress The address we try to connect to_@param logging Boolean indicating the logging verbosity_@return null if we could not find an address using this strategy, otherwise, the local address._@throws IOException;private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy,_														InetSocketAddress targetAddress,_														boolean logging) throws IOException_	{_		_		if (strategy == AddressDetectionState.LOCAL_HOST) {_			InetAddress localhostName = InetAddress.getLocalHost()___			if (tryToConnect(localhostName, targetAddress, strategy.getTimeout(), logging)) {_				LOG.debug("Using InetAddress.getLocalHost() immediately for the connecting address")__				_				return localhostName__			} else {_				return null__			}_		}__		final byte[] targetAddressBytes = targetAddress.getAddress().getAddress()___		_		Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces()__		while (e.hasMoreElements()) {__			NetworkInterface netInterface = e.nextElement()___			_			Enumeration<InetAddress> ee = netInterface.getInetAddresses()__			while (ee.hasMoreElements()) {_				InetAddress interfaceAddress = ee.nextElement()___				switch (strategy) {_					case ADDRESS:_						if (hasCommonPrefix(targetAddressBytes, interfaceAddress.getAddress())) {_							LOG.debug("Target address {} and local address {} share prefix - trying to connect.",_										targetAddress, interfaceAddress)___							if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_								return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__							}_						}_						break___					case FAST_CONNECT:_					case SLOW_CONNECT:_						LOG.debug("Trying to connect to {} from local address {} with timeout {}",_								targetAddress, interfaceAddress, strategy.getTimeout())___						if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_							return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__						}_						break___					case HEURISTIC:_						if (LOG.isDebugEnabled()) {_							LOG.debug("Checking address {} using heuristics: linkLocal: {} loopback: {}",_									interfaceAddress, interfaceAddress.isLinkLocalAddress(),_									interfaceAddress.isLoopbackAddress())__						}_						_						if (interfaceAddress instanceof Inet4Address && !interfaceAddress.isLinkLocalAddress() &&_								!interfaceAddress.isLoopbackAddress())_						{_							return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__						}_						break___					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			} _		} __		return null__	};try,to,find,a,local,address,which,allows,as,to,connect,to,the,target,address,using,the,given,strategy,param,strategy,depending,on,the,strategy,the,method,will,enumerate,all,interfaces,trying,to,connect,to,the,target,address,param,target,address,the,address,we,try,to,connect,to,param,logging,boolean,indicating,the,logging,verbosity,return,null,if,we,could,not,find,an,address,using,this,strategy,otherwise,the,local,address,throws,ioexception;private,static,inet,address,find,address,using,strategy,address,detection,state,strategy,inet,socket,address,target,address,boolean,logging,throws,ioexception,if,strategy,address,detection,state,inet,address,localhost,name,inet,address,get,local,host,if,try,to,connect,localhost,name,target,address,strategy,get,timeout,logging,log,debug,using,inet,address,get,local,host,immediately,for,the,connecting,address,return,localhost,name,else,return,null,final,byte,target,address,bytes,target,address,get,address,get,address,enumeration,network,interface,e,network,interface,get,network,interfaces,while,e,has,more,elements,network,interface,net,interface,e,next,element,enumeration,inet,address,ee,net,interface,get,inet,addresses,while,ee,has,more,elements,inet,address,interface,address,ee,next,element,switch,strategy,case,address,if,has,common,prefix,target,address,bytes,interface,address,get,address,log,debug,target,address,and,local,address,share,prefix,trying,to,connect,target,address,interface,address,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,case,log,debug,trying,to,connect,to,from,local,address,with,timeout,target,address,interface,address,strategy,get,timeout,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,heuristic,if,log,is,debug,enabled,log,debug,checking,address,using,heuristics,link,local,loopback,interface,address,interface,address,is,link,local,address,interface,address,is,loopback,address,if,interface,address,instanceof,inet4address,interface,address,is,link,local,address,interface,address,is,loopback,address,return,try,local,host,before,returning,interface,address,target,address,logging,break,default,throw,new,runtime,exception,unsupported,strategy,strategy,return,null
ConnectionUtils -> private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy, 														InetSocketAddress targetAddress, 														boolean logging) throws IOException;1457084088;Try to find a local address which allows as to connect to the targetAddress using the given_strategy__@param strategy Depending on the strategy, the method will enumerate all interfaces, trying to connect_to the target address_@param targetAddress The address we try to connect to_@param logging Boolean indicating the logging verbosity_@return null if we could not find an address using this strategy, otherwise, the local address._@throws IOException;private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy,_														InetSocketAddress targetAddress,_														boolean logging) throws IOException_	{_		_		if (strategy == AddressDetectionState.LOCAL_HOST) {_			InetAddress localhostName = InetAddress.getLocalHost()___			if (tryToConnect(localhostName, targetAddress, strategy.getTimeout(), logging)) {_				LOG.debug("Using InetAddress.getLocalHost() immediately for the connecting address")__				_				return localhostName__			} else {_				return null__			}_		}__		final byte[] targetAddressBytes = targetAddress.getAddress().getAddress()___		_		Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces()__		while (e.hasMoreElements()) {__			NetworkInterface netInterface = e.nextElement()___			_			Enumeration<InetAddress> ee = netInterface.getInetAddresses()__			while (ee.hasMoreElements()) {_				InetAddress interfaceAddress = ee.nextElement()___				switch (strategy) {_					case ADDRESS:_						if (hasCommonPrefix(targetAddressBytes, interfaceAddress.getAddress())) {_							LOG.debug("Target address {} and local address {} share prefix - trying to connect.",_										targetAddress, interfaceAddress)___							if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_								return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__							}_						}_						break___					case FAST_CONNECT:_					case SLOW_CONNECT:_						LOG.debug("Trying to connect to {} from local address {} with timeout {}",_								targetAddress, interfaceAddress, strategy.getTimeout())___						if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_							return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__						}_						break___					case HEURISTIC:_						if (LOG.isDebugEnabled()) {_							LOG.debug("Choosing InetAddress.getLocalHost() address as a heuristic.")__						}__						return InetAddress.getLocalHost()___					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			} _		} __		return null__	};try,to,find,a,local,address,which,allows,as,to,connect,to,the,target,address,using,the,given,strategy,param,strategy,depending,on,the,strategy,the,method,will,enumerate,all,interfaces,trying,to,connect,to,the,target,address,param,target,address,the,address,we,try,to,connect,to,param,logging,boolean,indicating,the,logging,verbosity,return,null,if,we,could,not,find,an,address,using,this,strategy,otherwise,the,local,address,throws,ioexception;private,static,inet,address,find,address,using,strategy,address,detection,state,strategy,inet,socket,address,target,address,boolean,logging,throws,ioexception,if,strategy,address,detection,state,inet,address,localhost,name,inet,address,get,local,host,if,try,to,connect,localhost,name,target,address,strategy,get,timeout,logging,log,debug,using,inet,address,get,local,host,immediately,for,the,connecting,address,return,localhost,name,else,return,null,final,byte,target,address,bytes,target,address,get,address,get,address,enumeration,network,interface,e,network,interface,get,network,interfaces,while,e,has,more,elements,network,interface,net,interface,e,next,element,enumeration,inet,address,ee,net,interface,get,inet,addresses,while,ee,has,more,elements,inet,address,interface,address,ee,next,element,switch,strategy,case,address,if,has,common,prefix,target,address,bytes,interface,address,get,address,log,debug,target,address,and,local,address,share,prefix,trying,to,connect,target,address,interface,address,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,case,log,debug,trying,to,connect,to,from,local,address,with,timeout,target,address,interface,address,strategy,get,timeout,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,heuristic,if,log,is,debug,enabled,log,debug,choosing,inet,address,get,local,host,address,as,a,heuristic,return,inet,address,get,local,host,default,throw,new,runtime,exception,unsupported,strategy,strategy,return,null
ConnectionUtils -> private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy, 														InetSocketAddress targetAddress, 														boolean logging) throws IOException;1463757966;Try to find a local address which allows as to connect to the targetAddress using the given_strategy__@param strategy Depending on the strategy, the method will enumerate all interfaces, trying to connect_to the target address_@param targetAddress The address we try to connect to_@param logging Boolean indicating the logging verbosity_@return null if we could not find an address using this strategy, otherwise, the local address._@throws IOException;private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy,_														InetSocketAddress targetAddress,_														boolean logging) throws IOException_	{_		_		if (strategy == AddressDetectionState.LOCAL_HOST) {_			InetAddress localhostName = InetAddress.getLocalHost()___			if (tryToConnect(localhostName, targetAddress, strategy.getTimeout(), logging)) {_				LOG.debug("Using InetAddress.getLocalHost() immediately for the connecting address")__				_				return localhostName__			} else {_				return null__			}_		}__		final InetAddress address = targetAddress.getAddress()__		if (address == null) {_			return null__		}_		final byte[] targetAddressBytes = address.getAddress()___		_		Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces()__		while (e.hasMoreElements()) {__			NetworkInterface netInterface = e.nextElement()___			_			Enumeration<InetAddress> ee = netInterface.getInetAddresses()__			while (ee.hasMoreElements()) {_				InetAddress interfaceAddress = ee.nextElement()___				switch (strategy) {_					case ADDRESS:_						if (hasCommonPrefix(targetAddressBytes, interfaceAddress.getAddress())) {_							LOG.debug("Target address {} and local address {} share prefix - trying to connect.",_										targetAddress, interfaceAddress)___							if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_								return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__							}_						}_						break___					case FAST_CONNECT:_					case SLOW_CONNECT:_						LOG.debug("Trying to connect to {} from local address {} with timeout {}",_								targetAddress, interfaceAddress, strategy.getTimeout())___						if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_							return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__						}_						break___					case HEURISTIC:_						if (LOG.isDebugEnabled()) {_							LOG.debug("Choosing InetAddress.getLocalHost() address as a heuristic.")__						}__						return InetAddress.getLocalHost()___					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			} _		} __		return null__	};try,to,find,a,local,address,which,allows,as,to,connect,to,the,target,address,using,the,given,strategy,param,strategy,depending,on,the,strategy,the,method,will,enumerate,all,interfaces,trying,to,connect,to,the,target,address,param,target,address,the,address,we,try,to,connect,to,param,logging,boolean,indicating,the,logging,verbosity,return,null,if,we,could,not,find,an,address,using,this,strategy,otherwise,the,local,address,throws,ioexception;private,static,inet,address,find,address,using,strategy,address,detection,state,strategy,inet,socket,address,target,address,boolean,logging,throws,ioexception,if,strategy,address,detection,state,inet,address,localhost,name,inet,address,get,local,host,if,try,to,connect,localhost,name,target,address,strategy,get,timeout,logging,log,debug,using,inet,address,get,local,host,immediately,for,the,connecting,address,return,localhost,name,else,return,null,final,inet,address,address,target,address,get,address,if,address,null,return,null,final,byte,target,address,bytes,address,get,address,enumeration,network,interface,e,network,interface,get,network,interfaces,while,e,has,more,elements,network,interface,net,interface,e,next,element,enumeration,inet,address,ee,net,interface,get,inet,addresses,while,ee,has,more,elements,inet,address,interface,address,ee,next,element,switch,strategy,case,address,if,has,common,prefix,target,address,bytes,interface,address,get,address,log,debug,target,address,and,local,address,share,prefix,trying,to,connect,target,address,interface,address,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,case,log,debug,trying,to,connect,to,from,local,address,with,timeout,target,address,interface,address,strategy,get,timeout,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,heuristic,if,log,is,debug,enabled,log,debug,choosing,inet,address,get,local,host,address,as,a,heuristic,return,inet,address,get,local,host,default,throw,new,runtime,exception,unsupported,strategy,strategy,return,null
ConnectionUtils -> private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy, 														InetSocketAddress targetAddress, 														boolean logging) throws IOException;1472226799;Try to find a local address which allows as to connect to the targetAddress using the given_strategy__@param strategy Depending on the strategy, the method will enumerate all interfaces, trying to connect_to the target address_@param targetAddress The address we try to connect to_@param logging Boolean indicating the logging verbosity_@return null if we could not find an address using this strategy, otherwise, the local address._@throws IOException;private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy,_														InetSocketAddress targetAddress,_														boolean logging) throws IOException_	{_		_		if (strategy == AddressDetectionState.LOCAL_HOST) {_			InetAddress localhostName__			try {_				localhostName = InetAddress.getLocalHost()__			} catch (UnknownHostException uhe) {_				LOG.warn("Could not resolve local hostname to an IP address: {}", uhe.getMessage())__				return null__			}__			if (tryToConnect(localhostName, targetAddress, strategy.getTimeout(), logging)) {_				LOG.debug("Using InetAddress.getLocalHost() immediately for the connecting address")__				_				return localhostName__			} else {_				return null__			}_		}__		final InetAddress address = targetAddress.getAddress()__		if (address == null) {_			return null__		}_		final byte[] targetAddressBytes = address.getAddress()___		_		Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces()__		while (e.hasMoreElements()) {__			NetworkInterface netInterface = e.nextElement()___			_			Enumeration<InetAddress> ee = netInterface.getInetAddresses()__			while (ee.hasMoreElements()) {_				InetAddress interfaceAddress = ee.nextElement()___				switch (strategy) {_					case ADDRESS:_						if (hasCommonPrefix(targetAddressBytes, interfaceAddress.getAddress())) {_							LOG.debug("Target address {} and local address {} share prefix - trying to connect.",_										targetAddress, interfaceAddress)___							if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_								return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__							}_						}_						break___					case FAST_CONNECT:_					case SLOW_CONNECT:_						LOG.debug("Trying to connect to {} from local address {} with timeout {}",_								targetAddress, interfaceAddress, strategy.getTimeout())___						if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_							return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__						}_						break___					case HEURISTIC:_						if (LOG.isDebugEnabled()) {_							LOG.debug("Choosing InetAddress.getLocalHost() address as a heuristic.")__						}__						return InetAddress.getLocalHost()___					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			} _		} __		return null__	};try,to,find,a,local,address,which,allows,as,to,connect,to,the,target,address,using,the,given,strategy,param,strategy,depending,on,the,strategy,the,method,will,enumerate,all,interfaces,trying,to,connect,to,the,target,address,param,target,address,the,address,we,try,to,connect,to,param,logging,boolean,indicating,the,logging,verbosity,return,null,if,we,could,not,find,an,address,using,this,strategy,otherwise,the,local,address,throws,ioexception;private,static,inet,address,find,address,using,strategy,address,detection,state,strategy,inet,socket,address,target,address,boolean,logging,throws,ioexception,if,strategy,address,detection,state,inet,address,localhost,name,try,localhost,name,inet,address,get,local,host,catch,unknown,host,exception,uhe,log,warn,could,not,resolve,local,hostname,to,an,ip,address,uhe,get,message,return,null,if,try,to,connect,localhost,name,target,address,strategy,get,timeout,logging,log,debug,using,inet,address,get,local,host,immediately,for,the,connecting,address,return,localhost,name,else,return,null,final,inet,address,address,target,address,get,address,if,address,null,return,null,final,byte,target,address,bytes,address,get,address,enumeration,network,interface,e,network,interface,get,network,interfaces,while,e,has,more,elements,network,interface,net,interface,e,next,element,enumeration,inet,address,ee,net,interface,get,inet,addresses,while,ee,has,more,elements,inet,address,interface,address,ee,next,element,switch,strategy,case,address,if,has,common,prefix,target,address,bytes,interface,address,get,address,log,debug,target,address,and,local,address,share,prefix,trying,to,connect,target,address,interface,address,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,case,log,debug,trying,to,connect,to,from,local,address,with,timeout,target,address,interface,address,strategy,get,timeout,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,heuristic,if,log,is,debug,enabled,log,debug,choosing,inet,address,get,local,host,address,as,a,heuristic,return,inet,address,get,local,host,default,throw,new,runtime,exception,unsupported,strategy,strategy,return,null
ConnectionUtils -> private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy, 														InetSocketAddress targetAddress, 														boolean logging) throws IOException;1484160227;Try to find a local address which allows as to connect to the targetAddress using the given_strategy__@param strategy Depending on the strategy, the method will enumerate all interfaces, trying to connect_to the target address_@param targetAddress The address we try to connect to_@param logging Boolean indicating the logging verbosity_@return null if we could not find an address using this strategy, otherwise, the local address._@throws IOException;private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy,_														InetSocketAddress targetAddress,_														boolean logging) throws IOException_	{_		_		if (strategy == AddressDetectionState.LOCAL_HOST) {_			InetAddress localhostName__			try {_				localhostName = InetAddress.getLocalHost()__			} catch (UnknownHostException uhe) {_				LOG.warn("Could not resolve local hostname to an IP address: {}", uhe.getMessage())__				return null__			}__			if (tryToConnect(localhostName, targetAddress, strategy.getTimeout(), logging)) {_				LOG.debug("Using InetAddress.getLocalHost() immediately for the connecting address")__				_				return localhostName__			} else {_				return null__			}_		}__		final InetAddress address = targetAddress.getAddress()__		if (address == null) {_			return null__		}_		final byte[] targetAddressBytes = address.getAddress()___		_		Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces()__		while (e.hasMoreElements()) {__			NetworkInterface netInterface = e.nextElement()___			_			Enumeration<InetAddress> ee = netInterface.getInetAddresses()__			while (ee.hasMoreElements()) {_				InetAddress interfaceAddress = ee.nextElement()___				switch (strategy) {_					case ADDRESS:_						if (hasCommonPrefix(targetAddressBytes, interfaceAddress.getAddress())) {_							LOG.debug("Target address {} and local address {} share prefix - trying to connect.",_										targetAddress, interfaceAddress)___							if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_								return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__							}_						}_						break___					case FAST_CONNECT:_					case SLOW_CONNECT:_						LOG.debug("Trying to connect to {} from local address {} with timeout {}",_								targetAddress, interfaceAddress, strategy.getTimeout())___						if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_							return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__						}_						break___					case HEURISTIC:_						if (LOG.isDebugEnabled()) {_							LOG.debug("Choosing InetAddress.getLocalHost() address as a heuristic.")__						}__						return InetAddress.getLocalHost()___					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			} _		} __		return null__	};try,to,find,a,local,address,which,allows,as,to,connect,to,the,target,address,using,the,given,strategy,param,strategy,depending,on,the,strategy,the,method,will,enumerate,all,interfaces,trying,to,connect,to,the,target,address,param,target,address,the,address,we,try,to,connect,to,param,logging,boolean,indicating,the,logging,verbosity,return,null,if,we,could,not,find,an,address,using,this,strategy,otherwise,the,local,address,throws,ioexception;private,static,inet,address,find,address,using,strategy,address,detection,state,strategy,inet,socket,address,target,address,boolean,logging,throws,ioexception,if,strategy,address,detection,state,inet,address,localhost,name,try,localhost,name,inet,address,get,local,host,catch,unknown,host,exception,uhe,log,warn,could,not,resolve,local,hostname,to,an,ip,address,uhe,get,message,return,null,if,try,to,connect,localhost,name,target,address,strategy,get,timeout,logging,log,debug,using,inet,address,get,local,host,immediately,for,the,connecting,address,return,localhost,name,else,return,null,final,inet,address,address,target,address,get,address,if,address,null,return,null,final,byte,target,address,bytes,address,get,address,enumeration,network,interface,e,network,interface,get,network,interfaces,while,e,has,more,elements,network,interface,net,interface,e,next,element,enumeration,inet,address,ee,net,interface,get,inet,addresses,while,ee,has,more,elements,inet,address,interface,address,ee,next,element,switch,strategy,case,address,if,has,common,prefix,target,address,bytes,interface,address,get,address,log,debug,target,address,and,local,address,share,prefix,trying,to,connect,target,address,interface,address,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,case,log,debug,trying,to,connect,to,from,local,address,with,timeout,target,address,interface,address,strategy,get,timeout,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,heuristic,if,log,is,debug,enabled,log,debug,choosing,inet,address,get,local,host,address,as,a,heuristic,return,inet,address,get,local,host,default,throw,new,runtime,exception,unsupported,strategy,strategy,return,null
ConnectionUtils -> private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy, 														InetSocketAddress targetAddress, 														boolean logging) throws IOException;1499164413;Try to find a local address which allows as to connect to the targetAddress using the given_strategy.__@param strategy Depending on the strategy, the method will enumerate all interfaces, trying to connect_to the target address_@param targetAddress The address we try to connect to_@param logging Boolean indicating the logging verbosity_@return null if we could not find an address using this strategy, otherwise, the local address._@throws IOException;private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy,_														InetSocketAddress targetAddress,_														boolean logging) throws IOException {_		_		if (strategy == AddressDetectionState.LOCAL_HOST) {_			InetAddress localhostName__			try {_				localhostName = InetAddress.getLocalHost()__			} catch (UnknownHostException uhe) {_				LOG.warn("Could not resolve local hostname to an IP address: {}", uhe.getMessage())__				return null__			}__			if (tryToConnect(localhostName, targetAddress, strategy.getTimeout(), logging)) {_				LOG.debug("Using InetAddress.getLocalHost() immediately for the connecting address")__				_				return localhostName__			} else {_				return null__			}_		}__		final InetAddress address = targetAddress.getAddress()__		if (address == null) {_			return null__		}_		final byte[] targetAddressBytes = address.getAddress()___		_		Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces()__		while (e.hasMoreElements()) {__			NetworkInterface netInterface = e.nextElement()___			_			Enumeration<InetAddress> ee = netInterface.getInetAddresses()__			while (ee.hasMoreElements()) {_				InetAddress interfaceAddress = ee.nextElement()___				switch (strategy) {_					case ADDRESS:_						if (hasCommonPrefix(targetAddressBytes, interfaceAddress.getAddress())) {_							LOG.debug("Target address {} and local address {} share prefix - trying to connect.",_										targetAddress, interfaceAddress)___							if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_								return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__							}_						}_						break___					case FAST_CONNECT:_					case SLOW_CONNECT:_						LOG.debug("Trying to connect to {} from local address {} with timeout {}",_								targetAddress, interfaceAddress, strategy.getTimeout())___						if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_							return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__						}_						break___					case HEURISTIC:_						if (LOG.isDebugEnabled()) {_							LOG.debug("Choosing InetAddress.getLocalHost() address as a heuristic.")__						}__						return InetAddress.getLocalHost()___					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			} _		} __		return null__	};try,to,find,a,local,address,which,allows,as,to,connect,to,the,target,address,using,the,given,strategy,param,strategy,depending,on,the,strategy,the,method,will,enumerate,all,interfaces,trying,to,connect,to,the,target,address,param,target,address,the,address,we,try,to,connect,to,param,logging,boolean,indicating,the,logging,verbosity,return,null,if,we,could,not,find,an,address,using,this,strategy,otherwise,the,local,address,throws,ioexception;private,static,inet,address,find,address,using,strategy,address,detection,state,strategy,inet,socket,address,target,address,boolean,logging,throws,ioexception,if,strategy,address,detection,state,inet,address,localhost,name,try,localhost,name,inet,address,get,local,host,catch,unknown,host,exception,uhe,log,warn,could,not,resolve,local,hostname,to,an,ip,address,uhe,get,message,return,null,if,try,to,connect,localhost,name,target,address,strategy,get,timeout,logging,log,debug,using,inet,address,get,local,host,immediately,for,the,connecting,address,return,localhost,name,else,return,null,final,inet,address,address,target,address,get,address,if,address,null,return,null,final,byte,target,address,bytes,address,get,address,enumeration,network,interface,e,network,interface,get,network,interfaces,while,e,has,more,elements,network,interface,net,interface,e,next,element,enumeration,inet,address,ee,net,interface,get,inet,addresses,while,ee,has,more,elements,inet,address,interface,address,ee,next,element,switch,strategy,case,address,if,has,common,prefix,target,address,bytes,interface,address,get,address,log,debug,target,address,and,local,address,share,prefix,trying,to,connect,target,address,interface,address,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,case,log,debug,trying,to,connect,to,from,local,address,with,timeout,target,address,interface,address,strategy,get,timeout,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,heuristic,if,log,is,debug,enabled,log,debug,choosing,inet,address,get,local,host,address,as,a,heuristic,return,inet,address,get,local,host,default,throw,new,runtime,exception,unsupported,strategy,strategy,return,null
ConnectionUtils -> private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy, 														InetSocketAddress targetAddress, 														boolean logging) throws IOException;1516028608;Try to find a local address which allows as to connect to the targetAddress using the given_strategy.__@param strategy Depending on the strategy, the method will enumerate all interfaces, trying to connect_to the target address_@param targetAddress The address we try to connect to_@param logging Boolean indicating the logging verbosity_@return null if we could not find an address using this strategy, otherwise, the local address._@throws IOException;private static InetAddress findAddressUsingStrategy(AddressDetectionState strategy,_														InetSocketAddress targetAddress,_														boolean logging) throws IOException {_		_		if (strategy == AddressDetectionState.LOCAL_HOST) {_			InetAddress localhostName__			try {_				localhostName = InetAddress.getLocalHost()__			} catch (UnknownHostException uhe) {_				LOG.warn("Could not resolve local hostname to an IP address: {}", uhe.getMessage())__				return null__			}__			if (tryToConnect(localhostName, targetAddress, strategy.getTimeout(), logging)) {_				LOG.debug("Using InetAddress.getLocalHost() immediately for the connecting address")__				_				return localhostName__			} else {_				return null__			}_		}__		final InetAddress address = targetAddress.getAddress()__		if (address == null) {_			return null__		}_		final byte[] targetAddressBytes = address.getAddress()___		_		Enumeration<NetworkInterface> e = NetworkInterface.getNetworkInterfaces()__		while (e.hasMoreElements()) {__			NetworkInterface netInterface = e.nextElement()___			_			Enumeration<InetAddress> ee = netInterface.getInetAddresses()__			while (ee.hasMoreElements()) {_				InetAddress interfaceAddress = ee.nextElement()___				switch (strategy) {_					case ADDRESS:_						if (hasCommonPrefix(targetAddressBytes, interfaceAddress.getAddress())) {_							LOG.debug("Target address {} and local address {} share prefix - trying to connect.",_										targetAddress, interfaceAddress)___							if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_								return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__							}_						}_						break___					case FAST_CONNECT:_					case SLOW_CONNECT:_						LOG.debug("Trying to connect to {} from local address {} with timeout {}",_								targetAddress, interfaceAddress, strategy.getTimeout())___						if (tryToConnect(interfaceAddress, targetAddress, strategy.getTimeout(), logging)) {_							return tryLocalHostBeforeReturning(interfaceAddress, targetAddress, logging)__						}_						break___					case HEURISTIC:_						if (LOG.isDebugEnabled()) {_							LOG.debug("Choosing InetAddress.getLocalHost() address as a heuristic.")__						}__						return InetAddress.getLocalHost()___					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			} _		} __		return null__	};try,to,find,a,local,address,which,allows,as,to,connect,to,the,target,address,using,the,given,strategy,param,strategy,depending,on,the,strategy,the,method,will,enumerate,all,interfaces,trying,to,connect,to,the,target,address,param,target,address,the,address,we,try,to,connect,to,param,logging,boolean,indicating,the,logging,verbosity,return,null,if,we,could,not,find,an,address,using,this,strategy,otherwise,the,local,address,throws,ioexception;private,static,inet,address,find,address,using,strategy,address,detection,state,strategy,inet,socket,address,target,address,boolean,logging,throws,ioexception,if,strategy,address,detection,state,inet,address,localhost,name,try,localhost,name,inet,address,get,local,host,catch,unknown,host,exception,uhe,log,warn,could,not,resolve,local,hostname,to,an,ip,address,uhe,get,message,return,null,if,try,to,connect,localhost,name,target,address,strategy,get,timeout,logging,log,debug,using,inet,address,get,local,host,immediately,for,the,connecting,address,return,localhost,name,else,return,null,final,inet,address,address,target,address,get,address,if,address,null,return,null,final,byte,target,address,bytes,address,get,address,enumeration,network,interface,e,network,interface,get,network,interfaces,while,e,has,more,elements,network,interface,net,interface,e,next,element,enumeration,inet,address,ee,net,interface,get,inet,addresses,while,ee,has,more,elements,inet,address,interface,address,ee,next,element,switch,strategy,case,address,if,has,common,prefix,target,address,bytes,interface,address,get,address,log,debug,target,address,and,local,address,share,prefix,trying,to,connect,target,address,interface,address,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,case,log,debug,trying,to,connect,to,from,local,address,with,timeout,target,address,interface,address,strategy,get,timeout,if,try,to,connect,interface,address,target,address,strategy,get,timeout,logging,return,try,local,host,before,returning,interface,address,target,address,logging,break,case,heuristic,if,log,is,debug,enabled,log,debug,choosing,inet,address,get,local,host,address,as,a,heuristic,return,inet,address,get,local,host,default,throw,new,runtime,exception,unsupported,strategy,strategy,return,null
ConnectionUtils -> public static InetAddress findConnectingAddress(InetSocketAddress targetAddress, 							long maxWaitMillis, long startLoggingAfter) throws IOException;1443682795;Finds the local network address from which this machine can connect to the target_address. This method tries to establish a proper network connection to the_given target, so it only succeeds if the target socket address actually accepts_connections. The method tries various strategies multiple times and uses an exponential_backoff timer between tries._<p>_If no connection attempt was successful after the given maximum time, the method_will choose some address based on heuristics (excluding link-local and loopback addresses.)_<p>_This method will initially not log on info level (to not flood the log while the_backoff time is still very low). It will start logging after a certain time_has passes.__@param targetAddress The address that the method tries to connect to._@param maxWaitMillis The maximum time that this method tries to connect, before falling_back to the heuristics._@param startLoggingAfter The time after which the method will log on INFO level.;public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,_							long maxWaitMillis, long startLoggingAfter) throws IOException_	{_		if (targetAddress == null) {_			throw new NullPointerException("targetAddress must not be null")__		}_		if (maxWaitMillis <= 0) {_			throw new IllegalArgumentException("Max wait time must be positive")__		}__		final long startTime = System.currentTimeMillis()___		long currentSleepTime = MIN_SLEEP_TIME__		long elapsedTime = 0___		_		while (elapsedTime < maxWaitMillis) {_			AddressDetectionState strategy = AddressDetectionState.LOCAL_HOST___			boolean logging = elapsedTime >= startLoggingAfter__			if (logging) {_				LOG.info("Trying to connect to " + targetAddress)__			}_			_			do {_				InetAddress address = findAddressUsingStrategy(strategy, targetAddress, logging)__				if (address != null) {_					return address__				}__				_				switch (strategy) {_					case LOCAL_HOST:_						strategy = AddressDetectionState.ADDRESS__						break__					case ADDRESS:_						strategy = AddressDetectionState.FAST_CONNECT__						break__					case FAST_CONNECT:_						strategy = AddressDetectionState.SLOW_CONNECT__						break__					case SLOW_CONNECT:_						strategy = null__						break__					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			}_			while (strategy != null)___			_			_			elapsedTime = System.currentTimeMillis() - startTime___			long toWait = Math.min(maxWaitMillis - elapsedTime, currentSleepTime)__			if (toWait > 0) {_				if (logging) {_					LOG.info("Could not connect. Waiting for {} msecs before next attempt", toWait)__				} else {_					LOG.debug("Could not connect. Waiting for {} msecs before next attempt", toWait)__				}__				try {_					Thread.sleep(toWait)__				}_				catch (InterruptedException e) {_					throw new IOException("Connection attempts have been interrupted.")__				}_			}__			_			currentSleepTime = Math.min(2 * currentSleepTime, MAX_SLEEP_TIME)__		}__		_		LOG.warn("Could not connect to {}. Selecting a local address using heuristics.", targetAddress)__		InetAddress heuristic = findAddressUsingStrategy(AddressDetectionState.HEURISTIC, targetAddress, true)__		if (heuristic != null) {_			return heuristic__		}_		else {_			LOG.warn("Could not find any IPv4 address that is not loopback or link-local. Using localhost address.")__			return InetAddress.getLocalHost()__		}_	};finds,the,local,network,address,from,which,this,machine,can,connect,to,the,target,address,this,method,tries,to,establish,a,proper,network,connection,to,the,given,target,so,it,only,succeeds,if,the,target,socket,address,actually,accepts,connections,the,method,tries,various,strategies,multiple,times,and,uses,an,exponential,backoff,timer,between,tries,p,if,no,connection,attempt,was,successful,after,the,given,maximum,time,the,method,will,choose,some,address,based,on,heuristics,excluding,link,local,and,loopback,addresses,p,this,method,will,initially,not,log,on,info,level,to,not,flood,the,log,while,the,backoff,time,is,still,very,low,it,will,start,logging,after,a,certain,time,has,passes,param,target,address,the,address,that,the,method,tries,to,connect,to,param,max,wait,millis,the,maximum,time,that,this,method,tries,to,connect,before,falling,back,to,the,heuristics,param,start,logging,after,the,time,after,which,the,method,will,log,on,info,level;public,static,inet,address,find,connecting,address,inet,socket,address,target,address,long,max,wait,millis,long,start,logging,after,throws,ioexception,if,target,address,null,throw,new,null,pointer,exception,target,address,must,not,be,null,if,max,wait,millis,0,throw,new,illegal,argument,exception,max,wait,time,must,be,positive,final,long,start,time,system,current,time,millis,long,current,sleep,time,long,elapsed,time,0,while,elapsed,time,max,wait,millis,address,detection,state,strategy,address,detection,state,boolean,logging,elapsed,time,start,logging,after,if,logging,log,info,trying,to,connect,to,target,address,do,inet,address,address,find,address,using,strategy,strategy,target,address,logging,if,address,null,return,address,switch,strategy,case,strategy,address,detection,state,address,break,case,address,strategy,address,detection,state,break,case,strategy,address,detection,state,break,case,strategy,null,break,default,throw,new,runtime,exception,unsupported,strategy,strategy,while,strategy,null,elapsed,time,system,current,time,millis,start,time,long,to,wait,math,min,max,wait,millis,elapsed,time,current,sleep,time,if,to,wait,0,if,logging,log,info,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,else,log,debug,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,try,thread,sleep,to,wait,catch,interrupted,exception,e,throw,new,ioexception,connection,attempts,have,been,interrupted,current,sleep,time,math,min,2,current,sleep,time,log,warn,could,not,connect,to,selecting,a,local,address,using,heuristics,target,address,inet,address,heuristic,find,address,using,strategy,address,detection,state,heuristic,target,address,true,if,heuristic,null,return,heuristic,else,log,warn,could,not,find,any,ipv4,address,that,is,not,loopback,or,link,local,using,localhost,address,return,inet,address,get,local,host
ConnectionUtils -> public static InetAddress findConnectingAddress(InetSocketAddress targetAddress, 							long maxWaitMillis, long startLoggingAfter) throws IOException;1443682796;Finds the local network address from which this machine can connect to the target_address. This method tries to establish a proper network connection to the_given target, so it only succeeds if the target socket address actually accepts_connections. The method tries various strategies multiple times and uses an exponential_backoff timer between tries._<p>_If no connection attempt was successful after the given maximum time, the method_will choose some address based on heuristics (excluding link-local and loopback addresses.)_<p>_This method will initially not log on info level (to not flood the log while the_backoff time is still very low). It will start logging after a certain time_has passes.__@param targetAddress The address that the method tries to connect to._@param maxWaitMillis The maximum time that this method tries to connect, before falling_back to the heuristics._@param startLoggingAfter The time after which the method will log on INFO level.;public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,_							long maxWaitMillis, long startLoggingAfter) throws IOException_	{_		if (targetAddress == null) {_			throw new NullPointerException("targetAddress must not be null")__		}_		if (maxWaitMillis <= 0) {_			throw new IllegalArgumentException("Max wait time must be positive")__		}__		final long startTime = System.currentTimeMillis()___		long currentSleepTime = MIN_SLEEP_TIME__		long elapsedTime = 0___		_		while (elapsedTime < maxWaitMillis) {_			AddressDetectionState strategy = AddressDetectionState.LOCAL_HOST___			boolean logging = elapsedTime >= startLoggingAfter__			if (logging) {_				LOG.info("Trying to connect to " + targetAddress)__			}_			_			do {_				InetAddress address = findAddressUsingStrategy(strategy, targetAddress, logging)__				if (address != null) {_					return address__				}__				_				switch (strategy) {_					case LOCAL_HOST:_						strategy = AddressDetectionState.ADDRESS__						break__					case ADDRESS:_						strategy = AddressDetectionState.FAST_CONNECT__						break__					case FAST_CONNECT:_						strategy = AddressDetectionState.SLOW_CONNECT__						break__					case SLOW_CONNECT:_						strategy = null__						break__					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			}_			while (strategy != null)___			_			_			elapsedTime = System.currentTimeMillis() - startTime___			long toWait = Math.min(maxWaitMillis - elapsedTime, currentSleepTime)__			if (toWait > 0) {_				if (logging) {_					LOG.info("Could not connect. Waiting for {} msecs before next attempt", toWait)__				} else {_					LOG.debug("Could not connect. Waiting for {} msecs before next attempt", toWait)__				}__				try {_					Thread.sleep(toWait)__				}_				catch (InterruptedException e) {_					throw new IOException("Connection attempts have been interrupted.")__				}_			}__			_			currentSleepTime = Math.min(2 * currentSleepTime, MAX_SLEEP_TIME)__		}__		_		LOG.warn("Could not connect to {}. Selecting a local address using heuristics.", targetAddress)__		InetAddress heuristic = findAddressUsingStrategy(AddressDetectionState.HEURISTIC, targetAddress, true)__		if (heuristic != null) {_			return heuristic__		}_		else {_			LOG.warn("Could not find any IPv4 address that is not loopback or link-local. Using localhost address.")__			return InetAddress.getLocalHost()__		}_	};finds,the,local,network,address,from,which,this,machine,can,connect,to,the,target,address,this,method,tries,to,establish,a,proper,network,connection,to,the,given,target,so,it,only,succeeds,if,the,target,socket,address,actually,accepts,connections,the,method,tries,various,strategies,multiple,times,and,uses,an,exponential,backoff,timer,between,tries,p,if,no,connection,attempt,was,successful,after,the,given,maximum,time,the,method,will,choose,some,address,based,on,heuristics,excluding,link,local,and,loopback,addresses,p,this,method,will,initially,not,log,on,info,level,to,not,flood,the,log,while,the,backoff,time,is,still,very,low,it,will,start,logging,after,a,certain,time,has,passes,param,target,address,the,address,that,the,method,tries,to,connect,to,param,max,wait,millis,the,maximum,time,that,this,method,tries,to,connect,before,falling,back,to,the,heuristics,param,start,logging,after,the,time,after,which,the,method,will,log,on,info,level;public,static,inet,address,find,connecting,address,inet,socket,address,target,address,long,max,wait,millis,long,start,logging,after,throws,ioexception,if,target,address,null,throw,new,null,pointer,exception,target,address,must,not,be,null,if,max,wait,millis,0,throw,new,illegal,argument,exception,max,wait,time,must,be,positive,final,long,start,time,system,current,time,millis,long,current,sleep,time,long,elapsed,time,0,while,elapsed,time,max,wait,millis,address,detection,state,strategy,address,detection,state,boolean,logging,elapsed,time,start,logging,after,if,logging,log,info,trying,to,connect,to,target,address,do,inet,address,address,find,address,using,strategy,strategy,target,address,logging,if,address,null,return,address,switch,strategy,case,strategy,address,detection,state,address,break,case,address,strategy,address,detection,state,break,case,strategy,address,detection,state,break,case,strategy,null,break,default,throw,new,runtime,exception,unsupported,strategy,strategy,while,strategy,null,elapsed,time,system,current,time,millis,start,time,long,to,wait,math,min,max,wait,millis,elapsed,time,current,sleep,time,if,to,wait,0,if,logging,log,info,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,else,log,debug,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,try,thread,sleep,to,wait,catch,interrupted,exception,e,throw,new,ioexception,connection,attempts,have,been,interrupted,current,sleep,time,math,min,2,current,sleep,time,log,warn,could,not,connect,to,selecting,a,local,address,using,heuristics,target,address,inet,address,heuristic,find,address,using,strategy,address,detection,state,heuristic,target,address,true,if,heuristic,null,return,heuristic,else,log,warn,could,not,find,any,ipv4,address,that,is,not,loopback,or,link,local,using,localhost,address,return,inet,address,get,local,host
ConnectionUtils -> public static InetAddress findConnectingAddress(InetSocketAddress targetAddress, 							long maxWaitMillis, long startLoggingAfter) throws IOException;1447771086;Finds the local network address from which this machine can connect to the target_address. This method tries to establish a proper network connection to the_given target, so it only succeeds if the target socket address actually accepts_connections. The method tries various strategies multiple times and uses an exponential_backoff timer between tries._<p>_If no connection attempt was successful after the given maximum time, the method_will choose some address based on heuristics (excluding link-local and loopback addresses.)_<p>_This method will initially not log on info level (to not flood the log while the_backoff time is still very low). It will start logging after a certain time_has passes.__@param targetAddress The address that the method tries to connect to._@param maxWaitMillis The maximum time that this method tries to connect, before falling_back to the heuristics._@param startLoggingAfter The time after which the method will log on INFO level.;public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,_							long maxWaitMillis, long startLoggingAfter) throws IOException_	{_		if (targetAddress == null) {_			throw new NullPointerException("targetAddress must not be null")__		}_		if (maxWaitMillis <= 0) {_			throw new IllegalArgumentException("Max wait time must be positive")__		}__		final long startTime = System.currentTimeMillis()___		long currentSleepTime = MIN_SLEEP_TIME__		long elapsedTime = 0___		_		while (elapsedTime < maxWaitMillis) {_			AddressDetectionState strategy = AddressDetectionState.LOCAL_HOST___			boolean logging = elapsedTime >= startLoggingAfter__			if (logging) {_				LOG.info("Trying to connect to " + targetAddress)__			}_			_			do {_				InetAddress address = findAddressUsingStrategy(strategy, targetAddress, logging)__				if (address != null) {_					return address__				}__				_				switch (strategy) {_					case LOCAL_HOST:_						strategy = AddressDetectionState.ADDRESS__						break__					case ADDRESS:_						strategy = AddressDetectionState.FAST_CONNECT__						break__					case FAST_CONNECT:_						strategy = AddressDetectionState.SLOW_CONNECT__						break__					case SLOW_CONNECT:_						strategy = null__						break__					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			}_			while (strategy != null)___			_			_			elapsedTime = System.currentTimeMillis() - startTime___			long toWait = Math.min(maxWaitMillis - elapsedTime, currentSleepTime)__			if (toWait > 0) {_				if (logging) {_					LOG.info("Could not connect. Waiting for {} msecs before next attempt", toWait)__				} else {_					LOG.debug("Could not connect. Waiting for {} msecs before next attempt", toWait)__				}__				try {_					Thread.sleep(toWait)__				}_				catch (InterruptedException e) {_					throw new IOException("Connection attempts have been interrupted.")__				}_			}__			_			currentSleepTime = Math.min(2 * currentSleepTime, MAX_SLEEP_TIME)__		}__		_		LOG.warn("Could not connect to {}. Selecting a local address using heuristics.", targetAddress)__		InetAddress heuristic = findAddressUsingStrategy(AddressDetectionState.HEURISTIC, targetAddress, true)__		if (heuristic != null) {_			return heuristic__		}_		else {_			LOG.warn("Could not find any IPv4 address that is not loopback or link-local. Using localhost address.")__			return InetAddress.getLocalHost()__		}_	};finds,the,local,network,address,from,which,this,machine,can,connect,to,the,target,address,this,method,tries,to,establish,a,proper,network,connection,to,the,given,target,so,it,only,succeeds,if,the,target,socket,address,actually,accepts,connections,the,method,tries,various,strategies,multiple,times,and,uses,an,exponential,backoff,timer,between,tries,p,if,no,connection,attempt,was,successful,after,the,given,maximum,time,the,method,will,choose,some,address,based,on,heuristics,excluding,link,local,and,loopback,addresses,p,this,method,will,initially,not,log,on,info,level,to,not,flood,the,log,while,the,backoff,time,is,still,very,low,it,will,start,logging,after,a,certain,time,has,passes,param,target,address,the,address,that,the,method,tries,to,connect,to,param,max,wait,millis,the,maximum,time,that,this,method,tries,to,connect,before,falling,back,to,the,heuristics,param,start,logging,after,the,time,after,which,the,method,will,log,on,info,level;public,static,inet,address,find,connecting,address,inet,socket,address,target,address,long,max,wait,millis,long,start,logging,after,throws,ioexception,if,target,address,null,throw,new,null,pointer,exception,target,address,must,not,be,null,if,max,wait,millis,0,throw,new,illegal,argument,exception,max,wait,time,must,be,positive,final,long,start,time,system,current,time,millis,long,current,sleep,time,long,elapsed,time,0,while,elapsed,time,max,wait,millis,address,detection,state,strategy,address,detection,state,boolean,logging,elapsed,time,start,logging,after,if,logging,log,info,trying,to,connect,to,target,address,do,inet,address,address,find,address,using,strategy,strategy,target,address,logging,if,address,null,return,address,switch,strategy,case,strategy,address,detection,state,address,break,case,address,strategy,address,detection,state,break,case,strategy,address,detection,state,break,case,strategy,null,break,default,throw,new,runtime,exception,unsupported,strategy,strategy,while,strategy,null,elapsed,time,system,current,time,millis,start,time,long,to,wait,math,min,max,wait,millis,elapsed,time,current,sleep,time,if,to,wait,0,if,logging,log,info,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,else,log,debug,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,try,thread,sleep,to,wait,catch,interrupted,exception,e,throw,new,ioexception,connection,attempts,have,been,interrupted,current,sleep,time,math,min,2,current,sleep,time,log,warn,could,not,connect,to,selecting,a,local,address,using,heuristics,target,address,inet,address,heuristic,find,address,using,strategy,address,detection,state,heuristic,target,address,true,if,heuristic,null,return,heuristic,else,log,warn,could,not,find,any,ipv4,address,that,is,not,loopback,or,link,local,using,localhost,address,return,inet,address,get,local,host
ConnectionUtils -> public static InetAddress findConnectingAddress(InetSocketAddress targetAddress, 							long maxWaitMillis, long startLoggingAfter) throws IOException;1457084088;Finds the local network address from which this machine can connect to the target_address. This method tries to establish a proper network connection to the_given target, so it only succeeds if the target socket address actually accepts_connections. The method tries various strategies multiple times and uses an exponential_backoff timer between tries._<p>_If no connection attempt was successful after the given maximum time, the method_will choose some address based on heuristics (excluding link-local and loopback addresses.)_<p>_This method will initially not log on info level (to not flood the log while the_backoff time is still very low). It will start logging after a certain time_has passes.__@param targetAddress The address that the method tries to connect to._@param maxWaitMillis The maximum time that this method tries to connect, before falling_back to the heuristics._@param startLoggingAfter The time after which the method will log on INFO level.;public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,_							long maxWaitMillis, long startLoggingAfter) throws IOException_	{_		if (targetAddress == null) {_			throw new NullPointerException("targetAddress must not be null")__		}_		if (maxWaitMillis <= 0) {_			throw new IllegalArgumentException("Max wait time must be positive")__		}__		final long startTime = System.currentTimeMillis()___		long currentSleepTime = MIN_SLEEP_TIME__		long elapsedTime = 0___		_		while (elapsedTime < maxWaitMillis) {_			AddressDetectionState strategy = AddressDetectionState.LOCAL_HOST___			boolean logging = elapsedTime >= startLoggingAfter__			if (logging) {_				LOG.info("Trying to connect to " + targetAddress)__			}_			_			do {_				InetAddress address = findAddressUsingStrategy(strategy, targetAddress, logging)__				if (address != null) {_					return address__				}__				_				switch (strategy) {_					case LOCAL_HOST:_						strategy = AddressDetectionState.ADDRESS__						break__					case ADDRESS:_						strategy = AddressDetectionState.FAST_CONNECT__						break__					case FAST_CONNECT:_						strategy = AddressDetectionState.SLOW_CONNECT__						break__					case SLOW_CONNECT:_						strategy = null__						break__					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			}_			while (strategy != null)___			_			_			elapsedTime = System.currentTimeMillis() - startTime___			long toWait = Math.min(maxWaitMillis - elapsedTime, currentSleepTime)__			if (toWait > 0) {_				if (logging) {_					LOG.info("Could not connect. Waiting for {} msecs before next attempt", toWait)__				} else {_					LOG.debug("Could not connect. Waiting for {} msecs before next attempt", toWait)__				}__				try {_					Thread.sleep(toWait)__				}_				catch (InterruptedException e) {_					throw new IOException("Connection attempts have been interrupted.")__				}_			}__			_			currentSleepTime = Math.min(2 * currentSleepTime, MAX_SLEEP_TIME)__		}__		_		LOG.warn("Could not connect to {}. Selecting a local address using heuristics.", targetAddress)__		InetAddress heuristic = findAddressUsingStrategy(AddressDetectionState.HEURISTIC, targetAddress, true)__		if (heuristic != null) {_			return heuristic__		}_		else {_			LOG.warn("Could not find any IPv4 address that is not loopback or link-local. Using localhost address.")__			return InetAddress.getLocalHost()__		}_	};finds,the,local,network,address,from,which,this,machine,can,connect,to,the,target,address,this,method,tries,to,establish,a,proper,network,connection,to,the,given,target,so,it,only,succeeds,if,the,target,socket,address,actually,accepts,connections,the,method,tries,various,strategies,multiple,times,and,uses,an,exponential,backoff,timer,between,tries,p,if,no,connection,attempt,was,successful,after,the,given,maximum,time,the,method,will,choose,some,address,based,on,heuristics,excluding,link,local,and,loopback,addresses,p,this,method,will,initially,not,log,on,info,level,to,not,flood,the,log,while,the,backoff,time,is,still,very,low,it,will,start,logging,after,a,certain,time,has,passes,param,target,address,the,address,that,the,method,tries,to,connect,to,param,max,wait,millis,the,maximum,time,that,this,method,tries,to,connect,before,falling,back,to,the,heuristics,param,start,logging,after,the,time,after,which,the,method,will,log,on,info,level;public,static,inet,address,find,connecting,address,inet,socket,address,target,address,long,max,wait,millis,long,start,logging,after,throws,ioexception,if,target,address,null,throw,new,null,pointer,exception,target,address,must,not,be,null,if,max,wait,millis,0,throw,new,illegal,argument,exception,max,wait,time,must,be,positive,final,long,start,time,system,current,time,millis,long,current,sleep,time,long,elapsed,time,0,while,elapsed,time,max,wait,millis,address,detection,state,strategy,address,detection,state,boolean,logging,elapsed,time,start,logging,after,if,logging,log,info,trying,to,connect,to,target,address,do,inet,address,address,find,address,using,strategy,strategy,target,address,logging,if,address,null,return,address,switch,strategy,case,strategy,address,detection,state,address,break,case,address,strategy,address,detection,state,break,case,strategy,address,detection,state,break,case,strategy,null,break,default,throw,new,runtime,exception,unsupported,strategy,strategy,while,strategy,null,elapsed,time,system,current,time,millis,start,time,long,to,wait,math,min,max,wait,millis,elapsed,time,current,sleep,time,if,to,wait,0,if,logging,log,info,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,else,log,debug,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,try,thread,sleep,to,wait,catch,interrupted,exception,e,throw,new,ioexception,connection,attempts,have,been,interrupted,current,sleep,time,math,min,2,current,sleep,time,log,warn,could,not,connect,to,selecting,a,local,address,using,heuristics,target,address,inet,address,heuristic,find,address,using,strategy,address,detection,state,heuristic,target,address,true,if,heuristic,null,return,heuristic,else,log,warn,could,not,find,any,ipv4,address,that,is,not,loopback,or,link,local,using,localhost,address,return,inet,address,get,local,host
ConnectionUtils -> public static InetAddress findConnectingAddress(InetSocketAddress targetAddress, 							long maxWaitMillis, long startLoggingAfter) throws IOException;1463757966;Finds the local network address from which this machine can connect to the target_address. This method tries to establish a proper network connection to the_given target, so it only succeeds if the target socket address actually accepts_connections. The method tries various strategies multiple times and uses an exponential_backoff timer between tries._<p>_If no connection attempt was successful after the given maximum time, the method_will choose some address based on heuristics (excluding link-local and loopback addresses.)_<p>_This method will initially not log on info level (to not flood the log while the_backoff time is still very low). It will start logging after a certain time_has passes.__@param targetAddress The address that the method tries to connect to._@param maxWaitMillis The maximum time that this method tries to connect, before falling_back to the heuristics._@param startLoggingAfter The time after which the method will log on INFO level.;public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,_							long maxWaitMillis, long startLoggingAfter) throws IOException_	{_		if (targetAddress == null) {_			throw new NullPointerException("targetAddress must not be null")__		}_		if (maxWaitMillis <= 0) {_			throw new IllegalArgumentException("Max wait time must be positive")__		}__		final long startTime = System.currentTimeMillis()___		long currentSleepTime = MIN_SLEEP_TIME__		long elapsedTime = 0___		_		while (elapsedTime < maxWaitMillis) {_			AddressDetectionState strategy = AddressDetectionState.LOCAL_HOST___			boolean logging = elapsedTime >= startLoggingAfter__			if (logging) {_				LOG.info("Trying to connect to " + targetAddress)__			}_			_			do {_				InetAddress address = findAddressUsingStrategy(strategy, targetAddress, logging)__				if (address != null) {_					return address__				}__				_				switch (strategy) {_					case LOCAL_HOST:_						strategy = AddressDetectionState.ADDRESS__						break__					case ADDRESS:_						strategy = AddressDetectionState.FAST_CONNECT__						break__					case FAST_CONNECT:_						strategy = AddressDetectionState.SLOW_CONNECT__						break__					case SLOW_CONNECT:_						strategy = null__						break__					default:_						throw new RuntimeException("Unsupported strategy: " + strategy)__				}_			}_			while (strategy != null)___			_			_			elapsedTime = System.currentTimeMillis() - startTime___			long toWait = Math.min(maxWaitMillis - elapsedTime, currentSleepTime)__			if (toWait > 0) {_				if (logging) {_					LOG.info("Could not connect. Waiting for {} msecs before next attempt", toWait)__				} else {_					LOG.debug("Could not connect. Waiting for {} msecs before next attempt", toWait)__				}__				try {_					Thread.sleep(toWait)__				}_				catch (InterruptedException e) {_					throw new IOException("Connection attempts have been interrupted.")__				}_			}__			_			currentSleepTime = Math.min(2 * currentSleepTime, MAX_SLEEP_TIME)__		}__		_		LOG.warn("Could not connect to {}. Selecting a local address using heuristics.", targetAddress)__		InetAddress heuristic = findAddressUsingStrategy(AddressDetectionState.HEURISTIC, targetAddress, true)__		if (heuristic != null) {_			return heuristic__		}_		else {_			LOG.warn("Could not find any IPv4 address that is not loopback or link-local. Using localhost address.")__			return InetAddress.getLocalHost()__		}_	};finds,the,local,network,address,from,which,this,machine,can,connect,to,the,target,address,this,method,tries,to,establish,a,proper,network,connection,to,the,given,target,so,it,only,succeeds,if,the,target,socket,address,actually,accepts,connections,the,method,tries,various,strategies,multiple,times,and,uses,an,exponential,backoff,timer,between,tries,p,if,no,connection,attempt,was,successful,after,the,given,maximum,time,the,method,will,choose,some,address,based,on,heuristics,excluding,link,local,and,loopback,addresses,p,this,method,will,initially,not,log,on,info,level,to,not,flood,the,log,while,the,backoff,time,is,still,very,low,it,will,start,logging,after,a,certain,time,has,passes,param,target,address,the,address,that,the,method,tries,to,connect,to,param,max,wait,millis,the,maximum,time,that,this,method,tries,to,connect,before,falling,back,to,the,heuristics,param,start,logging,after,the,time,after,which,the,method,will,log,on,info,level;public,static,inet,address,find,connecting,address,inet,socket,address,target,address,long,max,wait,millis,long,start,logging,after,throws,ioexception,if,target,address,null,throw,new,null,pointer,exception,target,address,must,not,be,null,if,max,wait,millis,0,throw,new,illegal,argument,exception,max,wait,time,must,be,positive,final,long,start,time,system,current,time,millis,long,current,sleep,time,long,elapsed,time,0,while,elapsed,time,max,wait,millis,address,detection,state,strategy,address,detection,state,boolean,logging,elapsed,time,start,logging,after,if,logging,log,info,trying,to,connect,to,target,address,do,inet,address,address,find,address,using,strategy,strategy,target,address,logging,if,address,null,return,address,switch,strategy,case,strategy,address,detection,state,address,break,case,address,strategy,address,detection,state,break,case,strategy,address,detection,state,break,case,strategy,null,break,default,throw,new,runtime,exception,unsupported,strategy,strategy,while,strategy,null,elapsed,time,system,current,time,millis,start,time,long,to,wait,math,min,max,wait,millis,elapsed,time,current,sleep,time,if,to,wait,0,if,logging,log,info,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,else,log,debug,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,try,thread,sleep,to,wait,catch,interrupted,exception,e,throw,new,ioexception,connection,attempts,have,been,interrupted,current,sleep,time,math,min,2,current,sleep,time,log,warn,could,not,connect,to,selecting,a,local,address,using,heuristics,target,address,inet,address,heuristic,find,address,using,strategy,address,detection,state,heuristic,target,address,true,if,heuristic,null,return,heuristic,else,log,warn,could,not,find,any,ipv4,address,that,is,not,loopback,or,link,local,using,localhost,address,return,inet,address,get,local,host
ConnectionUtils -> public static InetAddress findConnectingAddress(InetSocketAddress targetAddress, 							long maxWaitMillis, long startLoggingAfter) throws IOException;1472226799;Finds the local network address from which this machine can connect to the target_address. This method tries to establish a proper network connection to the_given target, so it only succeeds if the target socket address actually accepts_connections. The method tries various strategies multiple times and uses an exponential_backoff timer between tries._<p>_If no connection attempt was successful after the given maximum time, the method_will choose some address based on heuristics (excluding link-local and loopback addresses.)_<p>_This method will initially not log on info level (to not flood the log while the_backoff time is still very low). It will start logging after a certain time_has passes.__@param targetAddress The address that the method tries to connect to._@param maxWaitMillis The maximum time that this method tries to connect, before falling_back to the heuristics._@param startLoggingAfter The time after which the method will log on INFO level.;public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,_							long maxWaitMillis, long startLoggingAfter) throws IOException_	{_		if (targetAddress == null) {_			throw new NullPointerException("targetAddress must not be null")__		}_		if (maxWaitMillis <= 0) {_			throw new IllegalArgumentException("Max wait time must be positive")__		}__		final long startTime = System.currentTimeMillis()___		long currentSleepTime = MIN_SLEEP_TIME__		long elapsedTime = 0___		final List<AddressDetectionState> strategies = Collections.unmodifiableList(_			Arrays.asList(_				AddressDetectionState.LOCAL_HOST,_				AddressDetectionState.ADDRESS,_				AddressDetectionState.FAST_CONNECT,_				AddressDetectionState.SLOW_CONNECT))___		_		while (elapsedTime < maxWaitMillis) {_			boolean logging = elapsedTime >= startLoggingAfter__			if (logging) {_				LOG.info("Trying to connect to " + targetAddress)__			}__			_			for (AddressDetectionState strategy : strategies) {_				InetAddress address = findAddressUsingStrategy(strategy, targetAddress, logging)__				if (address != null) {_					return address__				}_			}__			_			_			elapsedTime = System.currentTimeMillis() - startTime___			long toWait = Math.min(maxWaitMillis - elapsedTime, currentSleepTime)__			if (toWait > 0) {_				if (logging) {_					LOG.info("Could not connect. Waiting for {} msecs before next attempt", toWait)__				} else {_					LOG.debug("Could not connect. Waiting for {} msecs before next attempt", toWait)__				}__				try {_					Thread.sleep(toWait)__				}_				catch (InterruptedException e) {_					throw new IOException("Connection attempts have been interrupted.")__				}_			}__			_			currentSleepTime = Math.min(2 * currentSleepTime, MAX_SLEEP_TIME)__		}__		_		LOG.warn("Could not connect to {}. Selecting a local address using heuristics.", targetAddress)__		InetAddress heuristic = findAddressUsingStrategy(AddressDetectionState.HEURISTIC, targetAddress, true)__		if (heuristic != null) {_			return heuristic__		}_		else {_			LOG.warn("Could not find any IPv4 address that is not loopback or link-local. Using localhost address.")__			return InetAddress.getLocalHost()__		}_	};finds,the,local,network,address,from,which,this,machine,can,connect,to,the,target,address,this,method,tries,to,establish,a,proper,network,connection,to,the,given,target,so,it,only,succeeds,if,the,target,socket,address,actually,accepts,connections,the,method,tries,various,strategies,multiple,times,and,uses,an,exponential,backoff,timer,between,tries,p,if,no,connection,attempt,was,successful,after,the,given,maximum,time,the,method,will,choose,some,address,based,on,heuristics,excluding,link,local,and,loopback,addresses,p,this,method,will,initially,not,log,on,info,level,to,not,flood,the,log,while,the,backoff,time,is,still,very,low,it,will,start,logging,after,a,certain,time,has,passes,param,target,address,the,address,that,the,method,tries,to,connect,to,param,max,wait,millis,the,maximum,time,that,this,method,tries,to,connect,before,falling,back,to,the,heuristics,param,start,logging,after,the,time,after,which,the,method,will,log,on,info,level;public,static,inet,address,find,connecting,address,inet,socket,address,target,address,long,max,wait,millis,long,start,logging,after,throws,ioexception,if,target,address,null,throw,new,null,pointer,exception,target,address,must,not,be,null,if,max,wait,millis,0,throw,new,illegal,argument,exception,max,wait,time,must,be,positive,final,long,start,time,system,current,time,millis,long,current,sleep,time,long,elapsed,time,0,final,list,address,detection,state,strategies,collections,unmodifiable,list,arrays,as,list,address,detection,state,address,detection,state,address,address,detection,state,address,detection,state,while,elapsed,time,max,wait,millis,boolean,logging,elapsed,time,start,logging,after,if,logging,log,info,trying,to,connect,to,target,address,for,address,detection,state,strategy,strategies,inet,address,address,find,address,using,strategy,strategy,target,address,logging,if,address,null,return,address,elapsed,time,system,current,time,millis,start,time,long,to,wait,math,min,max,wait,millis,elapsed,time,current,sleep,time,if,to,wait,0,if,logging,log,info,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,else,log,debug,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,try,thread,sleep,to,wait,catch,interrupted,exception,e,throw,new,ioexception,connection,attempts,have,been,interrupted,current,sleep,time,math,min,2,current,sleep,time,log,warn,could,not,connect,to,selecting,a,local,address,using,heuristics,target,address,inet,address,heuristic,find,address,using,strategy,address,detection,state,heuristic,target,address,true,if,heuristic,null,return,heuristic,else,log,warn,could,not,find,any,ipv4,address,that,is,not,loopback,or,link,local,using,localhost,address,return,inet,address,get,local,host
ConnectionUtils -> public static InetAddress findConnectingAddress(InetSocketAddress targetAddress, 							long maxWaitMillis, long startLoggingAfter) throws IOException;1484160227;Finds the local network address from which this machine can connect to the target_address. This method tries to establish a proper network connection to the_given target, so it only succeeds if the target socket address actually accepts_connections. The method tries various strategies multiple times and uses an exponential_backoff timer between tries._<p>_If no connection attempt was successful after the given maximum time, the method_will choose some address based on heuristics (excluding link-local and loopback addresses.)_<p>_This method will initially not log on info level (to not flood the log while the_backoff time is still very low). It will start logging after a certain time_has passes.__@param targetAddress The address that the method tries to connect to._@param maxWaitMillis The maximum time that this method tries to connect, before falling_back to the heuristics._@param startLoggingAfter The time after which the method will log on INFO level.;public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,_							long maxWaitMillis, long startLoggingAfter) throws IOException_	{_		if (targetAddress == null) {_			throw new NullPointerException("targetAddress must not be null")__		}_		if (maxWaitMillis <= 0) {_			throw new IllegalArgumentException("Max wait time must be positive")__		}__		final long startTimeNanos = System.nanoTime()___		long currentSleepTime = MIN_SLEEP_TIME__		long elapsedTimeMillis = 0___		final List<AddressDetectionState> strategies = Collections.unmodifiableList(_			Arrays.asList(_				AddressDetectionState.LOCAL_HOST,_				AddressDetectionState.ADDRESS,_				AddressDetectionState.FAST_CONNECT,_				AddressDetectionState.SLOW_CONNECT))___		_		while (elapsedTimeMillis < maxWaitMillis) {_			boolean logging = elapsedTimeMillis >= startLoggingAfter__			if (logging) {_				LOG.info("Trying to connect to " + targetAddress)__			}__			_			for (AddressDetectionState strategy : strategies) {_				InetAddress address = findAddressUsingStrategy(strategy, targetAddress, logging)__				if (address != null) {_					return address__				}_			}__			_			_			elapsedTimeMillis = (System.nanoTime() - startTimeNanos) / 1_000_000___			long toWait = Math.min(maxWaitMillis - elapsedTimeMillis, currentSleepTime)__			if (toWait > 0) {_				if (logging) {_					LOG.info("Could not connect. Waiting for {} msecs before next attempt", toWait)__				} else {_					LOG.debug("Could not connect. Waiting for {} msecs before next attempt", toWait)__				}__				try {_					Thread.sleep(toWait)__				}_				catch (InterruptedException e) {_					throw new IOException("Connection attempts have been interrupted.")__				}_			}__			_			currentSleepTime = Math.min(2 * currentSleepTime, MAX_SLEEP_TIME)__		}__		_		LOG.warn("Could not connect to {}. Selecting a local address using heuristics.", targetAddress)__		InetAddress heuristic = findAddressUsingStrategy(AddressDetectionState.HEURISTIC, targetAddress, true)__		if (heuristic != null) {_			return heuristic__		}_		else {_			LOG.warn("Could not find any IPv4 address that is not loopback or link-local. Using localhost address.")__			return InetAddress.getLocalHost()__		}_	};finds,the,local,network,address,from,which,this,machine,can,connect,to,the,target,address,this,method,tries,to,establish,a,proper,network,connection,to,the,given,target,so,it,only,succeeds,if,the,target,socket,address,actually,accepts,connections,the,method,tries,various,strategies,multiple,times,and,uses,an,exponential,backoff,timer,between,tries,p,if,no,connection,attempt,was,successful,after,the,given,maximum,time,the,method,will,choose,some,address,based,on,heuristics,excluding,link,local,and,loopback,addresses,p,this,method,will,initially,not,log,on,info,level,to,not,flood,the,log,while,the,backoff,time,is,still,very,low,it,will,start,logging,after,a,certain,time,has,passes,param,target,address,the,address,that,the,method,tries,to,connect,to,param,max,wait,millis,the,maximum,time,that,this,method,tries,to,connect,before,falling,back,to,the,heuristics,param,start,logging,after,the,time,after,which,the,method,will,log,on,info,level;public,static,inet,address,find,connecting,address,inet,socket,address,target,address,long,max,wait,millis,long,start,logging,after,throws,ioexception,if,target,address,null,throw,new,null,pointer,exception,target,address,must,not,be,null,if,max,wait,millis,0,throw,new,illegal,argument,exception,max,wait,time,must,be,positive,final,long,start,time,nanos,system,nano,time,long,current,sleep,time,long,elapsed,time,millis,0,final,list,address,detection,state,strategies,collections,unmodifiable,list,arrays,as,list,address,detection,state,address,detection,state,address,address,detection,state,address,detection,state,while,elapsed,time,millis,max,wait,millis,boolean,logging,elapsed,time,millis,start,logging,after,if,logging,log,info,trying,to,connect,to,target,address,for,address,detection,state,strategy,strategies,inet,address,address,find,address,using,strategy,strategy,target,address,logging,if,address,null,return,address,elapsed,time,millis,system,nano,time,start,time,nanos,long,to,wait,math,min,max,wait,millis,elapsed,time,millis,current,sleep,time,if,to,wait,0,if,logging,log,info,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,else,log,debug,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,try,thread,sleep,to,wait,catch,interrupted,exception,e,throw,new,ioexception,connection,attempts,have,been,interrupted,current,sleep,time,math,min,2,current,sleep,time,log,warn,could,not,connect,to,selecting,a,local,address,using,heuristics,target,address,inet,address,heuristic,find,address,using,strategy,address,detection,state,heuristic,target,address,true,if,heuristic,null,return,heuristic,else,log,warn,could,not,find,any,ipv4,address,that,is,not,loopback,or,link,local,using,localhost,address,return,inet,address,get,local,host
ConnectionUtils -> public static InetAddress findConnectingAddress(InetSocketAddress targetAddress, 							long maxWaitMillis, long startLoggingAfter) throws IOException;1499164413;Finds the local network address from which this machine can connect to the target_address. This method tries to establish a proper network connection to the_given target, so it only succeeds if the target socket address actually accepts_connections. The method tries various strategies multiple times and uses an exponential_backoff timer between tries.__<p>If no connection attempt was successful after the given maximum time, the method_will choose some address based on heuristics (excluding link-local and loopback addresses.)__<p>This method will initially not log on info level (to not flood the log while the_backoff time is still very low). It will start logging after a certain time_has passes.__@param targetAddress The address that the method tries to connect to._@param maxWaitMillis The maximum time that this method tries to connect, before falling_back to the heuristics._@param startLoggingAfter The time after which the method will log on INFO level.;public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,_							long maxWaitMillis, long startLoggingAfter) throws IOException {_		if (targetAddress == null) {_			throw new NullPointerException("targetAddress must not be null")__		}_		if (maxWaitMillis <= 0) {_			throw new IllegalArgumentException("Max wait time must be positive")__		}__		final long startTimeNanos = System.nanoTime()___		long currentSleepTime = MIN_SLEEP_TIME__		long elapsedTimeMillis = 0___		final List<AddressDetectionState> strategies = Collections.unmodifiableList(_			Arrays.asList(_				AddressDetectionState.LOCAL_HOST,_				AddressDetectionState.ADDRESS,_				AddressDetectionState.FAST_CONNECT,_				AddressDetectionState.SLOW_CONNECT))___		_		while (elapsedTimeMillis < maxWaitMillis) {_			boolean logging = elapsedTimeMillis >= startLoggingAfter__			if (logging) {_				LOG.info("Trying to connect to " + targetAddress)__			}__			_			for (AddressDetectionState strategy : strategies) {_				InetAddress address = findAddressUsingStrategy(strategy, targetAddress, logging)__				if (address != null) {_					return address__				}_			}__			_			_			elapsedTimeMillis = (System.nanoTime() - startTimeNanos) / 1_000_000___			long toWait = Math.min(maxWaitMillis - elapsedTimeMillis, currentSleepTime)__			if (toWait > 0) {_				if (logging) {_					LOG.info("Could not connect. Waiting for {} msecs before next attempt", toWait)__				} else {_					LOG.debug("Could not connect. Waiting for {} msecs before next attempt", toWait)__				}__				try {_					Thread.sleep(toWait)__				}_				catch (InterruptedException e) {_					throw new IOException("Connection attempts have been interrupted.")__				}_			}__			_			currentSleepTime = Math.min(2 * currentSleepTime, MAX_SLEEP_TIME)__		}__		_		LOG.warn("Could not connect to {}. Selecting a local address using heuristics.", targetAddress)__		InetAddress heuristic = findAddressUsingStrategy(AddressDetectionState.HEURISTIC, targetAddress, true)__		if (heuristic != null) {_			return heuristic__		}_		else {_			LOG.warn("Could not find any IPv4 address that is not loopback or link-local. Using localhost address.")__			return InetAddress.getLocalHost()__		}_	};finds,the,local,network,address,from,which,this,machine,can,connect,to,the,target,address,this,method,tries,to,establish,a,proper,network,connection,to,the,given,target,so,it,only,succeeds,if,the,target,socket,address,actually,accepts,connections,the,method,tries,various,strategies,multiple,times,and,uses,an,exponential,backoff,timer,between,tries,p,if,no,connection,attempt,was,successful,after,the,given,maximum,time,the,method,will,choose,some,address,based,on,heuristics,excluding,link,local,and,loopback,addresses,p,this,method,will,initially,not,log,on,info,level,to,not,flood,the,log,while,the,backoff,time,is,still,very,low,it,will,start,logging,after,a,certain,time,has,passes,param,target,address,the,address,that,the,method,tries,to,connect,to,param,max,wait,millis,the,maximum,time,that,this,method,tries,to,connect,before,falling,back,to,the,heuristics,param,start,logging,after,the,time,after,which,the,method,will,log,on,info,level;public,static,inet,address,find,connecting,address,inet,socket,address,target,address,long,max,wait,millis,long,start,logging,after,throws,ioexception,if,target,address,null,throw,new,null,pointer,exception,target,address,must,not,be,null,if,max,wait,millis,0,throw,new,illegal,argument,exception,max,wait,time,must,be,positive,final,long,start,time,nanos,system,nano,time,long,current,sleep,time,long,elapsed,time,millis,0,final,list,address,detection,state,strategies,collections,unmodifiable,list,arrays,as,list,address,detection,state,address,detection,state,address,address,detection,state,address,detection,state,while,elapsed,time,millis,max,wait,millis,boolean,logging,elapsed,time,millis,start,logging,after,if,logging,log,info,trying,to,connect,to,target,address,for,address,detection,state,strategy,strategies,inet,address,address,find,address,using,strategy,strategy,target,address,logging,if,address,null,return,address,elapsed,time,millis,system,nano,time,start,time,nanos,long,to,wait,math,min,max,wait,millis,elapsed,time,millis,current,sleep,time,if,to,wait,0,if,logging,log,info,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,else,log,debug,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,try,thread,sleep,to,wait,catch,interrupted,exception,e,throw,new,ioexception,connection,attempts,have,been,interrupted,current,sleep,time,math,min,2,current,sleep,time,log,warn,could,not,connect,to,selecting,a,local,address,using,heuristics,target,address,inet,address,heuristic,find,address,using,strategy,address,detection,state,heuristic,target,address,true,if,heuristic,null,return,heuristic,else,log,warn,could,not,find,any,ipv4,address,that,is,not,loopback,or,link,local,using,localhost,address,return,inet,address,get,local,host
ConnectionUtils -> public static InetAddress findConnectingAddress(InetSocketAddress targetAddress, 							long maxWaitMillis, long startLoggingAfter) throws IOException;1516028608;Finds the local network address from which this machine can connect to the target_address. This method tries to establish a proper network connection to the_given target, so it only succeeds if the target socket address actually accepts_connections. The method tries various strategies multiple times and uses an exponential_backoff timer between tries.__<p>If no connection attempt was successful after the given maximum time, the method_will choose some address based on heuristics (excluding link-local and loopback addresses.)__<p>This method will initially not log on info level (to not flood the log while the_backoff time is still very low). It will start logging after a certain time_has passes.__@param targetAddress The address that the method tries to connect to._@param maxWaitMillis The maximum time that this method tries to connect, before falling_back to the heuristics._@param startLoggingAfter The time after which the method will log on INFO level.;public static InetAddress findConnectingAddress(InetSocketAddress targetAddress,_							long maxWaitMillis, long startLoggingAfter) throws IOException {_		if (targetAddress == null) {_			throw new NullPointerException("targetAddress must not be null")__		}_		if (maxWaitMillis <= 0) {_			throw new IllegalArgumentException("Max wait time must be positive")__		}__		final long startTimeNanos = System.nanoTime()___		long currentSleepTime = MIN_SLEEP_TIME__		long elapsedTimeMillis = 0___		final List<AddressDetectionState> strategies = Collections.unmodifiableList(_			Arrays.asList(_				AddressDetectionState.LOCAL_HOST,_				AddressDetectionState.ADDRESS,_				AddressDetectionState.FAST_CONNECT,_				AddressDetectionState.SLOW_CONNECT))___		_		while (elapsedTimeMillis < maxWaitMillis) {_			boolean logging = elapsedTimeMillis >= startLoggingAfter__			if (logging) {_				LOG.info("Trying to connect to " + targetAddress)__			}__			_			for (AddressDetectionState strategy : strategies) {_				InetAddress address = findAddressUsingStrategy(strategy, targetAddress, logging)__				if (address != null) {_					return address__				}_			}__			_			_			elapsedTimeMillis = (System.nanoTime() - startTimeNanos) / 1_000_000___			long toWait = Math.min(maxWaitMillis - elapsedTimeMillis, currentSleepTime)__			if (toWait > 0) {_				if (logging) {_					LOG.info("Could not connect. Waiting for {} msecs before next attempt", toWait)__				} else {_					LOG.debug("Could not connect. Waiting for {} msecs before next attempt", toWait)__				}__				try {_					Thread.sleep(toWait)__				}_				catch (InterruptedException e) {_					throw new IOException("Connection attempts have been interrupted.")__				}_			}__			_			currentSleepTime = Math.min(2 * currentSleepTime, MAX_SLEEP_TIME)__		}__		_		LOG.warn("Could not connect to {}. Selecting a local address using heuristics.", targetAddress)__		InetAddress heuristic = findAddressUsingStrategy(AddressDetectionState.HEURISTIC, targetAddress, true)__		if (heuristic != null) {_			return heuristic__		}_		else {_			LOG.warn("Could not find any IPv4 address that is not loopback or link-local. Using localhost address.")__			return InetAddress.getLocalHost()__		}_	};finds,the,local,network,address,from,which,this,machine,can,connect,to,the,target,address,this,method,tries,to,establish,a,proper,network,connection,to,the,given,target,so,it,only,succeeds,if,the,target,socket,address,actually,accepts,connections,the,method,tries,various,strategies,multiple,times,and,uses,an,exponential,backoff,timer,between,tries,p,if,no,connection,attempt,was,successful,after,the,given,maximum,time,the,method,will,choose,some,address,based,on,heuristics,excluding,link,local,and,loopback,addresses,p,this,method,will,initially,not,log,on,info,level,to,not,flood,the,log,while,the,backoff,time,is,still,very,low,it,will,start,logging,after,a,certain,time,has,passes,param,target,address,the,address,that,the,method,tries,to,connect,to,param,max,wait,millis,the,maximum,time,that,this,method,tries,to,connect,before,falling,back,to,the,heuristics,param,start,logging,after,the,time,after,which,the,method,will,log,on,info,level;public,static,inet,address,find,connecting,address,inet,socket,address,target,address,long,max,wait,millis,long,start,logging,after,throws,ioexception,if,target,address,null,throw,new,null,pointer,exception,target,address,must,not,be,null,if,max,wait,millis,0,throw,new,illegal,argument,exception,max,wait,time,must,be,positive,final,long,start,time,nanos,system,nano,time,long,current,sleep,time,long,elapsed,time,millis,0,final,list,address,detection,state,strategies,collections,unmodifiable,list,arrays,as,list,address,detection,state,address,detection,state,address,address,detection,state,address,detection,state,while,elapsed,time,millis,max,wait,millis,boolean,logging,elapsed,time,millis,start,logging,after,if,logging,log,info,trying,to,connect,to,target,address,for,address,detection,state,strategy,strategies,inet,address,address,find,address,using,strategy,strategy,target,address,logging,if,address,null,return,address,elapsed,time,millis,system,nano,time,start,time,nanos,long,to,wait,math,min,max,wait,millis,elapsed,time,millis,current,sleep,time,if,to,wait,0,if,logging,log,info,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,else,log,debug,could,not,connect,waiting,for,msecs,before,next,attempt,to,wait,try,thread,sleep,to,wait,catch,interrupted,exception,e,throw,new,ioexception,connection,attempts,have,been,interrupted,current,sleep,time,math,min,2,current,sleep,time,log,warn,could,not,connect,to,selecting,a,local,address,using,heuristics,target,address,inet,address,heuristic,find,address,using,strategy,address,detection,state,heuristic,target,address,true,if,heuristic,null,return,heuristic,else,log,warn,could,not,find,any,ipv4,address,that,is,not,loopback,or,link,local,using,localhost,address,return,inet,address,get,local,host
ConnectionUtils -> private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket, 										int timeout, boolean logFailed) throws IOException;1443682795;@param fromAddress The address to connect from._@param toSocket The socket address to connect to._@param timeout The timeout fr the connection._@param logFailed Flag to indicate whether to log failed attempts on info level_(failed attempts are always logged on DEBUG level)._@return True, if the connection was successful, false otherwise._@throws IOException Thrown if the socket cleanup fails.;private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,_										int timeout, boolean logFailed) throws IOException_	{_		if (LOG.isDebugEnabled()) {_			LOG.debug("Trying to connect to (" + toSocket + ") from local address " + fromAddress_					+ " with timeout " + timeout)__		}_		try (Socket socket = new Socket()) {_			_			SocketAddress bindP = new InetSocketAddress(fromAddress, 0)__			_			socket.bind(bindP)__			socket.connect(toSocket, timeout)__			return true__		}_		catch (Exception ex) {_			String message = "Failed to connect from address '" + fromAddress + "': " + ex.getMessage()__			if (LOG.isDebugEnabled()) {_				LOG.debug(message, ex)__			} else if (logFailed) {_				LOG.info(message)__			}_			return false__		}_	};param,from,address,the,address,to,connect,from,param,to,socket,the,socket,address,to,connect,to,param,timeout,the,timeout,fr,the,connection,param,log,failed,flag,to,indicate,whether,to,log,failed,attempts,on,info,level,failed,attempts,are,always,logged,on,debug,level,return,true,if,the,connection,was,successful,false,otherwise,throws,ioexception,thrown,if,the,socket,cleanup,fails;private,static,boolean,try,to,connect,inet,address,from,address,socket,address,to,socket,int,timeout,boolean,log,failed,throws,ioexception,if,log,is,debug,enabled,log,debug,trying,to,connect,to,to,socket,from,local,address,from,address,with,timeout,timeout,try,socket,socket,new,socket,socket,address,bind,p,new,inet,socket,address,from,address,0,socket,bind,bind,p,socket,connect,to,socket,timeout,return,true,catch,exception,ex,string,message,failed,to,connect,from,address,from,address,ex,get,message,if,log,is,debug,enabled,log,debug,message,ex,else,if,log,failed,log,info,message,return,false
ConnectionUtils -> private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket, 										int timeout, boolean logFailed) throws IOException;1443682796;@param fromAddress The address to connect from._@param toSocket The socket address to connect to._@param timeout The timeout fr the connection._@param logFailed Flag to indicate whether to log failed attempts on info level_(failed attempts are always logged on DEBUG level)._@return True, if the connection was successful, false otherwise._@throws IOException Thrown if the socket cleanup fails.;private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,_										int timeout, boolean logFailed) throws IOException_	{_		if (LOG.isDebugEnabled()) {_			LOG.debug("Trying to connect to (" + toSocket + ") from local address " + fromAddress_					+ " with timeout " + timeout)__		}_		try (Socket socket = new Socket()) {_			_			SocketAddress bindP = new InetSocketAddress(fromAddress, 0)__			_			socket.bind(bindP)__			socket.connect(toSocket, timeout)__			return true__		}_		catch (Exception ex) {_			String message = "Failed to connect from address '" + fromAddress + "': " + ex.getMessage()__			if (LOG.isDebugEnabled()) {_				LOG.debug(message, ex)__			} else if (logFailed) {_				LOG.info(message)__			}_			return false__		}_	};param,from,address,the,address,to,connect,from,param,to,socket,the,socket,address,to,connect,to,param,timeout,the,timeout,fr,the,connection,param,log,failed,flag,to,indicate,whether,to,log,failed,attempts,on,info,level,failed,attempts,are,always,logged,on,debug,level,return,true,if,the,connection,was,successful,false,otherwise,throws,ioexception,thrown,if,the,socket,cleanup,fails;private,static,boolean,try,to,connect,inet,address,from,address,socket,address,to,socket,int,timeout,boolean,log,failed,throws,ioexception,if,log,is,debug,enabled,log,debug,trying,to,connect,to,to,socket,from,local,address,from,address,with,timeout,timeout,try,socket,socket,new,socket,socket,address,bind,p,new,inet,socket,address,from,address,0,socket,bind,bind,p,socket,connect,to,socket,timeout,return,true,catch,exception,ex,string,message,failed,to,connect,from,address,from,address,ex,get,message,if,log,is,debug,enabled,log,debug,message,ex,else,if,log,failed,log,info,message,return,false
ConnectionUtils -> private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket, 										int timeout, boolean logFailed) throws IOException;1447771086;@param fromAddress The address to connect from._@param toSocket The socket address to connect to._@param timeout The timeout fr the connection._@param logFailed Flag to indicate whether to log failed attempts on info level_(failed attempts are always logged on DEBUG level)._@return True, if the connection was successful, false otherwise._@throws IOException Thrown if the socket cleanup fails.;private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,_										int timeout, boolean logFailed) throws IOException_	{_		if (LOG.isDebugEnabled()) {_			LOG.debug("Trying to connect to (" + toSocket + ") from local address " + fromAddress_					+ " with timeout " + timeout)__		}_		try (Socket socket = new Socket()) {_			_			SocketAddress bindP = new InetSocketAddress(fromAddress, 0)__			_			socket.bind(bindP)__			socket.connect(toSocket, timeout)__			return true__		}_		catch (Exception ex) {_			String message = "Failed to connect from address '" + fromAddress + "': " + ex.getMessage()__			if (LOG.isDebugEnabled()) {_				LOG.debug(message, ex)__			} else if (logFailed) {_				LOG.info(message)__			}_			return false__		}_	};param,from,address,the,address,to,connect,from,param,to,socket,the,socket,address,to,connect,to,param,timeout,the,timeout,fr,the,connection,param,log,failed,flag,to,indicate,whether,to,log,failed,attempts,on,info,level,failed,attempts,are,always,logged,on,debug,level,return,true,if,the,connection,was,successful,false,otherwise,throws,ioexception,thrown,if,the,socket,cleanup,fails;private,static,boolean,try,to,connect,inet,address,from,address,socket,address,to,socket,int,timeout,boolean,log,failed,throws,ioexception,if,log,is,debug,enabled,log,debug,trying,to,connect,to,to,socket,from,local,address,from,address,with,timeout,timeout,try,socket,socket,new,socket,socket,address,bind,p,new,inet,socket,address,from,address,0,socket,bind,bind,p,socket,connect,to,socket,timeout,return,true,catch,exception,ex,string,message,failed,to,connect,from,address,from,address,ex,get,message,if,log,is,debug,enabled,log,debug,message,ex,else,if,log,failed,log,info,message,return,false
ConnectionUtils -> private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket, 										int timeout, boolean logFailed) throws IOException;1457084088;@param fromAddress The address to connect from._@param toSocket The socket address to connect to._@param timeout The timeout fr the connection._@param logFailed Flag to indicate whether to log failed attempts on info level_(failed attempts are always logged on DEBUG level)._@return True, if the connection was successful, false otherwise._@throws IOException Thrown if the socket cleanup fails.;private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,_										int timeout, boolean logFailed) throws IOException_	{_		if (LOG.isDebugEnabled()) {_			LOG.debug("Trying to connect to (" + toSocket + ") from local address " + fromAddress_					+ " with timeout " + timeout)__		}_		try (Socket socket = new Socket()) {_			_			SocketAddress bindP = new InetSocketAddress(fromAddress, 0)__			_			socket.bind(bindP)__			socket.connect(toSocket, timeout)__			return true__		}_		catch (Exception ex) {_			String message = "Failed to connect from address '" + fromAddress + "': " + ex.getMessage()__			if (LOG.isDebugEnabled()) {_				LOG.debug(message, ex)__			} else if (logFailed) {_				LOG.info(message)__			}_			return false__		}_	};param,from,address,the,address,to,connect,from,param,to,socket,the,socket,address,to,connect,to,param,timeout,the,timeout,fr,the,connection,param,log,failed,flag,to,indicate,whether,to,log,failed,attempts,on,info,level,failed,attempts,are,always,logged,on,debug,level,return,true,if,the,connection,was,successful,false,otherwise,throws,ioexception,thrown,if,the,socket,cleanup,fails;private,static,boolean,try,to,connect,inet,address,from,address,socket,address,to,socket,int,timeout,boolean,log,failed,throws,ioexception,if,log,is,debug,enabled,log,debug,trying,to,connect,to,to,socket,from,local,address,from,address,with,timeout,timeout,try,socket,socket,new,socket,socket,address,bind,p,new,inet,socket,address,from,address,0,socket,bind,bind,p,socket,connect,to,socket,timeout,return,true,catch,exception,ex,string,message,failed,to,connect,from,address,from,address,ex,get,message,if,log,is,debug,enabled,log,debug,message,ex,else,if,log,failed,log,info,message,return,false
ConnectionUtils -> private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket, 										int timeout, boolean logFailed) throws IOException;1463757966;@param fromAddress The address to connect from._@param toSocket The socket address to connect to._@param timeout The timeout fr the connection._@param logFailed Flag to indicate whether to log failed attempts on info level_(failed attempts are always logged on DEBUG level)._@return True, if the connection was successful, false otherwise._@throws IOException Thrown if the socket cleanup fails.;private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,_										int timeout, boolean logFailed) throws IOException_	{_		if (LOG.isDebugEnabled()) {_			LOG.debug("Trying to connect to (" + toSocket + ") from local address " + fromAddress_					+ " with timeout " + timeout)__		}_		try (Socket socket = new Socket()) {_			_			SocketAddress bindP = new InetSocketAddress(fromAddress, 0)__			_			socket.bind(bindP)__			socket.connect(toSocket, timeout)__			return true__		}_		catch (Exception ex) {_			String message = "Failed to connect from address '" + fromAddress + "': " + ex.getMessage()__			if (LOG.isDebugEnabled()) {_				LOG.debug(message, ex)__			} else if (logFailed) {_				LOG.info(message)__			}_			return false__		}_	};param,from,address,the,address,to,connect,from,param,to,socket,the,socket,address,to,connect,to,param,timeout,the,timeout,fr,the,connection,param,log,failed,flag,to,indicate,whether,to,log,failed,attempts,on,info,level,failed,attempts,are,always,logged,on,debug,level,return,true,if,the,connection,was,successful,false,otherwise,throws,ioexception,thrown,if,the,socket,cleanup,fails;private,static,boolean,try,to,connect,inet,address,from,address,socket,address,to,socket,int,timeout,boolean,log,failed,throws,ioexception,if,log,is,debug,enabled,log,debug,trying,to,connect,to,to,socket,from,local,address,from,address,with,timeout,timeout,try,socket,socket,new,socket,socket,address,bind,p,new,inet,socket,address,from,address,0,socket,bind,bind,p,socket,connect,to,socket,timeout,return,true,catch,exception,ex,string,message,failed,to,connect,from,address,from,address,ex,get,message,if,log,is,debug,enabled,log,debug,message,ex,else,if,log,failed,log,info,message,return,false
ConnectionUtils -> private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket, 										int timeout, boolean logFailed) throws IOException;1472226799;@param fromAddress The address to connect from._@param toSocket The socket address to connect to._@param timeout The timeout fr the connection._@param logFailed Flag to indicate whether to log failed attempts on info level_(failed attempts are always logged on DEBUG level)._@return True, if the connection was successful, false otherwise._@throws IOException Thrown if the socket cleanup fails.;private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,_										int timeout, boolean logFailed) throws IOException_	{_		if (LOG.isDebugEnabled()) {_			LOG.debug("Trying to connect to (" + toSocket + ") from local address " + fromAddress_					+ " with timeout " + timeout)__		}_		try (Socket socket = new Socket()) {_			_			SocketAddress bindP = new InetSocketAddress(fromAddress, 0)__			_			socket.bind(bindP)__			socket.connect(toSocket, timeout)__			return true__		}_		catch (Exception ex) {_			String message = "Failed to connect from address '" + fromAddress + "': " + ex.getMessage()__			if (LOG.isDebugEnabled()) {_				LOG.debug(message, ex)__			} else if (logFailed) {_				LOG.info(message)__			}_			return false__		}_	};param,from,address,the,address,to,connect,from,param,to,socket,the,socket,address,to,connect,to,param,timeout,the,timeout,fr,the,connection,param,log,failed,flag,to,indicate,whether,to,log,failed,attempts,on,info,level,failed,attempts,are,always,logged,on,debug,level,return,true,if,the,connection,was,successful,false,otherwise,throws,ioexception,thrown,if,the,socket,cleanup,fails;private,static,boolean,try,to,connect,inet,address,from,address,socket,address,to,socket,int,timeout,boolean,log,failed,throws,ioexception,if,log,is,debug,enabled,log,debug,trying,to,connect,to,to,socket,from,local,address,from,address,with,timeout,timeout,try,socket,socket,new,socket,socket,address,bind,p,new,inet,socket,address,from,address,0,socket,bind,bind,p,socket,connect,to,socket,timeout,return,true,catch,exception,ex,string,message,failed,to,connect,from,address,from,address,ex,get,message,if,log,is,debug,enabled,log,debug,message,ex,else,if,log,failed,log,info,message,return,false
ConnectionUtils -> private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket, 										int timeout, boolean logFailed) throws IOException;1484160227;@param fromAddress The address to connect from._@param toSocket The socket address to connect to._@param timeout The timeout fr the connection._@param logFailed Flag to indicate whether to log failed attempts on info level_(failed attempts are always logged on DEBUG level)._@return True, if the connection was successful, false otherwise._@throws IOException Thrown if the socket cleanup fails.;private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,_										int timeout, boolean logFailed) throws IOException_	{_		if (LOG.isDebugEnabled()) {_			LOG.debug("Trying to connect to (" + toSocket + ") from local address " + fromAddress_					+ " with timeout " + timeout)__		}_		try (Socket socket = new Socket()) {_			_			SocketAddress bindP = new InetSocketAddress(fromAddress, 0)__			_			socket.bind(bindP)__			socket.connect(toSocket, timeout)__			return true__		}_		catch (Exception ex) {_			String message = "Failed to connect from address '" + fromAddress + "': " + ex.getMessage()__			if (LOG.isDebugEnabled()) {_				LOG.debug(message, ex)__			} else if (logFailed) {_				LOG.info(message)__			}_			return false__		}_	};param,from,address,the,address,to,connect,from,param,to,socket,the,socket,address,to,connect,to,param,timeout,the,timeout,fr,the,connection,param,log,failed,flag,to,indicate,whether,to,log,failed,attempts,on,info,level,failed,attempts,are,always,logged,on,debug,level,return,true,if,the,connection,was,successful,false,otherwise,throws,ioexception,thrown,if,the,socket,cleanup,fails;private,static,boolean,try,to,connect,inet,address,from,address,socket,address,to,socket,int,timeout,boolean,log,failed,throws,ioexception,if,log,is,debug,enabled,log,debug,trying,to,connect,to,to,socket,from,local,address,from,address,with,timeout,timeout,try,socket,socket,new,socket,socket,address,bind,p,new,inet,socket,address,from,address,0,socket,bind,bind,p,socket,connect,to,socket,timeout,return,true,catch,exception,ex,string,message,failed,to,connect,from,address,from,address,ex,get,message,if,log,is,debug,enabled,log,debug,message,ex,else,if,log,failed,log,info,message,return,false
ConnectionUtils -> private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket, 										int timeout, boolean logFailed) throws IOException;1499164413;@param fromAddress The address to connect from._@param toSocket The socket address to connect to._@param timeout The timeout fr the connection._@param logFailed Flag to indicate whether to log failed attempts on info level_(failed attempts are always logged on DEBUG level)._@return True, if the connection was successful, false otherwise._@throws IOException Thrown if the socket cleanup fails.;private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,_										int timeout, boolean logFailed) throws IOException {_		if (LOG.isDebugEnabled()) {_			LOG.debug("Trying to connect to (" + toSocket + ") from local address " + fromAddress_					+ " with timeout " + timeout)__		}_		try (Socket socket = new Socket()) {_			_			SocketAddress bindP = new InetSocketAddress(fromAddress, 0)__			_			socket.bind(bindP)__			socket.connect(toSocket, timeout)__			return true__		}_		catch (Exception ex) {_			String message = "Failed to connect from address '" + fromAddress + "': " + ex.getMessage()__			if (LOG.isDebugEnabled()) {_				LOG.debug(message, ex)__			} else if (logFailed) {_				LOG.info(message)__			}_			return false__		}_	};param,from,address,the,address,to,connect,from,param,to,socket,the,socket,address,to,connect,to,param,timeout,the,timeout,fr,the,connection,param,log,failed,flag,to,indicate,whether,to,log,failed,attempts,on,info,level,failed,attempts,are,always,logged,on,debug,level,return,true,if,the,connection,was,successful,false,otherwise,throws,ioexception,thrown,if,the,socket,cleanup,fails;private,static,boolean,try,to,connect,inet,address,from,address,socket,address,to,socket,int,timeout,boolean,log,failed,throws,ioexception,if,log,is,debug,enabled,log,debug,trying,to,connect,to,to,socket,from,local,address,from,address,with,timeout,timeout,try,socket,socket,new,socket,socket,address,bind,p,new,inet,socket,address,from,address,0,socket,bind,bind,p,socket,connect,to,socket,timeout,return,true,catch,exception,ex,string,message,failed,to,connect,from,address,from,address,ex,get,message,if,log,is,debug,enabled,log,debug,message,ex,else,if,log,failed,log,info,message,return,false
ConnectionUtils -> private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket, 										int timeout, boolean logFailed) throws IOException;1516028608;@param fromAddress The address to connect from._@param toSocket The socket address to connect to._@param timeout The timeout fr the connection._@param logFailed Flag to indicate whether to log failed attempts on info level_(failed attempts are always logged on DEBUG level)._@return True, if the connection was successful, false otherwise._@throws IOException Thrown if the socket cleanup fails.;private static boolean tryToConnect(InetAddress fromAddress, SocketAddress toSocket,_										int timeout, boolean logFailed) throws IOException {_		if (LOG.isDebugEnabled()) {_			LOG.debug("Trying to connect to (" + toSocket + ") from local address " + fromAddress_					+ " with timeout " + timeout)__		}_		try (Socket socket = new Socket()) {_			_			SocketAddress bindP = new InetSocketAddress(fromAddress, 0)__			_			socket.bind(bindP)__			socket.connect(toSocket, timeout)__			return true__		}_		catch (Exception ex) {_			String message = "Failed to connect from address '" + fromAddress + "': " + ex.getMessage()__			if (LOG.isDebugEnabled()) {_				LOG.debug(message, ex)__			} else if (logFailed) {_				LOG.info(message)__			}_			return false__		}_	};param,from,address,the,address,to,connect,from,param,to,socket,the,socket,address,to,connect,to,param,timeout,the,timeout,fr,the,connection,param,log,failed,flag,to,indicate,whether,to,log,failed,attempts,on,info,level,failed,attempts,are,always,logged,on,debug,level,return,true,if,the,connection,was,successful,false,otherwise,throws,ioexception,thrown,if,the,socket,cleanup,fails;private,static,boolean,try,to,connect,inet,address,from,address,socket,address,to,socket,int,timeout,boolean,log,failed,throws,ioexception,if,log,is,debug,enabled,log,debug,trying,to,connect,to,to,socket,from,local,address,from,address,with,timeout,timeout,try,socket,socket,new,socket,socket,address,bind,p,new,inet,socket,address,from,address,0,socket,bind,bind,p,socket,connect,to,socket,timeout,return,true,catch,exception,ex,string,message,failed,to,connect,from,address,from,address,ex,get,message,if,log,is,debug,enabled,log,debug,message,ex,else,if,log,failed,log,info,message,return,false
ConnectionUtils -> private static InetAddress tryLocalHostBeforeReturning( 				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException;1447771086;This utility method tries to connect to the JobManager using the InetAddress returned by_InetAddress.getLocalHost(). The purpose of the utility is to have a final try connecting to_the target address using the LocalHost before using the address returned._We do a second try because the JM might have been unavailable during the first check.__@param preliminaryResult The address detected by the heuristic_@return either the preliminaryResult or the address returned by InetAddress.getLocalHost() (if_we are able to connect to targetAddress from there);private static InetAddress tryLocalHostBeforeReturning(_				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException {_		_		InetAddress localhostName = InetAddress.getLocalHost()__		_		if (preliminaryResult.equals(localhostName)) {_			_			return preliminaryResult__		}_		else if (tryToConnect(localhostName, targetAddress, AddressDetectionState.SLOW_CONNECT.getTimeout(), logging)) {_			_			LOG.debug("Preferring {} (InetAddress.getLocalHost()) for local bind point over previous candidate {}",_					localhostName, preliminaryResult)__			return localhostName__		}_		else {_			_			return preliminaryResult__		}_	};this,utility,method,tries,to,connect,to,the,job,manager,using,the,inet,address,returned,by,inet,address,get,local,host,the,purpose,of,the,utility,is,to,have,a,final,try,connecting,to,the,target,address,using,the,local,host,before,using,the,address,returned,we,do,a,second,try,because,the,jm,might,have,been,unavailable,during,the,first,check,param,preliminary,result,the,address,detected,by,the,heuristic,return,either,the,preliminary,result,or,the,address,returned,by,inet,address,get,local,host,if,we,are,able,to,connect,to,target,address,from,there;private,static,inet,address,try,local,host,before,returning,inet,address,preliminary,result,socket,address,target,address,boolean,logging,throws,ioexception,inet,address,localhost,name,inet,address,get,local,host,if,preliminary,result,equals,localhost,name,return,preliminary,result,else,if,try,to,connect,localhost,name,target,address,address,detection,state,get,timeout,logging,log,debug,preferring,inet,address,get,local,host,for,local,bind,point,over,previous,candidate,localhost,name,preliminary,result,return,localhost,name,else,return,preliminary,result
ConnectionUtils -> private static InetAddress tryLocalHostBeforeReturning( 				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException;1457084088;This utility method tries to connect to the JobManager using the InetAddress returned by_InetAddress.getLocalHost(). The purpose of the utility is to have a final try connecting to_the target address using the LocalHost before using the address returned._We do a second try because the JM might have been unavailable during the first check.__@param preliminaryResult The address detected by the heuristic_@return either the preliminaryResult or the address returned by InetAddress.getLocalHost() (if_we are able to connect to targetAddress from there);private static InetAddress tryLocalHostBeforeReturning(_				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException {_		_		InetAddress localhostName = InetAddress.getLocalHost()__		_		if (preliminaryResult.equals(localhostName)) {_			_			return preliminaryResult__		}_		else if (tryToConnect(localhostName, targetAddress, AddressDetectionState.SLOW_CONNECT.getTimeout(), logging)) {_			_			LOG.debug("Preferring {} (InetAddress.getLocalHost()) for local bind point over previous candidate {}",_					localhostName, preliminaryResult)__			return localhostName__		}_		else {_			_			return preliminaryResult__		}_	};this,utility,method,tries,to,connect,to,the,job,manager,using,the,inet,address,returned,by,inet,address,get,local,host,the,purpose,of,the,utility,is,to,have,a,final,try,connecting,to,the,target,address,using,the,local,host,before,using,the,address,returned,we,do,a,second,try,because,the,jm,might,have,been,unavailable,during,the,first,check,param,preliminary,result,the,address,detected,by,the,heuristic,return,either,the,preliminary,result,or,the,address,returned,by,inet,address,get,local,host,if,we,are,able,to,connect,to,target,address,from,there;private,static,inet,address,try,local,host,before,returning,inet,address,preliminary,result,socket,address,target,address,boolean,logging,throws,ioexception,inet,address,localhost,name,inet,address,get,local,host,if,preliminary,result,equals,localhost,name,return,preliminary,result,else,if,try,to,connect,localhost,name,target,address,address,detection,state,get,timeout,logging,log,debug,preferring,inet,address,get,local,host,for,local,bind,point,over,previous,candidate,localhost,name,preliminary,result,return,localhost,name,else,return,preliminary,result
ConnectionUtils -> private static InetAddress tryLocalHostBeforeReturning( 				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException;1463757966;This utility method tries to connect to the JobManager using the InetAddress returned by_InetAddress.getLocalHost(). The purpose of the utility is to have a final try connecting to_the target address using the LocalHost before using the address returned._We do a second try because the JM might have been unavailable during the first check.__@param preliminaryResult The address detected by the heuristic_@return either the preliminaryResult or the address returned by InetAddress.getLocalHost() (if_we are able to connect to targetAddress from there);private static InetAddress tryLocalHostBeforeReturning(_				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException {_		_		InetAddress localhostName = InetAddress.getLocalHost()__		_		if (preliminaryResult.equals(localhostName)) {_			_			return preliminaryResult__		}_		else if (tryToConnect(localhostName, targetAddress, AddressDetectionState.SLOW_CONNECT.getTimeout(), logging)) {_			_			LOG.debug("Preferring {} (InetAddress.getLocalHost()) for local bind point over previous candidate {}",_					localhostName, preliminaryResult)__			return localhostName__		}_		else {_			_			return preliminaryResult__		}_	};this,utility,method,tries,to,connect,to,the,job,manager,using,the,inet,address,returned,by,inet,address,get,local,host,the,purpose,of,the,utility,is,to,have,a,final,try,connecting,to,the,target,address,using,the,local,host,before,using,the,address,returned,we,do,a,second,try,because,the,jm,might,have,been,unavailable,during,the,first,check,param,preliminary,result,the,address,detected,by,the,heuristic,return,either,the,preliminary,result,or,the,address,returned,by,inet,address,get,local,host,if,we,are,able,to,connect,to,target,address,from,there;private,static,inet,address,try,local,host,before,returning,inet,address,preliminary,result,socket,address,target,address,boolean,logging,throws,ioexception,inet,address,localhost,name,inet,address,get,local,host,if,preliminary,result,equals,localhost,name,return,preliminary,result,else,if,try,to,connect,localhost,name,target,address,address,detection,state,get,timeout,logging,log,debug,preferring,inet,address,get,local,host,for,local,bind,point,over,previous,candidate,localhost,name,preliminary,result,return,localhost,name,else,return,preliminary,result
ConnectionUtils -> private static InetAddress tryLocalHostBeforeReturning( 				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException;1472226799;This utility method tries to connect to the JobManager using the InetAddress returned by_InetAddress.getLocalHost(). The purpose of the utility is to have a final try connecting to_the target address using the LocalHost before using the address returned._We do a second try because the JM might have been unavailable during the first check.__@param preliminaryResult The address detected by the heuristic_@return either the preliminaryResult or the address returned by InetAddress.getLocalHost() (if_we are able to connect to targetAddress from there);private static InetAddress tryLocalHostBeforeReturning(_				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException {_		_		InetAddress localhostName = InetAddress.getLocalHost()__		_		if (preliminaryResult.equals(localhostName)) {_			_			return preliminaryResult__		}_		else if (tryToConnect(localhostName, targetAddress, AddressDetectionState.SLOW_CONNECT.getTimeout(), logging)) {_			_			LOG.debug("Preferring {} (InetAddress.getLocalHost()) for local bind point over previous candidate {}",_					localhostName, preliminaryResult)__			return localhostName__		}_		else {_			_			return preliminaryResult__		}_	};this,utility,method,tries,to,connect,to,the,job,manager,using,the,inet,address,returned,by,inet,address,get,local,host,the,purpose,of,the,utility,is,to,have,a,final,try,connecting,to,the,target,address,using,the,local,host,before,using,the,address,returned,we,do,a,second,try,because,the,jm,might,have,been,unavailable,during,the,first,check,param,preliminary,result,the,address,detected,by,the,heuristic,return,either,the,preliminary,result,or,the,address,returned,by,inet,address,get,local,host,if,we,are,able,to,connect,to,target,address,from,there;private,static,inet,address,try,local,host,before,returning,inet,address,preliminary,result,socket,address,target,address,boolean,logging,throws,ioexception,inet,address,localhost,name,inet,address,get,local,host,if,preliminary,result,equals,localhost,name,return,preliminary,result,else,if,try,to,connect,localhost,name,target,address,address,detection,state,get,timeout,logging,log,debug,preferring,inet,address,get,local,host,for,local,bind,point,over,previous,candidate,localhost,name,preliminary,result,return,localhost,name,else,return,preliminary,result
ConnectionUtils -> private static InetAddress tryLocalHostBeforeReturning( 				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException;1484160227;This utility method tries to connect to the JobManager using the InetAddress returned by_InetAddress.getLocalHost(). The purpose of the utility is to have a final try connecting to_the target address using the LocalHost before using the address returned._We do a second try because the JM might have been unavailable during the first check.__@param preliminaryResult The address detected by the heuristic_@return either the preliminaryResult or the address returned by InetAddress.getLocalHost() (if_we are able to connect to targetAddress from there);private static InetAddress tryLocalHostBeforeReturning(_				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException {_		_		InetAddress localhostName = InetAddress.getLocalHost()__		_		if (preliminaryResult.equals(localhostName)) {_			_			return preliminaryResult__		}_		else if (tryToConnect(localhostName, targetAddress, AddressDetectionState.SLOW_CONNECT.getTimeout(), logging)) {_			_			LOG.debug("Preferring {} (InetAddress.getLocalHost()) for local bind point over previous candidate {}",_					localhostName, preliminaryResult)__			return localhostName__		}_		else {_			_			return preliminaryResult__		}_	};this,utility,method,tries,to,connect,to,the,job,manager,using,the,inet,address,returned,by,inet,address,get,local,host,the,purpose,of,the,utility,is,to,have,a,final,try,connecting,to,the,target,address,using,the,local,host,before,using,the,address,returned,we,do,a,second,try,because,the,jm,might,have,been,unavailable,during,the,first,check,param,preliminary,result,the,address,detected,by,the,heuristic,return,either,the,preliminary,result,or,the,address,returned,by,inet,address,get,local,host,if,we,are,able,to,connect,to,target,address,from,there;private,static,inet,address,try,local,host,before,returning,inet,address,preliminary,result,socket,address,target,address,boolean,logging,throws,ioexception,inet,address,localhost,name,inet,address,get,local,host,if,preliminary,result,equals,localhost,name,return,preliminary,result,else,if,try,to,connect,localhost,name,target,address,address,detection,state,get,timeout,logging,log,debug,preferring,inet,address,get,local,host,for,local,bind,point,over,previous,candidate,localhost,name,preliminary,result,return,localhost,name,else,return,preliminary,result
ConnectionUtils -> private static InetAddress tryLocalHostBeforeReturning( 				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException;1499164413;This utility method tries to connect to the JobManager using the InetAddress returned by_InetAddress.getLocalHost(). The purpose of the utility is to have a final try connecting to_the target address using the LocalHost before using the address returned._We do a second try because the JM might have been unavailable during the first check.__@param preliminaryResult The address detected by the heuristic_@return either the preliminaryResult or the address returned by InetAddress.getLocalHost() (if_we are able to connect to targetAddress from there);private static InetAddress tryLocalHostBeforeReturning(_				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException {__		InetAddress localhostName = InetAddress.getLocalHost()___		if (preliminaryResult.equals(localhostName)) {_			_			return preliminaryResult__		}_		else if (tryToConnect(localhostName, targetAddress, AddressDetectionState.SLOW_CONNECT.getTimeout(), logging)) {_			_			LOG.debug("Preferring {} (InetAddress.getLocalHost()) for local bind point over previous candidate {}",_					localhostName, preliminaryResult)__			return localhostName__		}_		else {_			_			return preliminaryResult__		}_	};this,utility,method,tries,to,connect,to,the,job,manager,using,the,inet,address,returned,by,inet,address,get,local,host,the,purpose,of,the,utility,is,to,have,a,final,try,connecting,to,the,target,address,using,the,local,host,before,using,the,address,returned,we,do,a,second,try,because,the,jm,might,have,been,unavailable,during,the,first,check,param,preliminary,result,the,address,detected,by,the,heuristic,return,either,the,preliminary,result,or,the,address,returned,by,inet,address,get,local,host,if,we,are,able,to,connect,to,target,address,from,there;private,static,inet,address,try,local,host,before,returning,inet,address,preliminary,result,socket,address,target,address,boolean,logging,throws,ioexception,inet,address,localhost,name,inet,address,get,local,host,if,preliminary,result,equals,localhost,name,return,preliminary,result,else,if,try,to,connect,localhost,name,target,address,address,detection,state,get,timeout,logging,log,debug,preferring,inet,address,get,local,host,for,local,bind,point,over,previous,candidate,localhost,name,preliminary,result,return,localhost,name,else,return,preliminary,result
ConnectionUtils -> private static InetAddress tryLocalHostBeforeReturning( 				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException;1516028608;This utility method tries to connect to the JobManager using the InetAddress returned by_InetAddress.getLocalHost(). The purpose of the utility is to have a final try connecting to_the target address using the LocalHost before using the address returned._We do a second try because the JM might have been unavailable during the first check.__@param preliminaryResult The address detected by the heuristic_@return either the preliminaryResult or the address returned by InetAddress.getLocalHost() (if_we are able to connect to targetAddress from there);private static InetAddress tryLocalHostBeforeReturning(_				InetAddress preliminaryResult, SocketAddress targetAddress, boolean logging) throws IOException {__		InetAddress localhostName = InetAddress.getLocalHost()___		if (preliminaryResult.equals(localhostName)) {_			_			return preliminaryResult__		}_		else if (tryToConnect(localhostName, targetAddress, AddressDetectionState.SLOW_CONNECT.getTimeout(), logging)) {_			_			LOG.debug("Preferring {} (InetAddress.getLocalHost()) for local bind point over previous candidate {}",_					localhostName, preliminaryResult)__			return localhostName__		}_		else {_			_			return preliminaryResult__		}_	};this,utility,method,tries,to,connect,to,the,job,manager,using,the,inet,address,returned,by,inet,address,get,local,host,the,purpose,of,the,utility,is,to,have,a,final,try,connecting,to,the,target,address,using,the,local,host,before,using,the,address,returned,we,do,a,second,try,because,the,jm,might,have,been,unavailable,during,the,first,check,param,preliminary,result,the,address,detected,by,the,heuristic,return,either,the,preliminary,result,or,the,address,returned,by,inet,address,get,local,host,if,we,are,able,to,connect,to,target,address,from,there;private,static,inet,address,try,local,host,before,returning,inet,address,preliminary,result,socket,address,target,address,boolean,logging,throws,ioexception,inet,address,localhost,name,inet,address,get,local,host,if,preliminary,result,equals,localhost,name,return,preliminary,result,else,if,try,to,connect,localhost,name,target,address,address,detection,state,get,timeout,logging,log,debug,preferring,inet,address,get,local,host,for,local,bind,point,over,previous,candidate,localhost,name,preliminary,result,return,localhost,name,else,return,preliminary,result
ConnectionUtils -> private static boolean hasCommonPrefix(byte[] address, byte[] address2);1443682795;Checks if two addresses have a common prefix (first 2 bytes)._Example: 192.168.???.???_Works also with ipv6, but accepts probably too many addresses;private static boolean hasCommonPrefix(byte[] address, byte[] address2) {_		return address[0] == address2[0] && address[1] == address2[1]__	};checks,if,two,addresses,have,a,common,prefix,first,2,bytes,example,192,168,works,also,with,ipv6,but,accepts,probably,too,many,addresses;private,static,boolean,has,common,prefix,byte,address,byte,address2,return,address,0,address2,0,address,1,address2,1
ConnectionUtils -> private static boolean hasCommonPrefix(byte[] address, byte[] address2);1443682796;Checks if two addresses have a common prefix (first 2 bytes)._Example: 192.168.???.???_Works also with ipv6, but accepts probably too many addresses;private static boolean hasCommonPrefix(byte[] address, byte[] address2) {_		return address[0] == address2[0] && address[1] == address2[1]__	};checks,if,two,addresses,have,a,common,prefix,first,2,bytes,example,192,168,works,also,with,ipv6,but,accepts,probably,too,many,addresses;private,static,boolean,has,common,prefix,byte,address,byte,address2,return,address,0,address2,0,address,1,address2,1
ConnectionUtils -> private static boolean hasCommonPrefix(byte[] address, byte[] address2);1447771086;Checks if two addresses have a common prefix (first 2 bytes)._Example: 192.168.???.???_Works also with ipv6, but accepts probably too many addresses;private static boolean hasCommonPrefix(byte[] address, byte[] address2) {_		return address[0] == address2[0] && address[1] == address2[1]__	};checks,if,two,addresses,have,a,common,prefix,first,2,bytes,example,192,168,works,also,with,ipv6,but,accepts,probably,too,many,addresses;private,static,boolean,has,common,prefix,byte,address,byte,address2,return,address,0,address2,0,address,1,address2,1
ConnectionUtils -> private static boolean hasCommonPrefix(byte[] address, byte[] address2);1457084088;Checks if two addresses have a common prefix (first 2 bytes)._Example: 192.168.???.???_Works also with ipv6, but accepts probably too many addresses;private static boolean hasCommonPrefix(byte[] address, byte[] address2) {_		return address[0] == address2[0] && address[1] == address2[1]__	};checks,if,two,addresses,have,a,common,prefix,first,2,bytes,example,192,168,works,also,with,ipv6,but,accepts,probably,too,many,addresses;private,static,boolean,has,common,prefix,byte,address,byte,address2,return,address,0,address2,0,address,1,address2,1
ConnectionUtils -> private static boolean hasCommonPrefix(byte[] address, byte[] address2);1463757966;Checks if two addresses have a common prefix (first 2 bytes)._Example: 192.168.???.???_Works also with ipv6, but accepts probably too many addresses;private static boolean hasCommonPrefix(byte[] address, byte[] address2) {_		return address[0] == address2[0] && address[1] == address2[1]__	};checks,if,two,addresses,have,a,common,prefix,first,2,bytes,example,192,168,works,also,with,ipv6,but,accepts,probably,too,many,addresses;private,static,boolean,has,common,prefix,byte,address,byte,address2,return,address,0,address2,0,address,1,address2,1
ConnectionUtils -> private static boolean hasCommonPrefix(byte[] address, byte[] address2);1472226799;Checks if two addresses have a common prefix (first 2 bytes)._Example: 192.168.???.???_Works also with ipv6, but accepts probably too many addresses;private static boolean hasCommonPrefix(byte[] address, byte[] address2) {_		return address[0] == address2[0] && address[1] == address2[1]__	};checks,if,two,addresses,have,a,common,prefix,first,2,bytes,example,192,168,works,also,with,ipv6,but,accepts,probably,too,many,addresses;private,static,boolean,has,common,prefix,byte,address,byte,address2,return,address,0,address2,0,address,1,address2,1
ConnectionUtils -> private static boolean hasCommonPrefix(byte[] address, byte[] address2);1484160227;Checks if two addresses have a common prefix (first 2 bytes)._Example: 192.168.???.???_Works also with ipv6, but accepts probably too many addresses;private static boolean hasCommonPrefix(byte[] address, byte[] address2) {_		return address[0] == address2[0] && address[1] == address2[1]__	};checks,if,two,addresses,have,a,common,prefix,first,2,bytes,example,192,168,works,also,with,ipv6,but,accepts,probably,too,many,addresses;private,static,boolean,has,common,prefix,byte,address,byte,address2,return,address,0,address2,0,address,1,address2,1
ConnectionUtils -> private static boolean hasCommonPrefix(byte[] address, byte[] address2);1499164413;Checks if two addresses have a common prefix (first 2 bytes)._Example: 192.168.???.???_Works also with ipv6, but accepts probably too many addresses;private static boolean hasCommonPrefix(byte[] address, byte[] address2) {_		return address[0] == address2[0] && address[1] == address2[1]__	};checks,if,two,addresses,have,a,common,prefix,first,2,bytes,example,192,168,works,also,with,ipv6,but,accepts,probably,too,many,addresses;private,static,boolean,has,common,prefix,byte,address,byte,address2,return,address,0,address2,0,address,1,address2,1
ConnectionUtils -> private static boolean hasCommonPrefix(byte[] address, byte[] address2);1516028608;Checks if two addresses have a common prefix (first 2 bytes)._Example: 192.168.???.???_Works also with ipv6, but accepts probably too many addresses;private static boolean hasCommonPrefix(byte[] address, byte[] address2) {_		return address[0] == address2[0] && address[1] == address2[1]__	};checks,if,two,addresses,have,a,common,prefix,first,2,bytes,example,192,168,works,also,with,ipv6,but,accepts,probably,too,many,addresses;private,static,boolean,has,common,prefix,byte,address,byte,address2,return,address,0,address2,0,address,1,address2,1
