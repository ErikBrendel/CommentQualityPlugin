# id;timestamp;commentText;codeText;commentWords;codeWords
FailoverRegion -> private void cancel(final long globalModVersionOfFailover);1492496129;cancel all executions in this sub graph;private void cancel(final long globalModVersionOfFailover) {_		while (true) {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				if (transitionState(curStatus, JobStatus.CANCELLING)) {__					_					final ArrayList<Future<?>> futures = new ArrayList<>(connectedExecutionVertexes.size())___					_					for (ExecutionVertex vertex : connectedExecutionVertexes) {_						futures.add(vertex.cancel())__					}__					final FutureUtils.ConjunctFuture allTerminal = FutureUtils.combineAll(futures)__					allTerminal.thenAcceptAsync(new AcceptFunction<Void>() {_						@Override_						public void accept(Void value) {_							allVerticesInTerminalState(globalModVersionOfFailover)__						}_					}, executor)___					break__				}_			}_			else {_				LOG.info("FailoverRegion {} is {} when cancel.", id, state)__				break__			}_		}_	};cancel,all,executions,in,this,sub,graph;private,void,cancel,final,long,global,mod,version,of,failover,while,true,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,if,transition,state,cur,status,job,status,cancelling,final,array,list,future,futures,new,array,list,connected,execution,vertexes,size,for,execution,vertex,vertex,connected,execution,vertexes,futures,add,vertex,cancel,final,future,utils,conjunct,future,all,terminal,future,utils,combine,all,futures,all,terminal,then,accept,async,new,accept,function,void,override,public,void,accept,void,value,all,vertices,in,terminal,state,global,mod,version,of,failover,executor,break,else,log,info,failover,region,is,when,cancel,id,state,break
FailoverRegion -> private void cancel(final long globalModVersionOfFailover);1494516977;cancel all executions in this sub graph;private void cancel(final long globalModVersionOfFailover) {_		while (true) {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				if (transitionState(curStatus, JobStatus.CANCELLING)) {__					_					final ArrayList<Future<?>> futures = new ArrayList<>(connectedExecutionVertexes.size())___					_					for (ExecutionVertex vertex : connectedExecutionVertexes) {_						futures.add(vertex.cancel())__					}__					final FutureUtils.ConjunctFuture<Void> allTerminal = FutureUtils.waitForAll(futures)__					allTerminal.thenAcceptAsync(new AcceptFunction<Void>() {_						@Override_						public void accept(Void value) {_							allVerticesInTerminalState(globalModVersionOfFailover)__						}_					}, executor)___					break__				}_			}_			else {_				LOG.info("FailoverRegion {} is {} when cancel.", id, state)__				break__			}_		}_	};cancel,all,executions,in,this,sub,graph;private,void,cancel,final,long,global,mod,version,of,failover,while,true,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,if,transition,state,cur,status,job,status,cancelling,final,array,list,future,futures,new,array,list,connected,execution,vertexes,size,for,execution,vertex,vertex,connected,execution,vertexes,futures,add,vertex,cancel,final,future,utils,conjunct,future,void,all,terminal,future,utils,wait,for,all,futures,all,terminal,then,accept,async,new,accept,function,void,override,public,void,accept,void,value,all,vertices,in,terminal,state,global,mod,version,of,failover,executor,break,else,log,info,failover,region,is,when,cancel,id,state,break
FailoverRegion -> private void cancel(final long globalModVersionOfFailover);1501511601;cancel all executions in this sub graph;private void cancel(final long globalModVersionOfFailover) {_		while (true) {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				if (transitionState(curStatus, JobStatus.CANCELLING)) {__					_					final ArrayList<CompletableFuture<?>> futures = new ArrayList<>(connectedExecutionVertexes.size())___					_					for (ExecutionVertex vertex : connectedExecutionVertexes) {_						futures.add(vertex.cancel())__					}__					final FutureUtils.ConjunctFuture<Void> allTerminal = FutureUtils.waitForAll(futures)__					allTerminal.thenAcceptAsync(_						(Void value) -> allVerticesInTerminalState(globalModVersionOfFailover),_						executor)___					break__				}_			}_			else {_				LOG.info("FailoverRegion {} is {} when cancel.", id, state)__				break__			}_		}_	};cancel,all,executions,in,this,sub,graph;private,void,cancel,final,long,global,mod,version,of,failover,while,true,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,if,transition,state,cur,status,job,status,cancelling,final,array,list,completable,future,futures,new,array,list,connected,execution,vertexes,size,for,execution,vertex,vertex,connected,execution,vertexes,futures,add,vertex,cancel,final,future,utils,conjunct,future,void,all,terminal,future,utils,wait,for,all,futures,all,terminal,then,accept,async,void,value,all,vertices,in,terminal,state,global,mod,version,of,failover,executor,break,else,log,info,failover,region,is,when,cancel,id,state,break
FailoverRegion -> private void cancel(final long globalModVersionOfFailover);1509090423;cancel all executions in this sub graph;private void cancel(final long globalModVersionOfFailover) {_		while (true) {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				if (transitionState(curStatus, JobStatus.CANCELLING)) {__					_					final ArrayList<CompletableFuture<?>> futures = new ArrayList<>(connectedExecutionVertexes.size())___					_					for (ExecutionVertex vertex : connectedExecutionVertexes) {_						futures.add(vertex.cancel())__					}__					final FutureUtils.ConjunctFuture<Void> allTerminal = FutureUtils.waitForAll(futures)__					allTerminal.thenAcceptAsync(_						(Void value) -> allVerticesInTerminalState(globalModVersionOfFailover),_						executor)___					break__				}_			}_			else {_				LOG.info("FailoverRegion {} is {} when cancel.", id, state)__				break__			}_		}_	};cancel,all,executions,in,this,sub,graph;private,void,cancel,final,long,global,mod,version,of,failover,while,true,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,if,transition,state,cur,status,job,status,cancelling,final,array,list,completable,future,futures,new,array,list,connected,execution,vertexes,size,for,execution,vertex,vertex,connected,execution,vertexes,futures,add,vertex,cancel,final,future,utils,conjunct,future,void,all,terminal,future,utils,wait,for,all,futures,all,terminal,then,accept,async,void,value,all,vertices,in,terminal,state,global,mod,version,of,failover,executor,break,else,log,info,failover,region,is,when,cancel,id,state,break
FailoverRegion -> private void cancel(final long globalModVersionOfFailover);1538764056;cancel all executions in this sub graph;private void cancel(final long globalModVersionOfFailover) {_		while (true) {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				if (transitionState(curStatus, JobStatus.CANCELLING)) {__					_					final ArrayList<CompletableFuture<?>> futures = new ArrayList<>(connectedExecutionVertexes.size())___					_					for (ExecutionVertex vertex : connectedExecutionVertexes) {_						futures.add(vertex.cancel())__					}__					final FutureUtils.ConjunctFuture<Void> allTerminal = FutureUtils.waitForAll(futures)__					allTerminal.thenAcceptAsync(_						(Void value) -> allVerticesInTerminalState(globalModVersionOfFailover),_						executor)___					break__				}_			}_			else {_				LOG.info("FailoverRegion {} is {} when cancel.", id, state)__				break__			}_		}_	};cancel,all,executions,in,this,sub,graph;private,void,cancel,final,long,global,mod,version,of,failover,while,true,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,if,transition,state,cur,status,job,status,cancelling,final,array,list,completable,future,futures,new,array,list,connected,execution,vertexes,size,for,execution,vertex,vertex,connected,execution,vertexes,futures,add,vertex,cancel,final,future,utils,conjunct,future,void,all,terminal,future,utils,wait,for,all,futures,all,terminal,then,accept,async,void,value,all,vertices,in,terminal,state,global,mod,version,of,failover,executor,break,else,log,info,failover,region,is,when,cancel,id,state,break
FailoverRegion -> private void cancel(final long globalModVersionOfFailover);1543229263;cancel all executions in this sub graph;private void cancel(final long globalModVersionOfFailover) {_		executionGraph.getJobMasterMainThreadExecutor().assertRunningInMainThread()__		while (true) {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				if (transitionState(curStatus, JobStatus.CANCELLING)) {__					createTerminationFutureOverAllConnectedVertexes()_						.thenAccept((nullptr) -> allVerticesInTerminalState(globalModVersionOfFailover))__					break__				}_			} else {_				LOG.info("FailoverRegion {} is {} when cancel.", id, state)__				break__			}_		}_	};cancel,all,executions,in,this,sub,graph;private,void,cancel,final,long,global,mod,version,of,failover,execution,graph,get,job,master,main,thread,executor,assert,running,in,main,thread,while,true,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,if,transition,state,cur,status,job,status,cancelling,create,termination,future,over,all,connected,vertexes,then,accept,nullptr,all,vertices,in,terminal,state,global,mod,version,of,failover,break,else,log,info,failover,region,is,when,cancel,id,state,break
FailoverRegion -> private void restart(long globalModVersionOfFailover);1492496129;restart all executions in this sub graph;private void restart(long globalModVersionOfFailover) {_		try {_			if (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) {_				_				_				_				_				_				for (ExecutionVertex ev : connectedExecutionVertexes) {_					try {_						ev.scheduleForExecution(_								executionGraph.getSlotProvider(),_								executionGraph.isQueuedSchedulingAllowed())__					}_					catch (Throwable e) {_						failover(globalModVersionOfFailover)__					}_				}_			}_			else {_				LOG.info("FailoverRegion {} switched from CREATED to RUNNING fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		} catch (Exception e) {_			LOG.info("FailoverRegion {} restart failed, failover again.", id, e)__			failover(globalModVersionOfFailover)__		}_	};restart,all,executions,in,this,sub,graph;private,void,restart,long,global,mod,version,of,failover,try,if,transition,state,job,status,created,job,status,running,for,execution,vertex,ev,connected,execution,vertexes,try,ev,schedule,for,execution,execution,graph,get,slot,provider,execution,graph,is,queued,scheduling,allowed,catch,throwable,e,failover,global,mod,version,of,failover,else,log,info,failover,region,switched,from,created,to,running,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,exception,e,log,info,failover,region,restart,failed,failover,again,id,e,failover,global,mod,version,of,failover
FailoverRegion -> private void restart(long globalModVersionOfFailover);1494516977;restart all executions in this sub graph;private void restart(long globalModVersionOfFailover) {_		try {_			if (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) {_				_				_				_				_				_				for (ExecutionVertex ev : connectedExecutionVertexes) {_					try {_						ev.scheduleForExecution(_								executionGraph.getSlotProvider(),_								executionGraph.isQueuedSchedulingAllowed())__					}_					catch (Throwable e) {_						failover(globalModVersionOfFailover)__					}_				}_			}_			else {_				LOG.info("FailoverRegion {} switched from CREATED to RUNNING fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		} catch (Exception e) {_			LOG.info("FailoverRegion {} restart failed, failover again.", id, e)__			failover(globalModVersionOfFailover)__		}_	};restart,all,executions,in,this,sub,graph;private,void,restart,long,global,mod,version,of,failover,try,if,transition,state,job,status,created,job,status,running,for,execution,vertex,ev,connected,execution,vertexes,try,ev,schedule,for,execution,execution,graph,get,slot,provider,execution,graph,is,queued,scheduling,allowed,catch,throwable,e,failover,global,mod,version,of,failover,else,log,info,failover,region,switched,from,created,to,running,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,exception,e,log,info,failover,region,restart,failed,failover,again,id,e,failover,global,mod,version,of,failover
FailoverRegion -> private void restart(long globalModVersionOfFailover);1501511601;restart all executions in this sub graph;private void restart(long globalModVersionOfFailover) {_		try {_			if (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) {_				_				_				_				_				_				for (ExecutionVertex ev : connectedExecutionVertexes) {_					try {_						ev.scheduleForExecution(_								executionGraph.getSlotProvider(),_								executionGraph.isQueuedSchedulingAllowed())__					}_					catch (Throwable e) {_						failover(globalModVersionOfFailover)__					}_				}_			}_			else {_				LOG.info("FailoverRegion {} switched from CREATED to RUNNING fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		} catch (Exception e) {_			LOG.info("FailoverRegion {} restart failed, failover again.", id, e)__			failover(globalModVersionOfFailover)__		}_	};restart,all,executions,in,this,sub,graph;private,void,restart,long,global,mod,version,of,failover,try,if,transition,state,job,status,created,job,status,running,for,execution,vertex,ev,connected,execution,vertexes,try,ev,schedule,for,execution,execution,graph,get,slot,provider,execution,graph,is,queued,scheduling,allowed,catch,throwable,e,failover,global,mod,version,of,failover,else,log,info,failover,region,switched,from,created,to,running,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,exception,e,log,info,failover,region,restart,failed,failover,again,id,e,failover,global,mod,version,of,failover
FailoverRegion -> private void restart(long globalModVersionOfFailover);1509090423;restart all executions in this sub graph;private void restart(long globalModVersionOfFailover) {_		try {_			if (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) {_				_				_				_				_				_				for (ExecutionVertex ev : connectedExecutionVertexes) {_					try {_						ev.scheduleForExecution(_							executionGraph.getSlotProvider(),_							executionGraph.isQueuedSchedulingAllowed(),_							LocationPreferenceConstraint.ANY)_ _					}_					catch (Throwable e) {_						failover(globalModVersionOfFailover)__					}_				}_			}_			else {_				LOG.info("FailoverRegion {} switched from CREATED to RUNNING fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		} catch (Exception e) {_			LOG.info("FailoverRegion {} restart failed, failover again.", id, e)__			failover(globalModVersionOfFailover)__		}_	};restart,all,executions,in,this,sub,graph;private,void,restart,long,global,mod,version,of,failover,try,if,transition,state,job,status,created,job,status,running,for,execution,vertex,ev,connected,execution,vertexes,try,ev,schedule,for,execution,execution,graph,get,slot,provider,execution,graph,is,queued,scheduling,allowed,location,preference,constraint,any,catch,throwable,e,failover,global,mod,version,of,failover,else,log,info,failover,region,switched,from,created,to,running,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,exception,e,log,info,failover,region,restart,failed,failover,again,id,e,failover,global,mod,version,of,failover
FailoverRegion -> private void restart(long globalModVersionOfFailover);1538764056;restart all executions in this sub graph;private void restart(long globalModVersionOfFailover) {_		try {_			if (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) {_				_				_				__				HashSet<AllocationID> previousAllocationsInRegion = new HashSet<>(connectedExecutionVertexes.size())__				for (ExecutionVertex connectedExecutionVertex : connectedExecutionVertexes) {_					AllocationID latestPriorAllocation = connectedExecutionVertex.getLatestPriorAllocation()__					if (latestPriorAllocation != null) {_						previousAllocationsInRegion.add(latestPriorAllocation)__					}_				}__				_				_				for (ExecutionVertex ev : connectedExecutionVertexes) {_					try {_						ev.scheduleForExecution(_							executionGraph.getSlotProvider(),_							executionGraph.isQueuedSchedulingAllowed(),_							LocationPreferenceConstraint.ANY,_							previousAllocationsInRegion)_ _					}_					catch (Throwable e) {_						failover(globalModVersionOfFailover)__					}_				}_			}_			else {_				LOG.info("FailoverRegion {} switched from CREATED to RUNNING fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		} catch (Exception e) {_			LOG.info("FailoverRegion {} restart failed, failover again.", id, e)__			failover(globalModVersionOfFailover)__		}_	};restart,all,executions,in,this,sub,graph;private,void,restart,long,global,mod,version,of,failover,try,if,transition,state,job,status,created,job,status,running,hash,set,allocation,id,previous,allocations,in,region,new,hash,set,connected,execution,vertexes,size,for,execution,vertex,connected,execution,vertex,connected,execution,vertexes,allocation,id,latest,prior,allocation,connected,execution,vertex,get,latest,prior,allocation,if,latest,prior,allocation,null,previous,allocations,in,region,add,latest,prior,allocation,for,execution,vertex,ev,connected,execution,vertexes,try,ev,schedule,for,execution,execution,graph,get,slot,provider,execution,graph,is,queued,scheduling,allowed,location,preference,constraint,any,previous,allocations,in,region,catch,throwable,e,failover,global,mod,version,of,failover,else,log,info,failover,region,switched,from,created,to,running,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,exception,e,log,info,failover,region,restart,failed,failover,again,id,e,failover,global,mod,version,of,failover
FailoverRegion -> private void restart(long globalModVersionOfFailover);1543229263;restart all executions in this sub graph;private void restart(long globalModVersionOfFailover) {_		try {_			if (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) {_				_				_				__				HashSet<AllocationID> previousAllocationsInRegion = new HashSet<>(connectedExecutionVertexes.size())__				for (ExecutionVertex connectedExecutionVertex : connectedExecutionVertexes) {_					AllocationID latestPriorAllocation = connectedExecutionVertex.getLatestPriorAllocation()__					if (latestPriorAllocation != null) {_						previousAllocationsInRegion.add(latestPriorAllocation)__					}_				}__				_				_				for (ExecutionVertex ev : connectedExecutionVertexes) {_					try {_						ev.scheduleForExecution(_							executionGraph.getSlotProvider(),_							executionGraph.isQueuedSchedulingAllowed(),_							LocationPreferenceConstraint.ANY,_							previousAllocationsInRegion)_ _					}_					catch (Throwable e) {_						failover(globalModVersionOfFailover)__					}_				}_			}_			else {_				LOG.info("FailoverRegion {} switched from CREATED to RUNNING fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		} catch (Exception e) {_			LOG.info("FailoverRegion {} restart failed, failover again.", id, e)__			failover(globalModVersionOfFailover)__		}_	};restart,all,executions,in,this,sub,graph;private,void,restart,long,global,mod,version,of,failover,try,if,transition,state,job,status,created,job,status,running,hash,set,allocation,id,previous,allocations,in,region,new,hash,set,connected,execution,vertexes,size,for,execution,vertex,connected,execution,vertex,connected,execution,vertexes,allocation,id,latest,prior,allocation,connected,execution,vertex,get,latest,prior,allocation,if,latest,prior,allocation,null,previous,allocations,in,region,add,latest,prior,allocation,for,execution,vertex,ev,connected,execution,vertexes,try,ev,schedule,for,execution,execution,graph,get,slot,provider,execution,graph,is,queued,scheduling,allowed,location,preference,constraint,any,previous,allocations,in,region,catch,throwable,e,failover,global,mod,version,of,failover,else,log,info,failover,region,switched,from,created,to,running,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,exception,e,log,info,failover,region,restart,failed,failover,again,id,e,failover,global,mod,version,of,failover
FailoverRegion -> public List<ExecutionVertex> getAllExecutionVertexes();1492496129;get all execution vertexes contained in this region;public List<ExecutionVertex> getAllExecutionVertexes() {_		return connectedExecutionVertexes__	};get,all,execution,vertexes,contained,in,this,region;public,list,execution,vertex,get,all,execution,vertexes,return,connected,execution,vertexes
FailoverRegion -> public List<ExecutionVertex> getAllExecutionVertexes();1494516977;get all execution vertexes contained in this region;public List<ExecutionVertex> getAllExecutionVertexes() {_		return connectedExecutionVertexes__	};get,all,execution,vertexes,contained,in,this,region;public,list,execution,vertex,get,all,execution,vertexes,return,connected,execution,vertexes
FailoverRegion -> public List<ExecutionVertex> getAllExecutionVertexes();1501511601;get all execution vertexes contained in this region;public List<ExecutionVertex> getAllExecutionVertexes() {_		return connectedExecutionVertexes__	};get,all,execution,vertexes,contained,in,this,region;public,list,execution,vertex,get,all,execution,vertexes,return,connected,execution,vertexes
FailoverRegion -> public List<ExecutionVertex> getAllExecutionVertexes();1509090423;get all execution vertexes contained in this region;public List<ExecutionVertex> getAllExecutionVertexes() {_		return connectedExecutionVertexes__	};get,all,execution,vertexes,contained,in,this,region;public,list,execution,vertex,get,all,execution,vertexes,return,connected,execution,vertexes
FailoverRegion -> public List<ExecutionVertex> getAllExecutionVertexes();1538764056;get all execution vertexes contained in this region;public List<ExecutionVertex> getAllExecutionVertexes() {_		return connectedExecutionVertexes__	};get,all,execution,vertexes,contained,in,this,region;public,list,execution,vertex,get,all,execution,vertexes,return,connected,execution,vertexes
FailoverRegion -> public List<ExecutionVertex> getAllExecutionVertexes();1543229263;get all execution vertexes contained in this region;public List<ExecutionVertex> getAllExecutionVertexes() {_		return connectedExecutionVertexes__	};get,all,execution,vertexes,contained,in,this,region;public,list,execution,vertex,get,all,execution,vertexes,return,connected,execution,vertexes
FailoverRegion -> private void reset(long globalModVersionOfFailover);1492496129;reset all executions in this sub graph;private void reset(long globalModVersionOfFailover) {_		try {_			_			final Collection<CoLocationGroup> colGroups = new HashSet<>()__			final long restartTimestamp = System.currentTimeMillis()___			for (ExecutionVertex ev : connectedExecutionVertexes) {_				CoLocationGroup cgroup = ev.getJobVertex().getCoLocationGroup()__				if (cgroup != null && !colGroups.contains(cgroup)){_					cgroup.resetConstraints()__					colGroups.add(cgroup)__				}__				ev.resetForNewExecution(restartTimestamp, globalModVersionOfFailover)__			}_			if (transitionState(JobStatus.CANCELED, JobStatus.CREATED)) {_				restart(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} switched from CANCELLING to CREATED fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		}_		catch (GlobalModVersionMismatch e) {_			_			_			state = JobStatus.RUNNING__		}_		catch (Throwable e) {_			LOG.info("FailoverRegion {} reset fail, will failover again.", id)__			failover(globalModVersionOfFailover)__		}_	};reset,all,executions,in,this,sub,graph;private,void,reset,long,global,mod,version,of,failover,try,final,collection,co,location,group,col,groups,new,hash,set,final,long,restart,timestamp,system,current,time,millis,for,execution,vertex,ev,connected,execution,vertexes,co,location,group,cgroup,ev,get,job,vertex,get,co,location,group,if,cgroup,null,col,groups,contains,cgroup,cgroup,reset,constraints,col,groups,add,cgroup,ev,reset,for,new,execution,restart,timestamp,global,mod,version,of,failover,if,transition,state,job,status,canceled,job,status,created,restart,global,mod,version,of,failover,else,log,info,failover,region,switched,from,cancelling,to,created,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,global,mod,version,mismatch,e,state,job,status,running,catch,throwable,e,log,info,failover,region,reset,fail,will,failover,again,id,failover,global,mod,version,of,failover
FailoverRegion -> private void reset(long globalModVersionOfFailover);1494516977;reset all executions in this sub graph;private void reset(long globalModVersionOfFailover) {_		try {_			_			final Collection<CoLocationGroup> colGroups = new HashSet<>()__			final long restartTimestamp = System.currentTimeMillis()___			for (ExecutionVertex ev : connectedExecutionVertexes) {_				CoLocationGroup cgroup = ev.getJobVertex().getCoLocationGroup()__				if (cgroup != null && !colGroups.contains(cgroup)){_					cgroup.resetConstraints()__					colGroups.add(cgroup)__				}__				ev.resetForNewExecution(restartTimestamp, globalModVersionOfFailover)__			}_			if (transitionState(JobStatus.CANCELED, JobStatus.CREATED)) {_				restart(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} switched from CANCELLING to CREATED fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		}_		catch (GlobalModVersionMismatch e) {_			_			_			state = JobStatus.RUNNING__		}_		catch (Throwable e) {_			LOG.info("FailoverRegion {} reset fail, will failover again.", id)__			failover(globalModVersionOfFailover)__		}_	};reset,all,executions,in,this,sub,graph;private,void,reset,long,global,mod,version,of,failover,try,final,collection,co,location,group,col,groups,new,hash,set,final,long,restart,timestamp,system,current,time,millis,for,execution,vertex,ev,connected,execution,vertexes,co,location,group,cgroup,ev,get,job,vertex,get,co,location,group,if,cgroup,null,col,groups,contains,cgroup,cgroup,reset,constraints,col,groups,add,cgroup,ev,reset,for,new,execution,restart,timestamp,global,mod,version,of,failover,if,transition,state,job,status,canceled,job,status,created,restart,global,mod,version,of,failover,else,log,info,failover,region,switched,from,cancelling,to,created,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,global,mod,version,mismatch,e,state,job,status,running,catch,throwable,e,log,info,failover,region,reset,fail,will,failover,again,id,failover,global,mod,version,of,failover
FailoverRegion -> private void reset(long globalModVersionOfFailover);1501511601;reset all executions in this sub graph;private void reset(long globalModVersionOfFailover) {_		try {_			_			final Collection<CoLocationGroup> colGroups = new HashSet<>()__			final long restartTimestamp = System.currentTimeMillis()___			for (ExecutionVertex ev : connectedExecutionVertexes) {_				CoLocationGroup cgroup = ev.getJobVertex().getCoLocationGroup()__				if (cgroup != null && !colGroups.contains(cgroup)){_					cgroup.resetConstraints()__					colGroups.add(cgroup)__				}__				ev.resetForNewExecution(restartTimestamp, globalModVersionOfFailover)__			}_			if (transitionState(JobStatus.CANCELED, JobStatus.CREATED)) {_				restart(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} switched from CANCELLING to CREATED fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		}_		catch (GlobalModVersionMismatch e) {_			_			_			state = JobStatus.RUNNING__		}_		catch (Throwable e) {_			LOG.info("FailoverRegion {} reset fail, will failover again.", id)__			failover(globalModVersionOfFailover)__		}_	};reset,all,executions,in,this,sub,graph;private,void,reset,long,global,mod,version,of,failover,try,final,collection,co,location,group,col,groups,new,hash,set,final,long,restart,timestamp,system,current,time,millis,for,execution,vertex,ev,connected,execution,vertexes,co,location,group,cgroup,ev,get,job,vertex,get,co,location,group,if,cgroup,null,col,groups,contains,cgroup,cgroup,reset,constraints,col,groups,add,cgroup,ev,reset,for,new,execution,restart,timestamp,global,mod,version,of,failover,if,transition,state,job,status,canceled,job,status,created,restart,global,mod,version,of,failover,else,log,info,failover,region,switched,from,cancelling,to,created,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,global,mod,version,mismatch,e,state,job,status,running,catch,throwable,e,log,info,failover,region,reset,fail,will,failover,again,id,failover,global,mod,version,of,failover
FailoverRegion -> private void reset(long globalModVersionOfFailover);1509090423;reset all executions in this sub graph;private void reset(long globalModVersionOfFailover) {_		try {_			_			final Collection<CoLocationGroup> colGroups = new HashSet<>()__			final long restartTimestamp = System.currentTimeMillis()___			for (ExecutionVertex ev : connectedExecutionVertexes) {_				CoLocationGroup cgroup = ev.getJobVertex().getCoLocationGroup()__				if (cgroup != null && !colGroups.contains(cgroup)){_					cgroup.resetConstraints()__					colGroups.add(cgroup)__				}__				ev.resetForNewExecution(restartTimestamp, globalModVersionOfFailover)__			}_			if (transitionState(JobStatus.CANCELED, JobStatus.CREATED)) {_				restart(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} switched from CANCELLING to CREATED fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		}_		catch (GlobalModVersionMismatch e) {_			_			_			state = JobStatus.RUNNING__		}_		catch (Throwable e) {_			LOG.info("FailoverRegion {} reset fail, will failover again.", id)__			failover(globalModVersionOfFailover)__		}_	};reset,all,executions,in,this,sub,graph;private,void,reset,long,global,mod,version,of,failover,try,final,collection,co,location,group,col,groups,new,hash,set,final,long,restart,timestamp,system,current,time,millis,for,execution,vertex,ev,connected,execution,vertexes,co,location,group,cgroup,ev,get,job,vertex,get,co,location,group,if,cgroup,null,col,groups,contains,cgroup,cgroup,reset,constraints,col,groups,add,cgroup,ev,reset,for,new,execution,restart,timestamp,global,mod,version,of,failover,if,transition,state,job,status,canceled,job,status,created,restart,global,mod,version,of,failover,else,log,info,failover,region,switched,from,cancelling,to,created,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,global,mod,version,mismatch,e,state,job,status,running,catch,throwable,e,log,info,failover,region,reset,fail,will,failover,again,id,failover,global,mod,version,of,failover
FailoverRegion -> private void reset(long globalModVersionOfFailover);1538764056;reset all executions in this sub graph;private void reset(long globalModVersionOfFailover) {_		try {_			_			final Collection<CoLocationGroup> colGroups = new HashSet<>()__			final long restartTimestamp = System.currentTimeMillis()___			for (ExecutionVertex ev : connectedExecutionVertexes) {_				CoLocationGroup cgroup = ev.getJobVertex().getCoLocationGroup()__				if (cgroup != null && !colGroups.contains(cgroup)){_					cgroup.resetConstraints()__					colGroups.add(cgroup)__				}__				ev.resetForNewExecution(restartTimestamp, globalModVersionOfFailover)__			}_			if (transitionState(JobStatus.CANCELED, JobStatus.CREATED)) {_				restart(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} switched from CANCELLING to CREATED fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		}_		catch (GlobalModVersionMismatch e) {_			_			_			state = JobStatus.RUNNING__		}_		catch (Throwable e) {_			LOG.info("FailoverRegion {} reset fail, will failover again.", id)__			failover(globalModVersionOfFailover)__		}_	};reset,all,executions,in,this,sub,graph;private,void,reset,long,global,mod,version,of,failover,try,final,collection,co,location,group,col,groups,new,hash,set,final,long,restart,timestamp,system,current,time,millis,for,execution,vertex,ev,connected,execution,vertexes,co,location,group,cgroup,ev,get,job,vertex,get,co,location,group,if,cgroup,null,col,groups,contains,cgroup,cgroup,reset,constraints,col,groups,add,cgroup,ev,reset,for,new,execution,restart,timestamp,global,mod,version,of,failover,if,transition,state,job,status,canceled,job,status,created,restart,global,mod,version,of,failover,else,log,info,failover,region,switched,from,cancelling,to,created,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,global,mod,version,mismatch,e,state,job,status,running,catch,throwable,e,log,info,failover,region,reset,fail,will,failover,again,id,failover,global,mod,version,of,failover
FailoverRegion -> private void reset(long globalModVersionOfFailover);1543229263;reset all executions in this sub graph;private void reset(long globalModVersionOfFailover) {_		try {_			_			final Collection<CoLocationGroup> colGroups = new HashSet<>()__			final long restartTimestamp = System.currentTimeMillis()___			for (ExecutionVertex ev : connectedExecutionVertexes) {_				CoLocationGroup cgroup = ev.getJobVertex().getCoLocationGroup()__				if (cgroup != null && !colGroups.contains(cgroup)){_					cgroup.resetConstraints()__					colGroups.add(cgroup)__				}__				ev.resetForNewExecution(restartTimestamp, globalModVersionOfFailover)__			}_			if (transitionState(JobStatus.CANCELED, JobStatus.CREATED)) {_				restart(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} switched from CANCELLING to CREATED fail, will fail this region again.", id)__				failover(globalModVersionOfFailover)__			}_		}_		catch (GlobalModVersionMismatch e) {_			_			_			state = JobStatus.RUNNING__		}_		catch (Throwable e) {_			LOG.info("FailoverRegion {} reset fail, will failover again.", id)__			failover(globalModVersionOfFailover)__		}_	};reset,all,executions,in,this,sub,graph;private,void,reset,long,global,mod,version,of,failover,try,final,collection,co,location,group,col,groups,new,hash,set,final,long,restart,timestamp,system,current,time,millis,for,execution,vertex,ev,connected,execution,vertexes,co,location,group,cgroup,ev,get,job,vertex,get,co,location,group,if,cgroup,null,col,groups,contains,cgroup,cgroup,reset,constraints,col,groups,add,cgroup,ev,reset,for,new,execution,restart,timestamp,global,mod,version,of,failover,if,transition,state,job,status,canceled,job,status,created,restart,global,mod,version,of,failover,else,log,info,failover,region,switched,from,cancelling,to,created,fail,will,fail,this,region,again,id,failover,global,mod,version,of,failover,catch,global,mod,version,mismatch,e,state,job,status,running,catch,throwable,e,log,info,failover,region,reset,fail,will,failover,again,id,failover,global,mod,version,of,failover
FailoverRegion -> private void failover(long globalModVersionOfFailover);1492496129;Notice the region to failover,;private void failover(long globalModVersionOfFailover) {_		if (!executionGraph.getRestartStrategy().canRestart()) {_			executionGraph.failGlobal(new FlinkException("RestartStrategy validate fail"))__		}_		else {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				cancel(globalModVersionOfFailover)__			}_			else if (curStatus.equals(JobStatus.CANCELED)) {_				reset(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} is {} when notified to failover.", id, state)__			}_		}_	};notice,the,region,to,failover;private,void,failover,long,global,mod,version,of,failover,if,execution,graph,get,restart,strategy,can,restart,execution,graph,fail,global,new,flink,exception,restart,strategy,validate,fail,else,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,cancel,global,mod,version,of,failover,else,if,cur,status,equals,job,status,canceled,reset,global,mod,version,of,failover,else,log,info,failover,region,is,when,notified,to,failover,id,state
FailoverRegion -> private void failover(long globalModVersionOfFailover);1494516977;Notice the region to failover,;private void failover(long globalModVersionOfFailover) {_		if (!executionGraph.getRestartStrategy().canRestart()) {_			executionGraph.failGlobal(new FlinkException("RestartStrategy validate fail"))__		}_		else {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				cancel(globalModVersionOfFailover)__			}_			else if (curStatus.equals(JobStatus.CANCELED)) {_				reset(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} is {} when notified to failover.", id, state)__			}_		}_	};notice,the,region,to,failover;private,void,failover,long,global,mod,version,of,failover,if,execution,graph,get,restart,strategy,can,restart,execution,graph,fail,global,new,flink,exception,restart,strategy,validate,fail,else,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,cancel,global,mod,version,of,failover,else,if,cur,status,equals,job,status,canceled,reset,global,mod,version,of,failover,else,log,info,failover,region,is,when,notified,to,failover,id,state
FailoverRegion -> private void failover(long globalModVersionOfFailover);1501511601;Notice the region to failover,;private void failover(long globalModVersionOfFailover) {_		if (!executionGraph.getRestartStrategy().canRestart()) {_			executionGraph.failGlobal(new FlinkException("RestartStrategy validate fail"))__		}_		else {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				cancel(globalModVersionOfFailover)__			}_			else if (curStatus.equals(JobStatus.CANCELED)) {_				reset(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} is {} when notified to failover.", id, state)__			}_		}_	};notice,the,region,to,failover;private,void,failover,long,global,mod,version,of,failover,if,execution,graph,get,restart,strategy,can,restart,execution,graph,fail,global,new,flink,exception,restart,strategy,validate,fail,else,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,cancel,global,mod,version,of,failover,else,if,cur,status,equals,job,status,canceled,reset,global,mod,version,of,failover,else,log,info,failover,region,is,when,notified,to,failover,id,state
FailoverRegion -> private void failover(long globalModVersionOfFailover);1509090423;Notice the region to failover,;private void failover(long globalModVersionOfFailover) {_		if (!executionGraph.getRestartStrategy().canRestart()) {_			executionGraph.failGlobal(new FlinkException("RestartStrategy validate fail"))__		}_		else {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				cancel(globalModVersionOfFailover)__			}_			else if (curStatus.equals(JobStatus.CANCELED)) {_				reset(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} is {} when notified to failover.", id, state)__			}_		}_	};notice,the,region,to,failover;private,void,failover,long,global,mod,version,of,failover,if,execution,graph,get,restart,strategy,can,restart,execution,graph,fail,global,new,flink,exception,restart,strategy,validate,fail,else,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,cancel,global,mod,version,of,failover,else,if,cur,status,equals,job,status,canceled,reset,global,mod,version,of,failover,else,log,info,failover,region,is,when,notified,to,failover,id,state
FailoverRegion -> private void failover(long globalModVersionOfFailover);1538764056;Notice the region to failover,;private void failover(long globalModVersionOfFailover) {_		if (!executionGraph.getRestartStrategy().canRestart()) {_			executionGraph.failGlobal(new FlinkException("RestartStrategy validate fail"))__		}_		else {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				cancel(globalModVersionOfFailover)__			}_			else if (curStatus.equals(JobStatus.CANCELED)) {_				reset(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} is {} when notified to failover.", id, state)__			}_		}_	};notice,the,region,to,failover;private,void,failover,long,global,mod,version,of,failover,if,execution,graph,get,restart,strategy,can,restart,execution,graph,fail,global,new,flink,exception,restart,strategy,validate,fail,else,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,cancel,global,mod,version,of,failover,else,if,cur,status,equals,job,status,canceled,reset,global,mod,version,of,failover,else,log,info,failover,region,is,when,notified,to,failover,id,state
FailoverRegion -> private void failover(long globalModVersionOfFailover);1543229263;Notice the region to failover,;private void failover(long globalModVersionOfFailover) {_		if (!executionGraph.getRestartStrategy().canRestart()) {_			executionGraph.failGlobal(new FlinkException("RestartStrategy validate fail"))__		}_		else {_			JobStatus curStatus = this.state__			if (curStatus.equals(JobStatus.RUNNING)) {_				cancel(globalModVersionOfFailover)__			}_			else if (curStatus.equals(JobStatus.CANCELED)) {_				reset(globalModVersionOfFailover)__			}_			else {_				LOG.info("FailoverRegion {} is {} when notified to failover.", id, state)__			}_		}_	};notice,the,region,to,failover;private,void,failover,long,global,mod,version,of,failover,if,execution,graph,get,restart,strategy,can,restart,execution,graph,fail,global,new,flink,exception,restart,strategy,validate,fail,else,job,status,cur,status,this,state,if,cur,status,equals,job,status,running,cancel,global,mod,version,of,failover,else,if,cur,status,equals,job,status,canceled,reset,global,mod,version,of,failover,else,log,info,failover,region,is,when,notified,to,failover,id,state
