# id;timestamp;commentText;codeText;commentWords;codeWords
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1504685932;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1506417942;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1509404933;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1516971025;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1518862304;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1519052657;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1519481114;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1521804759;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1522339661;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1532383539;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1536158411;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1538395078;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryFailure() throws Throwable;1549365080;Tests that a retry future is failed after all retries have been consumed.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryFailure() throws Throwable {_		final int retries = 3___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			retries,_			TestingUtils.defaultExecutor())___		try {_			retryFuture.get()__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,a,retry,future,is,failed,after,all,retries,have,been,consumed;test,expected,future,utils,retry,exception,class,public,void,test,retry,failure,throws,throwable,final,int,retries,3,completable,future,retry,future,future,utils,retry,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,testing,utils,default,executor,try,retry,future,get,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1509404933;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1516971025;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1518862304;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1519052657;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1519481114;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1521804759;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1522339661;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1532383539;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1536158411;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1538395078;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test 	public void testOrTimeout() throws Exception;1549365080;Tests that a future is timed out after the specified timeout.;@Test_	public void testOrTimeout() throws Exception {_		final CompletableFuture<String> future = new CompletableFuture<>()__		final long timeout = 10L___		FutureUtils.orTimeout(future, timeout, TimeUnit.MILLISECONDS)___		try {_			future.get()__		} catch (ExecutionException e) {_			assertTrue(ExceptionUtils.stripExecutionException(e) instanceof TimeoutException)__		}_	};tests,that,a,future,is,timed,out,after,the,specified,timeout;test,public,void,test,or,timeout,throws,exception,final,completable,future,string,future,new,completable,future,final,long,timeout,10l,future,utils,or,timeout,future,timeout,time,unit,milliseconds,try,future,get,catch,execution,exception,e,assert,true,exception,utils,strip,execution,exception,e,instanceof,timeout,exception
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1504685932;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1506417942;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1509404933;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1516971025;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1518862304;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1519052657;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1519481114;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1521804759;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1522339661;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1532383539;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1536158411;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1538395078;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test(expected = FutureUtils.RetryException.class) 	public void testRetryWithDelayFailure() throws Throwable;1549365080;Tests that retry with delay fails after having exceeded all retries.;@Test(expected = FutureUtils.RetryException.class)_	public void testRetryWithDelayFailure() throws Throwable {_		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			3,_			Time.milliseconds(1L),_			TestingUtils.defaultScheduledExecutor())___		try {_			retryFuture.get(TestingUtils.TIMEOUT().toMilliseconds(), TimeUnit.MILLISECONDS)__		} catch (ExecutionException ee) {_			throw ExceptionUtils.stripExecutionException(ee)__		}_	};tests,that,retry,with,delay,fails,after,having,exceeded,all,retries;test,expected,future,utils,retry,exception,class,public,void,test,retry,with,delay,failure,throws,throwable,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,3,time,milliseconds,1l,testing,utils,default,scheduled,executor,try,retry,future,get,testing,utils,timeout,to,milliseconds,time,unit,milliseconds,catch,execution,exception,ee,throw,exception,utils,strip,execution,exception,ee
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1504685932;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new FlinkFutureException("Test exception")__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,flink,future,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1506417942;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1509404933;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1516971025;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1518862304;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1519052657;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1519481114;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1521804759;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1522339661;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1532383539;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1536158411;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1538395078;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetryCancellation() throws Exception;1549365080;Tests that we can cancel a retry future.;@Test_	public void testRetryCancellation() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		final OneShotLatch notificationLatch = new OneShotLatch()__		final OneShotLatch waitLatch = new OneShotLatch()__		final AtomicReference<Throwable> atomicThrowable = new AtomicReference<>(null)___		CompletableFuture<?> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == 2) {_							notificationLatch.trigger()__							try {_								waitLatch.await()__							} catch (InterruptedException e) {_								atomicThrowable.compareAndSet(null, e)__							}_						}__						throw new CompletionException(new FlinkException("Test exception"))__					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		_		notificationLatch.await()___		assertFalse(retryFuture.isDone())___		_		retryFuture.cancel(false)___		_		waitLatch.trigger()___		assertTrue(retryFuture.isCancelled())__		assertEquals(2, atomicInteger.get())___		if (atomicThrowable.get() != null) {_			throw new FlinkException("Exception occurred in the retry operation.", atomicThrowable.get())__		}_	};tests,that,we,can,cancel,a,retry,future;test,public,void,test,retry,cancellation,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,final,one,shot,latch,notification,latch,new,one,shot,latch,final,one,shot,latch,wait,latch,new,one,shot,latch,final,atomic,reference,throwable,atomic,throwable,new,atomic,reference,null,completable,future,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,2,notification,latch,trigger,try,wait,latch,await,catch,interrupted,exception,e,atomic,throwable,compare,and,set,null,e,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,notification,latch,await,assert,false,retry,future,is,done,retry,future,cancel,false,wait,latch,trigger,assert,true,retry,future,is,cancelled,assert,equals,2,atomic,integer,get,if,atomic,throwable,get,null,throw,new,flink,exception,exception,occurred,in,the,retry,operation,atomic,throwable,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1504685932;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new FlinkFutureException("Test exception")__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,flink,future,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1506417942;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1509404933;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1516971025;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1518862304;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1519052657;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1519481114;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1521804759;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1522339661;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1532383539;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1536158411;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertTrue(retries == atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,true,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1538395078;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertEquals(retries, atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,equals,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetrySuccess() throws Exception;1549365080;Tests that we can retry an operation.;@Test_	public void testRetrySuccess() throws Exception {_		final int retries = 10__		final AtomicInteger atomicInteger = new AtomicInteger(0)__		CompletableFuture<Boolean> retryFuture = FutureUtils.retry(_			() ->_				CompletableFuture.supplyAsync(_					() -> {_						if (atomicInteger.incrementAndGet() == retries) {_							return true__						} else {_							throw new CompletionException(new FlinkException("Test exception"))__						}_					},_					TestingUtils.defaultExecutor()),_			retries,_			TestingUtils.defaultExecutor())___		assertTrue(retryFuture.get())__		assertEquals(retries, atomicInteger.get())__	};tests,that,we,can,retry,an,operation;test,public,void,test,retry,success,throws,exception,final,int,retries,10,final,atomic,integer,atomic,integer,new,atomic,integer,0,completable,future,boolean,retry,future,future,utils,retry,completable,future,supply,async,if,atomic,integer,increment,and,get,retries,return,true,else,throw,new,completion,exception,new,flink,exception,test,exception,testing,utils,default,executor,retries,testing,utils,default,executor,assert,true,retry,future,get,assert,equals,retries,atomic,integer,get
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1504685932;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(50L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		long start = System.currentTimeMillis()___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,50l,final,atomic,integer,count,down,new,atomic,integer,retries,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,long,start,system,current,time,millis,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1506417942;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(50L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		long start = System.currentTimeMillis()___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,50l,final,atomic,integer,count,down,new,atomic,integer,retries,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,long,start,system,current,time,millis,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1509404933;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(50L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		long start = System.currentTimeMillis()___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,50l,final,atomic,integer,count,down,new,atomic,integer,retries,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,long,start,system,current,time,millis,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1516971025;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(50L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		long start = System.currentTimeMillis()___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,50l,final,atomic,integer,count,down,new,atomic,integer,retries,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,long,start,system,current,time,millis,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1518862304;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(5L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		long start = System.currentTimeMillis()___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,5l,final,atomic,integer,count,down,new,atomic,integer,retries,long,start,system,current,time,millis,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1519052657;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(5L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		long start = System.currentTimeMillis()___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,5l,final,atomic,integer,count,down,new,atomic,integer,retries,long,start,system,current,time,millis,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1519481114;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(5L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		long start = System.currentTimeMillis()___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,5l,final,atomic,integer,count,down,new,atomic,integer,retries,long,start,system,current,time,millis,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1521804759;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(5L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		long start = System.currentTimeMillis()___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,5l,final,atomic,integer,count,down,new,atomic,integer,retries,long,start,system,current,time,millis,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1522339661;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(5L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		long start = System.currentTimeMillis()___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,5l,final,atomic,integer,count,down,new,atomic,integer,retries,long,start,system,current,time,millis,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1532383539;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(5L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		long start = System.currentTimeMillis()___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,5l,final,atomic,integer,count,down,new,atomic,integer,retries,long,start,system,current,time,millis,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1536158411;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(5L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		long start = System.currentTimeMillis()___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,5l,final,atomic,integer,count,down,new,atomic,integer,retries,long,start,system,current,time,millis,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1538395078;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(5L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		long start = System.currentTimeMillis()___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,5l,final,atomic,integer,count,down,new,atomic,integer,retries,long,start,system,current,time,millis,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testRetryWithDelay() throws Exception;1549365080;Tests that the delay is respected between subsequent retries of a retry future with retry delay.;@Test_	public void testRetryWithDelay() throws Exception {_		final int retries = 4__		final Time delay = Time.milliseconds(5L)__		final AtomicInteger countDown = new AtomicInteger(retries)___		long start = System.currentTimeMillis()___		CompletableFuture<Boolean> retryFuture = FutureUtils.retryWithDelay(_			() -> {_				if (countDown.getAndDecrement() == 0) {_					return CompletableFuture.completedFuture(true)__				} else {_					return FutureUtils.completedExceptionally(new FlinkException("Test exception."))__				}_			},_			retries,_			delay,_			TestingUtils.defaultScheduledExecutor())___		Boolean result = retryFuture.get()___		long completionTime = System.currentTimeMillis() - start___		assertTrue(result)__		assertTrue("The completion time should be at least rertries times delay between retries.", completionTime >= retries * delay.toMilliseconds())__	};tests,that,the,delay,is,respected,between,subsequent,retries,of,a,retry,future,with,retry,delay;test,public,void,test,retry,with,delay,throws,exception,final,int,retries,4,final,time,delay,time,milliseconds,5l,final,atomic,integer,count,down,new,atomic,integer,retries,long,start,system,current,time,millis,completable,future,boolean,retry,future,future,utils,retry,with,delay,if,count,down,get,and,decrement,0,return,completable,future,completed,future,true,else,return,future,utils,completed,exceptionally,new,flink,exception,test,exception,retries,delay,testing,utils,default,scheduled,executor,boolean,result,retry,future,get,long,completion,time,system,current,time,millis,start,assert,true,result,assert,true,the,completion,time,should,be,at,least,rertries,times,delay,between,retries,completion,time,retries,delay,to,milliseconds
FutureUtilsTest -> @Test 	public void testConjunctFutureValue() throws ExecutionException, InterruptedException;1495001903;Tests that the conjunct future returns upon completion the collection of all future values;@Test_	public void testConjunctFutureValue() throws ExecutionException, InterruptedException {_		CompletableFuture<Integer> future1 = FlinkCompletableFuture.completed(1)__		CompletableFuture<Long> future2 = FlinkCompletableFuture.completed(2L)__		CompletableFuture<Double> future3 = new FlinkCompletableFuture<>()___		ConjunctFuture<Collection<Number>> result = FutureUtils.<Number>combineAll(Arrays.asList(future1, future2, future3))___		assertFalse(result.isDone())___		future3.complete(.1)___		assertTrue(result.isDone())___		assertThat(result.get(), IsIterableContainingInAnyOrder.<Number>containsInAnyOrder(1, 2L, .1))__	};tests,that,the,conjunct,future,returns,upon,completion,the,collection,of,all,future,values;test,public,void,test,conjunct,future,value,throws,execution,exception,interrupted,exception,completable,future,integer,future1,flink,completable,future,completed,1,completable,future,long,future2,flink,completable,future,completed,2l,completable,future,double,future3,new,flink,completable,future,conjunct,future,collection,number,result,future,utils,number,combine,all,arrays,as,list,future1,future2,future3,assert,false,result,is,done,future3,complete,1,assert,true,result,is,done,assert,that,result,get,is,iterable,containing,in,any,order,number,contains,in,any,order,1,2l,1
FutureUtilsTest -> @Test 	public void testConjunctFutureValue() throws ExecutionException, InterruptedException;1501622876;Tests that the conjunct future returns upon completion the collection of all future values;@Test_	public void testConjunctFutureValue() throws ExecutionException, InterruptedException {_		java.util.concurrent.CompletableFuture<Integer> future1 = java.util.concurrent.CompletableFuture.completedFuture(1)__		java.util.concurrent.CompletableFuture<Long> future2 = java.util.concurrent.CompletableFuture.completedFuture(2L)__		java.util.concurrent.CompletableFuture<Double> future3 = new java.util.concurrent.CompletableFuture<>()___		ConjunctFuture<Collection<Number>> result = FutureUtils.combineAll(Arrays.asList(future1, future2, future3))___		assertFalse(result.isDone())___		future3.complete(.1)___		assertTrue(result.isDone())___		assertThat(result.get(), IsIterableContainingInAnyOrder.<Number>containsInAnyOrder(1, 2L, .1))__	};tests,that,the,conjunct,future,returns,upon,completion,the,collection,of,all,future,values;test,public,void,test,conjunct,future,value,throws,execution,exception,interrupted,exception,java,util,concurrent,completable,future,integer,future1,java,util,concurrent,completable,future,completed,future,1,java,util,concurrent,completable,future,long,future2,java,util,concurrent,completable,future,completed,future,2l,java,util,concurrent,completable,future,double,future3,new,java,util,concurrent,completable,future,conjunct,future,collection,number,result,future,utils,combine,all,arrays,as,list,future1,future2,future3,assert,false,result,is,done,future3,complete,1,assert,true,result,is,done,assert,that,result,get,is,iterable,containing,in,any,order,number,contains,in,any,order,1,2l,1
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1504685932;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		ScheduledFuture<?> scheduledFutureMock = mock(ScheduledFuture.class)__		ScheduledExecutor scheduledExecutorMock = mock(ScheduledExecutor.class)__		doReturn(scheduledFutureMock).when(scheduledExecutorMock).schedule(any(Runnable.class), anyLong(), any(TimeUnit.class))__		doAnswer(_			(InvocationOnMock invocation) -> {_				invocation.getArgumentAt(0, Runnable.class).run()__				return null__			}).when(scheduledExecutorMock).execute(any(Runnable.class))___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutorMock)___		assertFalse(retryFuture.isDone())___		verify(scheduledExecutorMock).schedule(any(Runnable.class), anyLong(), any(TimeUnit.class))___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		verify(scheduledFutureMock).cancel(anyBoolean())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,scheduled,future,scheduled,future,mock,mock,scheduled,future,class,scheduled,executor,scheduled,executor,mock,mock,scheduled,executor,class,do,return,scheduled,future,mock,when,scheduled,executor,mock,schedule,any,runnable,class,any,long,any,time,unit,class,do,answer,invocation,on,mock,invocation,invocation,get,argument,at,0,runnable,class,run,return,null,when,scheduled,executor,mock,execute,any,runnable,class,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,mock,assert,false,retry,future,is,done,verify,scheduled,executor,mock,schedule,any,runnable,class,any,long,any,time,unit,class,retry,future,cancel,false,assert,true,retry,future,is,cancelled,verify,scheduled,future,mock,cancel,any,boolean
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1506417942;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		ScheduledFuture<?> scheduledFutureMock = mock(ScheduledFuture.class)__		ScheduledExecutor scheduledExecutorMock = mock(ScheduledExecutor.class)__		doReturn(scheduledFutureMock).when(scheduledExecutorMock).schedule(any(Runnable.class), anyLong(), any(TimeUnit.class))__		doAnswer(_			(InvocationOnMock invocation) -> {_				invocation.getArgumentAt(0, Runnable.class).run()__				return null__			}).when(scheduledExecutorMock).execute(any(Runnable.class))___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutorMock)___		assertFalse(retryFuture.isDone())___		verify(scheduledExecutorMock).schedule(any(Runnable.class), anyLong(), any(TimeUnit.class))___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		verify(scheduledFutureMock).cancel(anyBoolean())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,scheduled,future,scheduled,future,mock,mock,scheduled,future,class,scheduled,executor,scheduled,executor,mock,mock,scheduled,executor,class,do,return,scheduled,future,mock,when,scheduled,executor,mock,schedule,any,runnable,class,any,long,any,time,unit,class,do,answer,invocation,on,mock,invocation,invocation,get,argument,at,0,runnable,class,run,return,null,when,scheduled,executor,mock,execute,any,runnable,class,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,mock,assert,false,retry,future,is,done,verify,scheduled,executor,mock,schedule,any,runnable,class,any,long,any,time,unit,class,retry,future,cancel,false,assert,true,retry,future,is,cancelled,verify,scheduled,future,mock,cancel,any,boolean
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1509404933;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		ScheduledFuture<?> scheduledFutureMock = mock(ScheduledFuture.class)__		ScheduledExecutor scheduledExecutorMock = mock(ScheduledExecutor.class)__		doReturn(scheduledFutureMock).when(scheduledExecutorMock).schedule(any(Runnable.class), anyLong(), any(TimeUnit.class))__		doAnswer(_			(InvocationOnMock invocation) -> {_				invocation.getArgumentAt(0, Runnable.class).run()__				return null__			}).when(scheduledExecutorMock).execute(any(Runnable.class))___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutorMock)___		assertFalse(retryFuture.isDone())___		verify(scheduledExecutorMock).schedule(any(Runnable.class), anyLong(), any(TimeUnit.class))___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		verify(scheduledFutureMock).cancel(anyBoolean())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,scheduled,future,scheduled,future,mock,mock,scheduled,future,class,scheduled,executor,scheduled,executor,mock,mock,scheduled,executor,class,do,return,scheduled,future,mock,when,scheduled,executor,mock,schedule,any,runnable,class,any,long,any,time,unit,class,do,answer,invocation,on,mock,invocation,invocation,get,argument,at,0,runnable,class,run,return,null,when,scheduled,executor,mock,execute,any,runnable,class,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,mock,assert,false,retry,future,is,done,verify,scheduled,executor,mock,schedule,any,runnable,class,any,long,any,time,unit,class,retry,future,cancel,false,assert,true,retry,future,is,cancelled,verify,scheduled,future,mock,cancel,any,boolean
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1516971025;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		ScheduledFuture<?> scheduledFutureMock = mock(ScheduledFuture.class)__		ScheduledExecutor scheduledExecutorMock = mock(ScheduledExecutor.class)__		doReturn(scheduledFutureMock).when(scheduledExecutorMock).schedule(any(Runnable.class), anyLong(), any(TimeUnit.class))__		doAnswer(_			(InvocationOnMock invocation) -> {_				invocation.getArgumentAt(0, Runnable.class).run()__				return null__			}).when(scheduledExecutorMock).execute(any(Runnable.class))___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutorMock)___		assertFalse(retryFuture.isDone())___		verify(scheduledExecutorMock).schedule(any(Runnable.class), anyLong(), any(TimeUnit.class))___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		verify(scheduledFutureMock).cancel(anyBoolean())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,scheduled,future,scheduled,future,mock,mock,scheduled,future,class,scheduled,executor,scheduled,executor,mock,mock,scheduled,executor,class,do,return,scheduled,future,mock,when,scheduled,executor,mock,schedule,any,runnable,class,any,long,any,time,unit,class,do,answer,invocation,on,mock,invocation,invocation,get,argument,at,0,runnable,class,run,return,null,when,scheduled,executor,mock,execute,any,runnable,class,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,mock,assert,false,retry,future,is,done,verify,scheduled,executor,mock,schedule,any,runnable,class,any,long,any,time,unit,class,retry,future,cancel,false,assert,true,retry,future,is,cancelled,verify,scheduled,future,mock,cancel,any,boolean
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1518862304;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		final ManuallyTriggeredScheduledExecutor scheduledExecutor = new ManuallyTriggeredScheduledExecutor()___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutor)___		assertFalse(retryFuture.isDone())___		final Collection<ScheduledFuture<?>> scheduledTasks = scheduledExecutor.getScheduledTasks()___		assertFalse(scheduledTasks.isEmpty())___		final ScheduledFuture<?> scheduledFuture = scheduledTasks.iterator().next()___		assertFalse(scheduledFuture.isDone())___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		assertTrue(scheduledFuture.isCancelled())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,final,manually,triggered,scheduled,executor,scheduled,executor,new,manually,triggered,scheduled,executor,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,assert,false,retry,future,is,done,final,collection,scheduled,future,scheduled,tasks,scheduled,executor,get,scheduled,tasks,assert,false,scheduled,tasks,is,empty,final,scheduled,future,scheduled,future,scheduled,tasks,iterator,next,assert,false,scheduled,future,is,done,retry,future,cancel,false,assert,true,retry,future,is,cancelled,assert,true,scheduled,future,is,cancelled
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1519052657;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		final ManuallyTriggeredScheduledExecutor scheduledExecutor = new ManuallyTriggeredScheduledExecutor()___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutor)___		assertFalse(retryFuture.isDone())___		final Collection<ScheduledFuture<?>> scheduledTasks = scheduledExecutor.getScheduledTasks()___		assertFalse(scheduledTasks.isEmpty())___		final ScheduledFuture<?> scheduledFuture = scheduledTasks.iterator().next()___		assertFalse(scheduledFuture.isDone())___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		assertTrue(scheduledFuture.isCancelled())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,final,manually,triggered,scheduled,executor,scheduled,executor,new,manually,triggered,scheduled,executor,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,assert,false,retry,future,is,done,final,collection,scheduled,future,scheduled,tasks,scheduled,executor,get,scheduled,tasks,assert,false,scheduled,tasks,is,empty,final,scheduled,future,scheduled,future,scheduled,tasks,iterator,next,assert,false,scheduled,future,is,done,retry,future,cancel,false,assert,true,retry,future,is,cancelled,assert,true,scheduled,future,is,cancelled
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1519481114;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		final ManuallyTriggeredScheduledExecutor scheduledExecutor = new ManuallyTriggeredScheduledExecutor()___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutor)___		assertFalse(retryFuture.isDone())___		final Collection<ScheduledFuture<?>> scheduledTasks = scheduledExecutor.getScheduledTasks()___		assertFalse(scheduledTasks.isEmpty())___		final ScheduledFuture<?> scheduledFuture = scheduledTasks.iterator().next()___		assertFalse(scheduledFuture.isDone())___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		assertTrue(scheduledFuture.isCancelled())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,final,manually,triggered,scheduled,executor,scheduled,executor,new,manually,triggered,scheduled,executor,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,assert,false,retry,future,is,done,final,collection,scheduled,future,scheduled,tasks,scheduled,executor,get,scheduled,tasks,assert,false,scheduled,tasks,is,empty,final,scheduled,future,scheduled,future,scheduled,tasks,iterator,next,assert,false,scheduled,future,is,done,retry,future,cancel,false,assert,true,retry,future,is,cancelled,assert,true,scheduled,future,is,cancelled
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1521804759;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		final ManuallyTriggeredScheduledExecutor scheduledExecutor = new ManuallyTriggeredScheduledExecutor()___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutor)___		assertFalse(retryFuture.isDone())___		final Collection<ScheduledFuture<?>> scheduledTasks = scheduledExecutor.getScheduledTasks()___		assertFalse(scheduledTasks.isEmpty())___		final ScheduledFuture<?> scheduledFuture = scheduledTasks.iterator().next()___		assertFalse(scheduledFuture.isDone())___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		assertTrue(scheduledFuture.isCancelled())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,final,manually,triggered,scheduled,executor,scheduled,executor,new,manually,triggered,scheduled,executor,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,assert,false,retry,future,is,done,final,collection,scheduled,future,scheduled,tasks,scheduled,executor,get,scheduled,tasks,assert,false,scheduled,tasks,is,empty,final,scheduled,future,scheduled,future,scheduled,tasks,iterator,next,assert,false,scheduled,future,is,done,retry,future,cancel,false,assert,true,retry,future,is,cancelled,assert,true,scheduled,future,is,cancelled
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1522339661;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		final ManuallyTriggeredScheduledExecutor scheduledExecutor = new ManuallyTriggeredScheduledExecutor()___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutor)___		assertFalse(retryFuture.isDone())___		final Collection<ScheduledFuture<?>> scheduledTasks = scheduledExecutor.getScheduledTasks()___		assertFalse(scheduledTasks.isEmpty())___		final ScheduledFuture<?> scheduledFuture = scheduledTasks.iterator().next()___		assertFalse(scheduledFuture.isDone())___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		assertTrue(scheduledFuture.isCancelled())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,final,manually,triggered,scheduled,executor,scheduled,executor,new,manually,triggered,scheduled,executor,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,assert,false,retry,future,is,done,final,collection,scheduled,future,scheduled,tasks,scheduled,executor,get,scheduled,tasks,assert,false,scheduled,tasks,is,empty,final,scheduled,future,scheduled,future,scheduled,tasks,iterator,next,assert,false,scheduled,future,is,done,retry,future,cancel,false,assert,true,retry,future,is,cancelled,assert,true,scheduled,future,is,cancelled
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1532383539;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		final ManuallyTriggeredScheduledExecutor scheduledExecutor = new ManuallyTriggeredScheduledExecutor()___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutor)___		assertFalse(retryFuture.isDone())___		final Collection<ScheduledFuture<?>> scheduledTasks = scheduledExecutor.getScheduledTasks()___		assertFalse(scheduledTasks.isEmpty())___		final ScheduledFuture<?> scheduledFuture = scheduledTasks.iterator().next()___		assertFalse(scheduledFuture.isDone())___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		assertTrue(scheduledFuture.isCancelled())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,final,manually,triggered,scheduled,executor,scheduled,executor,new,manually,triggered,scheduled,executor,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,assert,false,retry,future,is,done,final,collection,scheduled,future,scheduled,tasks,scheduled,executor,get,scheduled,tasks,assert,false,scheduled,tasks,is,empty,final,scheduled,future,scheduled,future,scheduled,tasks,iterator,next,assert,false,scheduled,future,is,done,retry,future,cancel,false,assert,true,retry,future,is,cancelled,assert,true,scheduled,future,is,cancelled
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1536158411;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		final ManuallyTriggeredScheduledExecutor scheduledExecutor = new ManuallyTriggeredScheduledExecutor()___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutor)___		assertFalse(retryFuture.isDone())___		final Collection<ScheduledFuture<?>> scheduledTasks = scheduledExecutor.getScheduledTasks()___		assertFalse(scheduledTasks.isEmpty())___		final ScheduledFuture<?> scheduledFuture = scheduledTasks.iterator().next()___		assertFalse(scheduledFuture.isDone())___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		assertTrue(scheduledFuture.isCancelled())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,final,manually,triggered,scheduled,executor,scheduled,executor,new,manually,triggered,scheduled,executor,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,assert,false,retry,future,is,done,final,collection,scheduled,future,scheduled,tasks,scheduled,executor,get,scheduled,tasks,assert,false,scheduled,tasks,is,empty,final,scheduled,future,scheduled,future,scheduled,tasks,iterator,next,assert,false,scheduled,future,is,done,retry,future,cancel,false,assert,true,retry,future,is,cancelled,assert,true,scheduled,future,is,cancelled
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1538395078;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		final ManuallyTriggeredScheduledExecutor scheduledExecutor = new ManuallyTriggeredScheduledExecutor()___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutor)___		assertFalse(retryFuture.isDone())___		final Collection<ScheduledFuture<?>> scheduledTasks = scheduledExecutor.getScheduledTasks()___		assertFalse(scheduledTasks.isEmpty())___		final ScheduledFuture<?> scheduledFuture = scheduledTasks.iterator().next()___		assertFalse(scheduledFuture.isDone())___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		assertTrue(scheduledFuture.isCancelled())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,final,manually,triggered,scheduled,executor,scheduled,executor,new,manually,triggered,scheduled,executor,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,assert,false,retry,future,is,done,final,collection,scheduled,future,scheduled,tasks,scheduled,executor,get,scheduled,tasks,assert,false,scheduled,tasks,is,empty,final,scheduled,future,scheduled,future,scheduled,tasks,iterator,next,assert,false,scheduled,future,is,done,retry,future,cancel,false,assert,true,retry,future,is,cancelled,assert,true,scheduled,future,is,cancelled
FutureUtilsTest -> @Test 	public void testRetryWithDelayCancellation();1549365080;Tests that all scheduled tasks are canceled if the retry future is being cancelled.;@Test_	public void testRetryWithDelayCancellation() {_		final ManuallyTriggeredScheduledExecutor scheduledExecutor = new ManuallyTriggeredScheduledExecutor()___		CompletableFuture<?> retryFuture = FutureUtils.retryWithDelay(_			() -> FutureUtils.completedExceptionally(new FlinkException("Test exception")),_			1,_			TestingUtils.infiniteTime(),_			scheduledExecutor)___		assertFalse(retryFuture.isDone())___		final Collection<ScheduledFuture<?>> scheduledTasks = scheduledExecutor.getScheduledTasks()___		assertFalse(scheduledTasks.isEmpty())___		final ScheduledFuture<?> scheduledFuture = scheduledTasks.iterator().next()___		assertFalse(scheduledFuture.isDone())___		retryFuture.cancel(false)___		assertTrue(retryFuture.isCancelled())__		assertTrue(scheduledFuture.isCancelled())__	};tests,that,all,scheduled,tasks,are,canceled,if,the,retry,future,is,being,cancelled;test,public,void,test,retry,with,delay,cancellation,final,manually,triggered,scheduled,executor,scheduled,executor,new,manually,triggered,scheduled,executor,completable,future,retry,future,future,utils,retry,with,delay,future,utils,completed,exceptionally,new,flink,exception,test,exception,1,testing,utils,infinite,time,scheduled,executor,assert,false,retry,future,is,done,final,collection,scheduled,future,scheduled,tasks,scheduled,executor,get,scheduled,tasks,assert,false,scheduled,tasks,is,empty,final,scheduled,future,scheduled,future,scheduled,tasks,iterator,next,assert,false,scheduled,future,is,done,retry,future,cancel,false,assert,true,retry,future,is,cancelled,assert,true,scheduled,future,is,cancelled
