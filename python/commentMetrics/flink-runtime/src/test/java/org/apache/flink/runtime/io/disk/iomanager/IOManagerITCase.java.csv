# id;timestamp;commentText;codeText;commentWords;codeWords
IOManagerITCase -> @Test 	@SuppressWarnings("unchecked") 	public void parallelChannelsTest() throws Exception;1426697080;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	@SuppressWarnings("unchecked")_	public void parallelChannelsTest() throws Exception {_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DefaultMemoryManagerTest.DummyInvokable()__		_		FileIOChannel.ID[] ids = new FileIOChannel.ID[NUM_CHANNELS]__		BlockChannelWriter<MemorySegment>[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader<MemorySegment>[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,suppress,warnings,unchecked,public,void,parallel,channels,test,throws,exception,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,default,memory,manager,test,dummy,invokable,file,iochannel,id,ids,new,file,iochannel,id,block,channel,writer,memory,segment,writers,new,block,channel,writer,block,channel,reader,memory,segment,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,for,int,i,0,i,i,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,for,int,i,0,i,i,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	@SuppressWarnings("unchecked") 	public void parallelChannelsTest() throws Exception;1432650142;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	@SuppressWarnings("unchecked")_	public void parallelChannelsTest() throws Exception {_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new MemoryManagerTest.DummyInvokable()__		_		FileIOChannel.ID[] ids = new FileIOChannel.ID[NUM_CHANNELS]__		BlockChannelWriter<MemorySegment>[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader<MemorySegment>[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,suppress,warnings,unchecked,public,void,parallel,channels,test,throws,exception,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,memory,manager,test,dummy,invokable,file,iochannel,id,ids,new,file,iochannel,id,block,channel,writer,memory,segment,writers,new,block,channel,writer,block,channel,reader,memory,segment,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,for,int,i,0,i,i,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,for,int,i,0,i,i,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	@SuppressWarnings("unchecked") 	public void parallelChannelsTest() throws Exception;1439908661;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	@SuppressWarnings("unchecked")_	public void parallelChannelsTest() throws Exception {_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DummyInvokable()__		_		FileIOChannel.ID[] ids = new FileIOChannel.ID[NUM_CHANNELS]__		BlockChannelWriter<MemorySegment>[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader<MemorySegment>[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,suppress,warnings,unchecked,public,void,parallel,channels,test,throws,exception,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,dummy,invokable,file,iochannel,id,ids,new,file,iochannel,id,block,channel,writer,memory,segment,writers,new,block,channel,writer,block,channel,reader,memory,segment,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,for,int,i,0,i,i,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,for,int,i,0,i,i,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	@SuppressWarnings("unchecked") 	public void parallelChannelsTest() throws Exception;1441738685;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	@SuppressWarnings("unchecked")_	public void parallelChannelsTest() throws Exception {_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DummyInvokable()__		_		FileIOChannel.ID[] ids = new FileIOChannel.ID[NUM_CHANNELS]__		BlockChannelWriter<MemorySegment>[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader<MemorySegment>[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,suppress,warnings,unchecked,public,void,parallel,channels,test,throws,exception,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,dummy,invokable,file,iochannel,id,ids,new,file,iochannel,id,block,channel,writer,memory,segment,writers,new,block,channel,writer,block,channel,reader,memory,segment,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,for,int,i,0,i,i,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,for,int,i,0,i,i,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	@SuppressWarnings("unchecked") 	public void parallelChannelsTest() throws Exception;1492256211;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	@SuppressWarnings("unchecked")_	public void parallelChannelsTest() throws Exception {_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DummyInvokable()__		_		FileIOChannel.ID[] ids = new FileIOChannel.ID[NUM_CHANNELS]__		BlockChannelWriter<MemorySegment>[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader<MemorySegment>[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			final BlockChannelReader<MemorySegment> reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,suppress,warnings,unchecked,public,void,parallel,channels,test,throws,exception,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,dummy,invokable,file,iochannel,id,ids,new,file,iochannel,id,block,channel,writer,memory,segment,writers,new,block,channel,writer,block,channel,reader,memory,segment,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,for,int,i,0,i,i,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,final,block,channel,reader,memory,segment,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,for,int,i,0,i,i,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	public void parallelChannelsTest() throws Exception;1405024514;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	public void parallelChannelsTest() throws Exception_	{_		LOG.info("Starting parallel channels test.")__		_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DefaultMemoryManagerTest.DummyInvokable()__		_		Channel.ID[] ids = new Channel.ID[NUM_CHANNELS]__		BlockChannelWriter[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		int nextLogCount = 0__		float nextLogFraction = 0.0f__		_		LOG.info("Writing to channels...")__		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		LOG.info("Writing done, flushing contents...")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		LOG.info("Reading channels sequentially...")__		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			_			LOG.info("Reading channel " + (i+1) + "/" + NUM_CHANNELS + '.')__				_			final BlockChannelReader reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		LOG.info("Sequential reading done.")__		_		_		LOG.info("Reading channels randomly...")__		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		nextLogCount = 0__		nextLogFraction = 0.0f__		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		LOG.info("Random reading done.")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,public,void,parallel,channels,test,throws,exception,log,info,starting,parallel,channels,test,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,default,memory,manager,test,dummy,invokable,channel,id,ids,new,channel,id,block,channel,writer,writers,new,block,channel,writer,block,channel,reader,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,int,next,log,count,0,float,next,log,fraction,0,0f,log,info,writing,to,channels,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,log,info,writing,done,flushing,contents,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,log,info,reading,channels,sequentially,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,log,info,reading,channel,i,1,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,log,info,sequential,reading,done,log,info,reading,channels,randomly,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,next,log,count,0,next,log,fraction,0,0f,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,log,info,random,reading,done,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	public void parallelChannelsTest() throws Exception;1405090423;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	public void parallelChannelsTest() throws Exception_	{_		LOG.info("Starting parallel channels test.")__		_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DefaultMemoryManagerTest.DummyInvokable()__		_		Channel.ID[] ids = new Channel.ID[NUM_CHANNELS]__		BlockChannelWriter[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		int nextLogCount = 0__		float nextLogFraction = 0.0f__		_		LOG.info("Writing to channels...")__		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		LOG.info("Writing done, flushing contents...")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		LOG.info("Reading channels sequentially...")__		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			_			LOG.info("Reading channel " + (i+1) + "/" + NUM_CHANNELS + '.')__				_			final BlockChannelReader reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		LOG.info("Sequential reading done.")__		_		_		LOG.info("Reading channels randomly...")__		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		nextLogCount = 0__		nextLogFraction = 0.0f__		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		LOG.info("Random reading done.")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,public,void,parallel,channels,test,throws,exception,log,info,starting,parallel,channels,test,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,default,memory,manager,test,dummy,invokable,channel,id,ids,new,channel,id,block,channel,writer,writers,new,block,channel,writer,block,channel,reader,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,int,next,log,count,0,float,next,log,fraction,0,0f,log,info,writing,to,channels,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,log,info,writing,done,flushing,contents,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,log,info,reading,channels,sequentially,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,log,info,reading,channel,i,1,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,log,info,sequential,reading,done,log,info,reading,channels,randomly,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,next,log,count,0,next,log,fraction,0,0f,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,log,info,random,reading,done,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	public void parallelChannelsTest() throws Exception;1406674317;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	public void parallelChannelsTest() throws Exception_	{_		LOG.info("Starting parallel channels test.")__		_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DefaultMemoryManagerTest.DummyInvokable()__		_		Channel.ID[] ids = new Channel.ID[NUM_CHANNELS]__		BlockChannelWriter[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		int nextLogCount = 0__		float nextLogFraction = 0.0f__		_		LOG.info("Writing to channels...")__		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		LOG.info("Writing done, flushing contents...")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		LOG.info("Reading channels sequentially...")__		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			_			LOG.info("Reading channel " + (i+1) + "/" + NUM_CHANNELS + '.')__				_			final BlockChannelReader reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		LOG.info("Sequential reading done.")__		_		_		LOG.info("Reading channels randomly...")__		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		nextLogCount = 0__		nextLogFraction = 0.0f__		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		LOG.info("Random reading done.")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,public,void,parallel,channels,test,throws,exception,log,info,starting,parallel,channels,test,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,default,memory,manager,test,dummy,invokable,channel,id,ids,new,channel,id,block,channel,writer,writers,new,block,channel,writer,block,channel,reader,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,int,next,log,count,0,float,next,log,fraction,0,0f,log,info,writing,to,channels,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,log,info,writing,done,flushing,contents,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,log,info,reading,channels,sequentially,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,log,info,reading,channel,i,1,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,log,info,sequential,reading,done,log,info,reading,channels,randomly,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,next,log,count,0,next,log,fraction,0,0f,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,log,info,random,reading,done,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	public void parallelChannelsTest() throws Exception;1409911022;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	public void parallelChannelsTest() throws Exception_	{_		LOG.info("Starting parallel channels test.")__		_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DefaultMemoryManagerTest.DummyInvokable()__		_		Channel.ID[] ids = new Channel.ID[NUM_CHANNELS]__		BlockChannelWriter[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		int nextLogCount = 0__		float nextLogFraction = 0.0f__		_		LOG.info("Writing to channels...")__		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		LOG.info("Writing done, flushing contents...")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		LOG.info("Reading channels sequentially...")__		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			_			LOG.info("Reading channel " + (i+1) + "/" + NUM_CHANNELS + '.')__				_			final BlockChannelReader reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		LOG.info("Sequential reading done.")__		_		_		LOG.info("Reading channels randomly...")__		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		nextLogCount = 0__		nextLogFraction = 0.0f__		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		LOG.info("Random reading done.")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,public,void,parallel,channels,test,throws,exception,log,info,starting,parallel,channels,test,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,default,memory,manager,test,dummy,invokable,channel,id,ids,new,channel,id,block,channel,writer,writers,new,block,channel,writer,block,channel,reader,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,int,next,log,count,0,float,next,log,fraction,0,0f,log,info,writing,to,channels,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,log,info,writing,done,flushing,contents,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,log,info,reading,channels,sequentially,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,log,info,reading,channel,i,1,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,log,info,sequential,reading,done,log,info,reading,channels,randomly,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,next,log,count,0,next,log,fraction,0,0f,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,log,info,random,reading,done,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	public void parallelChannelsTest() throws Exception;1411236169;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	public void parallelChannelsTest() throws Exception_	{_		LOG.info("Starting parallel channels test.")__		_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DefaultMemoryManagerTest.DummyInvokable()__		_		Channel.ID[] ids = new Channel.ID[NUM_CHANNELS]__		BlockChannelWriter[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		int nextLogCount = 0__		float nextLogFraction = 0.0f__		_		LOG.info("Writing to channels...")__		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		LOG.info("Writing done, flushing contents...")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		LOG.info("Reading channels sequentially...")__		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			_			LOG.info("Reading channel " + (i+1) + "/" + NUM_CHANNELS + '.')__				_			final BlockChannelReader reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		LOG.info("Sequential reading done.")__		_		_		LOG.info("Reading channels randomly...")__		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		nextLogCount = 0__		nextLogFraction = 0.0f__		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		LOG.info("Random reading done.")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,public,void,parallel,channels,test,throws,exception,log,info,starting,parallel,channels,test,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,default,memory,manager,test,dummy,invokable,channel,id,ids,new,channel,id,block,channel,writer,writers,new,block,channel,writer,block,channel,reader,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,int,next,log,count,0,float,next,log,fraction,0,0f,log,info,writing,to,channels,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,log,info,writing,done,flushing,contents,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,log,info,reading,channels,sequentially,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,log,info,reading,channel,i,1,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,log,info,sequential,reading,done,log,info,reading,channels,randomly,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,next,log,count,0,next,log,fraction,0,0f,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,log,info,random,reading,done,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	public void parallelChannelsTest() throws Exception;1411473593;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	public void parallelChannelsTest() throws Exception_	{_		LOG.info("Starting parallel channels test.")__		_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DefaultMemoryManagerTest.DummyInvokable()__		_		Channel.ID[] ids = new Channel.ID[NUM_CHANNELS]__		BlockChannelWriter[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		int nextLogCount = 0__		float nextLogFraction = 0.0f__		_		LOG.info("Writing to channels...")__		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		LOG.info("Writing done, flushing contents...")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		LOG.info("Reading channels sequentially...")__		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			_			LOG.info("Reading channel " + (i+1) + "/" + NUM_CHANNELS + '.')__				_			final BlockChannelReader reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		LOG.info("Sequential reading done.")__		_		_		LOG.info("Reading channels randomly...")__		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		nextLogCount = 0__		nextLogFraction = 0.0f__		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		LOG.info("Random reading done.")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,public,void,parallel,channels,test,throws,exception,log,info,starting,parallel,channels,test,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,default,memory,manager,test,dummy,invokable,channel,id,ids,new,channel,id,block,channel,writer,writers,new,block,channel,writer,block,channel,reader,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,int,next,log,count,0,float,next,log,fraction,0,0f,log,info,writing,to,channels,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,log,info,writing,done,flushing,contents,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,log,info,reading,channels,sequentially,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,log,info,reading,channel,i,1,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,log,info,sequential,reading,done,log,info,reading,channels,randomly,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,next,log,count,0,next,log,fraction,0,0f,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,log,info,random,reading,done,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	public void parallelChannelsTest() throws Exception;1415702894;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	public void parallelChannelsTest() throws Exception_	{_		LOG.info("Starting parallel channels test.")__		_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DefaultMemoryManagerTest.DummyInvokable()__		_		FileIOChannel.ID[] ids = new FileIOChannel.ID[NUM_CHANNELS]__		BlockChannelWriter[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		int nextLogCount = 0__		float nextLogFraction = 0.0f__		_		LOG.info("Writing to channels...")__		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		LOG.info("Writing done, flushing contents...")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		LOG.info("Reading channels sequentially...")__		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__			_			LOG.info("Reading channel " + (i+1) + "/" + NUM_CHANNELS + '.')__				_			final BlockChannelReader reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		LOG.info("Sequential reading done.")__		_		_		LOG.info("Reading channels randomly...")__		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(NUMBER_OF_SEGMENTS - 2) + 2)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		nextLogCount = 0__		nextLogFraction = 0.0f__		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			if (i == nextLogCount) {_				LOG.info("... " + (int) (nextLogFraction * 100) + "% done.")__				nextLogFraction += 0.05__				nextLogCount = (int) (nextLogFraction * NUMBERS_TO_BE_WRITTEN)__			}_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		LOG.info("Random reading done.")__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,public,void,parallel,channels,test,throws,exception,log,info,starting,parallel,channels,test,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,default,memory,manager,test,dummy,invokable,file,iochannel,id,ids,new,file,iochannel,id,block,channel,writer,writers,new,block,channel,writer,block,channel,reader,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,int,next,log,count,0,float,next,log,fraction,0,0f,log,info,writing,to,channels,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,log,info,writing,done,flushing,contents,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,log,info,reading,channels,sequentially,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,log,info,reading,channel,i,1,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,log,info,sequential,reading,done,log,info,reading,channels,randomly,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,2,2,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,next,log,count,0,next,log,fraction,0,0f,for,int,i,0,i,i,if,i,next,log,count,log,info,int,next,log,fraction,100,done,next,log,fraction,0,05,next,log,count,int,next,log,fraction,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,log,info,random,reading,done,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
IOManagerITCase -> @Test 	public void parallelChannelsTest() throws Exception;1421838095;This test instantiates multiple channels and writes to them in parallel and re-reads the data in_parallel. It is designed to check the ability of the IO manager to correctly handle multiple threads.;@Test_	public void parallelChannelsTest() throws Exception {_		final Random rnd = new Random(SEED)__		final AbstractInvokable memOwner = new DefaultMemoryManagerTest.DummyInvokable()__		_		FileIOChannel.ID[] ids = new FileIOChannel.ID[NUM_CHANNELS]__		BlockChannelWriter[] writers = new BlockChannelWriter[NUM_CHANNELS]__		BlockChannelReader[] readers = new BlockChannelReader[NUM_CHANNELS]__		ChannelWriterOutputView[] outs = new ChannelWriterOutputView[NUM_CHANNELS]__		ChannelReaderInputView[] ins = new ChannelReaderInputView[NUM_CHANNELS]__		_		int[] writingCounters = new int[NUM_CHANNELS]__		int[] readingCounters = new int[NUM_CHANNELS]__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++)_		{_			ids[i] = this.ioManager.createChannel()__			writers[i] = this.ioManager.createBlockChannelWriter(ids[i])__			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__			outs[i] = new ChannelWriterOutputView(writers[i], memSegs, this.memoryManager.getPageSize())__		}_		_		_		Value val = new Value()__		_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			int channel = skewedSample(rnd, NUM_CHANNELS - 1)__			_			val.value = String.valueOf(writingCounters[channel]++)__			val.write(outs[channel])__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			this.memoryManager.release(outs[i].close())__		}_		outs = null__		writers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			final BlockChannelReader reader = this.ioManager.createBlockChannelReader(ids[i])__			final ChannelReaderInputView in = new ChannelReaderInputView(reader, memSegs, false)__			int nextVal = 0__			_			try {_				while (true) {_					val.read(in)__					int intValue = 0__					try {_						intValue = Integer.parseInt(val.value)__					}_					catch (NumberFormatException nfex) {_						Assert.fail("Invalid value read from reader. Valid decimal number expected.")__					}_					Assert.assertEquals("Written and read values do not match during sequential read.", nextVal, intValue)__					nextVal++__				}_			} catch (EOFException eofex) {_				_			}_			_			Assert.assertEquals("NUmber of written numbers differs from number of read numbers.", writingCounters[i], nextVal)__			_			this.memoryManager.release(in.close())__		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			_			List<MemorySegment> memSegs = this.memoryManager.allocatePages(memOwner, rnd.nextInt(MAXIMUM_NUMBER_OF_SEGMENTS_PER_CHANNEL - 1) + 1)__				_			readers[i] = this.ioManager.createBlockChannelReader(ids[i])__			ins[i] = new ChannelReaderInputView(readers[i], memSegs, false)__		}_		_		_		for (int i = 0_ i < NUMBERS_TO_BE_WRITTEN_ i++) {_			_			while (true) {_				final int channel = skewedSample(rnd, NUM_CHANNELS - 1)__				if (ins[channel] != null) {_					try {_						val.read(ins[channel])__						int intValue__						try {_							intValue = Integer.parseInt(val.value)__						}_						catch (NumberFormatException nfex) {_							Assert.fail("Invalid value read from reader. Valid decimal number expected.")__							return__						}_						_						Assert.assertEquals("Written and read values do not match.", readingCounters[channel]++, intValue)__						_						break__					} catch (EOFException eofex) {_						this.memoryManager.release(ins[channel].close())__						ins[channel] = null__					}_				}_			}_			_		}_		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			if (ins[i] != null) {_				this.memoryManager.release(ins[i].close())__			}_			readers[i].closeAndDelete()__		}_		_		ins = null__		readers = null__		_		_		for (int i = 0_ i < NUM_CHANNELS_ i++) {_			File f = new File(ids[i].getPath())__			Assert.assertFalse("Channel file has not been deleted.", f.exists())__		}_	};this,test,instantiates,multiple,channels,and,writes,to,them,in,parallel,and,re,reads,the,data,in,parallel,it,is,designed,to,check,the,ability,of,the,io,manager,to,correctly,handle,multiple,threads;test,public,void,parallel,channels,test,throws,exception,final,random,rnd,new,random,seed,final,abstract,invokable,mem,owner,new,default,memory,manager,test,dummy,invokable,file,iochannel,id,ids,new,file,iochannel,id,block,channel,writer,writers,new,block,channel,writer,block,channel,reader,readers,new,block,channel,reader,channel,writer,output,view,outs,new,channel,writer,output,view,channel,reader,input,view,ins,new,channel,reader,input,view,int,writing,counters,new,int,int,reading,counters,new,int,for,int,i,0,i,i,ids,i,this,io,manager,create,channel,writers,i,this,io,manager,create,block,channel,writer,ids,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,outs,i,new,channel,writer,output,view,writers,i,mem,segs,this,memory,manager,get,page,size,value,val,new,value,for,int,i,0,i,i,int,channel,skewed,sample,rnd,1,val,value,string,value,of,writing,counters,channel,val,write,outs,channel,for,int,i,0,i,i,this,memory,manager,release,outs,i,close,outs,null,writers,null,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,final,block,channel,reader,reader,this,io,manager,create,block,channel,reader,ids,i,final,channel,reader,input,view,in,new,channel,reader,input,view,reader,mem,segs,false,int,next,val,0,try,while,true,val,read,in,int,int,value,0,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,assert,assert,equals,written,and,read,values,do,not,match,during,sequential,read,next,val,int,value,next,val,catch,eofexception,eofex,assert,assert,equals,number,of,written,numbers,differs,from,number,of,read,numbers,writing,counters,i,next,val,this,memory,manager,release,in,close,for,int,i,0,i,i,list,memory,segment,mem,segs,this,memory,manager,allocate,pages,mem,owner,rnd,next,int,1,1,readers,i,this,io,manager,create,block,channel,reader,ids,i,ins,i,new,channel,reader,input,view,readers,i,mem,segs,false,for,int,i,0,i,i,while,true,final,int,channel,skewed,sample,rnd,1,if,ins,channel,null,try,val,read,ins,channel,int,int,value,try,int,value,integer,parse,int,val,value,catch,number,format,exception,nfex,assert,fail,invalid,value,read,from,reader,valid,decimal,number,expected,return,assert,assert,equals,written,and,read,values,do,not,match,reading,counters,channel,int,value,break,catch,eofexception,eofex,this,memory,manager,release,ins,channel,close,ins,channel,null,for,int,i,0,i,i,if,ins,i,null,this,memory,manager,release,ins,i,close,readers,i,close,and,delete,ins,null,readers,null,for,int,i,0,i,i,file,f,new,file,ids,i,get,path,assert,assert,false,channel,file,has,not,been,deleted,f,exists
