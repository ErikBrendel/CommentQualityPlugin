# id;timestamp;commentText;codeText;commentWords;codeWords
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnWrite() throws Exception;1432625417;Verifies that failed client requests via {@link PartitionRequestClient} are correctly_attributed to the respective {@link RemoteInputChannel}.;@Test_	public void testExceptionOnWrite() throws Exception {__		NettyProtocol protocol = new NettyProtocol() {_			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[0]__			}__			@Override_			public ChannelHandler[] getClientChannelHandlers() {_				return new PartitionRequestProtocol(_						mock(ResultPartitionProvider.class),_						mock(TaskEventDispatcher.class),_						mock(NetworkBufferPool.class)).getClientChannelHandlers()__			}_		}___		_		_		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		ch.pipeline().addFirst(new ChannelOutboundHandlerAdapter() {_			int writeNum = 0___			@Override_			public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)_					throws Exception {__				if (writeNum >= 1) {_					throw new RuntimeException("Expected test exception.")__				}__				writeNum++__				ctx.write(msg, promise)__			}_		})___		PartitionRequestClient requestClient = new PartitionRequestClient(_				ch, handler, mock(ConnectionID.class), mock(PartitionRequestClientFactory.class))___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(1)___		_		_		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}).when(rich[1]).onError(isA(LocalTransportException.class))___		_		ChannelFuture f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[0], 0)__		assertTrue(f.await().isSuccess())___		_		f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[1], 0)__		assertFalse(f.await().isSuccess())___		_		verify(rich[0], times(0)).onError(any(LocalTransportException.class))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about the channel error.")__		}__		shutdown(serverAndClient)__	};verifies,that,failed,client,requests,via,link,partition,request,client,are,correctly,attributed,to,the,respective,link,remote,input,channel;test,public,void,test,exception,on,write,throws,exception,netty,protocol,protocol,new,netty,protocol,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,0,override,public,channel,handler,get,client,channel,handlers,return,new,partition,request,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,mock,network,buffer,pool,class,get,client,channel,handlers,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,partition,request,client,handler,handler,get,client,handler,ch,ch,pipeline,add,first,new,channel,outbound,handler,adapter,int,write,num,0,override,public,void,write,channel,handler,context,ctx,object,msg,channel,promise,promise,throws,exception,if,write,num,1,throw,new,runtime,exception,expected,test,exception,write,num,ctx,write,msg,promise,partition,request,client,request,client,new,partition,request,client,ch,handler,mock,connection,id,class,mock,partition,request,client,factory,class,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,when,rich,1,on,error,is,a,local,transport,exception,class,channel,future,f,request,client,request,subpartition,new,result,partition,id,0,rich,0,0,assert,true,f,await,is,success,f,request,client,request,subpartition,new,result,partition,id,0,rich,1,0,assert,false,f,await,is,success,verify,rich,0,times,0,on,error,any,local,transport,exception,class,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,the,channel,error,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnWrite() throws Exception;1487082763;Verifies that failed client requests via {@link PartitionRequestClient} are correctly_attributed to the respective {@link RemoteInputChannel}.;@Test_	public void testExceptionOnWrite() throws Exception {__		NettyProtocol protocol = new NettyProtocol() {_			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[0]__			}__			@Override_			public ChannelHandler[] getClientChannelHandlers() {_				return new PartitionRequestProtocol(_						mock(ResultPartitionProvider.class),_						mock(TaskEventDispatcher.class),_						mock(NetworkBufferPool.class)).getClientChannelHandlers()__			}_		}___		_		_		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		ch.pipeline().addFirst(new ChannelOutboundHandlerAdapter() {_			int writeNum = 0___			@Override_			public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)_					throws Exception {__				if (writeNum >= 1) {_					throw new RuntimeException("Expected test exception.")__				}__				writeNum++__				ctx.write(msg, promise)__			}_		})___		PartitionRequestClient requestClient = new PartitionRequestClient(_				ch, handler, mock(ConnectionID.class), mock(PartitionRequestClientFactory.class))___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(1)___		_		_		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}).when(rich[1]).onError(isA(LocalTransportException.class))___		_		ChannelFuture f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[0], 0)__		assertTrue(f.await().isSuccess())___		_		f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[1], 0)__		assertFalse(f.await().isSuccess())___		_		verify(rich[0], times(0)).onError(any(LocalTransportException.class))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about the channel error.")__		}__		shutdown(serverAndClient)__	};verifies,that,failed,client,requests,via,link,partition,request,client,are,correctly,attributed,to,the,respective,link,remote,input,channel;test,public,void,test,exception,on,write,throws,exception,netty,protocol,protocol,new,netty,protocol,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,0,override,public,channel,handler,get,client,channel,handlers,return,new,partition,request,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,mock,network,buffer,pool,class,get,client,channel,handlers,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,partition,request,client,handler,handler,get,client,handler,ch,ch,pipeline,add,first,new,channel,outbound,handler,adapter,int,write,num,0,override,public,void,write,channel,handler,context,ctx,object,msg,channel,promise,promise,throws,exception,if,write,num,1,throw,new,runtime,exception,expected,test,exception,write,num,ctx,write,msg,promise,partition,request,client,request,client,new,partition,request,client,ch,handler,mock,connection,id,class,mock,partition,request,client,factory,class,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,when,rich,1,on,error,is,a,local,transport,exception,class,channel,future,f,request,client,request,subpartition,new,result,partition,id,0,rich,0,0,assert,true,f,await,is,success,f,request,client,request,subpartition,new,result,partition,id,0,rich,1,0,assert,false,f,await,is,success,verify,rich,0,times,0,on,error,any,local,transport,exception,class,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,the,channel,error,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnWrite() throws Exception;1493724918;Verifies that failed client requests via {@link PartitionRequestClient} are correctly_attributed to the respective {@link RemoteInputChannel}.;@Test_	public void testExceptionOnWrite() throws Exception {__		NettyProtocol protocol = new NettyProtocol() {_			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[0]__			}__			@Override_			public ChannelHandler[] getClientChannelHandlers() {_				return new PartitionRequestProtocol(_						mock(ResultPartitionProvider.class),_						mock(TaskEventDispatcher.class)).getClientChannelHandlers()__			}_		}___		_		_		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		ch.pipeline().addFirst(new ChannelOutboundHandlerAdapter() {_			int writeNum = 0___			@Override_			public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)_					throws Exception {__				if (writeNum >= 1) {_					throw new RuntimeException("Expected test exception.")__				}__				writeNum++__				ctx.write(msg, promise)__			}_		})___		PartitionRequestClient requestClient = new PartitionRequestClient(_				ch, handler, mock(ConnectionID.class), mock(PartitionRequestClientFactory.class))___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(1)___		_		_		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}).when(rich[1]).onError(isA(LocalTransportException.class))___		_		ChannelFuture f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[0], 0)__		assertTrue(f.await().isSuccess())___		_		f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[1], 0)__		assertFalse(f.await().isSuccess())___		_		verify(rich[0], times(0)).onError(any(LocalTransportException.class))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about the channel error.")__		}__		shutdown(serverAndClient)__	};verifies,that,failed,client,requests,via,link,partition,request,client,are,correctly,attributed,to,the,respective,link,remote,input,channel;test,public,void,test,exception,on,write,throws,exception,netty,protocol,protocol,new,netty,protocol,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,0,override,public,channel,handler,get,client,channel,handlers,return,new,partition,request,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,get,client,channel,handlers,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,partition,request,client,handler,handler,get,client,handler,ch,ch,pipeline,add,first,new,channel,outbound,handler,adapter,int,write,num,0,override,public,void,write,channel,handler,context,ctx,object,msg,channel,promise,promise,throws,exception,if,write,num,1,throw,new,runtime,exception,expected,test,exception,write,num,ctx,write,msg,promise,partition,request,client,request,client,new,partition,request,client,ch,handler,mock,connection,id,class,mock,partition,request,client,factory,class,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,when,rich,1,on,error,is,a,local,transport,exception,class,channel,future,f,request,client,request,subpartition,new,result,partition,id,0,rich,0,0,assert,true,f,await,is,success,f,request,client,request,subpartition,new,result,partition,id,0,rich,1,0,assert,false,f,await,is,success,verify,rich,0,times,0,on,error,any,local,transport,exception,class,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,the,channel,error,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnWrite() throws Exception;1502111816;Verifies that failed client requests via {@link PartitionRequestClient} are correctly_attributed to the respective {@link RemoteInputChannel}.;@Test_	public void testExceptionOnWrite() throws Exception {__		NettyProtocol protocol = new NettyProtocol() {_			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[0]__			}__			@Override_			public ChannelHandler[] getClientChannelHandlers() {_				return new PartitionRequestProtocol(_						mock(ResultPartitionProvider.class),_						mock(TaskEventDispatcher.class)).getClientChannelHandlers()__			}_		}___		_		_		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		ch.pipeline().addFirst(new ChannelOutboundHandlerAdapter() {_			int writeNum = 0___			@Override_			public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)_					throws Exception {__				if (writeNum >= 1) {_					throw new RuntimeException("Expected test exception.")__				}__				writeNum++__				ctx.write(msg, promise)__			}_		})___		PartitionRequestClient requestClient = new PartitionRequestClient(_				ch, handler, mock(ConnectionID.class), mock(PartitionRequestClientFactory.class))___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(1)___		_		_		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}).when(rich[1]).onError(isA(LocalTransportException.class))___		_		ChannelFuture f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[0], 0)__		assertTrue(f.await().isSuccess())___		_		f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[1], 0)__		assertFalse(f.await().isSuccess())___		_		verify(rich[0], times(0)).onError(any(LocalTransportException.class))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about the channel error.")__		}__		shutdown(serverAndClient)__	};verifies,that,failed,client,requests,via,link,partition,request,client,are,correctly,attributed,to,the,respective,link,remote,input,channel;test,public,void,test,exception,on,write,throws,exception,netty,protocol,protocol,new,netty,protocol,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,0,override,public,channel,handler,get,client,channel,handlers,return,new,partition,request,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,get,client,channel,handlers,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,partition,request,client,handler,handler,get,client,handler,ch,ch,pipeline,add,first,new,channel,outbound,handler,adapter,int,write,num,0,override,public,void,write,channel,handler,context,ctx,object,msg,channel,promise,promise,throws,exception,if,write,num,1,throw,new,runtime,exception,expected,test,exception,write,num,ctx,write,msg,promise,partition,request,client,request,client,new,partition,request,client,ch,handler,mock,connection,id,class,mock,partition,request,client,factory,class,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,when,rich,1,on,error,is,a,local,transport,exception,class,channel,future,f,request,client,request,subpartition,new,result,partition,id,0,rich,0,0,assert,true,f,await,is,success,f,request,client,request,subpartition,new,result,partition,id,0,rich,1,0,assert,false,f,await,is,success,verify,rich,0,times,0,on,error,any,local,transport,exception,class,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,the,channel,error,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnWrite() throws Exception;1515160618;Verifies that failed client requests via {@link PartitionRequestClient} are correctly_attributed to the respective {@link RemoteInputChannel}.;@Test_	public void testExceptionOnWrite() throws Exception {__		NettyProtocol protocol = new NettyProtocol(_				mock(ResultPartitionProvider.class),_				mock(TaskEventDispatcher.class)) {__			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[0]__			}_		}___		_		_		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		ch.pipeline().addFirst(new ChannelOutboundHandlerAdapter() {_			int writeNum = 0___			@Override_			public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)_					throws Exception {__				if (writeNum >= 1) {_					throw new RuntimeException("Expected test exception.")__				}__				writeNum++__				ctx.write(msg, promise)__			}_		})___		PartitionRequestClient requestClient = new PartitionRequestClient(_				ch, handler, mock(ConnectionID.class), mock(PartitionRequestClientFactory.class))___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(1)___		_		_		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}).when(rich[1]).onError(isA(LocalTransportException.class))___		_		ChannelFuture f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[0], 0)__		assertTrue(f.await().isSuccess())___		_		f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[1], 0)__		assertFalse(f.await().isSuccess())___		_		verify(rich[0], times(0)).onError(any(LocalTransportException.class))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about the channel error.")__		}__		shutdown(serverAndClient)__	};verifies,that,failed,client,requests,via,link,partition,request,client,are,correctly,attributed,to,the,respective,link,remote,input,channel;test,public,void,test,exception,on,write,throws,exception,netty,protocol,protocol,new,netty,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,0,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,partition,request,client,handler,handler,get,client,handler,ch,ch,pipeline,add,first,new,channel,outbound,handler,adapter,int,write,num,0,override,public,void,write,channel,handler,context,ctx,object,msg,channel,promise,promise,throws,exception,if,write,num,1,throw,new,runtime,exception,expected,test,exception,write,num,ctx,write,msg,promise,partition,request,client,request,client,new,partition,request,client,ch,handler,mock,connection,id,class,mock,partition,request,client,factory,class,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,when,rich,1,on,error,is,a,local,transport,exception,class,channel,future,f,request,client,request,subpartition,new,result,partition,id,0,rich,0,0,assert,true,f,await,is,success,f,request,client,request,subpartition,new,result,partition,id,0,rich,1,0,assert,false,f,await,is,success,verify,rich,0,times,0,on,error,any,local,transport,exception,class,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,the,channel,error,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnWrite() throws Exception;1518785736;Verifies that failed client requests via {@link PartitionRequestClient} are correctly_attributed to the respective {@link RemoteInputChannel}.;@Test_	public void testExceptionOnWrite() throws Exception {__		NettyProtocol protocol = new NettyProtocol(_				mock(ResultPartitionProvider.class),_				mock(TaskEventDispatcher.class),_				true) {__			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[0]__			}_		}___		_		_		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		NetworkClientHandler handler = getClientHandler(ch)___		_		ch.pipeline().addFirst(new ChannelOutboundHandlerAdapter() {_			int writeNum = 0___			@Override_			public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)_					throws Exception {__				if (writeNum >= 1) {_					throw new RuntimeException("Expected test exception.")__				}__				writeNum++__				ctx.write(msg, promise)__			}_		})___		PartitionRequestClient requestClient = new PartitionRequestClient(_				ch, handler, mock(ConnectionID.class), mock(PartitionRequestClientFactory.class))___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(1)___		_		_		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}).when(rich[1]).onError(isA(LocalTransportException.class))___		_		ChannelFuture f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[0], 0)__		assertTrue(f.await().isSuccess())___		_		f = requestClient.requestSubpartition(new ResultPartitionID(), 0, rich[1], 0)__		assertFalse(f.await().isSuccess())___		_		verify(rich[0], times(0)).onError(any(LocalTransportException.class))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about the channel error.")__		}__		shutdown(serverAndClient)__	};verifies,that,failed,client,requests,via,link,partition,request,client,are,correctly,attributed,to,the,respective,link,remote,input,channel;test,public,void,test,exception,on,write,throws,exception,netty,protocol,protocol,new,netty,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,true,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,0,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,network,client,handler,handler,get,client,handler,ch,ch,pipeline,add,first,new,channel,outbound,handler,adapter,int,write,num,0,override,public,void,write,channel,handler,context,ctx,object,msg,channel,promise,promise,throws,exception,if,write,num,1,throw,new,runtime,exception,expected,test,exception,write,num,ctx,write,msg,promise,partition,request,client,request,client,new,partition,request,client,ch,handler,mock,connection,id,class,mock,partition,request,client,factory,class,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,when,rich,1,on,error,is,a,local,transport,exception,class,channel,future,f,request,client,request,subpartition,new,result,partition,id,0,rich,0,0,assert,true,f,await,is,success,f,request,client,request,subpartition,new,result,partition,id,0,rich,1,0,assert,false,f,await,is,success,verify,rich,0,times,0,on,error,any,local,transport,exception,class,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,the,channel,error,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testWrappingOfRemoteErrorMessage() throws Exception;1432625417;Verifies that {@link NettyMessage.ErrorResponse} messages are correctly wrapped in_{@link RemoteTransportException} instances.;@Test_	public void testWrappingOfRemoteErrorMessage() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception"),_				rich[0].getInputChannelId()))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(1)).onError(isA(RemoteTransportException.class))__		verify(rich[1], never()).onError(any(Throwable.class))___		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception")))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(2)).onError(isA(RemoteTransportException.class))__		verify(rich[1], times(1)).onError(isA(RemoteTransportException.class))__	};verifies,that,link,netty,message,error,response,messages,are,correctly,wrapped,in,link,remote,transport,exception,instances;test,public,void,test,wrapping,of,remote,error,message,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,rich,0,get,input,channel,id,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,1,on,error,is,a,remote,transport,exception,class,verify,rich,1,never,on,error,any,throwable,class,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,2,on,error,is,a,remote,transport,exception,class,verify,rich,1,times,1,on,error,is,a,remote,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testWrappingOfRemoteErrorMessage() throws Exception;1487082763;Verifies that {@link NettyMessage.ErrorResponse} messages are correctly wrapped in_{@link RemoteTransportException} instances.;@Test_	public void testWrappingOfRemoteErrorMessage() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception"),_				rich[0].getInputChannelId()))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(1)).onError(isA(RemoteTransportException.class))__		verify(rich[1], never()).onError(any(Throwable.class))___		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception")))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(2)).onError(isA(RemoteTransportException.class))__		verify(rich[1], times(1)).onError(isA(RemoteTransportException.class))__	};verifies,that,link,netty,message,error,response,messages,are,correctly,wrapped,in,link,remote,transport,exception,instances;test,public,void,test,wrapping,of,remote,error,message,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,rich,0,get,input,channel,id,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,1,on,error,is,a,remote,transport,exception,class,verify,rich,1,never,on,error,any,throwable,class,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,2,on,error,is,a,remote,transport,exception,class,verify,rich,1,times,1,on,error,is,a,remote,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testWrappingOfRemoteErrorMessage() throws Exception;1493724918;Verifies that {@link NettyMessage.ErrorResponse} messages are correctly wrapped in_{@link RemoteTransportException} instances.;@Test_	public void testWrappingOfRemoteErrorMessage() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception"),_				rich[0].getInputChannelId()))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(1)).onError(isA(RemoteTransportException.class))__		verify(rich[1], never()).onError(any(Throwable.class))___		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception")))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(2)).onError(isA(RemoteTransportException.class))__		verify(rich[1], times(1)).onError(isA(RemoteTransportException.class))__	};verifies,that,link,netty,message,error,response,messages,are,correctly,wrapped,in,link,remote,transport,exception,instances;test,public,void,test,wrapping,of,remote,error,message,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,rich,0,get,input,channel,id,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,1,on,error,is,a,remote,transport,exception,class,verify,rich,1,never,on,error,any,throwable,class,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,2,on,error,is,a,remote,transport,exception,class,verify,rich,1,times,1,on,error,is,a,remote,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testWrappingOfRemoteErrorMessage() throws Exception;1502111816;Verifies that {@link NettyMessage.ErrorResponse} messages are correctly wrapped in_{@link RemoteTransportException} instances.;@Test_	public void testWrappingOfRemoteErrorMessage() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception"),_				rich[0].getInputChannelId()))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(1)).onError(isA(RemoteTransportException.class))__		verify(rich[1], never()).onError(any(Throwable.class))___		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception")))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(2)).onError(isA(RemoteTransportException.class))__		verify(rich[1], times(1)).onError(isA(RemoteTransportException.class))__	};verifies,that,link,netty,message,error,response,messages,are,correctly,wrapped,in,link,remote,transport,exception,instances;test,public,void,test,wrapping,of,remote,error,message,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,rich,0,get,input,channel,id,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,1,on,error,is,a,remote,transport,exception,class,verify,rich,1,never,on,error,any,throwable,class,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,2,on,error,is,a,remote,transport,exception,class,verify,rich,1,times,1,on,error,is,a,remote,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testWrappingOfRemoteErrorMessage() throws Exception;1515160618;Verifies that {@link NettyMessage.ErrorResponse} messages are correctly wrapped in_{@link RemoteTransportException} instances.;@Test_	public void testWrappingOfRemoteErrorMessage() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception"),_				rich[0].getInputChannelId()))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(1)).onError(isA(RemoteTransportException.class))__		verify(rich[1], never()).onError(any(Throwable.class))___		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception")))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(2)).onError(isA(RemoteTransportException.class))__		verify(rich[1], times(1)).onError(isA(RemoteTransportException.class))__	};verifies,that,link,netty,message,error,response,messages,are,correctly,wrapped,in,link,remote,transport,exception,instances;test,public,void,test,wrapping,of,remote,error,message,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,rich,0,get,input,channel,id,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,1,on,error,is,a,remote,transport,exception,class,verify,rich,1,never,on,error,any,throwable,class,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,2,on,error,is,a,remote,transport,exception,class,verify,rich,1,times,1,on,error,is,a,remote,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testWrappingOfRemoteErrorMessage() throws Exception;1518785736;Verifies that {@link NettyMessage.ErrorResponse} messages are correctly wrapped in_{@link RemoteTransportException} instances.;@Test_	public void testWrappingOfRemoteErrorMessage() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		NetworkClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception"),_				rich[0].getInputChannelId()))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(1)).onError(isA(RemoteTransportException.class))__		verify(rich[1], never()).onError(any(Throwable.class))___		_		ch.pipeline().fireChannelRead(new NettyMessage.ErrorResponse(_				new RuntimeException("Expected test exception")))___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		verify(rich[0], times(2)).onError(isA(RemoteTransportException.class))__		verify(rich[1], times(1)).onError(isA(RemoteTransportException.class))__	};verifies,that,link,netty,message,error,response,messages,are,correctly,wrapped,in,link,remote,transport,exception,instances;test,public,void,test,wrapping,of,remote,error,message,throws,exception,embedded,channel,ch,create,embedded,channel,network,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,rich,0,get,input,channel,id,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,1,on,error,is,a,remote,transport,exception,class,verify,rich,1,never,on,error,any,throwable,class,ch,pipeline,fire,channel,read,new,netty,message,error,response,new,runtime,exception,expected,test,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,verify,rich,0,times,2,on,error,is,a,remote,transport,exception,class,verify,rich,1,times,1,on,error,is,a,remote,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionCaught() throws Exception;1432625417;Verifies that fired Exceptions are handled correctly by the pipeline.;@Test_	public void testExceptionCaught() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		ch.pipeline().fireExceptionCaught(new Exception())___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(LocalTransportException.class))__		}_	};verifies,that,fired,exceptions,are,handled,correctly,by,the,pipeline;test,public,void,test,exception,caught,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,exception,caught,new,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,for,remote,input,channel,r,rich,verify,r,on,error,is,a,local,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionCaught() throws Exception;1487082763;Verifies that fired Exceptions are handled correctly by the pipeline.;@Test_	public void testExceptionCaught() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		ch.pipeline().fireExceptionCaught(new Exception())___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(LocalTransportException.class))__		}_	};verifies,that,fired,exceptions,are,handled,correctly,by,the,pipeline;test,public,void,test,exception,caught,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,exception,caught,new,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,for,remote,input,channel,r,rich,verify,r,on,error,is,a,local,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionCaught() throws Exception;1493724918;Verifies that fired Exceptions are handled correctly by the pipeline.;@Test_	public void testExceptionCaught() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		ch.pipeline().fireExceptionCaught(new Exception())___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(LocalTransportException.class))__		}_	};verifies,that,fired,exceptions,are,handled,correctly,by,the,pipeline;test,public,void,test,exception,caught,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,exception,caught,new,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,for,remote,input,channel,r,rich,verify,r,on,error,is,a,local,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionCaught() throws Exception;1502111816;Verifies that fired Exceptions are handled correctly by the pipeline.;@Test_	public void testExceptionCaught() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		ch.pipeline().fireExceptionCaught(new Exception())___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(LocalTransportException.class))__		}_	};verifies,that,fired,exceptions,are,handled,correctly,by,the,pipeline;test,public,void,test,exception,caught,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,exception,caught,new,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,for,remote,input,channel,r,rich,verify,r,on,error,is,a,local,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionCaught() throws Exception;1515160618;Verifies that fired Exceptions are handled correctly by the pipeline.;@Test_	public void testExceptionCaught() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		ch.pipeline().fireExceptionCaught(new Exception())___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(LocalTransportException.class))__		}_	};verifies,that,fired,exceptions,are,handled,correctly,by,the,pipeline;test,public,void,test,exception,caught,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,exception,caught,new,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,for,remote,input,channel,r,rich,verify,r,on,error,is,a,local,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionCaught() throws Exception;1518785736;Verifies that fired Exceptions are handled correctly by the pipeline.;@Test_	public void testExceptionCaught() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		NetworkClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		for (RemoteInputChannel r : rich) {_			when(r.getInputChannelId()).thenReturn(new InputChannelID())__			handler.addInputChannel(r)__		}__		ch.pipeline().fireExceptionCaught(new Exception())___		try {_			_			ch.checkException()__		}_		catch (Exception e) {_			fail("The exception reached the end of the pipeline and "_					+ "was not handled correctly by the last handler.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(LocalTransportException.class))__		}_	};verifies,that,fired,exceptions,are,handled,correctly,by,the,pipeline;test,public,void,test,exception,caught,throws,exception,embedded,channel,ch,create,embedded,channel,network,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,for,remote,input,channel,r,rich,when,r,get,input,channel,id,then,return,new,input,channel,id,handler,add,input,channel,r,ch,pipeline,fire,exception,caught,new,exception,try,ch,check,exception,catch,exception,e,fail,the,exception,reached,the,end,of,the,pipeline,and,was,not,handled,correctly,by,the,last,handler,for,remote,input,channel,r,rich,verify,r,on,error,is,a,local,transport,exception,class
ClientTransportErrorHandlingTest -> @Test 	public void testConnectionResetByPeer() throws Throwable;1432625417;Verifies that "Connection reset by peer" Exceptions are special-cased and are reported as_an instance of {@link RemoteTransportException}.;@Test_	public void testConnectionResetByPeer() throws Throwable {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		final Throwable[] error = new Throwable[1]___		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				Throwable cause = (Throwable) invocation.getArguments()[0]___				try {_					assertEquals(RemoteTransportException.class, cause.getClass())__					assertNotEquals("Connection reset by peer", cause.getMessage())___					assertEquals(IOException.class, cause.getCause().getClass())__					assertEquals("Connection reset by peer", cause.getCause().getMessage())__				}_				catch (Throwable t) {_					error[0] = t__				}__				return null__			}_		}).when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new IOException("Connection reset by peer"))___		assertNull(error[0])__	};verifies,that,connection,reset,by,peer,exceptions,are,special,cased,and,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,connection,reset,by,peer,throws,throwable,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,final,throwable,error,new,throwable,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,throwable,cause,throwable,invocation,get,arguments,0,try,assert,equals,remote,transport,exception,class,cause,get,class,assert,not,equals,connection,reset,by,peer,cause,get,message,assert,equals,ioexception,class,cause,get,cause,get,class,assert,equals,connection,reset,by,peer,cause,get,cause,get,message,catch,throwable,t,error,0,t,return,null,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,ioexception,connection,reset,by,peer,assert,null,error,0
ClientTransportErrorHandlingTest -> @Test 	public void testConnectionResetByPeer() throws Throwable;1487082763;Verifies that "Connection reset by peer" Exceptions are special-cased and are reported as_an instance of {@link RemoteTransportException}.;@Test_	public void testConnectionResetByPeer() throws Throwable {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		final Throwable[] error = new Throwable[1]___		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				Throwable cause = (Throwable) invocation.getArguments()[0]___				try {_					assertEquals(RemoteTransportException.class, cause.getClass())__					assertNotEquals("Connection reset by peer", cause.getMessage())___					assertEquals(IOException.class, cause.getCause().getClass())__					assertEquals("Connection reset by peer", cause.getCause().getMessage())__				}_				catch (Throwable t) {_					error[0] = t__				}__				return null__			}_		}).when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new IOException("Connection reset by peer"))___		assertNull(error[0])__	};verifies,that,connection,reset,by,peer,exceptions,are,special,cased,and,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,connection,reset,by,peer,throws,throwable,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,final,throwable,error,new,throwable,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,throwable,cause,throwable,invocation,get,arguments,0,try,assert,equals,remote,transport,exception,class,cause,get,class,assert,not,equals,connection,reset,by,peer,cause,get,message,assert,equals,ioexception,class,cause,get,cause,get,class,assert,equals,connection,reset,by,peer,cause,get,cause,get,message,catch,throwable,t,error,0,t,return,null,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,ioexception,connection,reset,by,peer,assert,null,error,0
ClientTransportErrorHandlingTest -> @Test 	public void testConnectionResetByPeer() throws Throwable;1493724918;Verifies that "Connection reset by peer" Exceptions are special-cased and are reported as_an instance of {@link RemoteTransportException}.;@Test_	public void testConnectionResetByPeer() throws Throwable {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		final Throwable[] error = new Throwable[1]___		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				Throwable cause = (Throwable) invocation.getArguments()[0]___				try {_					assertEquals(RemoteTransportException.class, cause.getClass())__					assertNotEquals("Connection reset by peer", cause.getMessage())___					assertEquals(IOException.class, cause.getCause().getClass())__					assertEquals("Connection reset by peer", cause.getCause().getMessage())__				}_				catch (Throwable t) {_					error[0] = t__				}__				return null__			}_		}).when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new IOException("Connection reset by peer"))___		assertNull(error[0])__	};verifies,that,connection,reset,by,peer,exceptions,are,special,cased,and,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,connection,reset,by,peer,throws,throwable,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,final,throwable,error,new,throwable,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,throwable,cause,throwable,invocation,get,arguments,0,try,assert,equals,remote,transport,exception,class,cause,get,class,assert,not,equals,connection,reset,by,peer,cause,get,message,assert,equals,ioexception,class,cause,get,cause,get,class,assert,equals,connection,reset,by,peer,cause,get,cause,get,message,catch,throwable,t,error,0,t,return,null,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,ioexception,connection,reset,by,peer,assert,null,error,0
ClientTransportErrorHandlingTest -> @Test 	public void testConnectionResetByPeer() throws Throwable;1502111816;Verifies that "Connection reset by peer" Exceptions are special-cased and are reported as_an instance of {@link RemoteTransportException}.;@Test_	public void testConnectionResetByPeer() throws Throwable {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		final Throwable[] error = new Throwable[1]___		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				Throwable cause = (Throwable) invocation.getArguments()[0]___				try {_					assertEquals(RemoteTransportException.class, cause.getClass())__					assertNotEquals("Connection reset by peer", cause.getMessage())___					assertEquals(IOException.class, cause.getCause().getClass())__					assertEquals("Connection reset by peer", cause.getCause().getMessage())__				}_				catch (Throwable t) {_					error[0] = t__				}__				return null__			}_		}).when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new IOException("Connection reset by peer"))___		assertNull(error[0])__	};verifies,that,connection,reset,by,peer,exceptions,are,special,cased,and,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,connection,reset,by,peer,throws,throwable,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,final,throwable,error,new,throwable,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,throwable,cause,throwable,invocation,get,arguments,0,try,assert,equals,remote,transport,exception,class,cause,get,class,assert,not,equals,connection,reset,by,peer,cause,get,message,assert,equals,ioexception,class,cause,get,cause,get,class,assert,equals,connection,reset,by,peer,cause,get,cause,get,message,catch,throwable,t,error,0,t,return,null,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,ioexception,connection,reset,by,peer,assert,null,error,0
ClientTransportErrorHandlingTest -> @Test 	public void testConnectionResetByPeer() throws Throwable;1515160618;Verifies that "Connection reset by peer" Exceptions are special-cased and are reported as_an instance of {@link RemoteTransportException}.;@Test_	public void testConnectionResetByPeer() throws Throwable {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		final Throwable[] error = new Throwable[1]___		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				Throwable cause = (Throwable) invocation.getArguments()[0]___				try {_					assertEquals(RemoteTransportException.class, cause.getClass())__					assertNotEquals("Connection reset by peer", cause.getMessage())___					assertEquals(IOException.class, cause.getCause().getClass())__					assertEquals("Connection reset by peer", cause.getCause().getMessage())__				}_				catch (Throwable t) {_					error[0] = t__				}__				return null__			}_		}).when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new IOException("Connection reset by peer"))___		assertNull(error[0])__	};verifies,that,connection,reset,by,peer,exceptions,are,special,cased,and,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,connection,reset,by,peer,throws,throwable,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,final,throwable,error,new,throwable,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,throwable,cause,throwable,invocation,get,arguments,0,try,assert,equals,remote,transport,exception,class,cause,get,class,assert,not,equals,connection,reset,by,peer,cause,get,message,assert,equals,ioexception,class,cause,get,cause,get,class,assert,equals,connection,reset,by,peer,cause,get,cause,get,message,catch,throwable,t,error,0,t,return,null,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,ioexception,connection,reset,by,peer,assert,null,error,0
ClientTransportErrorHandlingTest -> @Test 	public void testConnectionResetByPeer() throws Throwable;1518785736;Verifies that "Connection reset by peer" Exceptions are special-cased and are reported as_an instance of {@link RemoteTransportException}.;@Test_	public void testConnectionResetByPeer() throws Throwable {_		EmbeddedChannel ch = createEmbeddedChannel()___		NetworkClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		final Throwable[] error = new Throwable[1]___		_		doAnswer(new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				Throwable cause = (Throwable) invocation.getArguments()[0]___				try {_					assertEquals(RemoteTransportException.class, cause.getClass())__					assertNotEquals("Connection reset by peer", cause.getMessage())___					assertEquals(IOException.class, cause.getCause().getClass())__					assertEquals("Connection reset by peer", cause.getCause().getMessage())__				}_				catch (Throwable t) {_					error[0] = t__				}__				return null__			}_		}).when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new IOException("Connection reset by peer"))___		assertNull(error[0])__	};verifies,that,connection,reset,by,peer,exceptions,are,special,cased,and,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,connection,reset,by,peer,throws,throwable,embedded,channel,ch,create,embedded,channel,network,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,final,throwable,error,new,throwable,1,do,answer,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,throwable,cause,throwable,invocation,get,arguments,0,try,assert,equals,remote,transport,exception,class,cause,get,class,assert,not,equals,connection,reset,by,peer,cause,get,message,assert,equals,ioexception,class,cause,get,cause,get,class,assert,equals,connection,reset,by,peer,cause,get,cause,get,message,catch,throwable,t,error,0,t,return,null,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,ioexception,connection,reset,by,peer,assert,null,error,0
ClientTransportErrorHandlingTest -> @Test 	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception;1432625417;Verifies that the channel is closed if there is an error *during* error notification.;@Test_	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		doThrow(new RuntimeException("Expected test exception"))_				.when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new Exception())___		assertFalse(ch.isActive())__	};verifies,that,the,channel,is,closed,if,there,is,an,error,during,error,notification;test,public,void,test,channel,closed,on,exception,during,error,notification,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,do,throw,new,runtime,exception,expected,test,exception,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,exception,assert,false,ch,is,active
ClientTransportErrorHandlingTest -> @Test 	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception;1487082763;Verifies that the channel is closed if there is an error *during* error notification.;@Test_	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		doThrow(new RuntimeException("Expected test exception"))_				.when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new Exception())___		assertFalse(ch.isActive())__	};verifies,that,the,channel,is,closed,if,there,is,an,error,during,error,notification;test,public,void,test,channel,closed,on,exception,during,error,notification,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,do,throw,new,runtime,exception,expected,test,exception,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,exception,assert,false,ch,is,active
ClientTransportErrorHandlingTest -> @Test 	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception;1493724918;Verifies that the channel is closed if there is an error *during* error notification.;@Test_	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		doThrow(new RuntimeException("Expected test exception"))_				.when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new Exception())___		assertFalse(ch.isActive())__	};verifies,that,the,channel,is,closed,if,there,is,an,error,during,error,notification;test,public,void,test,channel,closed,on,exception,during,error,notification,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,do,throw,new,runtime,exception,expected,test,exception,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,exception,assert,false,ch,is,active
ClientTransportErrorHandlingTest -> @Test 	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception;1502111816;Verifies that the channel is closed if there is an error *during* error notification.;@Test_	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		doThrow(new RuntimeException("Expected test exception"))_				.when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new Exception())___		assertFalse(ch.isActive())__	};verifies,that,the,channel,is,closed,if,there,is,an,error,during,error,notification;test,public,void,test,channel,closed,on,exception,during,error,notification,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,do,throw,new,runtime,exception,expected,test,exception,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,exception,assert,false,ch,is,active
ClientTransportErrorHandlingTest -> @Test 	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception;1515160618;Verifies that the channel is closed if there is an error *during* error notification.;@Test_	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		PartitionRequestClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		doThrow(new RuntimeException("Expected test exception"))_				.when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new Exception())___		assertFalse(ch.isActive())__	};verifies,that,the,channel,is,closed,if,there,is,an,error,during,error,notification;test,public,void,test,channel,closed,on,exception,during,error,notification,throws,exception,embedded,channel,ch,create,embedded,channel,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,do,throw,new,runtime,exception,expected,test,exception,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,exception,assert,false,ch,is,active
ClientTransportErrorHandlingTest -> @Test 	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception;1518785736;Verifies that the channel is closed if there is an error *during* error notification.;@Test_	public void testChannelClosedOnExceptionDuringErrorNotification() throws Exception {_		EmbeddedChannel ch = createEmbeddedChannel()___		NetworkClientHandler handler = getClientHandler(ch)___		RemoteInputChannel rich = addInputChannel(handler)___		doThrow(new RuntimeException("Expected test exception"))_				.when(rich).onError(any(Throwable.class))___		ch.pipeline().fireExceptionCaught(new Exception())___		assertFalse(ch.isActive())__	};verifies,that,the,channel,is,closed,if,there,is,an,error,during,error,notification;test,public,void,test,channel,closed,on,exception,during,error,notification,throws,exception,embedded,channel,ch,create,embedded,channel,network,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,add,input,channel,handler,do,throw,new,runtime,exception,expected,test,exception,when,rich,on,error,any,throwable,class,ch,pipeline,fire,exception,caught,new,exception,assert,false,ch,is,active
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnRemoteClose() throws Exception;1432625417;Verifies that unexpected remote closes are reported as an instance of_{@link RemoteTransportException}.;@Test_	public void testExceptionOnRemoteClose() throws Exception {__		NettyProtocol protocol = new NettyProtocol() {_			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[] {_						_						new ChannelInboundHandlerAdapter() {_							@Override_							public void channelRead(ChannelHandlerContext ctx, Object msg)_									throws Exception {__								ctx.channel().close()__							}_						}_				}__			}__			@Override_			public ChannelHandler[] getClientChannelHandlers() {_				return new PartitionRequestProtocol(_						mock(ResultPartitionProvider.class),_						mock(TaskEventDispatcher.class),_						mock(NetworkBufferPool.class)).getClientChannelHandlers()__			}_		}___		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(rich.length)___		Answer<Void> countDownLatch = new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}___		for (RemoteInputChannel r : rich) {_			doAnswer(countDownLatch).when(r).onError(any(Throwable.class))__			handler.addInputChannel(r)__		}__		_		ch.writeAndFlush(Unpooled.buffer().writerIndex(16))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about remote connection close.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(RemoteTransportException.class))__		}__		shutdown(serverAndClient)__	};verifies,that,unexpected,remote,closes,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,exception,on,remote,close,throws,exception,netty,protocol,protocol,new,netty,protocol,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,new,channel,inbound,handler,adapter,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,ctx,channel,close,override,public,channel,handler,get,client,channel,handlers,return,new,partition,request,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,mock,network,buffer,pool,class,get,client,channel,handlers,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,rich,length,answer,void,count,down,latch,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,for,remote,input,channel,r,rich,do,answer,count,down,latch,when,r,on,error,any,throwable,class,handler,add,input,channel,r,ch,write,and,flush,unpooled,buffer,writer,index,16,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,remote,connection,close,for,remote,input,channel,r,rich,verify,r,on,error,is,a,remote,transport,exception,class,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnRemoteClose() throws Exception;1487082763;Verifies that unexpected remote closes are reported as an instance of_{@link RemoteTransportException}.;@Test_	public void testExceptionOnRemoteClose() throws Exception {__		NettyProtocol protocol = new NettyProtocol() {_			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[] {_						_						new ChannelInboundHandlerAdapter() {_							@Override_							public void channelRead(ChannelHandlerContext ctx, Object msg)_									throws Exception {__								ctx.channel().close()__							}_						}_				}__			}__			@Override_			public ChannelHandler[] getClientChannelHandlers() {_				return new PartitionRequestProtocol(_						mock(ResultPartitionProvider.class),_						mock(TaskEventDispatcher.class),_						mock(NetworkBufferPool.class)).getClientChannelHandlers()__			}_		}___		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(rich.length)___		Answer<Void> countDownLatch = new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}___		for (RemoteInputChannel r : rich) {_			doAnswer(countDownLatch).when(r).onError(any(Throwable.class))__			handler.addInputChannel(r)__		}__		_		ch.writeAndFlush(Unpooled.buffer().writerIndex(16))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about remote connection close.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(RemoteTransportException.class))__		}__		shutdown(serverAndClient)__	};verifies,that,unexpected,remote,closes,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,exception,on,remote,close,throws,exception,netty,protocol,protocol,new,netty,protocol,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,new,channel,inbound,handler,adapter,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,ctx,channel,close,override,public,channel,handler,get,client,channel,handlers,return,new,partition,request,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,mock,network,buffer,pool,class,get,client,channel,handlers,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,rich,length,answer,void,count,down,latch,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,for,remote,input,channel,r,rich,do,answer,count,down,latch,when,r,on,error,any,throwable,class,handler,add,input,channel,r,ch,write,and,flush,unpooled,buffer,writer,index,16,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,remote,connection,close,for,remote,input,channel,r,rich,verify,r,on,error,is,a,remote,transport,exception,class,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnRemoteClose() throws Exception;1493724918;Verifies that unexpected remote closes are reported as an instance of_{@link RemoteTransportException}.;@Test_	public void testExceptionOnRemoteClose() throws Exception {__		NettyProtocol protocol = new NettyProtocol() {_			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[] {_						_						new ChannelInboundHandlerAdapter() {_							@Override_							public void channelRead(ChannelHandlerContext ctx, Object msg)_									throws Exception {__								ctx.channel().close()__							}_						}_				}__			}__			@Override_			public ChannelHandler[] getClientChannelHandlers() {_				return new PartitionRequestProtocol(_						mock(ResultPartitionProvider.class),_						mock(TaskEventDispatcher.class)).getClientChannelHandlers()__			}_		}___		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(rich.length)___		Answer<Void> countDownLatch = new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}___		for (RemoteInputChannel r : rich) {_			doAnswer(countDownLatch).when(r).onError(any(Throwable.class))__			handler.addInputChannel(r)__		}__		_		ch.writeAndFlush(Unpooled.buffer().writerIndex(16))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about remote connection close.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(RemoteTransportException.class))__		}__		shutdown(serverAndClient)__	};verifies,that,unexpected,remote,closes,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,exception,on,remote,close,throws,exception,netty,protocol,protocol,new,netty,protocol,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,new,channel,inbound,handler,adapter,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,ctx,channel,close,override,public,channel,handler,get,client,channel,handlers,return,new,partition,request,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,get,client,channel,handlers,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,rich,length,answer,void,count,down,latch,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,for,remote,input,channel,r,rich,do,answer,count,down,latch,when,r,on,error,any,throwable,class,handler,add,input,channel,r,ch,write,and,flush,unpooled,buffer,writer,index,16,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,remote,connection,close,for,remote,input,channel,r,rich,verify,r,on,error,is,a,remote,transport,exception,class,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnRemoteClose() throws Exception;1502111816;Verifies that unexpected remote closes are reported as an instance of_{@link RemoteTransportException}.;@Test_	public void testExceptionOnRemoteClose() throws Exception {__		NettyProtocol protocol = new NettyProtocol() {_			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[] {_						_						new ChannelInboundHandlerAdapter() {_							@Override_							public void channelRead(ChannelHandlerContext ctx, Object msg)_									throws Exception {__								ctx.channel().close()__							}_						}_				}__			}__			@Override_			public ChannelHandler[] getClientChannelHandlers() {_				return new PartitionRequestProtocol(_						mock(ResultPartitionProvider.class),_						mock(TaskEventDispatcher.class)).getClientChannelHandlers()__			}_		}___		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(rich.length)___		Answer<Void> countDownLatch = new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}___		for (RemoteInputChannel r : rich) {_			doAnswer(countDownLatch).when(r).onError(any(Throwable.class))__			handler.addInputChannel(r)__		}__		_		ch.writeAndFlush(Unpooled.buffer().writerIndex(16))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about remote connection close.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(RemoteTransportException.class))__		}__		shutdown(serverAndClient)__	};verifies,that,unexpected,remote,closes,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,exception,on,remote,close,throws,exception,netty,protocol,protocol,new,netty,protocol,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,new,channel,inbound,handler,adapter,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,ctx,channel,close,override,public,channel,handler,get,client,channel,handlers,return,new,partition,request,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,get,client,channel,handlers,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,rich,length,answer,void,count,down,latch,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,for,remote,input,channel,r,rich,do,answer,count,down,latch,when,r,on,error,any,throwable,class,handler,add,input,channel,r,ch,write,and,flush,unpooled,buffer,writer,index,16,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,remote,connection,close,for,remote,input,channel,r,rich,verify,r,on,error,is,a,remote,transport,exception,class,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnRemoteClose() throws Exception;1515160618;Verifies that unexpected remote closes are reported as an instance of_{@link RemoteTransportException}.;@Test_	public void testExceptionOnRemoteClose() throws Exception {__		NettyProtocol protocol = new NettyProtocol(_				mock(ResultPartitionProvider.class),_				mock(TaskEventDispatcher.class)) {__			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[] {_						_						new ChannelInboundHandlerAdapter() {_							@Override_							public void channelRead(ChannelHandlerContext ctx, Object msg)_									throws Exception {__								ctx.channel().close()__							}_						}_				}__			}_		}___		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		PartitionRequestClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(rich.length)___		Answer<Void> countDownLatch = new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}___		for (RemoteInputChannel r : rich) {_			doAnswer(countDownLatch).when(r).onError(any(Throwable.class))__			handler.addInputChannel(r)__		}__		_		ch.writeAndFlush(Unpooled.buffer().writerIndex(16))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about remote connection close.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(RemoteTransportException.class))__		}__		shutdown(serverAndClient)__	};verifies,that,unexpected,remote,closes,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,exception,on,remote,close,throws,exception,netty,protocol,protocol,new,netty,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,new,channel,inbound,handler,adapter,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,ctx,channel,close,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,partition,request,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,rich,length,answer,void,count,down,latch,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,for,remote,input,channel,r,rich,do,answer,count,down,latch,when,r,on,error,any,throwable,class,handler,add,input,channel,r,ch,write,and,flush,unpooled,buffer,writer,index,16,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,remote,connection,close,for,remote,input,channel,r,rich,verify,r,on,error,is,a,remote,transport,exception,class,shutdown,server,and,client
ClientTransportErrorHandlingTest -> @Test 	public void testExceptionOnRemoteClose() throws Exception;1518785736;Verifies that unexpected remote closes are reported as an instance of_{@link RemoteTransportException}.;@Test_	public void testExceptionOnRemoteClose() throws Exception {__		NettyProtocol protocol = new NettyProtocol(_				mock(ResultPartitionProvider.class),_				mock(TaskEventDispatcher.class),_				true) {__			@Override_			public ChannelHandler[] getServerChannelHandlers() {_				return new ChannelHandler[] {_						_						new ChannelInboundHandlerAdapter() {_							@Override_							public void channelRead(ChannelHandlerContext ctx, Object msg)_									throws Exception {__								ctx.channel().close()__							}_						}_				}__			}_		}___		NettyServerAndClient serverAndClient = initServerAndClient(protocol, createConfig())___		Channel ch = connect(serverAndClient)___		NetworkClientHandler handler = getClientHandler(ch)___		_		RemoteInputChannel[] rich = new RemoteInputChannel[] {_				createRemoteInputChannel(), createRemoteInputChannel()}___		final CountDownLatch sync = new CountDownLatch(rich.length)___		Answer<Void> countDownLatch = new Answer<Void>() {_			@Override_			public Void answer(InvocationOnMock invocation) throws Throwable {_				sync.countDown()__				return null__			}_		}___		for (RemoteInputChannel r : rich) {_			doAnswer(countDownLatch).when(r).onError(any(Throwable.class))__			handler.addInputChannel(r)__		}__		_		ch.writeAndFlush(Unpooled.buffer().writerIndex(16))___		_		if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_			fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_					" ms to be notified about remote connection close.")__		}__		_		for (RemoteInputChannel r : rich) {_			verify(r).onError(isA(RemoteTransportException.class))__		}__		shutdown(serverAndClient)__	};verifies,that,unexpected,remote,closes,are,reported,as,an,instance,of,link,remote,transport,exception;test,public,void,test,exception,on,remote,close,throws,exception,netty,protocol,protocol,new,netty,protocol,mock,result,partition,provider,class,mock,task,event,dispatcher,class,true,override,public,channel,handler,get,server,channel,handlers,return,new,channel,handler,new,channel,inbound,handler,adapter,override,public,void,channel,read,channel,handler,context,ctx,object,msg,throws,exception,ctx,channel,close,netty,server,and,client,server,and,client,init,server,and,client,protocol,create,config,channel,ch,connect,server,and,client,network,client,handler,handler,get,client,handler,ch,remote,input,channel,rich,new,remote,input,channel,create,remote,input,channel,create,remote,input,channel,final,count,down,latch,sync,new,count,down,latch,rich,length,answer,void,count,down,latch,new,answer,void,override,public,void,answer,invocation,on,mock,invocation,throws,throwable,sync,count,down,return,null,for,remote,input,channel,r,rich,do,answer,count,down,latch,when,r,on,error,any,throwable,class,handler,add,input,channel,r,ch,write,and,flush,unpooled,buffer,writer,index,16,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,remote,connection,close,for,remote,input,channel,r,rich,verify,r,on,error,is,a,remote,transport,exception,class,shutdown,server,and,client
