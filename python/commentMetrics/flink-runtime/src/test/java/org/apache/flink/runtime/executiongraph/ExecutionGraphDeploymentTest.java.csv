# id;timestamp;commentText;codeText;commentWords;codeWords
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1488878443;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1489060856;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1489671807;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1489671807;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1490819573;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1492678790;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1493831843;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1506618381;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1508861310;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1508861311;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1508861311;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1509638685;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1513201052;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1513258344;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1513261599;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1516295283;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1516295283;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1518680774;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1548932775;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1549365080;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1550220073;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1550683188;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1550749890;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsForwarding() throws Exception;1550855836;Verifies that {@link ExecutionGraph#updateState(TaskExecutionState)} updates the accumulators and metrics for an_execution that failed or was canceled.;@Test_	public void testAccumulatorsAndMetricsForwarding() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Tuple2<ExecutionGraph, Map<ExecutionAttemptID, Execution>> graphAndExecutions = setupExecution(v1, 1, v2, 1)__		ExecutionGraph graph = graphAndExecutions.f0__		_		_		Execution execution1 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = new HashMap<>()__		accumulators.put("acc", new IntCounter(4))__		AccumulatorSnapshot accumulatorSnapshot = new AccumulatorSnapshot(graph.getJobID(), execution1.getAttemptId(), accumulators)__		_		TaskExecutionState state = new TaskExecutionState(graph.getJobID(), execution1.getAttemptId(), ExecutionState.CANCELED, null, accumulatorSnapshot, ioMetrics)__		_		graph.updateState(state)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertNotNull(execution1.getUserAccumulators())__		assertEquals(4, execution1.getUserAccumulators().get("acc").getLocalValue())__		_		_		Execution execution2 = graphAndExecutions.f1.values().iterator().next()___		IOMetrics ioMetrics2 = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators2 = new HashMap<>()__		accumulators2.put("acc", new IntCounter(8))__		AccumulatorSnapshot accumulatorSnapshot2 = new AccumulatorSnapshot(graph.getJobID(), execution2.getAttemptId(), accumulators2)___		TaskExecutionState state2 = new TaskExecutionState(graph.getJobID(), execution2.getAttemptId(), ExecutionState.FAILED, null, accumulatorSnapshot2, ioMetrics2)___		graph.updateState(state2)___		assertEquals(ioMetrics2, execution2.getIOMetrics())__		assertNotNull(execution2.getUserAccumulators())__		assertEquals(8, execution2.getUserAccumulators().get("acc").getLocalValue())__	};verifies,that,link,execution,graph,update,state,task,execution,state,updates,the,accumulators,and,metrics,for,an,execution,that,failed,or,was,canceled;test,public,void,test,accumulators,and,metrics,forwarding,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,tuple2,execution,graph,map,execution,attempt,id,execution,graph,and,executions,setup,execution,v1,1,v2,1,execution,graph,graph,graph,and,executions,f0,execution,execution1,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,new,hash,map,accumulators,put,acc,new,int,counter,4,accumulator,snapshot,accumulator,snapshot,new,accumulator,snapshot,graph,get,job,id,execution1,get,attempt,id,accumulators,task,execution,state,state,new,task,execution,state,graph,get,job,id,execution1,get,attempt,id,execution,state,canceled,null,accumulator,snapshot,io,metrics,graph,update,state,state,assert,equals,io,metrics,execution1,get,iometrics,assert,not,null,execution1,get,user,accumulators,assert,equals,4,execution1,get,user,accumulators,get,acc,get,local,value,execution,execution2,graph,and,executions,f1,values,iterator,next,iometrics,io,metrics2,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators2,new,hash,map,accumulators2,put,acc,new,int,counter,8,accumulator,snapshot,accumulator,snapshot2,new,accumulator,snapshot,graph,get,job,id,execution2,get,attempt,id,accumulators2,task,execution,state,state2,new,task,execution,state,graph,get,job,id,execution2,get,attempt,id,execution,state,failed,null,accumulator,snapshot2,io,metrics2,graph,update,state,state2,assert,equals,io,metrics2,execution2,get,iometrics,assert,not,null,execution2,get,user,accumulators,assert,equals,8,execution2,get,user,accumulators,get,acc,get,local,value
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1508861310;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertNull(eg.getJobInformationBlobKey())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,null,eg,get,job,information,blob,key
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1508861311;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1508861311;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1509638685;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1513201052;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1513258344;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1513261599;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1516295283;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1516295283;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1518680774;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1548932775;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1549365080;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1550220073;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1550683188;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1550749890;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkJobOffloaded(ExecutionGraph eg) throws Exception;1550855836;Checks that the job information for the given ID has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created;protected void checkJobOffloaded(ExecutionGraph eg) throws Exception {_		assertTrue(eg.getJobInformationOrBlobKey().isLeft())__	};checks,that,the,job,information,for,the,given,id,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created;protected,void,check,job,offloaded,execution,graph,eg,throws,exception,assert,true,eg,get,job,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1508861310;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertNull(eg.getJobVertex(jobVertexId).getTaskInformationBlobKey())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,null,eg,get,job,vertex,job,vertex,id,get,task,information,blob,key
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1508861311;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1508861311;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1509638685;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1513201052;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1513258344;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1513261599;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1516295283;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1516295283;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1518680774;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1548932775;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1549365080;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1550220073;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1550683188;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1550749890;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception;1550855836;Checks that the task information for the job vertex has been offloaded successfully (if_offloading is used).__@param eg           the execution graph that was created_@param jobVertexId  job vertex ID;protected void checkTaskOffloaded(ExecutionGraph eg, JobVertexID jobVertexId) throws Exception {_		assertTrue(eg.getJobVertex(jobVertexId).getTaskInformationOrBlobKey().isLeft())__	};checks,that,the,task,information,for,the,job,vertex,has,been,offloaded,successfully,if,offloading,is,used,param,eg,the,execution,graph,that,was,created,param,job,vertex,id,job,vertex,id;protected,void,check,task,offloaded,execution,graph,eg,job,vertex,id,job,vertex,id,throws,exception,assert,true,eg,get,job,vertex,job,vertex,id,get,task,information,or,blob,key,is,left
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1509638685;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<SimpleSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<SimpleSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(executionGraph.getJobID(), localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(executionGraph.getJobID(), localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(executionGraph.getJobID(), localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(executionGraph.getJobID(), localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,simple,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,simple,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,execution,graph,get,job,id,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,execution,graph,get,job,id,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,execution,graph,get,job,id,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,execution,graph,get,job,id,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1513201052;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(executionGraph.getJobID(), localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(executionGraph.getJobID(), localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(executionGraph.getJobID(), localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(executionGraph.getJobID(), localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,execution,graph,get,job,id,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,execution,graph,get,job,id,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,execution,graph,get,job,id,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,execution,graph,get,job,id,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1513258344;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1513261599;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1516295283;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1516295283;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1518680774;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1548932775;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1549365080;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread())__		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,start,testing,component,main,thread,executor,service,adapter,for,main,thread,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1550220073;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread())__		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,start,testing,component,main,thread,executor,service,adapter,for,main,thread,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1550683188;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread())__		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,start,testing,component,main,thread,executor,service,adapter,for,main,thread,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1550749890;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread())__		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,start,testing,component,main,thread,executor,service,adapter,for,main,thread,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception;1550855836;Tests that eager scheduling will wait until all input locations have been set before_scheduling a task.;@Test_	public void testEagerSchedulingWaitsOnAllInputPreferredLocations() throws Exception {_		final int parallelism = 2__		final ProgrammedSlotProvider slotProvider = new ProgrammedSlotProvider(parallelism)___		final Time timeout = Time.hours(1L)__		final JobVertexID sourceVertexId = new JobVertexID()__		final JobVertex sourceVertex = new JobVertex("Test source", sourceVertexId)__		sourceVertex.setInvokableClass(NoOpInvokable.class)__		sourceVertex.setParallelism(parallelism)___		final JobVertexID sinkVertexId = new JobVertexID()__		final JobVertex sinkVertex = new JobVertex("Test sink", sinkVertexId)__		sinkVertex.setInvokableClass(NoOpInvokable.class)__		sinkVertex.setParallelism(parallelism)___		sinkVertex.connectNewDataSetAsInput(sourceVertex, DistributionPattern.ALL_TO_ALL, ResultPartitionType.PIPELINED)___		final Map<JobVertexID, CompletableFuture<LogicalSlot>[]> slotFutures = new HashMap<>(2)___		for (JobVertexID jobVertexID : Arrays.asList(sourceVertexId, sinkVertexId)) {_			CompletableFuture<LogicalSlot>[] slotFutureArray = new CompletableFuture[parallelism]___			for (int i = 0_ i < parallelism_ i++) {_				slotFutureArray[i] = new CompletableFuture<>()__			}__			slotFutures.put(jobVertexID, slotFutureArray)__			slotProvider.addSlots(jobVertexID, slotFutureArray)__		}__		final ScheduledExecutorService scheduledExecutorService = new ScheduledThreadPoolExecutor(3)___		final ExecutionGraph executionGraph = ExecutionGraphTestUtils.createExecutionGraph(_			new JobID(),_			slotProvider,_			new NoRestartStrategy(),_			scheduledExecutorService,_			timeout,_			sourceVertex,_			sinkVertex)___		executionGraph.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread())__		executionGraph.setScheduleMode(ScheduleMode.EAGER)__		executionGraph.scheduleForExecution()___		_		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			assertEquals(ExecutionState.SCHEDULED, executionVertex.getCurrentExecutionAttempt().getState())__		}__		_		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sourceVertexId, 1).get())___		_		_		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).isDone())__		assertFalse(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).isDone())___		final TaskManagerLocation localTaskManagerLocation = new LocalTaskManagerLocation()___		final SimpleSlot sourceSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sourceSlot2 = createSlot(localTaskManagerLocation, 1)___		final SimpleSlot sinkSlot1 = createSlot(localTaskManagerLocation, 0)___		final SimpleSlot sinkSlot2 = createSlot(localTaskManagerLocation, 1)___		slotFutures.get(sourceVertexId)[0].complete(sourceSlot1)__		slotFutures.get(sourceVertexId)[1].complete(sourceSlot2)___		_		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 0).get())__		assertTrue(slotProvider.getSlotRequestedFuture(sinkVertexId, 1).get())___		slotFutures.get(sinkVertexId)[0].complete(sinkSlot1)__		slotFutures.get(sinkVertexId)[1].complete(sinkSlot2)___		for (ExecutionVertex executionVertex : executionGraph.getAllExecutionVertices()) {_			ExecutionGraphTestUtils.waitUntilExecutionState(executionVertex.getCurrentExecutionAttempt(), ExecutionState.DEPLOYING, 5000L)__		}_	};tests,that,eager,scheduling,will,wait,until,all,input,locations,have,been,set,before,scheduling,a,task;test,public,void,test,eager,scheduling,waits,on,all,input,preferred,locations,throws,exception,final,int,parallelism,2,final,programmed,slot,provider,slot,provider,new,programmed,slot,provider,parallelism,final,time,timeout,time,hours,1l,final,job,vertex,id,source,vertex,id,new,job,vertex,id,final,job,vertex,source,vertex,new,job,vertex,test,source,source,vertex,id,source,vertex,set,invokable,class,no,op,invokable,class,source,vertex,set,parallelism,parallelism,final,job,vertex,id,sink,vertex,id,new,job,vertex,id,final,job,vertex,sink,vertex,new,job,vertex,test,sink,sink,vertex,id,sink,vertex,set,invokable,class,no,op,invokable,class,sink,vertex,set,parallelism,parallelism,sink,vertex,connect,new,data,set,as,input,source,vertex,distribution,pattern,result,partition,type,pipelined,final,map,job,vertex,id,completable,future,logical,slot,slot,futures,new,hash,map,2,for,job,vertex,id,job,vertex,id,arrays,as,list,source,vertex,id,sink,vertex,id,completable,future,logical,slot,slot,future,array,new,completable,future,parallelism,for,int,i,0,i,parallelism,i,slot,future,array,i,new,completable,future,slot,futures,put,job,vertex,id,slot,future,array,slot,provider,add,slots,job,vertex,id,slot,future,array,final,scheduled,executor,service,scheduled,executor,service,new,scheduled,thread,pool,executor,3,final,execution,graph,execution,graph,execution,graph,test,utils,create,execution,graph,new,job,id,slot,provider,new,no,restart,strategy,scheduled,executor,service,timeout,source,vertex,sink,vertex,execution,graph,start,testing,component,main,thread,executor,service,adapter,for,main,thread,execution,graph,set,schedule,mode,schedule,mode,eager,execution,graph,schedule,for,execution,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,assert,equals,execution,state,scheduled,execution,vertex,get,current,execution,attempt,get,state,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,source,vertex,id,1,get,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,0,is,done,assert,false,slot,provider,get,slot,requested,future,sink,vertex,id,1,is,done,final,task,manager,location,local,task,manager,location,new,local,task,manager,location,final,simple,slot,source,slot1,create,slot,local,task,manager,location,0,final,simple,slot,source,slot2,create,slot,local,task,manager,location,1,final,simple,slot,sink,slot1,create,slot,local,task,manager,location,0,final,simple,slot,sink,slot2,create,slot,local,task,manager,location,1,slot,futures,get,source,vertex,id,0,complete,source,slot1,slot,futures,get,source,vertex,id,1,complete,source,slot2,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,0,get,assert,true,slot,provider,get,slot,requested,future,sink,vertex,id,1,get,slot,futures,get,sink,vertex,id,0,complete,sink,slot1,slot,futures,get,sink,vertex,id,1,complete,sink,slot2,for,execution,vertex,execution,vertex,execution,graph,get,all,execution,vertices,execution,graph,test,utils,wait,until,execution,state,execution,vertex,get,current,execution,attempt,execution,state,deploying,5000l
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1488878443;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1489060856;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1489671807;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1489671807;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1490819573;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1492678790;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1493831843;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1506618381;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1508861310;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1508861311;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1508861311;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1509638685;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1513201052;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1513258344;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1513261599;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1516295283;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1516295283;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1518680774;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1548932775;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1549365080;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1550220073;Verifies that {@link Execution#cancelingComplete(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.cancelingComplete(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,canceling,complete,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,canceling,complete,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1550683188;Verifies that {@link Execution#completeCancelling(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.completeCancelling(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,complete,cancelling,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,complete,cancelling,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1550749890;Verifies that {@link Execution#completeCancelling(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.completeCancelling(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,complete,cancelling,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,complete,cancelling,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testAccumulatorsAndMetricsStorage() throws Exception;1550855836;Verifies that {@link Execution#completeCancelling(Map, IOMetrics)} and {@link Execution#markFailed(Throwable, Map, IOMetrics)}_store the given accumulators and metrics correctly.;@Test_	public void testAccumulatorsAndMetricsStorage() throws Exception {_		final JobVertexID jid1 = new JobVertexID()__		final JobVertexID jid2 = new JobVertexID()___		JobVertex v1 = new JobVertex("v1", jid1)__		JobVertex v2 = new JobVertex("v2", jid2)___		Map<ExecutionAttemptID, Execution> executions = setupExecution(v1, 1, v2, 1).f1__		_		IOMetrics ioMetrics = new IOMetrics(0, 0, 0, 0, 0, 0.0, 0.0, 0.0, 0.0, 0.0)__		Map<String, Accumulator<?, ?>> accumulators = Collections.emptyMap()___		Execution execution1 = executions.values().iterator().next()__		execution1.cancel()__		execution1.completeCancelling(accumulators, ioMetrics)__		_		assertEquals(ioMetrics, execution1.getIOMetrics())__		assertEquals(accumulators, execution1.getUserAccumulators())___		Execution execution2 = executions.values().iterator().next()__		execution2.markFailed(new Throwable(), accumulators, ioMetrics)___		assertEquals(ioMetrics, execution2.getIOMetrics())__		assertEquals(accumulators, execution2.getUserAccumulators())__	};verifies,that,link,execution,complete,cancelling,map,iometrics,and,link,execution,mark,failed,throwable,map,iometrics,store,the,given,accumulators,and,metrics,correctly;test,public,void,test,accumulators,and,metrics,storage,throws,exception,final,job,vertex,id,jid1,new,job,vertex,id,final,job,vertex,id,jid2,new,job,vertex,id,job,vertex,v1,new,job,vertex,v1,jid1,job,vertex,v2,new,job,vertex,v2,jid2,map,execution,attempt,id,execution,executions,setup,execution,v1,1,v2,1,f1,iometrics,io,metrics,new,iometrics,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,map,string,accumulator,accumulators,collections,empty,map,execution,execution1,executions,values,iterator,next,execution1,cancel,execution1,complete,cancelling,accumulators,io,metrics,assert,equals,io,metrics,execution1,get,iometrics,assert,equals,accumulators,execution1,get,user,accumulators,execution,execution2,executions,values,iterator,next,execution2,mark,failed,new,throwable,accumulators,io,metrics,assert,equals,io,metrics,execution2,get,iometrics,assert,equals,accumulators,execution2,get,user,accumulators
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1508861311;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		Scheduler scheduler = new Scheduler(TestingUtils.directExecutionContext())__		for (int i = 0_ i < dop1_ i++) {_			scheduler.newInstanceAvailable(_				ExecutionGraphTestUtils.getInstance(_					new ActorTaskManagerGateway(_						new ExecutionGraphTestUtils.SimpleActorGateway(_							TestingUtils.directExecutionContext()))))__		}__		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			new DirectScheduledExecutorService(),_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			scheduler,_			ExecutionGraph.class.getClassLoader(),_			blobServer)___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		assertEquals(dop1, scheduler.getNumberOfAvailableSlots())___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,scheduler,scheduler,new,scheduler,testing,utils,direct,execution,context,for,int,i,0,i,dop1,i,scheduler,new,instance,available,execution,graph,test,utils,get,instance,new,actor,task,manager,gateway,new,execution,graph,test,utils,simple,actor,gateway,testing,utils,direct,execution,context,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,execution,graph,eg,new,execution,graph,job,information,new,direct,scheduled,executor,service,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,scheduler,execution,graph,class,get,class,loader,blob,server,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,assert,equals,dop1,scheduler,get,number,of,available,slots,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1508861311;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		Scheduler scheduler = new Scheduler(TestingUtils.directExecutionContext())__		for (int i = 0_ i < dop1_ i++) {_			scheduler.newInstanceAvailable(_				ExecutionGraphTestUtils.getInstance(_					new ActorTaskManagerGateway(_						new ExecutionGraphTestUtils.SimpleActorGateway(_							TestingUtils.directExecutionContext()))))__		}__		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			new DirectScheduledExecutorService(),_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			scheduler,_			ExecutionGraph.class.getClassLoader(),_			blobWriter)___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		assertEquals(dop1, scheduler.getNumberOfAvailableSlots())___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,scheduler,scheduler,new,scheduler,testing,utils,direct,execution,context,for,int,i,0,i,dop1,i,scheduler,new,instance,available,execution,graph,test,utils,get,instance,new,actor,task,manager,gateway,new,execution,graph,test,utils,simple,actor,gateway,testing,utils,direct,execution,context,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,execution,graph,eg,new,execution,graph,job,information,new,direct,scheduled,executor,service,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,scheduler,execution,graph,class,get,class,loader,blob,writer,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,assert,equals,dop1,scheduler,get,number,of,available,slots,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1509638685;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		Scheduler scheduler = new Scheduler(TestingUtils.directExecutionContext())__		for (int i = 0_ i < dop1_ i++) {_			scheduler.newInstanceAvailable(_				ExecutionGraphTestUtils.getInstance(_					new ActorTaskManagerGateway(_						new ExecutionGraphTestUtils.SimpleActorGateway(_							TestingUtils.directExecutionContext()))))__		}__		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			new DirectScheduledExecutorService(),_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			scheduler,_			ExecutionGraph.class.getClassLoader(),_			blobWriter)___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		assertEquals(dop1, scheduler.getNumberOfAvailableSlots())___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,scheduler,scheduler,new,scheduler,testing,utils,direct,execution,context,for,int,i,0,i,dop1,i,scheduler,new,instance,available,execution,graph,test,utils,get,instance,new,actor,task,manager,gateway,new,execution,graph,test,utils,simple,actor,gateway,testing,utils,direct,execution,context,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,execution,graph,eg,new,execution,graph,job,information,new,direct,scheduled,executor,service,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,scheduler,execution,graph,class,get,class,loader,blob,writer,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,assert,equals,dop1,scheduler,get,number,of,available,slots,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1513201052;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		Scheduler scheduler = new Scheduler(TestingUtils.directExecutionContext())__		for (int i = 0_ i < dop1_ i++) {_			scheduler.newInstanceAvailable(_				ExecutionGraphTestUtils.getInstance(_					new ActorTaskManagerGateway(_						new ExecutionGraphTestUtils.SimpleActorGateway(_							TestingUtils.directExecutionContext()))))__		}__		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			new DirectScheduledExecutorService(),_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			scheduler,_			ExecutionGraph.class.getClassLoader(),_			blobWriter)___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		assertEquals(dop1, scheduler.getNumberOfAvailableSlots())___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,scheduler,scheduler,new,scheduler,testing,utils,direct,execution,context,for,int,i,0,i,dop1,i,scheduler,new,instance,available,execution,graph,test,utils,get,instance,new,actor,task,manager,gateway,new,execution,graph,test,utils,simple,actor,gateway,testing,utils,direct,execution,context,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,execution,graph,eg,new,execution,graph,job,information,new,direct,scheduled,executor,service,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,scheduler,execution,graph,class,get,class,loader,blob,writer,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,assert,equals,dop1,scheduler,get,number,of,available,slots,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1513258344;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		Scheduler scheduler = new Scheduler(TestingUtils.directExecutionContext())__		for (int i = 0_ i < dop1_ i++) {_			scheduler.newInstanceAvailable(_				ExecutionGraphTestUtils.getInstance(_					new ActorTaskManagerGateway(_						new ExecutionGraphTestUtils.SimpleActorGateway(_							TestingUtils.directExecutionContext()))))__		}__		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			new DirectScheduledExecutorService(),_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			scheduler,_			ExecutionGraph.class.getClassLoader(),_			blobWriter)___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		assertEquals(dop1, scheduler.getNumberOfAvailableSlots())___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,scheduler,scheduler,new,scheduler,testing,utils,direct,execution,context,for,int,i,0,i,dop1,i,scheduler,new,instance,available,execution,graph,test,utils,get,instance,new,actor,task,manager,gateway,new,execution,graph,test,utils,simple,actor,gateway,testing,utils,direct,execution,context,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,execution,graph,eg,new,execution,graph,job,information,new,direct,scheduled,executor,service,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,scheduler,execution,graph,class,get,class,loader,blob,writer,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,assert,equals,dop1,scheduler,get,number,of,available,slots,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1513261599;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		Scheduler scheduler = new Scheduler(TestingUtils.directExecutionContext())__		for (int i = 0_ i < dop1_ i++) {_			scheduler.newInstanceAvailable(_				ExecutionGraphTestUtils.getInstance(_					new ActorTaskManagerGateway(_						new ExecutionGraphTestUtils.SimpleActorGateway(_							TestingUtils.directExecutionContext()))))__		}__		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			new DirectScheduledExecutorService(),_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			scheduler,_			ExecutionGraph.class.getClassLoader(),_			blobWriter)___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		assertEquals(dop1, scheduler.getNumberOfAvailableSlots())___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,scheduler,scheduler,new,scheduler,testing,utils,direct,execution,context,for,int,i,0,i,dop1,i,scheduler,new,instance,available,execution,graph,test,utils,get,instance,new,actor,task,manager,gateway,new,execution,graph,test,utils,simple,actor,gateway,testing,utils,direct,execution,context,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,execution,graph,eg,new,execution,graph,job,information,new,direct,scheduled,executor,service,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,scheduler,execution,graph,class,get,class,loader,blob,writer,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,assert,equals,dop1,scheduler,get,number,of,available,slots,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1516295283;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		Scheduler scheduler = new Scheduler(TestingUtils.directExecutionContext())__		for (int i = 0_ i < dop1_ i++) {_			scheduler.newInstanceAvailable(_				ExecutionGraphTestUtils.getInstance(_					new ActorTaskManagerGateway(_						new ExecutionGraphTestUtils.SimpleActorGateway(_							TestingUtils.directExecutionContext()))))__		}__		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			new DirectScheduledExecutorService(),_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			scheduler,_			ExecutionGraph.class.getClassLoader(),_			blobWriter)___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		assertEquals(dop1, scheduler.getNumberOfAvailableSlots())___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,scheduler,scheduler,new,scheduler,testing,utils,direct,execution,context,for,int,i,0,i,dop1,i,scheduler,new,instance,available,execution,graph,test,utils,get,instance,new,actor,task,manager,gateway,new,execution,graph,test,utils,simple,actor,gateway,testing,utils,direct,execution,context,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,execution,graph,eg,new,execution,graph,job,information,new,direct,scheduled,executor,service,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,scheduler,execution,graph,class,get,class,loader,blob,writer,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,assert,equals,dop1,scheduler,get,number,of,available,slots,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1516295283;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		Scheduler scheduler = new Scheduler(TestingUtils.directExecutionContext())__		for (int i = 0_ i < dop1_ i++) {_			scheduler.newInstanceAvailable(_				ExecutionGraphTestUtils.getInstance(_					new ActorTaskManagerGateway(_						new ExecutionGraphTestUtils.SimpleActorGateway(_							TestingUtils.directExecutionContext()))))__		}__		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			new DirectScheduledExecutorService(),_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			scheduler,_			ExecutionGraph.class.getClassLoader(),_			blobWriter)___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		assertEquals(dop1, scheduler.getNumberOfAvailableSlots())___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,scheduler,scheduler,new,scheduler,testing,utils,direct,execution,context,for,int,i,0,i,dop1,i,scheduler,new,instance,available,execution,graph,test,utils,get,instance,new,actor,task,manager,gateway,new,execution,graph,test,utils,simple,actor,gateway,testing,utils,direct,execution,context,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,execution,graph,eg,new,execution,graph,job,information,new,direct,scheduled,executor,service,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,scheduler,execution,graph,class,get,class,loader,blob,writer,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,assert,equals,dop1,scheduler,get,number,of,available,slots,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1518680774;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		Scheduler scheduler = new Scheduler(TestingUtils.directExecutionContext())__		for (int i = 0_ i < dop1_ i++) {_			scheduler.newInstanceAvailable(_				ExecutionGraphTestUtils.getInstance(_					new ActorTaskManagerGateway(_						new ExecutionGraphTestUtils.SimpleActorGateway(_							TestingUtils.directExecutionContext()))))__		}__		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			new DirectScheduledExecutorService(),_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			scheduler,_			ExecutionGraph.class.getClassLoader(),_			blobWriter,_			AkkaUtils.getDefaultTimeout())___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		assertEquals(dop1, scheduler.getNumberOfAvailableSlots())___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,scheduler,scheduler,new,scheduler,testing,utils,direct,execution,context,for,int,i,0,i,dop1,i,scheduler,new,instance,available,execution,graph,test,utils,get,instance,new,actor,task,manager,gateway,new,execution,graph,test,utils,simple,actor,gateway,testing,utils,direct,execution,context,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,execution,graph,eg,new,execution,graph,job,information,new,direct,scheduled,executor,service,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,scheduler,execution,graph,class,get,class,loader,blob,writer,akka,utils,get,default,timeout,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,assert,equals,dop1,scheduler,get,number,of,available,slots,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1548932775;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final ArrayDeque<CompletableFuture<LogicalSlot>> slotFutures = new ArrayDeque<>()__		for (int i = 0_ i < dop1_ i++) {_			slotFutures.addLast(CompletableFuture.completedFuture(new TestingLogicalSlot()))__		}__		final SlotProvider slotProvider = new TestingSlotProvider(ignore -> slotFutures.removeFirst())___		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			new DirectScheduledExecutorService(),_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			slotProvider,_			ExecutionGraph.class.getClassLoader(),_			blobWriter,_			AkkaUtils.getDefaultTimeout())___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,final,array,deque,completable,future,logical,slot,slot,futures,new,array,deque,for,int,i,0,i,dop1,i,slot,futures,add,last,completable,future,completed,future,new,testing,logical,slot,final,slot,provider,slot,provider,new,testing,slot,provider,ignore,slot,futures,remove,first,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,execution,graph,eg,new,execution,graph,job,information,new,direct,scheduled,executor,service,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,slot,provider,execution,graph,class,get,class,loader,blob,writer,akka,utils,get,default,timeout,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1549365080;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final ArrayDeque<CompletableFuture<LogicalSlot>> slotFutures = new ArrayDeque<>()__		for (int i = 0_ i < dop1_ i++) {_			slotFutures.addLast(CompletableFuture.completedFuture(new TestingLogicalSlot()))__		}__		final SlotProvider slotProvider = new TestingSlotProvider(ignore -> slotFutures.removeFirst())___		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		DirectScheduledExecutorService directExecutor = new DirectScheduledExecutorService()___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			directExecutor,_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			slotProvider,_			ExecutionGraph.class.getClassLoader(),_			blobWriter,_			AkkaUtils.getDefaultTimeout())___		eg.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread())___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,final,array,deque,completable,future,logical,slot,slot,futures,new,array,deque,for,int,i,0,i,dop1,i,slot,futures,add,last,completable,future,completed,future,new,testing,logical,slot,final,slot,provider,slot,provider,new,testing,slot,provider,ignore,slot,futures,remove,first,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,direct,scheduled,executor,service,direct,executor,new,direct,scheduled,executor,service,execution,graph,eg,new,execution,graph,job,information,direct,executor,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,slot,provider,execution,graph,class,get,class,loader,blob,writer,akka,utils,get,default,timeout,eg,start,testing,component,main,thread,executor,service,adapter,for,main,thread,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1550220073;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final ArrayDeque<CompletableFuture<LogicalSlot>> slotFutures = new ArrayDeque<>()__		for (int i = 0_ i < dop1_ i++) {_			slotFutures.addLast(CompletableFuture.completedFuture(new TestingLogicalSlot()))__		}__		final SlotProvider slotProvider = new TestingSlotProvider(ignore -> slotFutures.removeFirst())___		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		DirectScheduledExecutorService directExecutor = new DirectScheduledExecutorService()___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			directExecutor,_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			slotProvider,_			ExecutionGraph.class.getClassLoader(),_			blobWriter,_			AkkaUtils.getDefaultTimeout())___		eg.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread())___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,final,array,deque,completable,future,logical,slot,slot,futures,new,array,deque,for,int,i,0,i,dop1,i,slot,futures,add,last,completable,future,completed,future,new,testing,logical,slot,final,slot,provider,slot,provider,new,testing,slot,provider,ignore,slot,futures,remove,first,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,direct,scheduled,executor,service,direct,executor,new,direct,scheduled,executor,service,execution,graph,eg,new,execution,graph,job,information,direct,executor,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,slot,provider,execution,graph,class,get,class,loader,blob,writer,akka,utils,get,default,timeout,eg,start,testing,component,main,thread,executor,service,adapter,for,main,thread,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1550683188;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final ArrayDeque<CompletableFuture<LogicalSlot>> slotFutures = new ArrayDeque<>()__		for (int i = 0_ i < dop1_ i++) {_			slotFutures.addLast(CompletableFuture.completedFuture(new TestingLogicalSlot()))__		}__		final SlotProvider slotProvider = new TestingSlotProvider(ignore -> slotFutures.removeFirst())___		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		DirectScheduledExecutorService directExecutor = new DirectScheduledExecutorService()___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			directExecutor,_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			slotProvider,_			ExecutionGraph.class.getClassLoader(),_			blobWriter,_			AkkaUtils.getDefaultTimeout())___		eg.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread())___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,final,array,deque,completable,future,logical,slot,slot,futures,new,array,deque,for,int,i,0,i,dop1,i,slot,futures,add,last,completable,future,completed,future,new,testing,logical,slot,final,slot,provider,slot,provider,new,testing,slot,provider,ignore,slot,futures,remove,first,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,direct,scheduled,executor,service,direct,executor,new,direct,scheduled,executor,service,execution,graph,eg,new,execution,graph,job,information,direct,executor,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,slot,provider,execution,graph,class,get,class,loader,blob,writer,akka,utils,get,default,timeout,eg,start,testing,component,main,thread,executor,service,adapter,for,main,thread,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1550749890;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final ArrayDeque<CompletableFuture<LogicalSlot>> slotFutures = new ArrayDeque<>()__		for (int i = 0_ i < dop1_ i++) {_			slotFutures.addLast(CompletableFuture.completedFuture(new TestingLogicalSlot()))__		}__		final SlotProvider slotProvider = new TestingSlotProvider(ignore -> slotFutures.removeFirst())___		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		DirectScheduledExecutorService directExecutor = new DirectScheduledExecutorService()___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			directExecutor,_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			slotProvider,_			ExecutionGraph.class.getClassLoader(),_			blobWriter,_			AkkaUtils.getDefaultTimeout())___		eg.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread())___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,final,array,deque,completable,future,logical,slot,slot,futures,new,array,deque,for,int,i,0,i,dop1,i,slot,futures,add,last,completable,future,completed,future,new,testing,logical,slot,final,slot,provider,slot,provider,new,testing,slot,provider,ignore,slot,futures,remove,first,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,direct,scheduled,executor,service,direct,executor,new,direct,scheduled,executor,service,execution,graph,eg,new,execution,graph,job,information,direct,executor,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,slot,provider,execution,graph,class,get,class,loader,blob,writer,akka,utils,get,default,timeout,eg,start,testing,component,main,thread,executor,service,adapter,for,main,thread,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
ExecutionGraphDeploymentTest -> @Test 	public void testNoResourceAvailableFailure() throws Exception;1550855836;Tests that a blocking batch job fails if there are not enough resources left to schedule the_succeeding tasks. This test case is related to [FLINK-4296] where finished producing tasks_swallow the fail exception when scheduling a consumer task.;@Test_	public void testNoResourceAvailableFailure() throws Exception {_		final JobID jobId = new JobID()__		JobVertex v1 = new JobVertex("source")__		JobVertex v2 = new JobVertex("sink")___		int dop1 = 1__		int dop2 = 1___		v1.setParallelism(dop1)__		v2.setParallelism(dop2)___		v1.setInvokableClass(BatchTask.class)__		v2.setInvokableClass(BatchTask.class)___		v2.connectNewDataSetAsInput(v1, DistributionPattern.POINTWISE, ResultPartitionType.BLOCKING)___		final ArrayDeque<CompletableFuture<LogicalSlot>> slotFutures = new ArrayDeque<>()__		for (int i = 0_ i < dop1_ i++) {_			slotFutures.addLast(CompletableFuture.completedFuture(new TestingLogicalSlot()))__		}__		final SlotProvider slotProvider = new TestingSlotProvider(ignore -> slotFutures.removeFirst())___		final JobInformation jobInformation = new DummyJobInformation(_			jobId,_			"failing test job")___		DirectScheduledExecutorService directExecutor = new DirectScheduledExecutorService()___		_		ExecutionGraph eg = new ExecutionGraph(_			jobInformation,_			directExecutor,_			TestingUtils.defaultExecutor(),_			AkkaUtils.getDefaultTimeout(),_			new NoRestartStrategy(),_			new RestartAllStrategy.Factory(),_			slotProvider,_			ExecutionGraph.class.getClassLoader(),_			blobWriter,_			AkkaUtils.getDefaultTimeout())___		eg.start(TestingComponentMainThreadExecutorServiceAdapter.forMainThread())___		checkJobOffloaded(eg)___		eg.setQueuedSchedulingAllowed(false)___		List<JobVertex> ordered = Arrays.asList(v1, v2)__		eg.attachJobGraph(ordered)___		_		eg.scheduleForExecution()___		ExecutionAttemptID attemptID = eg.getJobVertex(v1.getID()).getTaskVertices()[0].getCurrentExecutionAttempt().getAttemptId()__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.RUNNING))__		eg.updateState(new TaskExecutionState(jobId, attemptID, ExecutionState.FINISHED, null))___		assertEquals(JobStatus.FAILED, eg.getState())__	};tests,that,a,blocking,batch,job,fails,if,there,are,not,enough,resources,left,to,schedule,the,succeeding,tasks,this,test,case,is,related,to,flink,4296,where,finished,producing,tasks,swallow,the,fail,exception,when,scheduling,a,consumer,task;test,public,void,test,no,resource,available,failure,throws,exception,final,job,id,job,id,new,job,id,job,vertex,v1,new,job,vertex,source,job,vertex,v2,new,job,vertex,sink,int,dop1,1,int,dop2,1,v1,set,parallelism,dop1,v2,set,parallelism,dop2,v1,set,invokable,class,batch,task,class,v2,set,invokable,class,batch,task,class,v2,connect,new,data,set,as,input,v1,distribution,pattern,pointwise,result,partition,type,blocking,final,array,deque,completable,future,logical,slot,slot,futures,new,array,deque,for,int,i,0,i,dop1,i,slot,futures,add,last,completable,future,completed,future,new,testing,logical,slot,final,slot,provider,slot,provider,new,testing,slot,provider,ignore,slot,futures,remove,first,final,job,information,job,information,new,dummy,job,information,job,id,failing,test,job,direct,scheduled,executor,service,direct,executor,new,direct,scheduled,executor,service,execution,graph,eg,new,execution,graph,job,information,direct,executor,testing,utils,default,executor,akka,utils,get,default,timeout,new,no,restart,strategy,new,restart,all,strategy,factory,slot,provider,execution,graph,class,get,class,loader,blob,writer,akka,utils,get,default,timeout,eg,start,testing,component,main,thread,executor,service,adapter,for,main,thread,check,job,offloaded,eg,eg,set,queued,scheduling,allowed,false,list,job,vertex,ordered,arrays,as,list,v1,v2,eg,attach,job,graph,ordered,eg,schedule,for,execution,execution,attempt,id,attempt,id,eg,get,job,vertex,v1,get,id,get,task,vertices,0,get,current,execution,attempt,get,attempt,id,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,running,eg,update,state,new,task,execution,state,job,id,attempt,id,execution,state,finished,null,assert,equals,job,status,failed,eg,get,state
