# id;timestamp;commentText;codeText;commentWords;codeWords
CompactingHashTableTest -> @Test 	public void testHashTableGrowthWithInsertOrReplace();1438803435;This test validates that records are not lost via "insertOrReplace()" as in bug [FLINK-2361];@Test_	public void testHashTableGrowthWithInsertOrReplace() {_		try {_			final int numElements = 1000000___			List<MemorySegment> memory = getMemory(10000, 32 * 1024)___			_			_			_			CompactingHashTable<Tuple2<Long, String>> table = new CompactingHashTable<Tuple2<Long, String>>(_					serializer, comparator, memory, 10000)__			table.open()__			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(new Tuple2<Long, String>(i, String.valueOf(i)))__			}__			_			{_				BitSet bitSet = new BitSet(numElements)__				MutableObjectIterator<Tuple2<Long, String>> iter = table.getEntryIterator()__				Tuple2<Long, String> next__				while ((next = iter.next()) != null) {_					assertNotNull(next.f0)__					assertNotNull(next.f1)__					assertEquals(next.f0.longValue(), Long.parseLong(next.f1))___					bitSet.set(next.f0.intValue())__				}__				assertEquals(numElements, bitSet.cardinality())__			}__			_			{_				CompactingHashTable<Tuple2<Long, String>>.HashTableProber<Long> proper =_						table.getProber(probeComparator, pairComparator)___				for (long i = 0_ i < numElements_ i++) {_					assertNotNull(proper.getMatchFor(i))__					assertNull(proper.getMatchFor(i + numElements))__				}_			}__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,validates,that,records,are,not,lost,via,insert,or,replace,as,in,bug,flink,2361;test,public,void,test,hash,table,growth,with,insert,or,replace,try,final,int,num,elements,1000000,list,memory,segment,memory,get,memory,10000,32,1024,compacting,hash,table,tuple2,long,string,table,new,compacting,hash,table,tuple2,long,string,serializer,comparator,memory,10000,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,new,tuple2,long,string,i,string,value,of,i,bit,set,bit,set,new,bit,set,num,elements,mutable,object,iterator,tuple2,long,string,iter,table,get,entry,iterator,tuple2,long,string,next,while,next,iter,next,null,assert,not,null,next,f0,assert,not,null,next,f1,assert,equals,next,f0,long,value,long,parse,long,next,f1,bit,set,set,next,f0,int,value,assert,equals,num,elements,bit,set,cardinality,compacting,hash,table,tuple2,long,string,hash,table,prober,long,proper,table,get,prober,probe,comparator,pair,comparator,for,long,i,0,i,num,elements,i,assert,not,null,proper,get,match,for,i,assert,null,proper,get,match,for,i,num,elements,catch,exception,e,e,print,stack,trace,fail,e,get,message
CompactingHashTableTest -> @Test 	public void testHashTableGrowthWithInsertOrReplace();1441738685;This test validates that records are not lost via "insertOrReplace()" as in bug [FLINK-2361];@Test_	public void testHashTableGrowthWithInsertOrReplace() {_		try {_			final int numElements = 1000000___			List<MemorySegment> memory = getMemory(10000, 32 * 1024)___			_			_			_			CompactingHashTable<Tuple2<Long, String>> table = new CompactingHashTable<Tuple2<Long, String>>(_					serializer, comparator, memory, 10000)__			table.open()__			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(new Tuple2<Long, String>(i, String.valueOf(i)))__			}__			_			{_				BitSet bitSet = new BitSet(numElements)__				MutableObjectIterator<Tuple2<Long, String>> iter = table.getEntryIterator()__				Tuple2<Long, String> next__				while ((next = iter.next()) != null) {_					assertNotNull(next.f0)__					assertNotNull(next.f1)__					assertEquals(next.f0.longValue(), Long.parseLong(next.f1))___					bitSet.set(next.f0.intValue())__				}__				assertEquals(numElements, bitSet.cardinality())__			}__			_			{_				CompactingHashTable<Tuple2<Long, String>>.HashTableProber<Long> proper =_						table.getProber(probeComparator, pairComparator)___				for (long i = 0_ i < numElements_ i++) {_					assertNotNull(proper.getMatchFor(i))__					assertNull(proper.getMatchFor(i + numElements))__				}_			}__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,validates,that,records,are,not,lost,via,insert,or,replace,as,in,bug,flink,2361;test,public,void,test,hash,table,growth,with,insert,or,replace,try,final,int,num,elements,1000000,list,memory,segment,memory,get,memory,10000,32,1024,compacting,hash,table,tuple2,long,string,table,new,compacting,hash,table,tuple2,long,string,serializer,comparator,memory,10000,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,new,tuple2,long,string,i,string,value,of,i,bit,set,bit,set,new,bit,set,num,elements,mutable,object,iterator,tuple2,long,string,iter,table,get,entry,iterator,tuple2,long,string,next,while,next,iter,next,null,assert,not,null,next,f0,assert,not,null,next,f1,assert,equals,next,f0,long,value,long,parse,long,next,f1,bit,set,set,next,f0,int,value,assert,equals,num,elements,bit,set,cardinality,compacting,hash,table,tuple2,long,string,hash,table,prober,long,proper,table,get,prober,probe,comparator,pair,comparator,for,long,i,0,i,num,elements,i,assert,not,null,proper,get,match,for,i,assert,null,proper,get,match,for,i,num,elements,catch,exception,e,e,print,stack,trace,fail,e,get,message
CompactingHashTableTest -> @Test 	public void testHashTableGrowthWithInsertOrReplace();1468441547;This test validates that records are not lost via "insertOrReplace()" as in bug [FLINK-2361]__This has to be duplicated in InPlaceMutableHashTableTest and CompactingHashTableTest_because of the different constructor calls.;@Test_	public void testHashTableGrowthWithInsertOrReplace() {_		try {_			final int numElements = 1000000___			List<MemorySegment> memory = getMemory(10000, 32 * 1024)___			_			_			_			CompactingHashTable<Tuple2<Long, String>> table = new CompactingHashTable<>(_				tuple2LongStringSerializer, tuple2LongStringComparator, memory, 10000)__			table.open()__			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(new Tuple2<Long, String>(i, String.valueOf(i)))__			}__			_			{_				BitSet bitSet = new BitSet(numElements)__				MutableObjectIterator<Tuple2<Long, String>> iter = table.getEntryIterator()__				Tuple2<Long, String> next__				while ((next = iter.next()) != null) {_					assertNotNull(next.f0)__					assertNotNull(next.f1)__					assertEquals(next.f0.longValue(), Long.parseLong(next.f1))___					bitSet.set(next.f0.intValue())__				}__				assertEquals(numElements, bitSet.cardinality())__			}__			_			{_				CompactingHashTable<Tuple2<Long, String>>.HashTableProber<Long> proper =_						table.getProber(probeComparator, pairComparator)___				for (long i = 0_ i < numElements_ i++) {_					assertNotNull(proper.getMatchFor(i))__					assertNull(proper.getMatchFor(i + numElements))__				}_			}__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,validates,that,records,are,not,lost,via,insert,or,replace,as,in,bug,flink,2361,this,has,to,be,duplicated,in,in,place,mutable,hash,table,test,and,compacting,hash,table,test,because,of,the,different,constructor,calls;test,public,void,test,hash,table,growth,with,insert,or,replace,try,final,int,num,elements,1000000,list,memory,segment,memory,get,memory,10000,32,1024,compacting,hash,table,tuple2,long,string,table,new,compacting,hash,table,tuple2long,string,serializer,tuple2long,string,comparator,memory,10000,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,new,tuple2,long,string,i,string,value,of,i,bit,set,bit,set,new,bit,set,num,elements,mutable,object,iterator,tuple2,long,string,iter,table,get,entry,iterator,tuple2,long,string,next,while,next,iter,next,null,assert,not,null,next,f0,assert,not,null,next,f1,assert,equals,next,f0,long,value,long,parse,long,next,f1,bit,set,set,next,f0,int,value,assert,equals,num,elements,bit,set,cardinality,compacting,hash,table,tuple2,long,string,hash,table,prober,long,proper,table,get,prober,probe,comparator,pair,comparator,for,long,i,0,i,num,elements,i,assert,not,null,proper,get,match,for,i,assert,null,proper,get,match,for,i,num,elements,catch,exception,e,e,print,stack,trace,fail,e,get,message
CompactingHashTableTest -> @Test 	public void testInsertsWithInsertOrReplace();1438803435;This test validates that new inserts (rather than updates) in "insertOrReplace()" properly_react to out of memory conditions.;@Test_	public void testInsertsWithInsertOrReplace() {_		try {_			final int numElements = 1000___			final String longString = getLongString(10000)__			List<MemorySegment> memory = getMemory(1000, 32 * 1024)___			_			_			_			CompactingHashTable<Tuple2<Long, String>> table = new CompactingHashTable<Tuple2<Long, String>>(_					serializer, comparator, memory, 100)__			table.open()___			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(new Tuple2<Long, String>(i, longString))__			}__			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(new Tuple2<Long, String>(i, longString))__			}_			_			_			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(new Tuple2<Long, String>(i + numElements, longString))__			}_		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,validates,that,new,inserts,rather,than,updates,in,insert,or,replace,properly,react,to,out,of,memory,conditions;test,public,void,test,inserts,with,insert,or,replace,try,final,int,num,elements,1000,final,string,long,string,get,long,string,10000,list,memory,segment,memory,get,memory,1000,32,1024,compacting,hash,table,tuple2,long,string,table,new,compacting,hash,table,tuple2,long,string,serializer,comparator,memory,100,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,new,tuple2,long,string,i,long,string,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,new,tuple2,long,string,i,long,string,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,new,tuple2,long,string,i,num,elements,long,string,catch,exception,e,e,print,stack,trace,fail,e,get,message
CompactingHashTableTest -> @Test 	public void testInsertsWithInsertOrReplace();1441738685;This test validates that new inserts (rather than updates) in "insertOrReplace()" properly_react to out of memory conditions.;@Test_	public void testInsertsWithInsertOrReplace() {_		try {_			final int numElements = 1000___			final String longString = getLongString(10000)__			List<MemorySegment> memory = getMemory(1000, 32 * 1024)___			_			_			_			CompactingHashTable<Tuple2<Long, String>> table = new CompactingHashTable<Tuple2<Long, String>>(_					serializer, comparator, memory, 100)__			table.open()___			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(new Tuple2<Long, String>(i, longString))__			}__			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(new Tuple2<Long, String>(i, longString))__			}_			_			_			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(new Tuple2<Long, String>(i + numElements, longString))__			}_		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,validates,that,new,inserts,rather,than,updates,in,insert,or,replace,properly,react,to,out,of,memory,conditions;test,public,void,test,inserts,with,insert,or,replace,try,final,int,num,elements,1000,final,string,long,string,get,long,string,10000,list,memory,segment,memory,get,memory,1000,32,1024,compacting,hash,table,tuple2,long,string,table,new,compacting,hash,table,tuple2,long,string,serializer,comparator,memory,100,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,new,tuple2,long,string,i,long,string,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,new,tuple2,long,string,i,long,string,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,new,tuple2,long,string,i,num,elements,long,string,catch,exception,e,e,print,stack,trace,fail,e,get,message
CompactingHashTableTest -> @Test 	public void testInsertsWithInsertOrReplace();1468441547;This test validates that new inserts (rather than updates) in "insertOrReplace()" properly_react to out of memory conditions.;@Test_	public void testInsertsWithInsertOrReplace() {_		try {_			final int numElements = 1000___			final String longString = getLongString(10000)__			List<MemorySegment> memory = getMemory(1000, 32 * 1024)___			_			_			_			CompactingHashTable<Tuple2<Long, String>> table = new CompactingHashTable<>(_				tuple2LongStringSerializer, tuple2LongStringComparator, memory, 100)__			table.open()___			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, longString))__			}__			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i, longString))__			}_			_			_			_			for (long i = 0_ i < numElements_ i++) {_				table.insertOrReplaceRecord(Tuple2.of(i + numElements, longString))__			}__			_			CompactingHashTable<Tuple2<Long, String>>.HashTableProber<Tuple2<Long, String>> prober =_				table.getProber(tuple2LongStringComparator, new SameTypePairComparator<>(tuple2LongStringComparator))__			Tuple2<Long, String> reuse = new Tuple2<>()__			for (long i = 0_ i < numElements_ i++) {_				assertNotNull(prober.getMatchFor(Tuple2.of(i, longString), reuse))__				assertNotNull(prober.getMatchFor(Tuple2.of(i + numElements, longString), reuse))__			}_		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_	};this,test,validates,that,new,inserts,rather,than,updates,in,insert,or,replace,properly,react,to,out,of,memory,conditions;test,public,void,test,inserts,with,insert,or,replace,try,final,int,num,elements,1000,final,string,long,string,get,long,string,10000,list,memory,segment,memory,get,memory,1000,32,1024,compacting,hash,table,tuple2,long,string,table,new,compacting,hash,table,tuple2long,string,serializer,tuple2long,string,comparator,memory,100,table,open,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,long,string,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,long,string,for,long,i,0,i,num,elements,i,table,insert,or,replace,record,tuple2,of,i,num,elements,long,string,compacting,hash,table,tuple2,long,string,hash,table,prober,tuple2,long,string,prober,table,get,prober,tuple2long,string,comparator,new,same,type,pair,comparator,tuple2long,string,comparator,tuple2,long,string,reuse,new,tuple2,for,long,i,0,i,num,elements,i,assert,not,null,prober,get,match,for,tuple2,of,i,long,string,reuse,assert,not,null,prober,get,match,for,tuple2,of,i,num,elements,long,string,reuse,catch,exception,e,e,print,stack,trace,fail,e,get,message
