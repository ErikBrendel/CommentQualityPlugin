# id;timestamp;commentText;codeText;commentWords;codeWords
BlobCacheGetTest -> @Test 	public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException;1507212387;FLINK-6020__<p>Tests that concurrent get operations don't concurrently access the BlobStore to download a blob.;@Test_	public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentGetOperations(null, false, false)__	};flink,6020,p,tests,that,concurrent,get,operations,don,t,concurrently,access,the,blob,store,to,download,a,blob;test,public,void,test,concurrent,get,operations,no,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,get,operations,null,false,false
BlobCacheGetTest -> @Test 	public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException;1507212387;FLINK-6020__<p>Tests that concurrent get operations don't concurrently access the BlobStore to download a blob.;@Test_	public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentGetOperations(null, TRANSIENT_BLOB, false)__	};flink,6020,p,tests,that,concurrent,get,operations,don,t,concurrently,access,the,blob,store,to,download,a,blob;test,public,void,test,concurrent,get,operations,no,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,get,operations,null,false
BlobCacheGetTest -> @Test 	public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException;1508138617;FLINK-6020__<p>Tests that concurrent get operations don't concurrently access the BlobStore to download a blob.;@Test_	public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentGetOperations(null, TRANSIENT_BLOB, false)__	};flink,6020,p,tests,that,concurrent,get,operations,don,t,concurrently,access,the,blob,store,to,download,a,blob;test,public,void,test,concurrent,get,operations,no,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,get,operations,null,false
BlobCacheGetTest -> @Test 	public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException;1515428991;FLINK-6020__<p>Tests that concurrent get operations don't concurrently access the BlobStore to download a blob.;@Test_	public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentGetOperations(null, TRANSIENT_BLOB, false)__	};flink,6020,p,tests,that,concurrent,get,operations,don,t,concurrently,access,the,blob,store,to,download,a,blob;test,public,void,test,concurrent,get,operations,no,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,get,operations,null,false
BlobCacheGetTest -> @Test 	public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException;1517915730;FLINK-6020__<p>Tests that concurrent get operations don't concurrently access the BlobStore to download a blob.;@Test_	public void testConcurrentGetOperationsNoJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentGetOperations(null, TRANSIENT_BLOB, false)__	};flink,6020,p,tests,that,concurrent,get,operations,don,t,concurrently,access,the,blob,store,to,download,a,blob;test,public,void,test,concurrent,get,operations,no,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,get,operations,null,false
BlobCacheGetTest -> private void testGetFailsDuringLookup(final JobID jobId1, final JobID jobId2, BlobKey.BlobType blobType) 			throws IOException, InterruptedException;1507212387;Checks the correct result if a GET operation fails during the lookup of the file.__@param jobId1 first job ID or <tt>null</tt> if job-unrelated_@param jobId2 second job ID different to <tt>jobId1</tt>_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsDuringLookup(final JobID jobId1, final JobID jobId2, BlobKey.BlobType blobType)_			throws IOException, InterruptedException {_		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			BlobKey key = put(server, jobId1, data, blobType)__			assertNotNull(key)__			verifyType(blobType, key)___			_			File blobFile = server.getStorageLocation(jobId1, key)__			assertTrue(blobFile.delete())___			_			verifyDeleted(cache, jobId1, key)___			_			BlobKey key2 = put(server, jobId2, data, blobType)__			assertNotNull(key)__			assertEquals(key, key2)___			_			get(cache, jobId2, key)__			_			verifyDeleted(cache, jobId1, key)___			if (blobType == PERMANENT_BLOB) {_				_				assertTrue(server.getStorageLocation(jobId2, key).exists())__				_				blobFile = cache.getPermanentBlobService().getStorageLocation(jobId2, key)__				assertTrue(blobFile.delete())__				_				get(cache, jobId2, key)___				_				blobFile = cache.getPermanentBlobService().getStorageLocation(jobId2, key)__				assertTrue(blobFile.delete())__				blobFile = server.getStorageLocation(jobId2, key)__				assertTrue(blobFile.delete())__				verifyDeleted(cache, jobId2, key)__			} else {_				_				verifyDeletedEventually(server, jobId2, key)__				_				blobFile = cache.getTransientBlobService().getStorageLocation(jobId2, key)__				assertTrue(blobFile.delete())__				_				verifyDeleted(cache, jobId2, key)__			}_		}_	};checks,the,correct,result,if,a,get,operation,fails,during,the,lookup,of,the,file,param,job,id1,first,job,id,or,tt,null,tt,if,job,unrelated,param,job,id2,second,job,id,different,to,tt,job,id1,tt,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,during,lookup,final,job,id,job,id1,final,job,id,job,id2,blob,key,blob,type,blob,type,throws,ioexception,interrupted,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,key,put,server,job,id1,data,blob,type,assert,not,null,key,verify,type,blob,type,key,file,blob,file,server,get,storage,location,job,id1,key,assert,true,blob,file,delete,verify,deleted,cache,job,id1,key,blob,key,key2,put,server,job,id2,data,blob,type,assert,not,null,key,assert,equals,key,key2,get,cache,job,id2,key,verify,deleted,cache,job,id1,key,if,blob,type,assert,true,server,get,storage,location,job,id2,key,exists,blob,file,cache,get,permanent,blob,service,get,storage,location,job,id2,key,assert,true,blob,file,delete,get,cache,job,id2,key,blob,file,cache,get,permanent,blob,service,get,storage,location,job,id2,key,assert,true,blob,file,delete,blob,file,server,get,storage,location,job,id2,key,assert,true,blob,file,delete,verify,deleted,cache,job,id2,key,else,verify,deleted,eventually,server,job,id2,key,blob,file,cache,get,transient,blob,service,get,storage,location,job,id2,key,assert,true,blob,file,delete,verify,deleted,cache,job,id2,key
BlobCacheGetTest -> private void testGetFailsDuringLookup(final JobID jobId1, final JobID jobId2, BlobKey.BlobType blobType) 			throws IOException, InterruptedException;1508138617;Checks the correct result if a GET operation fails during the lookup of the file.__@param jobId1 first job ID or <tt>null</tt> if job-unrelated_@param jobId2 second job ID different to <tt>jobId1</tt>_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsDuringLookup(final JobID jobId1, final JobID jobId2, BlobKey.BlobType blobType)_			throws IOException, InterruptedException {_		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			BlobKey key = put(server, jobId1, data, blobType)__			assertNotNull(key)__			verifyType(blobType, key)___			_			File blobFile = server.getStorageLocation(jobId1, key)__			assertTrue(blobFile.delete())___			_			verifyDeleted(cache, jobId1, key)___			_			BlobKey key2 = put(server, jobId2, data, blobType)__			assertNotNull(key2)__			verifyKeyDifferentHashEquals(key, key2)___			_			get(cache, jobId2, key2)__			_			verifyDeleted(cache, jobId1, key)___			if (blobType == PERMANENT_BLOB) {_				_				assertTrue(server.getStorageLocation(jobId2, key2).exists())__				_				blobFile = cache.getPermanentBlobService().getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				_				get(cache, jobId2, key2)___				_				blobFile = cache.getPermanentBlobService().getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				blobFile = server.getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				verifyDeleted(cache, jobId2, key2)__			} else {_				_				verifyDeletedEventually(server, jobId2, key2)__				_				blobFile = cache.getTransientBlobService().getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				_				verifyDeleted(cache, jobId2, key2)__			}_		}_	};checks,the,correct,result,if,a,get,operation,fails,during,the,lookup,of,the,file,param,job,id1,first,job,id,or,tt,null,tt,if,job,unrelated,param,job,id2,second,job,id,different,to,tt,job,id1,tt,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,during,lookup,final,job,id,job,id1,final,job,id,job,id2,blob,key,blob,type,blob,type,throws,ioexception,interrupted,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,key,put,server,job,id1,data,blob,type,assert,not,null,key,verify,type,blob,type,key,file,blob,file,server,get,storage,location,job,id1,key,assert,true,blob,file,delete,verify,deleted,cache,job,id1,key,blob,key,key2,put,server,job,id2,data,blob,type,assert,not,null,key2,verify,key,different,hash,equals,key,key2,get,cache,job,id2,key2,verify,deleted,cache,job,id1,key,if,blob,type,assert,true,server,get,storage,location,job,id2,key2,exists,blob,file,cache,get,permanent,blob,service,get,storage,location,job,id2,key2,assert,true,blob,file,delete,get,cache,job,id2,key2,blob,file,cache,get,permanent,blob,service,get,storage,location,job,id2,key2,assert,true,blob,file,delete,blob,file,server,get,storage,location,job,id2,key2,assert,true,blob,file,delete,verify,deleted,cache,job,id2,key2,else,verify,deleted,eventually,server,job,id2,key2,blob,file,cache,get,transient,blob,service,get,storage,location,job,id2,key2,assert,true,blob,file,delete,verify,deleted,cache,job,id2,key2
BlobCacheGetTest -> private void testGetFailsDuringLookup(final JobID jobId1, final JobID jobId2, BlobKey.BlobType blobType) 			throws IOException, InterruptedException;1515428991;Checks the correct result if a GET operation fails during the lookup of the file.__@param jobId1 first job ID or <tt>null</tt> if job-unrelated_@param jobId2 second job ID different to <tt>jobId1</tt>_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsDuringLookup(final JobID jobId1, final JobID jobId2, BlobKey.BlobType blobType)_			throws IOException, InterruptedException {_		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			BlobKey key = put(server, jobId1, data, blobType)__			assertNotNull(key)__			verifyType(blobType, key)___			_			File blobFile = server.getStorageLocation(jobId1, key)__			assertTrue(blobFile.delete())___			_			verifyDeleted(cache, jobId1, key)___			_			BlobKey key2 = put(server, jobId2, data, blobType)__			assertNotNull(key2)__			verifyKeyDifferentHashEquals(key, key2)___			_			get(cache, jobId2, key2)__			_			verifyDeleted(cache, jobId1, key)___			if (blobType == PERMANENT_BLOB) {_				_				assertTrue(server.getStorageLocation(jobId2, key2).exists())__				_				blobFile = cache.getPermanentBlobService().getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				_				get(cache, jobId2, key2)___				_				blobFile = cache.getPermanentBlobService().getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				blobFile = server.getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				verifyDeleted(cache, jobId2, key2)__			} else {_				_				verifyDeletedEventually(server, jobId2, key2)__				_				blobFile = cache.getTransientBlobService().getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				_				verifyDeleted(cache, jobId2, key2)__			}_		}_	};checks,the,correct,result,if,a,get,operation,fails,during,the,lookup,of,the,file,param,job,id1,first,job,id,or,tt,null,tt,if,job,unrelated,param,job,id2,second,job,id,different,to,tt,job,id1,tt,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,during,lookup,final,job,id,job,id1,final,job,id,job,id2,blob,key,blob,type,blob,type,throws,ioexception,interrupted,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,key,put,server,job,id1,data,blob,type,assert,not,null,key,verify,type,blob,type,key,file,blob,file,server,get,storage,location,job,id1,key,assert,true,blob,file,delete,verify,deleted,cache,job,id1,key,blob,key,key2,put,server,job,id2,data,blob,type,assert,not,null,key2,verify,key,different,hash,equals,key,key2,get,cache,job,id2,key2,verify,deleted,cache,job,id1,key,if,blob,type,assert,true,server,get,storage,location,job,id2,key2,exists,blob,file,cache,get,permanent,blob,service,get,storage,location,job,id2,key2,assert,true,blob,file,delete,get,cache,job,id2,key2,blob,file,cache,get,permanent,blob,service,get,storage,location,job,id2,key2,assert,true,blob,file,delete,blob,file,server,get,storage,location,job,id2,key2,assert,true,blob,file,delete,verify,deleted,cache,job,id2,key2,else,verify,deleted,eventually,server,job,id2,key2,blob,file,cache,get,transient,blob,service,get,storage,location,job,id2,key2,assert,true,blob,file,delete,verify,deleted,cache,job,id2,key2
BlobCacheGetTest -> private void testGetFailsDuringLookup(final JobID jobId1, final JobID jobId2, BlobKey.BlobType blobType) 			throws IOException, InterruptedException;1517915730;Checks the correct result if a GET operation fails during the lookup of the file.__@param jobId1 first job ID or <tt>null</tt> if job-unrelated_@param jobId2 second job ID different to <tt>jobId1</tt>_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsDuringLookup(final JobID jobId1, final JobID jobId2, BlobKey.BlobType blobType)_			throws IOException, InterruptedException {_		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			BlobKey key = put(server, jobId1, data, blobType)__			assertNotNull(key)__			verifyType(blobType, key)___			_			File blobFile = server.getStorageLocation(jobId1, key)__			assertTrue(blobFile.delete())___			_			verifyDeleted(cache, jobId1, key)___			_			BlobKey key2 = put(server, jobId2, data, blobType)__			assertNotNull(key2)__			verifyKeyDifferentHashEquals(key, key2)___			_			get(cache, jobId2, key2)__			_			verifyDeleted(cache, jobId1, key)___			if (blobType == PERMANENT_BLOB) {_				_				assertTrue(server.getStorageLocation(jobId2, key2).exists())__				_				blobFile = cache.getPermanentBlobService().getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				_				get(cache, jobId2, key2)___				_				blobFile = cache.getPermanentBlobService().getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				blobFile = server.getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				verifyDeleted(cache, jobId2, key2)__			} else {_				_				verifyDeletedEventually(server, jobId2, key2)__				_				blobFile = cache.getTransientBlobService().getStorageLocation(jobId2, key2)__				assertTrue(blobFile.delete())__				_				verifyDeleted(cache, jobId2, key2)__			}_		}_	};checks,the,correct,result,if,a,get,operation,fails,during,the,lookup,of,the,file,param,job,id1,first,job,id,or,tt,null,tt,if,job,unrelated,param,job,id2,second,job,id,different,to,tt,job,id1,tt,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,during,lookup,final,job,id,job,id1,final,job,id,job,id2,blob,key,blob,type,blob,type,throws,ioexception,interrupted,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,key,put,server,job,id1,data,blob,type,assert,not,null,key,verify,type,blob,type,key,file,blob,file,server,get,storage,location,job,id1,key,assert,true,blob,file,delete,verify,deleted,cache,job,id1,key,blob,key,key2,put,server,job,id2,data,blob,type,assert,not,null,key2,verify,key,different,hash,equals,key,key2,get,cache,job,id2,key2,verify,deleted,cache,job,id1,key,if,blob,type,assert,true,server,get,storage,location,job,id2,key2,exists,blob,file,cache,get,permanent,blob,service,get,storage,location,job,id2,key2,assert,true,blob,file,delete,get,cache,job,id2,key2,blob,file,cache,get,permanent,blob,service,get,storage,location,job,id2,key2,assert,true,blob,file,delete,blob,file,server,get,storage,location,job,id2,key2,assert,true,blob,file,delete,verify,deleted,cache,job,id2,key2,else,verify,deleted,eventually,server,job,id2,key2,blob,file,cache,get,transient,blob,service,get,storage,location,job,id2,key2,assert,true,blob,file,delete,verify,deleted,cache,job,id2,key2
BlobCacheGetTest -> private void testConcurrentGetOperations(final JobID jobId, final BlobKey.BlobType blobType, 			final boolean cacheAccessesHAStore) 			throws IOException, InterruptedException, ExecutionException;1507212387;[FLINK-6020] Tests that concurrent get operations don't concurrently access the BlobStore to_download a blob.__@param jobId_job ID to use (or <tt>null</tt> if job-unrelated)_@param blobType_whether the BLOB should become permanent or transient_@param cacheAccessesHAStore_whether the cache has access to the {@link BlobServer}'s HA store or not;private void testConcurrentGetOperations(final JobID jobId, final BlobKey.BlobType blobType,_			final boolean cacheAccessesHAStore)_			throws IOException, InterruptedException, ExecutionException {_		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final BlobStore blobStoreServer = mock(BlobStore.class)__		final BlobStore blobStoreCache = mock(BlobStore.class)___		final int numberConcurrentGetOperations = 3__		final List<CompletableFuture<File>> getOperations = new ArrayList<>(numberConcurrentGetOperations)___		final byte[] data = {1, 2, 3, 4, 99, 42}___		MessageDigest md = BlobUtils.createMessageDigest()___		_		final BlobKey blobKey = BlobKey.createKey(blobType, md.digest(data))___		final ExecutorService executor = Executors.newFixedThreadPool(numberConcurrentGetOperations)___		try (_			final BlobServer server = new BlobServer(config, blobStoreServer)__			final BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, cacheAccessesHAStore ? blobStoreServer : blobStoreCache)) {__			server.start()___			_			assertEquals(blobKey, put(server, jobId, data, blobType))___			_			for (int i = 0_ i < numberConcurrentGetOperations_ i++) {_				CompletableFuture<File> getOperation = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								File file = get(cache, jobId, blobKey)__								_								validateGetAndClose(new FileInputStream(file), data)__								return file__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not read blob for key " + blobKey + '.', e))__							}_						}, executor)___				getOperations.add(getOperation)__			}__			FutureUtils.ConjunctFuture<Collection<File>> filesFuture = FutureUtils.combineAll(getOperations)___			if (blobType == PERMANENT_BLOB) {_				_				filesFuture.get()__			} else {_				_				_				int completedSuccessfully = 0__				for (CompletableFuture<File> op : getOperations) {_					try {_						op.get()__						++completedSuccessfully__					} catch (Throwable t) {_						_						if (!(ExceptionUtils.getRootCause(t) instanceof FileNotFoundException)) {_							_							org.apache.flink.util.ExceptionUtils.rethrowIOException(t)__						}_					}_				}_				_				_				assertThat(completedSuccessfully, greaterThanOrEqualTo(1))__			}_		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,get,operations,don,t,concurrently,access,the,blob,store,to,download,a,blob,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated,param,blob,type,whether,the,blob,should,become,permanent,or,transient,param,cache,accesses,hastore,whether,the,cache,has,access,to,the,link,blob,server,s,ha,store,or,not;private,void,test,concurrent,get,operations,final,job,id,job,id,final,blob,key,blob,type,blob,type,final,boolean,cache,accesses,hastore,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,blob,store,blob,store,server,mock,blob,store,class,final,blob,store,blob,store,cache,mock,blob,store,class,final,int,number,concurrent,get,operations,3,final,list,completable,future,file,get,operations,new,array,list,number,concurrent,get,operations,final,byte,data,1,2,3,4,99,42,message,digest,md,blob,utils,create,message,digest,final,blob,key,blob,key,blob,key,create,key,blob,type,md,digest,data,final,executor,service,executor,executors,new,fixed,thread,pool,number,concurrent,get,operations,try,final,blob,server,server,new,blob,server,config,blob,store,server,final,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,cache,accesses,hastore,blob,store,server,blob,store,cache,server,start,assert,equals,blob,key,put,server,job,id,data,blob,type,for,int,i,0,i,number,concurrent,get,operations,i,completable,future,file,get,operation,completable,future,supply,async,try,file,file,get,cache,job,id,blob,key,validate,get,and,close,new,file,input,stream,file,data,return,file,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,read,blob,for,key,blob,key,e,executor,get,operations,add,get,operation,future,utils,conjunct,future,collection,file,files,future,future,utils,combine,all,get,operations,if,blob,type,files,future,get,else,int,completed,successfully,0,for,completable,future,file,op,get,operations,try,op,get,completed,successfully,catch,throwable,t,if,exception,utils,get,root,cause,t,instanceof,file,not,found,exception,org,apache,flink,util,exception,utils,rethrow,ioexception,t,assert,that,completed,successfully,greater,than,or,equal,to,1,finally,executor,shutdown,now
BlobCacheGetTest -> private void testConcurrentGetOperations(final JobID jobId, final BlobKey.BlobType blobType, 			final boolean cacheAccessesHAStore) 			throws IOException, InterruptedException, ExecutionException;1508138617;[FLINK-6020] Tests that concurrent get operations don't concurrently access the BlobStore to_download a blob.__@param jobId_job ID to use (or <tt>null</tt> if job-unrelated)_@param blobType_whether the BLOB should become permanent or transient_@param cacheAccessesHAStore_whether the cache has access to the {@link BlobServer}'s HA store or not;private void testConcurrentGetOperations(final JobID jobId, final BlobKey.BlobType blobType,_			final boolean cacheAccessesHAStore)_			throws IOException, InterruptedException, ExecutionException {_		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final BlobStore blobStoreServer = mock(BlobStore.class)__		final BlobStore blobStoreCache = mock(BlobStore.class)___		final int numberConcurrentGetOperations = 3__		final List<CompletableFuture<File>> getOperations = new ArrayList<>(numberConcurrentGetOperations)___		final byte[] data = {1, 2, 3, 4, 99, 42}___		final ExecutorService executor = Executors.newFixedThreadPool(numberConcurrentGetOperations)___		try (_			final BlobServer server = new BlobServer(config, blobStoreServer)__			final BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, cacheAccessesHAStore ? blobStoreServer : blobStoreCache)) {__			server.start()___			_			final BlobKey blobKey = put(server, jobId, data, blobType)___			_			for (int i = 0_ i < numberConcurrentGetOperations_ i++) {_				CompletableFuture<File> getOperation = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								File file = get(cache, jobId, blobKey)__								_								validateGetAndClose(new FileInputStream(file), data)__								return file__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not read blob for key " + blobKey + '.', e))__							}_						}, executor)___				getOperations.add(getOperation)__			}__			FutureUtils.ConjunctFuture<Collection<File>> filesFuture = FutureUtils.combineAll(getOperations)___			if (blobType == PERMANENT_BLOB) {_				_				filesFuture.get()__			} else {_				_				_				int completedSuccessfully = 0__				for (CompletableFuture<File> op : getOperations) {_					try {_						op.get()__						++completedSuccessfully__					} catch (Throwable t) {_						_						if (!(ExceptionUtils.getRootCause(t) instanceof FileNotFoundException)) {_							_							org.apache.flink.util.ExceptionUtils.rethrowIOException(t)__						}_					}_				}_				_				_				assertThat(completedSuccessfully, greaterThanOrEqualTo(1))__			}_		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,get,operations,don,t,concurrently,access,the,blob,store,to,download,a,blob,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated,param,blob,type,whether,the,blob,should,become,permanent,or,transient,param,cache,accesses,hastore,whether,the,cache,has,access,to,the,link,blob,server,s,ha,store,or,not;private,void,test,concurrent,get,operations,final,job,id,job,id,final,blob,key,blob,type,blob,type,final,boolean,cache,accesses,hastore,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,blob,store,blob,store,server,mock,blob,store,class,final,blob,store,blob,store,cache,mock,blob,store,class,final,int,number,concurrent,get,operations,3,final,list,completable,future,file,get,operations,new,array,list,number,concurrent,get,operations,final,byte,data,1,2,3,4,99,42,final,executor,service,executor,executors,new,fixed,thread,pool,number,concurrent,get,operations,try,final,blob,server,server,new,blob,server,config,blob,store,server,final,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,cache,accesses,hastore,blob,store,server,blob,store,cache,server,start,final,blob,key,blob,key,put,server,job,id,data,blob,type,for,int,i,0,i,number,concurrent,get,operations,i,completable,future,file,get,operation,completable,future,supply,async,try,file,file,get,cache,job,id,blob,key,validate,get,and,close,new,file,input,stream,file,data,return,file,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,read,blob,for,key,blob,key,e,executor,get,operations,add,get,operation,future,utils,conjunct,future,collection,file,files,future,future,utils,combine,all,get,operations,if,blob,type,files,future,get,else,int,completed,successfully,0,for,completable,future,file,op,get,operations,try,op,get,completed,successfully,catch,throwable,t,if,exception,utils,get,root,cause,t,instanceof,file,not,found,exception,org,apache,flink,util,exception,utils,rethrow,ioexception,t,assert,that,completed,successfully,greater,than,or,equal,to,1,finally,executor,shutdown,now
BlobCacheGetTest -> private void testConcurrentGetOperations(final JobID jobId, final BlobKey.BlobType blobType, 			final boolean cacheAccessesHAStore) 			throws IOException, InterruptedException, ExecutionException;1515428991;[FLINK-6020] Tests that concurrent get operations don't concurrently access the BlobStore to_download a blob.__@param jobId_job ID to use (or <tt>null</tt> if job-unrelated)_@param blobType_whether the BLOB should become permanent or transient_@param cacheAccessesHAStore_whether the cache has access to the {@link BlobServer}'s HA store or not;private void testConcurrentGetOperations(final JobID jobId, final BlobKey.BlobType blobType,_			final boolean cacheAccessesHAStore)_			throws IOException, InterruptedException, ExecutionException {_		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final BlobStore blobStoreServer = mock(BlobStore.class)__		final BlobStore blobStoreCache = mock(BlobStore.class)___		final int numberConcurrentGetOperations = 3__		final List<CompletableFuture<File>> getOperations = new ArrayList<>(numberConcurrentGetOperations)___		final byte[] data = {1, 2, 3, 4, 99, 42}___		final ExecutorService executor = Executors.newFixedThreadPool(numberConcurrentGetOperations)___		try (_			final BlobServer server = new BlobServer(config, blobStoreServer)__			final BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, cacheAccessesHAStore ? blobStoreServer : blobStoreCache)) {__			server.start()___			_			final BlobKey blobKey = put(server, jobId, data, blobType)___			_			for (int i = 0_ i < numberConcurrentGetOperations_ i++) {_				CompletableFuture<File> getOperation = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								File file = get(cache, jobId, blobKey)__								_								validateGetAndClose(new FileInputStream(file), data)__								return file__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not read blob for key " + blobKey + '.', e))__							}_						}, executor)___				getOperations.add(getOperation)__			}__			FutureUtils.ConjunctFuture<Collection<File>> filesFuture = FutureUtils.combineAll(getOperations)___			if (blobType == PERMANENT_BLOB) {_				_				filesFuture.get()__			} else {_				_				_				int completedSuccessfully = 0__				for (CompletableFuture<File> op : getOperations) {_					try {_						op.get()__						++completedSuccessfully__					} catch (Throwable t) {_						_						if (!(ExceptionUtils.getRootCause(t) instanceof FileNotFoundException)) {_							_							org.apache.flink.util.ExceptionUtils.rethrowIOException(t)__						}_					}_				}_				_				_				assertThat(completedSuccessfully, greaterThanOrEqualTo(1))__			}_		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,get,operations,don,t,concurrently,access,the,blob,store,to,download,a,blob,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated,param,blob,type,whether,the,blob,should,become,permanent,or,transient,param,cache,accesses,hastore,whether,the,cache,has,access,to,the,link,blob,server,s,ha,store,or,not;private,void,test,concurrent,get,operations,final,job,id,job,id,final,blob,key,blob,type,blob,type,final,boolean,cache,accesses,hastore,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,blob,store,blob,store,server,mock,blob,store,class,final,blob,store,blob,store,cache,mock,blob,store,class,final,int,number,concurrent,get,operations,3,final,list,completable,future,file,get,operations,new,array,list,number,concurrent,get,operations,final,byte,data,1,2,3,4,99,42,final,executor,service,executor,executors,new,fixed,thread,pool,number,concurrent,get,operations,try,final,blob,server,server,new,blob,server,config,blob,store,server,final,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,cache,accesses,hastore,blob,store,server,blob,store,cache,server,start,final,blob,key,blob,key,put,server,job,id,data,blob,type,for,int,i,0,i,number,concurrent,get,operations,i,completable,future,file,get,operation,completable,future,supply,async,try,file,file,get,cache,job,id,blob,key,validate,get,and,close,new,file,input,stream,file,data,return,file,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,read,blob,for,key,blob,key,e,executor,get,operations,add,get,operation,future,utils,conjunct,future,collection,file,files,future,future,utils,combine,all,get,operations,if,blob,type,files,future,get,else,int,completed,successfully,0,for,completable,future,file,op,get,operations,try,op,get,completed,successfully,catch,throwable,t,if,exception,utils,get,root,cause,t,instanceof,file,not,found,exception,org,apache,flink,util,exception,utils,rethrow,ioexception,t,assert,that,completed,successfully,greater,than,or,equal,to,1,finally,executor,shutdown,now
BlobCacheGetTest -> private void testConcurrentGetOperations(final JobID jobId, final BlobKey.BlobType blobType, 			final boolean cacheAccessesHAStore) 			throws IOException, InterruptedException, ExecutionException;1517915730;[FLINK-6020] Tests that concurrent get operations don't concurrently access the BlobStore to_download a blob.__@param jobId_job ID to use (or <tt>null</tt> if job-unrelated)_@param blobType_whether the BLOB should become permanent or transient_@param cacheAccessesHAStore_whether the cache has access to the {@link BlobServer}'s HA store or not;private void testConcurrentGetOperations(final JobID jobId, final BlobKey.BlobType blobType,_			final boolean cacheAccessesHAStore)_			throws IOException, InterruptedException, ExecutionException {_		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final BlobStore blobStoreServer = mock(BlobStore.class)__		final BlobStore blobStoreCache = mock(BlobStore.class)___		final int numberConcurrentGetOperations = 3__		final List<CompletableFuture<File>> getOperations = new ArrayList<>(numberConcurrentGetOperations)___		final byte[] data = {1, 2, 3, 4, 99, 42}___		final ExecutorService executor = Executors.newFixedThreadPool(numberConcurrentGetOperations)___		try (_			final BlobServer server = new BlobServer(config, blobStoreServer)__			final BlobCacheService cache = new BlobCacheService(config, cacheAccessesHAStore ? blobStoreServer : blobStoreCache, new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			_			final BlobKey blobKey = put(server, jobId, data, blobType)___			_			for (int i = 0_ i < numberConcurrentGetOperations_ i++) {_				CompletableFuture<File> getOperation = CompletableFuture_					.supplyAsync(_						() -> {_							try {_								File file = get(cache, jobId, blobKey)__								_								validateGetAndClose(new FileInputStream(file), data)__								return file__							} catch (IOException e) {_								throw new CompletionException(new FlinkException(_									"Could not read blob for key " + blobKey + '.', e))__							}_						}, executor)___				getOperations.add(getOperation)__			}__			FutureUtils.ConjunctFuture<Collection<File>> filesFuture = FutureUtils.combineAll(getOperations)___			if (blobType == PERMANENT_BLOB) {_				_				filesFuture.get()__			} else {_				_				_				int completedSuccessfully = 0__				for (CompletableFuture<File> op : getOperations) {_					try {_						op.get()__						++completedSuccessfully__					} catch (Throwable t) {_						_						if (!(ExceptionUtils.getRootCause(t) instanceof FileNotFoundException)) {_							_							org.apache.flink.util.ExceptionUtils.rethrowIOException(t)__						}_					}_				}_				_				_				assertThat(completedSuccessfully, greaterThanOrEqualTo(1))__			}_		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,get,operations,don,t,concurrently,access,the,blob,store,to,download,a,blob,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated,param,blob,type,whether,the,blob,should,become,permanent,or,transient,param,cache,accesses,hastore,whether,the,cache,has,access,to,the,link,blob,server,s,ha,store,or,not;private,void,test,concurrent,get,operations,final,job,id,job,id,final,blob,key,blob,type,blob,type,final,boolean,cache,accesses,hastore,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,blob,store,blob,store,server,mock,blob,store,class,final,blob,store,blob,store,cache,mock,blob,store,class,final,int,number,concurrent,get,operations,3,final,list,completable,future,file,get,operations,new,array,list,number,concurrent,get,operations,final,byte,data,1,2,3,4,99,42,final,executor,service,executor,executors,new,fixed,thread,pool,number,concurrent,get,operations,try,final,blob,server,server,new,blob,server,config,blob,store,server,final,blob,cache,service,cache,new,blob,cache,service,config,cache,accesses,hastore,blob,store,server,blob,store,cache,new,inet,socket,address,localhost,server,get,port,server,start,final,blob,key,blob,key,put,server,job,id,data,blob,type,for,int,i,0,i,number,concurrent,get,operations,i,completable,future,file,get,operation,completable,future,supply,async,try,file,file,get,cache,job,id,blob,key,validate,get,and,close,new,file,input,stream,file,data,return,file,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,read,blob,for,key,blob,key,e,executor,get,operations,add,get,operation,future,utils,conjunct,future,collection,file,files,future,future,utils,combine,all,get,operations,if,blob,type,files,future,get,else,int,completed,successfully,0,for,completable,future,file,op,get,operations,try,op,get,completed,successfully,catch,throwable,t,if,exception,utils,get,root,cause,t,instanceof,file,not,found,exception,org,apache,flink,util,exception,utils,rethrow,ioexception,t,assert,that,completed,successfully,greater,than,or,equal,to,1,finally,executor,shutdown,now
BlobCacheGetTest -> private void testGetFailsStore(@Nullable final JobID jobId, BlobKey.BlobType blobType) 			throws IOException, InterruptedException;1507212387;Retrieves a BLOB via a {@link BlobCacheService} which cannot create the final storage file._File transfers should fail.__@param jobId_job id_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsStore(@Nullable final JobID jobId, BlobKey.BlobType blobType)_			throws IOException, InterruptedException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File jobStoreDir = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			BlobKey blobKey = put(server, jobId, data, blobType)__			verifyType(blobType, blobKey)___			_			if (blobType == PERMANENT_BLOB) {_				jobStoreDir = cache.getPermanentBlobService()_					.getStorageLocation(jobId, new PermanentBlobKey())_					.getParentFile()__			} else {_				jobStoreDir = cache.getTransientBlobService()_					.getStorageLocation(jobId, new TransientBlobKey())_					.getParentFile()__			}_			assertTrue(jobStoreDir.setExecutable(true, false))__			assertTrue(jobStoreDir.setReadable(true, false))__			assertTrue(jobStoreDir.setWritable(false, false))___			_			exception.expect(AccessDeniedException.class)___			try {_				get(cache, jobId, blobKey)__			} finally {_				_				File incomingFileDir = new File(jobStoreDir.getParent(), "incoming")__				assertArrayEquals(new String[] {}, incomingFileDir.list())___				_				assertArrayEquals(new String[] {}, jobStoreDir.list())___				_				_				if (blobType == TRANSIENT_BLOB) {_					verifyDeletedEventually(server, jobId, blobKey)__				} else {_					assertTrue(server.getStorageLocation(jobId, blobKey).exists())__				}_			}_		} finally {_			_			if (jobStoreDir != null) {_				_				jobStoreDir.setWritable(true, false)__			}_		}_	};retrieves,a,blob,via,a,link,blob,cache,service,which,cannot,create,the,final,storage,file,file,transfers,should,fail,param,job,id,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,store,nullable,final,job,id,job,id,blob,key,blob,type,blob,type,throws,ioexception,interrupted,exception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,job,store,dir,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,blob,key,put,server,job,id,data,blob,type,verify,type,blob,type,blob,key,if,blob,type,job,store,dir,cache,get,permanent,blob,service,get,storage,location,job,id,new,permanent,blob,key,get,parent,file,else,job,store,dir,cache,get,transient,blob,service,get,storage,location,job,id,new,transient,blob,key,get,parent,file,assert,true,job,store,dir,set,executable,true,false,assert,true,job,store,dir,set,readable,true,false,assert,true,job,store,dir,set,writable,false,false,exception,expect,access,denied,exception,class,try,get,cache,job,id,blob,key,finally,file,incoming,file,dir,new,file,job,store,dir,get,parent,incoming,assert,array,equals,new,string,incoming,file,dir,list,assert,array,equals,new,string,job,store,dir,list,if,blob,type,verify,deleted,eventually,server,job,id,blob,key,else,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,if,job,store,dir,null,job,store,dir,set,writable,true,false
BlobCacheGetTest -> private void testGetFailsStore(@Nullable final JobID jobId, BlobKey.BlobType blobType) 			throws IOException, InterruptedException;1508138617;Retrieves a BLOB via a {@link BlobCacheService} which cannot create the final storage file._File transfers should fail.__@param jobId_job id_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsStore(@Nullable final JobID jobId, BlobKey.BlobType blobType)_			throws IOException, InterruptedException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File jobStoreDir = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			BlobKey blobKey = put(server, jobId, data, blobType)__			verifyType(blobType, blobKey)___			_			if (blobType == PERMANENT_BLOB) {_				jobStoreDir = cache.getPermanentBlobService()_					.getStorageLocation(jobId, new PermanentBlobKey())_					.getParentFile()__			} else {_				jobStoreDir = cache.getTransientBlobService()_					.getStorageLocation(jobId, new TransientBlobKey())_					.getParentFile()__			}_			assertTrue(jobStoreDir.setExecutable(true, false))__			assertTrue(jobStoreDir.setReadable(true, false))__			assertTrue(jobStoreDir.setWritable(false, false))___			_			exception.expect(AccessDeniedException.class)___			try {_				get(cache, jobId, blobKey)__			} finally {_				_				File incomingFileDir = new File(jobStoreDir.getParent(), "incoming")__				assertArrayEquals(new String[] {}, incomingFileDir.list())___				_				assertArrayEquals(new String[] {}, jobStoreDir.list())___				_				_				if (blobType == TRANSIENT_BLOB) {_					verifyDeletedEventually(server, jobId, blobKey)__				} else {_					assertTrue(server.getStorageLocation(jobId, blobKey).exists())__				}_			}_		} finally {_			_			if (jobStoreDir != null) {_				_				jobStoreDir.setWritable(true, false)__			}_		}_	};retrieves,a,blob,via,a,link,blob,cache,service,which,cannot,create,the,final,storage,file,file,transfers,should,fail,param,job,id,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,store,nullable,final,job,id,job,id,blob,key,blob,type,blob,type,throws,ioexception,interrupted,exception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,job,store,dir,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,blob,key,put,server,job,id,data,blob,type,verify,type,blob,type,blob,key,if,blob,type,job,store,dir,cache,get,permanent,blob,service,get,storage,location,job,id,new,permanent,blob,key,get,parent,file,else,job,store,dir,cache,get,transient,blob,service,get,storage,location,job,id,new,transient,blob,key,get,parent,file,assert,true,job,store,dir,set,executable,true,false,assert,true,job,store,dir,set,readable,true,false,assert,true,job,store,dir,set,writable,false,false,exception,expect,access,denied,exception,class,try,get,cache,job,id,blob,key,finally,file,incoming,file,dir,new,file,job,store,dir,get,parent,incoming,assert,array,equals,new,string,incoming,file,dir,list,assert,array,equals,new,string,job,store,dir,list,if,blob,type,verify,deleted,eventually,server,job,id,blob,key,else,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,if,job,store,dir,null,job,store,dir,set,writable,true,false
BlobCacheGetTest -> private void testGetFailsStore(@Nullable final JobID jobId, BlobKey.BlobType blobType) 			throws IOException, InterruptedException;1515428991;Retrieves a BLOB via a {@link BlobCacheService} which cannot create the final storage file._File transfers should fail.__@param jobId_job id_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsStore(@Nullable final JobID jobId, BlobKey.BlobType blobType)_			throws IOException, InterruptedException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File jobStoreDir = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			BlobKey blobKey = put(server, jobId, data, blobType)__			verifyType(blobType, blobKey)___			_			if (blobType == PERMANENT_BLOB) {_				jobStoreDir = cache.getPermanentBlobService()_					.getStorageLocation(jobId, new PermanentBlobKey())_					.getParentFile()__			} else {_				jobStoreDir = cache.getTransientBlobService()_					.getStorageLocation(jobId, new TransientBlobKey())_					.getParentFile()__			}_			assertTrue(jobStoreDir.setExecutable(true, false))__			assertTrue(jobStoreDir.setReadable(true, false))__			assertTrue(jobStoreDir.setWritable(false, false))___			_			exception.expect(AccessDeniedException.class)___			try {_				get(cache, jobId, blobKey)__			} finally {_				_				File incomingFileDir = new File(jobStoreDir.getParent(), "incoming")__				assertArrayEquals(new String[] {}, incomingFileDir.list())___				_				assertArrayEquals(new String[] {}, jobStoreDir.list())___				_				_				if (blobType == TRANSIENT_BLOB) {_					verifyDeletedEventually(server, jobId, blobKey)__				} else {_					assertTrue(server.getStorageLocation(jobId, blobKey).exists())__				}_			}_		} finally {_			_			if (jobStoreDir != null) {_				_				jobStoreDir.setWritable(true, false)__			}_		}_	};retrieves,a,blob,via,a,link,blob,cache,service,which,cannot,create,the,final,storage,file,file,transfers,should,fail,param,job,id,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,store,nullable,final,job,id,job,id,blob,key,blob,type,blob,type,throws,ioexception,interrupted,exception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,job,store,dir,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,blob,key,put,server,job,id,data,blob,type,verify,type,blob,type,blob,key,if,blob,type,job,store,dir,cache,get,permanent,blob,service,get,storage,location,job,id,new,permanent,blob,key,get,parent,file,else,job,store,dir,cache,get,transient,blob,service,get,storage,location,job,id,new,transient,blob,key,get,parent,file,assert,true,job,store,dir,set,executable,true,false,assert,true,job,store,dir,set,readable,true,false,assert,true,job,store,dir,set,writable,false,false,exception,expect,access,denied,exception,class,try,get,cache,job,id,blob,key,finally,file,incoming,file,dir,new,file,job,store,dir,get,parent,incoming,assert,array,equals,new,string,incoming,file,dir,list,assert,array,equals,new,string,job,store,dir,list,if,blob,type,verify,deleted,eventually,server,job,id,blob,key,else,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,if,job,store,dir,null,job,store,dir,set,writable,true,false
BlobCacheGetTest -> private void testGetFailsStore(@Nullable final JobID jobId, BlobKey.BlobType blobType) 			throws IOException, InterruptedException;1517915730;Retrieves a BLOB via a {@link BlobCacheService} which cannot create the final storage file._File transfers should fail.__@param jobId_job id_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsStore(@Nullable final JobID jobId, BlobKey.BlobType blobType)_			throws IOException, InterruptedException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File jobStoreDir = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			BlobKey blobKey = put(server, jobId, data, blobType)__			verifyType(blobType, blobKey)___			_			if (blobType == PERMANENT_BLOB) {_				jobStoreDir = cache.getPermanentBlobService()_					.getStorageLocation(jobId, new PermanentBlobKey())_					.getParentFile()__			} else {_				jobStoreDir = cache.getTransientBlobService()_					.getStorageLocation(jobId, new TransientBlobKey())_					.getParentFile()__			}_			assertTrue(jobStoreDir.setExecutable(true, false))__			assertTrue(jobStoreDir.setReadable(true, false))__			assertTrue(jobStoreDir.setWritable(false, false))___			_			exception.expect(AccessDeniedException.class)___			try {_				get(cache, jobId, blobKey)__			} finally {_				_				File incomingFileDir = new File(jobStoreDir.getParent(), "incoming")__				assertArrayEquals(new String[] {}, incomingFileDir.list())___				_				assertArrayEquals(new String[] {}, jobStoreDir.list())___				_				_				if (blobType == TRANSIENT_BLOB) {_					verifyDeletedEventually(server, jobId, blobKey)__				} else {_					assertTrue(server.getStorageLocation(jobId, blobKey).exists())__				}_			}_		} finally {_			_			if (jobStoreDir != null) {_				_				jobStoreDir.setWritable(true, false)__			}_		}_	};retrieves,a,blob,via,a,link,blob,cache,service,which,cannot,create,the,final,storage,file,file,transfers,should,fail,param,job,id,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,store,nullable,final,job,id,job,id,blob,key,blob,type,blob,type,throws,ioexception,interrupted,exception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,job,store,dir,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,blob,key,put,server,job,id,data,blob,type,verify,type,blob,type,blob,key,if,blob,type,job,store,dir,cache,get,permanent,blob,service,get,storage,location,job,id,new,permanent,blob,key,get,parent,file,else,job,store,dir,cache,get,transient,blob,service,get,storage,location,job,id,new,transient,blob,key,get,parent,file,assert,true,job,store,dir,set,executable,true,false,assert,true,job,store,dir,set,readable,true,false,assert,true,job,store,dir,set,writable,false,false,exception,expect,access,denied,exception,class,try,get,cache,job,id,blob,key,finally,file,incoming,file,dir,new,file,job,store,dir,get,parent,incoming,assert,array,equals,new,string,incoming,file,dir,list,assert,array,equals,new,string,job,store,dir,list,if,blob,type,verify,deleted,eventually,server,job,id,blob,key,else,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,if,job,store,dir,null,job,store,dir,set,writable,true,false
BlobCacheGetTest -> private void testGetTransientRemoteDeleteFails(@Nullable final JobID jobId) throws IOException;1507212387;Uploads a byte array for the given job and verifies that a get operation of a transient BLOB_(via the {@link BlobCacheService}_ also deletes the file on the {@link BlobServer}) does not_fail even if the file is not deletable on the {@link BlobServer}, e.g. via restricting the_permissions.__@param jobId_job id;private void testGetTransientRemoteDeleteFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				blobFile = server.getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				verifyContents(cache, jobId, key, data)__				_				assertTrue(delete(cache, jobId, key))__				File blobFileAtCache = cache.getTransientBlobService().getStorageLocation(jobId, key)__				assertFalse(blobFileAtCache.exists())___				_				verifyContents(server, jobId, key, data)__				_				verifyContents(cache, jobId, key, data)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,get,operation,of,a,transient,blob,via,the,link,blob,cache,service,also,deletes,the,file,on,the,link,blob,server,does,not,fail,even,if,the,file,is,not,deletable,on,the,link,blob,server,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,get,transient,remote,delete,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,blob,file,server,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,verify,contents,cache,job,id,key,data,assert,true,delete,cache,job,id,key,file,blob,file,at,cache,cache,get,transient,blob,service,get,storage,location,job,id,key,assert,false,blob,file,at,cache,exists,verify,contents,server,job,id,key,data,verify,contents,cache,job,id,key,data,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobCacheGetTest -> private void testGetTransientRemoteDeleteFails(@Nullable final JobID jobId) throws IOException;1508138617;Uploads a byte array for the given job and verifies that a get operation of a transient BLOB_(via the {@link BlobCacheService}_ also deletes the file on the {@link BlobServer}) does not_fail even if the file is not deletable on the {@link BlobServer}, e.g. via restricting the_permissions.__@param jobId_job id;private void testGetTransientRemoteDeleteFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				blobFile = server.getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				verifyContents(cache, jobId, key, data)__				_				assertTrue(delete(cache, jobId, key))__				File blobFileAtCache = cache.getTransientBlobService().getStorageLocation(jobId, key)__				assertFalse(blobFileAtCache.exists())___				_				verifyContents(server, jobId, key, data)__				_				verifyContents(cache, jobId, key, data)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,get,operation,of,a,transient,blob,via,the,link,blob,cache,service,also,deletes,the,file,on,the,link,blob,server,does,not,fail,even,if,the,file,is,not,deletable,on,the,link,blob,server,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,get,transient,remote,delete,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,blob,file,server,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,verify,contents,cache,job,id,key,data,assert,true,delete,cache,job,id,key,file,blob,file,at,cache,cache,get,transient,blob,service,get,storage,location,job,id,key,assert,false,blob,file,at,cache,exists,verify,contents,server,job,id,key,data,verify,contents,cache,job,id,key,data,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobCacheGetTest -> private void testGetTransientRemoteDeleteFails(@Nullable final JobID jobId) throws IOException;1515428991;Uploads a byte array for the given job and verifies that a get operation of a transient BLOB_(via the {@link BlobCacheService}_ also deletes the file on the {@link BlobServer}) does not_fail even if the file is not deletable on the {@link BlobServer}, e.g. via restricting the_permissions.__@param jobId_job id;private void testGetTransientRemoteDeleteFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				blobFile = server.getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				verifyContents(cache, jobId, key, data)__				_				assertTrue(delete(cache, jobId, key))__				File blobFileAtCache = cache.getTransientBlobService().getStorageLocation(jobId, key)__				assertFalse(blobFileAtCache.exists())___				_				verifyContents(server, jobId, key, data)__				_				verifyContents(cache, jobId, key, data)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,get,operation,of,a,transient,blob,via,the,link,blob,cache,service,also,deletes,the,file,on,the,link,blob,server,does,not,fail,even,if,the,file,is,not,deletable,on,the,link,blob,server,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,get,transient,remote,delete,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,blob,file,server,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,verify,contents,cache,job,id,key,data,assert,true,delete,cache,job,id,key,file,blob,file,at,cache,cache,get,transient,blob,service,get,storage,location,job,id,key,assert,false,blob,file,at,cache,exists,verify,contents,server,job,id,key,data,verify,contents,cache,job,id,key,data,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobCacheGetTest -> private void testGetTransientRemoteDeleteFails(@Nullable final JobID jobId) throws IOException;1517915730;Uploads a byte array for the given job and verifies that a get operation of a transient BLOB_(via the {@link BlobCacheService}_ also deletes the file on the {@link BlobServer}) does not_fail even if the file is not deletable on the {@link BlobServer}, e.g. via restricting the_permissions.__@param jobId_job id;private void testGetTransientRemoteDeleteFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				blobFile = server.getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				verifyContents(cache, jobId, key, data)__				_				assertTrue(delete(cache, jobId, key))__				File blobFileAtCache = cache.getTransientBlobService().getStorageLocation(jobId, key)__				assertFalse(blobFileAtCache.exists())___				_				verifyContents(server, jobId, key, data)__				_				verifyContents(cache, jobId, key, data)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,get,operation,of,a,transient,blob,via,the,link,blob,cache,service,also,deletes,the,file,on,the,link,blob,server,does,not,fail,even,if,the,file,is,not,deletable,on,the,link,blob,server,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,get,transient,remote,delete,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,blob,file,server,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,verify,contents,cache,job,id,key,data,assert,true,delete,cache,job,id,key,file,blob,file,at,cache,cache,get,transient,blob,service,get,storage,location,job,id,key,assert,false,blob,file,at,cache,exists,verify,contents,server,job,id,key,data,verify,contents,cache,job,id,key,data,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobCacheGetTest -> @Test 	public void testGetFailsHaStoreForJobHa() throws IOException;1507212387;Retrieves a BLOB from the HA store to a {@link BlobServer} whose HA store does not contain_the file. File transfers should fail.;@Test_	public void testGetFailsHaStoreForJobHa() throws IOException {_		final JobID jobId = new JobID()___		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCache cache = new BlobCache(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			BlobKey blobKey = put(server, jobId, data, true)__			assertTrue(server.getStorageLocation(jobId, blobKey).delete())___			File tempFileDir = server.createTemporaryFilename().getParentFile()___			_			exception.expect(IOException.class)__			exception.expectMessage("Failed to fetch BLOB ")___			try {_				get(cache, jobId, blobKey, true)__			} finally {_				HashSet<String> expectedDirs = new HashSet<>()__				expectedDirs.add("incoming")__				expectedDirs.add(JOB_DIR_PREFIX + jobId)__				_				File storageDir = tempFileDir.getParentFile()__				String[] actualDirs = storageDir.list()__				assertNotNull(actualDirs)__				assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___				_				File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId)__				assertArrayEquals(new String[] {}, jobDir.list())__			}_		}_	};retrieves,a,blob,from,the,ha,store,to,a,link,blob,server,whose,ha,store,does,not,contain,the,file,file,transfers,should,fail;test,public,void,test,get,fails,ha,store,for,job,ha,throws,ioexception,final,job,id,job,id,new,job,id,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,cache,new,blob,cache,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,blob,key,put,server,job,id,data,true,assert,true,server,get,storage,location,job,id,blob,key,delete,file,temp,file,dir,server,create,temporary,filename,get,parent,file,exception,expect,ioexception,class,exception,expect,message,failed,to,fetch,blob,try,get,cache,job,id,blob,key,true,finally,hash,set,string,expected,dirs,new,hash,set,expected,dirs,add,incoming,expected,dirs,add,job,id,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,job,dir,new,file,temp,file,dir,get,parent,file,job,id,assert,array,equals,new,string,job,dir,list
BlobCacheGetTest -> @Test 	public void testGetFailsHaStoreForJobHa() throws IOException;1507212387;Retrieves a BLOB from the HA store to a {@link BlobServer} whose HA store does not contain_the file. File transfers should fail.;@Test_	public void testGetFailsHaStoreForJobHa() throws IOException {_		final JobID jobId = new JobID()___		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			PermanentBlobKey blobKey = (PermanentBlobKey) put(server, jobId, data, PERMANENT_BLOB)__			assertTrue(server.getStorageLocation(jobId, blobKey).delete())___			File tempFileDir = server.createTemporaryFilename().getParentFile()___			_			exception.expect(IOException.class)__			exception.expectMessage("Failed to fetch BLOB ")___			try {_				get(cache, jobId, blobKey)__			} finally {_				HashSet<String> expectedDirs = new HashSet<>()__				expectedDirs.add("incoming")__				expectedDirs.add(JOB_DIR_PREFIX + jobId)__				_				File storageDir = tempFileDir.getParentFile()__				String[] actualDirs = storageDir.list()__				assertNotNull(actualDirs)__				assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___				_				File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId)__				assertArrayEquals(new String[] {}, jobDir.list())__			}_		}_	};retrieves,a,blob,from,the,ha,store,to,a,link,blob,server,whose,ha,store,does,not,contain,the,file,file,transfers,should,fail;test,public,void,test,get,fails,ha,store,for,job,ha,throws,ioexception,final,job,id,job,id,new,job,id,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,permanent,blob,key,blob,key,permanent,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,delete,file,temp,file,dir,server,create,temporary,filename,get,parent,file,exception,expect,ioexception,class,exception,expect,message,failed,to,fetch,blob,try,get,cache,job,id,blob,key,finally,hash,set,string,expected,dirs,new,hash,set,expected,dirs,add,incoming,expected,dirs,add,job,id,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,job,dir,new,file,temp,file,dir,get,parent,file,job,id,assert,array,equals,new,string,job,dir,list
BlobCacheGetTest -> @Test 	public void testGetFailsHaStoreForJobHa() throws IOException;1508138617;Retrieves a BLOB from the HA store to a {@link BlobServer} whose HA store does not contain_the file. File transfers should fail.;@Test_	public void testGetFailsHaStoreForJobHa() throws IOException {_		final JobID jobId = new JobID()___		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			PermanentBlobKey blobKey = (PermanentBlobKey) put(server, jobId, data, PERMANENT_BLOB)__			assertTrue(server.getStorageLocation(jobId, blobKey).delete())___			File tempFileDir = server.createTemporaryFilename().getParentFile()___			_			exception.expect(IOException.class)__			exception.expectMessage("Failed to fetch BLOB ")___			try {_				get(cache, jobId, blobKey)__			} finally {_				HashSet<String> expectedDirs = new HashSet<>()__				expectedDirs.add("incoming")__				expectedDirs.add(JOB_DIR_PREFIX + jobId)__				_				File storageDir = tempFileDir.getParentFile()__				String[] actualDirs = storageDir.list()__				assertNotNull(actualDirs)__				assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___				_				File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId)__				assertArrayEquals(new String[] {}, jobDir.list())__			}_		}_	};retrieves,a,blob,from,the,ha,store,to,a,link,blob,server,whose,ha,store,does,not,contain,the,file,file,transfers,should,fail;test,public,void,test,get,fails,ha,store,for,job,ha,throws,ioexception,final,job,id,job,id,new,job,id,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,permanent,blob,key,blob,key,permanent,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,delete,file,temp,file,dir,server,create,temporary,filename,get,parent,file,exception,expect,ioexception,class,exception,expect,message,failed,to,fetch,blob,try,get,cache,job,id,blob,key,finally,hash,set,string,expected,dirs,new,hash,set,expected,dirs,add,incoming,expected,dirs,add,job,id,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,job,dir,new,file,temp,file,dir,get,parent,file,job,id,assert,array,equals,new,string,job,dir,list
BlobCacheGetTest -> @Test 	public void testGetFailsHaStoreForJobHa() throws IOException;1515428991;Retrieves a BLOB from the HA store to a {@link BlobServer} whose HA store does not contain_the file. File transfers should fail.;@Test_	public void testGetFailsHaStoreForJobHa() throws IOException {_		final JobID jobId = new JobID()___		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			PermanentBlobKey blobKey = (PermanentBlobKey) put(server, jobId, data, PERMANENT_BLOB)__			assertTrue(server.getStorageLocation(jobId, blobKey).delete())___			File tempFileDir = server.createTemporaryFilename().getParentFile()___			_			exception.expect(IOException.class)__			exception.expectMessage("Failed to fetch BLOB ")___			try {_				get(cache, jobId, blobKey)__			} finally {_				HashSet<String> expectedDirs = new HashSet<>()__				expectedDirs.add("incoming")__				expectedDirs.add(JOB_DIR_PREFIX + jobId)__				_				File storageDir = tempFileDir.getParentFile()__				String[] actualDirs = storageDir.list()__				assertNotNull(actualDirs)__				assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___				_				File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId)__				assertArrayEquals(new String[] {}, jobDir.list())__			}_		}_	};retrieves,a,blob,from,the,ha,store,to,a,link,blob,server,whose,ha,store,does,not,contain,the,file,file,transfers,should,fail;test,public,void,test,get,fails,ha,store,for,job,ha,throws,ioexception,final,job,id,job,id,new,job,id,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,permanent,blob,key,blob,key,permanent,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,delete,file,temp,file,dir,server,create,temporary,filename,get,parent,file,exception,expect,ioexception,class,exception,expect,message,failed,to,fetch,blob,try,get,cache,job,id,blob,key,finally,hash,set,string,expected,dirs,new,hash,set,expected,dirs,add,incoming,expected,dirs,add,job,id,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,job,dir,new,file,temp,file,dir,get,parent,file,job,id,assert,array,equals,new,string,job,dir,list
BlobCacheGetTest -> @Test 	public void testGetFailsHaStoreForJobHa() throws IOException;1517915730;Retrieves a BLOB from the HA store to a {@link BlobServer} whose HA store does not contain_the file. File transfers should fail.;@Test_	public void testGetFailsHaStoreForJobHa() throws IOException {_		final JobID jobId = new JobID()___		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			PermanentBlobKey blobKey = (PermanentBlobKey) put(server, jobId, data, PERMANENT_BLOB)__			assertTrue(server.getStorageLocation(jobId, blobKey).delete())___			File tempFileDir = server.createTemporaryFilename().getParentFile()___			_			exception.expect(IOException.class)__			exception.expectMessage("Failed to fetch BLOB ")___			try {_				get(cache, jobId, blobKey)__			} finally {_				HashSet<String> expectedDirs = new HashSet<>()__				expectedDirs.add("incoming")__				expectedDirs.add(JOB_DIR_PREFIX + jobId)__				_				File storageDir = tempFileDir.getParentFile()__				String[] actualDirs = storageDir.list()__				assertNotNull(actualDirs)__				assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___				_				File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId)__				assertArrayEquals(new String[] {}, jobDir.list())__			}_		}_	};retrieves,a,blob,from,the,ha,store,to,a,link,blob,server,whose,ha,store,does,not,contain,the,file,file,transfers,should,fail;test,public,void,test,get,fails,ha,store,for,job,ha,throws,ioexception,final,job,id,job,id,new,job,id,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,permanent,blob,key,blob,key,permanent,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,delete,file,temp,file,dir,server,create,temporary,filename,get,parent,file,exception,expect,ioexception,class,exception,expect,message,failed,to,fetch,blob,try,get,cache,job,id,blob,key,finally,hash,set,string,expected,dirs,new,hash,set,expected,dirs,add,incoming,expected,dirs,add,job,id,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,job,dir,new,file,temp,file,dir,get,parent,file,job,id,assert,array,equals,new,string,job,dir,list
BlobCacheGetTest -> private void testGetFailsIncoming(@Nullable final JobID jobId, BlobKey.BlobType blobType) 			throws IOException;1507212387;Retrieves a BLOB via a {@link BlobCacheService} which cannot create incoming files. File_transfers should fail.__@param jobId_job id_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsIncoming(@Nullable final JobID jobId, BlobKey.BlobType blobType)_			throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File tempFileDir = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			BlobKey blobKey = put(server, jobId, data, blobType)__			verifyType(blobType, blobKey)___			_			if (blobType == PERMANENT_BLOB) {_				tempFileDir =_					cache.getPermanentBlobService().createTemporaryFilename().getParentFile()__			} else {_				tempFileDir =_					cache.getTransientBlobService().createTemporaryFilename().getParentFile()__			}_			assertTrue(tempFileDir.setExecutable(true, false))__			assertTrue(tempFileDir.setReadable(true, false))__			assertTrue(tempFileDir.setWritable(false, false))___			_			exception.expect(IOException.class)__			exception.expectMessage("Failed to fetch BLOB ")___			try {_				get(cache, jobId, blobKey)__			} finally {_				HashSet<String> expectedDirs = new HashSet<>()__				expectedDirs.add("incoming")__				if (jobId != null) {_					_					expectedDirs.add(JOB_DIR_PREFIX + jobId)__					File storageDir = tempFileDir.getParentFile()__					String[] actualDirs = storageDir.list()__					assertNotNull(actualDirs)__					assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___					_					File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId)__					assertArrayEquals(new String[] {}, jobDir.list())__				} else {_					_					expectedDirs.add(NO_JOB_DIR_PREFIX)__					File storageDir = tempFileDir.getParentFile()__					String[] actualDirs = storageDir.list()__					assertNotNull(actualDirs)__					assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___					_					File noJobDir = new File(tempFileDir.getParentFile(), NO_JOB_DIR_PREFIX)__					assertArrayEquals(new String[] {}, noJobDir.list())__				}__				_				assertTrue(server.getStorageLocation(jobId, blobKey).exists())__			}_		} finally {_			_			if (tempFileDir != null) {_				_				tempFileDir.setWritable(true, false)__			}_		}_	};retrieves,a,blob,via,a,link,blob,cache,service,which,cannot,create,incoming,files,file,transfers,should,fail,param,job,id,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,incoming,nullable,final,job,id,job,id,blob,key,blob,type,blob,type,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,temp,file,dir,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,blob,key,put,server,job,id,data,blob,type,verify,type,blob,type,blob,key,if,blob,type,temp,file,dir,cache,get,permanent,blob,service,create,temporary,filename,get,parent,file,else,temp,file,dir,cache,get,transient,blob,service,create,temporary,filename,get,parent,file,assert,true,temp,file,dir,set,executable,true,false,assert,true,temp,file,dir,set,readable,true,false,assert,true,temp,file,dir,set,writable,false,false,exception,expect,ioexception,class,exception,expect,message,failed,to,fetch,blob,try,get,cache,job,id,blob,key,finally,hash,set,string,expected,dirs,new,hash,set,expected,dirs,add,incoming,if,job,id,null,expected,dirs,add,job,id,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,job,dir,new,file,temp,file,dir,get,parent,file,job,id,assert,array,equals,new,string,job,dir,list,else,expected,dirs,add,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,no,job,dir,new,file,temp,file,dir,get,parent,file,assert,array,equals,new,string,no,job,dir,list,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,if,temp,file,dir,null,temp,file,dir,set,writable,true,false
BlobCacheGetTest -> private void testGetFailsIncoming(@Nullable final JobID jobId, BlobKey.BlobType blobType) 			throws IOException;1508138617;Retrieves a BLOB via a {@link BlobCacheService} which cannot create incoming files. File_transfers should fail.__@param jobId_job id_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsIncoming(@Nullable final JobID jobId, BlobKey.BlobType blobType)_			throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File tempFileDir = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			BlobKey blobKey = put(server, jobId, data, blobType)__			verifyType(blobType, blobKey)___			_			if (blobType == PERMANENT_BLOB) {_				tempFileDir =_					cache.getPermanentBlobService().createTemporaryFilename().getParentFile()__			} else {_				tempFileDir =_					cache.getTransientBlobService().createTemporaryFilename().getParentFile()__			}_			assertTrue(tempFileDir.setExecutable(true, false))__			assertTrue(tempFileDir.setReadable(true, false))__			assertTrue(tempFileDir.setWritable(false, false))___			_			exception.expect(IOException.class)__			exception.expectMessage("Failed to fetch BLOB ")___			try {_				get(cache, jobId, blobKey)__			} finally {_				HashSet<String> expectedDirs = new HashSet<>()__				expectedDirs.add("incoming")__				if (jobId != null) {_					_					expectedDirs.add(JOB_DIR_PREFIX + jobId)__					File storageDir = tempFileDir.getParentFile()__					String[] actualDirs = storageDir.list()__					assertNotNull(actualDirs)__					assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___					_					File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId)__					assertArrayEquals(new String[] {}, jobDir.list())__				} else {_					_					expectedDirs.add(NO_JOB_DIR_PREFIX)__					File storageDir = tempFileDir.getParentFile()__					String[] actualDirs = storageDir.list()__					assertNotNull(actualDirs)__					assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___					_					File noJobDir = new File(tempFileDir.getParentFile(), NO_JOB_DIR_PREFIX)__					assertArrayEquals(new String[] {}, noJobDir.list())__				}__				_				assertTrue(server.getStorageLocation(jobId, blobKey).exists())__			}_		} finally {_			_			if (tempFileDir != null) {_				_				tempFileDir.setWritable(true, false)__			}_		}_	};retrieves,a,blob,via,a,link,blob,cache,service,which,cannot,create,incoming,files,file,transfers,should,fail,param,job,id,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,incoming,nullable,final,job,id,job,id,blob,key,blob,type,blob,type,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,temp,file,dir,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,blob,key,put,server,job,id,data,blob,type,verify,type,blob,type,blob,key,if,blob,type,temp,file,dir,cache,get,permanent,blob,service,create,temporary,filename,get,parent,file,else,temp,file,dir,cache,get,transient,blob,service,create,temporary,filename,get,parent,file,assert,true,temp,file,dir,set,executable,true,false,assert,true,temp,file,dir,set,readable,true,false,assert,true,temp,file,dir,set,writable,false,false,exception,expect,ioexception,class,exception,expect,message,failed,to,fetch,blob,try,get,cache,job,id,blob,key,finally,hash,set,string,expected,dirs,new,hash,set,expected,dirs,add,incoming,if,job,id,null,expected,dirs,add,job,id,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,job,dir,new,file,temp,file,dir,get,parent,file,job,id,assert,array,equals,new,string,job,dir,list,else,expected,dirs,add,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,no,job,dir,new,file,temp,file,dir,get,parent,file,assert,array,equals,new,string,no,job,dir,list,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,if,temp,file,dir,null,temp,file,dir,set,writable,true,false
BlobCacheGetTest -> private void testGetFailsIncoming(@Nullable final JobID jobId, BlobKey.BlobType blobType) 			throws IOException;1515428991;Retrieves a BLOB via a {@link BlobCacheService} which cannot create incoming files. File_transfers should fail.__@param jobId_job id_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsIncoming(@Nullable final JobID jobId, BlobKey.BlobType blobType)_			throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File tempFileDir = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(new InetSocketAddress("localhost", server.getPort()),_				config, new VoidBlobStore())) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			BlobKey blobKey = put(server, jobId, data, blobType)__			verifyType(blobType, blobKey)___			_			if (blobType == PERMANENT_BLOB) {_				tempFileDir =_					cache.getPermanentBlobService().createTemporaryFilename().getParentFile()__			} else {_				tempFileDir =_					cache.getTransientBlobService().createTemporaryFilename().getParentFile()__			}_			assertTrue(tempFileDir.setExecutable(true, false))__			assertTrue(tempFileDir.setReadable(true, false))__			assertTrue(tempFileDir.setWritable(false, false))___			_			exception.expect(IOException.class)__			exception.expectMessage("Failed to fetch BLOB ")___			try {_				get(cache, jobId, blobKey)__			} finally {_				HashSet<String> expectedDirs = new HashSet<>()__				expectedDirs.add("incoming")__				if (jobId != null) {_					_					expectedDirs.add(JOB_DIR_PREFIX + jobId)__					File storageDir = tempFileDir.getParentFile()__					String[] actualDirs = storageDir.list()__					assertNotNull(actualDirs)__					assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___					_					File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId)__					assertArrayEquals(new String[] {}, jobDir.list())__				} else {_					_					expectedDirs.add(NO_JOB_DIR_PREFIX)__					File storageDir = tempFileDir.getParentFile()__					String[] actualDirs = storageDir.list()__					assertNotNull(actualDirs)__					assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___					_					File noJobDir = new File(tempFileDir.getParentFile(), NO_JOB_DIR_PREFIX)__					assertArrayEquals(new String[] {}, noJobDir.list())__				}__				_				assertTrue(server.getStorageLocation(jobId, blobKey).exists())__			}_		} finally {_			_			if (tempFileDir != null) {_				_				tempFileDir.setWritable(true, false)__			}_		}_	};retrieves,a,blob,via,a,link,blob,cache,service,which,cannot,create,incoming,files,file,transfers,should,fail,param,job,id,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,incoming,nullable,final,job,id,job,id,blob,key,blob,type,blob,type,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,temp,file,dir,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,new,inet,socket,address,localhost,server,get,port,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,blob,key,put,server,job,id,data,blob,type,verify,type,blob,type,blob,key,if,blob,type,temp,file,dir,cache,get,permanent,blob,service,create,temporary,filename,get,parent,file,else,temp,file,dir,cache,get,transient,blob,service,create,temporary,filename,get,parent,file,assert,true,temp,file,dir,set,executable,true,false,assert,true,temp,file,dir,set,readable,true,false,assert,true,temp,file,dir,set,writable,false,false,exception,expect,ioexception,class,exception,expect,message,failed,to,fetch,blob,try,get,cache,job,id,blob,key,finally,hash,set,string,expected,dirs,new,hash,set,expected,dirs,add,incoming,if,job,id,null,expected,dirs,add,job,id,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,job,dir,new,file,temp,file,dir,get,parent,file,job,id,assert,array,equals,new,string,job,dir,list,else,expected,dirs,add,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,no,job,dir,new,file,temp,file,dir,get,parent,file,assert,array,equals,new,string,no,job,dir,list,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,if,temp,file,dir,null,temp,file,dir,set,writable,true,false
BlobCacheGetTest -> private void testGetFailsIncoming(@Nullable final JobID jobId, BlobKey.BlobType blobType) 			throws IOException;1517915730;Retrieves a BLOB via a {@link BlobCacheService} which cannot create incoming files. File_transfers should fail.__@param jobId_job id_@param blobType_whether the BLOB should become permanent or transient;private void testGetFailsIncoming(@Nullable final JobID jobId, BlobKey.BlobType blobType)_			throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File tempFileDir = null__		try (_			BlobServer server = new BlobServer(config, new VoidBlobStore())__			BlobCacheService cache = new BlobCacheService(config, new VoidBlobStore(), new InetSocketAddress("localhost", server.getPort())_			)) {__			server.start()___			_			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			BlobKey blobKey = put(server, jobId, data, blobType)__			verifyType(blobType, blobKey)___			_			if (blobType == PERMANENT_BLOB) {_				tempFileDir =_					cache.getPermanentBlobService().createTemporaryFilename().getParentFile()__			} else {_				tempFileDir =_					cache.getTransientBlobService().createTemporaryFilename().getParentFile()__			}_			assertTrue(tempFileDir.setExecutable(true, false))__			assertTrue(tempFileDir.setReadable(true, false))__			assertTrue(tempFileDir.setWritable(false, false))___			_			exception.expect(IOException.class)__			exception.expectMessage("Failed to fetch BLOB ")___			try {_				get(cache, jobId, blobKey)__			} finally {_				HashSet<String> expectedDirs = new HashSet<>()__				expectedDirs.add("incoming")__				if (jobId != null) {_					_					expectedDirs.add(JOB_DIR_PREFIX + jobId)__					File storageDir = tempFileDir.getParentFile()__					String[] actualDirs = storageDir.list()__					assertNotNull(actualDirs)__					assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___					_					File jobDir = new File(tempFileDir.getParentFile(), JOB_DIR_PREFIX + jobId)__					assertArrayEquals(new String[] {}, jobDir.list())__				} else {_					_					expectedDirs.add(NO_JOB_DIR_PREFIX)__					File storageDir = tempFileDir.getParentFile()__					String[] actualDirs = storageDir.list()__					assertNotNull(actualDirs)__					assertEquals(expectedDirs, new HashSet<>(Arrays.asList(actualDirs)))___					_					File noJobDir = new File(tempFileDir.getParentFile(), NO_JOB_DIR_PREFIX)__					assertArrayEquals(new String[] {}, noJobDir.list())__				}__				_				assertTrue(server.getStorageLocation(jobId, blobKey).exists())__			}_		} finally {_			_			if (tempFileDir != null) {_				_				tempFileDir.setWritable(true, false)__			}_		}_	};retrieves,a,blob,via,a,link,blob,cache,service,which,cannot,create,incoming,files,file,transfers,should,fail,param,job,id,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,get,fails,incoming,nullable,final,job,id,job,id,blob,key,blob,type,blob,type,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,temp,file,dir,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,blob,cache,service,cache,new,blob,cache,service,config,new,void,blob,store,new,inet,socket,address,localhost,server,get,port,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,blob,key,put,server,job,id,data,blob,type,verify,type,blob,type,blob,key,if,blob,type,temp,file,dir,cache,get,permanent,blob,service,create,temporary,filename,get,parent,file,else,temp,file,dir,cache,get,transient,blob,service,create,temporary,filename,get,parent,file,assert,true,temp,file,dir,set,executable,true,false,assert,true,temp,file,dir,set,readable,true,false,assert,true,temp,file,dir,set,writable,false,false,exception,expect,ioexception,class,exception,expect,message,failed,to,fetch,blob,try,get,cache,job,id,blob,key,finally,hash,set,string,expected,dirs,new,hash,set,expected,dirs,add,incoming,if,job,id,null,expected,dirs,add,job,id,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,job,dir,new,file,temp,file,dir,get,parent,file,job,id,assert,array,equals,new,string,job,dir,list,else,expected,dirs,add,file,storage,dir,temp,file,dir,get,parent,file,string,actual,dirs,storage,dir,list,assert,not,null,actual,dirs,assert,equals,expected,dirs,new,hash,set,arrays,as,list,actual,dirs,file,no,job,dir,new,file,temp,file,dir,get,parent,file,assert,array,equals,new,string,no,job,dir,list,assert,true,server,get,storage,location,job,id,blob,key,exists,finally,if,temp,file,dir,null,temp,file,dir,set,writable,true,false
