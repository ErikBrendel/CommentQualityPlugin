# id;timestamp;commentText;codeText;commentWords;codeWords
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1499173045;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			keys.add(bc.put(buf))__			buf[0] += 1__			keys.add(bc.put(buf))___			long cleanupInterval = 1000l__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerJob(jid, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(keys, libraryCacheManager, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterJob(jid)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(500)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(keys, libraryCacheManager, false))___			try {_				bc.get(jid, "test")__				fail("name-addressable BLOB should have been deleted")__			} catch (IOException e) {_				_			}__			bc.close()__		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,keys,add,bc,put,buf,buf,0,1,keys,add,bc,put,buf,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,job,jid,keys,collections,url,empty,list,assert,equals,2,check,files,exist,keys,library,cache,manager,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,job,jid,long,deadline,system,current,time,millis,30000,do,thread,sleep,500,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,keys,library,cache,manager,false,try,bc,get,jid,test,fail,name,addressable,blob,should,have,been,deleted,catch,ioexception,e,bc,close,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1499789965;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			keys.add(bc.put(buf))__			buf[0] += 1__			keys.add(bc.put(buf))___			bc.close()___			long cleanupInterval = 1000l__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerJob(jid, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(keys, libraryCacheManager, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterJob(jid)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(500)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(keys, libraryCacheManager, false))___			try {_				server.getURL(keys.get(0))__				fail("name-addressable BLOB should have been deleted")__			} catch (IOException e) {_				_			}_			try {_				server.getURL(keys.get(1))__				fail("name-addressable BLOB should have been deleted")__			} catch (IOException e) {_				_			}_		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,keys,add,bc,put,buf,buf,0,1,keys,add,bc,put,buf,bc,close,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,job,jid,keys,collections,url,empty,list,assert,equals,2,check,files,exist,keys,library,cache,manager,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,job,jid,long,deadline,system,current,time,millis,30000,do,thread,sleep,500,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,keys,library,cache,manager,false,try,server,get,url,keys,get,0,fail,name,addressable,blob,should,have,been,deleted,catch,ioexception,e,try,server,get,url,keys,get,1,fail,name,addressable,blob,should,have,been,deleted,catch,ioexception,e,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1502100084;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			keys.add(bc.put(buf))__			buf[0] += 1__			keys.add(bc.put(buf))___			bc.close()___			long cleanupInterval = 1000l__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerJob(jid, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(keys, libraryCacheManager, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterJob(jid)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(500)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(keys, libraryCacheManager, false))___			try {_				server.getURL(keys.get(0))__				fail("name-addressable BLOB should have been deleted")__			} catch (IOException e) {_				_			}_			try {_				server.getURL(keys.get(1))__				fail("name-addressable BLOB should have been deleted")__			} catch (IOException e) {_				_			}_		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,keys,add,bc,put,buf,buf,0,1,keys,add,bc,put,buf,bc,close,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,job,jid,keys,collections,url,empty,list,assert,equals,2,check,files,exist,keys,library,cache,manager,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,job,jid,long,deadline,system,current,time,millis,30000,do,thread,sleep,500,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,keys,library,cache,manager,false,try,server,get,url,keys,get,0,fail,name,addressable,blob,should,have,been,deleted,catch,ioexception,e,try,server,get,url,keys,get,1,fail,name,addressable,blob,should,have,been,deleted,catch,ioexception,e,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1502201311;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			keys.add(bc.put(buf))__			buf[0] += 1__			keys.add(bc.put(buf))___			bc.close()___			long cleanupInterval = 1000l__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerJob(jid, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(keys, server, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterJob(jid)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(500)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(keys, server, false))___			try {_				server.getURL(keys.get(0))__				fail("name-addressable BLOB should have been deleted")__			} catch (IOException e) {_				_			}_			try {_				server.getURL(keys.get(1))__				fail("name-addressable BLOB should have been deleted")__			} catch (IOException e) {_				_			}_		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,keys,add,bc,put,buf,buf,0,1,keys,add,bc,put,buf,bc,close,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,job,jid,keys,collections,url,empty,list,assert,equals,2,check,files,exist,keys,server,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,job,jid,long,deadline,system,current,time,millis,30000,do,thread,sleep,500,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,keys,server,false,try,server,get,url,keys,get,0,fail,name,addressable,blob,should,have,been,deleted,catch,ioexception,e,try,server,get,url,keys,get,1,fail,name,addressable,blob,should,have,been,deleted,catch,ioexception,e,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1502692653;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			keys.add(bc.put(buf))__			buf[0] += 1__			keys.add(bc.put(buf))___			bc.close()___			long cleanupInterval = 1000l__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerJob(jid, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(keys, server, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterJob(jid)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(500)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(keys, server, false))___			try {_				server.getFile(keys.get(0))__				fail("name-addressable BLOB should have been deleted")__			} catch (IOException e) {_				_			}_			try {_				server.getFile(keys.get(1))__				fail("name-addressable BLOB should have been deleted")__			} catch (IOException e) {_				_			}_		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,keys,add,bc,put,buf,buf,0,1,keys,add,bc,put,buf,bc,close,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,job,jid,keys,collections,url,empty,list,assert,equals,2,check,files,exist,keys,server,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,job,jid,long,deadline,system,current,time,millis,30000,do,thread,sleep,500,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,keys,server,false,try,server,get,file,keys,get,0,fail,name,addressable,blob,should,have,been,deleted,catch,ioexception,e,try,server,get,file,keys,get,1,fail,name,addressable,blob,should,have,been,deleted,catch,ioexception,e,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1502701584;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			_			JobID jobId = null___			keys.add(bc.put(jobId, buf))__			buf[0] += 1__			keys.add(bc.put(jobId, buf))___			bc.close()___			long cleanupInterval = 1000L__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerJob(jid, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(jobId, keys, server, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterJob(jid)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(500)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_					System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(jobId, keys, server, false))___			try {_				if (jobId == null) {_					server.getFile(keys.get(0))__				} else {_					server.getFile(jobId, keys.get(0))__				}_				fail("BLOB should have been deleted")__			} catch (IOException e) {_				_			}_			try {_				if (jobId == null) {_					server.getFile(keys.get(1))__				} else {_					server.getFile(jobId, keys.get(1))__				}_				fail("BLOB should have been deleted")__			} catch (IOException e) {_				_			}_		}_		catch (Exception e) {_			e.printStackTrace()__			fail(e.getMessage())__		}_		finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,job,id,job,id,null,keys,add,bc,put,job,id,buf,buf,0,1,keys,add,bc,put,job,id,buf,bc,close,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,job,jid,keys,collections,url,empty,list,assert,equals,2,check,files,exist,job,id,keys,server,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,job,jid,long,deadline,system,current,time,millis,30000,do,thread,sleep,500,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,job,id,keys,server,false,try,if,job,id,null,server,get,file,keys,get,0,else,server,get,file,job,id,keys,get,0,fail,blob,should,have,been,deleted,catch,ioexception,e,try,if,job,id,null,server,get,file,keys,get,1,else,server,get,file,job,id,keys,get,1,fail,blob,should,have,been,deleted,catch,ioexception,e,catch,exception,e,e,print,stack,trace,fail,e,get,message,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1503041372;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()__		List<BlobKey> keys1 = new ArrayList<>()__		List<BlobKey> keys2 = new ArrayList<>()__		BlobServer server = null__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			BlobClient bc = new BlobClient(serverAddress, config)__			cache = new BlobCache(serverAddress, config, new VoidBlobStore())___			keys1.add(bc.put(jobId1, buf))__			buf[0] += 1__			keys1.add(bc.put(jobId1, buf))__			keys2.add(bc.put(jobId2, buf))___			bc.close()___			libCache = new BlobLibraryCacheManager(cache)__			cache.registerJob(jobId1)__			cache.registerJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(0, jobId1, cache)__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId1, keys1, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(0, checkFilesExist(jobId2, keys2, cache, false))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId2, keys2, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId2)__			assertNotEquals(classLoader1, classLoader2)___			try {_				libCache.registerJob(jobId2, keys1, Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerJob(_					jobId2, keys2,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(2, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,list,blob,key,keys1,new,array,list,list,blob,key,keys2,new,array,list,blob,server,server,null,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,blob,client,bc,new,blob,client,server,address,config,cache,new,blob,cache,server,address,config,new,void,blob,store,keys1,add,bc,put,job,id1,buf,buf,0,1,keys1,add,bc,put,job,id1,buf,keys2,add,bc,put,job,id2,buf,bc,close,lib,cache,new,blob,library,cache,manager,cache,cache,register,job,job,id1,cache,register,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,0,job,id1,cache,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id1,keys1,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,0,check,files,exist,job,id2,keys2,cache,false,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id2,keys2,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id2,assert,not,equals,class,loader1,class,loader2,try,lib,cache,register,job,job,id2,keys1,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,job,job,id2,keys2,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,2,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1505998908;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()__		List<BlobKey> keys1 = new ArrayList<>()__		List<BlobKey> keys2 = new ArrayList<>()__		BlobServer server = null__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			BlobClient bc = new BlobClient(serverAddress, config)__			cache = new BlobCache(serverAddress, config, new VoidBlobStore())___			keys1.add(bc.put(jobId1, buf))__			buf[0] += 1__			keys1.add(bc.put(jobId1, buf))__			keys2.add(bc.put(jobId2, buf))___			bc.close()___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId1)__			cache.registerJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(0, jobId1, cache)__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId1, keys1, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(0, checkFilesExist(jobId2, keys2, cache, false))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId2, keys2, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId2)__			assertNotEquals(classLoader1, classLoader2)___			try {_				libCache.registerJob(jobId2, keys1, Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerJob(_					jobId2, keys2,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(2, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,list,blob,key,keys1,new,array,list,list,blob,key,keys2,new,array,list,blob,server,server,null,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,blob,client,bc,new,blob,client,server,address,config,cache,new,blob,cache,server,address,config,new,void,blob,store,keys1,add,bc,put,job,id1,buf,buf,0,1,keys1,add,bc,put,job,id1,buf,keys2,add,bc,put,job,id2,buf,bc,close,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id1,cache,register,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,0,job,id1,cache,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id1,keys1,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,0,check,files,exist,job,id2,keys2,cache,false,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id2,keys2,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id2,assert,not,equals,class,loader1,class,loader2,try,lib,cache,register,job,job,id2,keys1,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,job,job,id2,keys2,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,2,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1507212387;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()__		List<BlobKey> keys1 = new ArrayList<>()__		List<BlobKey> keys2 = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys1.add(server.putHA(jobId1, buf))__			buf[0] += 1__			keys1.add(server.putHA(jobId1, buf))__			keys2.add(server.putHA(jobId2, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId1)__			cache.registerJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(0, jobId1, cache)__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId1, keys1, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(0, checkFilesExist(jobId2, keys2, cache, false))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId2, keys2, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId2)__			assertNotEquals(classLoader1, classLoader2)___			try {_				libCache.registerJob(jobId2, keys1, Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerJob(_					jobId2, keys2,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(2, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,list,blob,key,keys1,new,array,list,list,blob,key,keys2,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys1,add,server,put,ha,job,id1,buf,buf,0,1,keys1,add,server,put,ha,job,id1,buf,keys2,add,server,put,ha,job,id2,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id1,cache,register,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,0,job,id1,cache,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id1,keys1,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,0,check,files,exist,job,id2,keys2,cache,false,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id2,keys2,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id2,assert,not,equals,class,loader1,class,loader2,try,lib,cache,register,job,job,id2,keys1,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,job,job,id2,keys2,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,2,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1507212387;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()__		List<PermanentBlobKey> keys1 = new ArrayList<>()__		List<PermanentBlobKey> keys2 = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys1.add(server.putPermanent(jobId1, buf))__			buf[0] += 1__			keys1.add(server.putPermanent(jobId1, buf))__			keys2.add(server.putPermanent(jobId2, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId1)__			cache.registerJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(0, jobId1, cache)__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId1, keys1, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(0, checkFilesExist(jobId2, keys2, cache, false))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId2, keys2, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId2)__			assertNotEquals(classLoader1, classLoader2)___			try {_				libCache.registerJob(jobId2, keys1, Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerJob(_					jobId2, keys2,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(2, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,list,permanent,blob,key,keys1,new,array,list,list,permanent,blob,key,keys2,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys1,add,server,put,permanent,job,id1,buf,buf,0,1,keys1,add,server,put,permanent,job,id1,buf,keys2,add,server,put,permanent,job,id2,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id1,cache,register,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,0,job,id1,cache,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id1,keys1,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,0,check,files,exist,job,id2,keys2,cache,false,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id2,keys2,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id2,assert,not,equals,class,loader1,class,loader2,try,lib,cache,register,job,job,id2,keys1,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,job,job,id2,keys2,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,2,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1508578816;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()__		List<PermanentBlobKey> keys1 = new ArrayList<>()__		List<PermanentBlobKey> keys2 = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys1.add(server.putPermanent(jobId1, buf))__			buf[0] += 1__			keys1.add(server.putPermanent(jobId1, buf))__			keys2.add(server.putPermanent(jobId2, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId1)__			cache.registerJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(0, jobId1, cache)__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId1, keys1, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(0, checkFilesExist(jobId2, keys2, cache, false))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId2, keys2, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId2)__			assertNotEquals(classLoader1, classLoader2)___			try {_				libCache.registerJob(jobId2, keys1, Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerJob(_					jobId2, keys2,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(2, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,list,permanent,blob,key,keys1,new,array,list,list,permanent,blob,key,keys2,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys1,add,server,put,permanent,job,id1,buf,buf,0,1,keys1,add,server,put,permanent,job,id1,buf,keys2,add,server,put,permanent,job,id2,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id1,cache,register,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,0,job,id1,cache,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id1,keys1,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,0,check,files,exist,job,id2,keys2,cache,false,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id2,keys2,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id2,assert,not,equals,class,loader1,class,loader2,try,lib,cache,register,job,job,id2,keys1,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,job,job,id2,keys2,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,2,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1508939746;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()__		List<PermanentBlobKey> keys1 = new ArrayList<>()__		List<PermanentBlobKey> keys2 = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys1.add(server.putPermanent(jobId1, buf))__			buf[0] += 1__			keys1.add(server.putPermanent(jobId1, buf))__			keys2.add(server.putPermanent(jobId2, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0])__			cache.registerJob(jobId1)__			cache.registerJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(0, jobId1, cache)__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId1, keys1, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(0, checkFilesExist(jobId2, keys2, cache, false))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId2, keys2, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId2)__			assertNotEquals(classLoader1, classLoader2)___			try {_				libCache.registerJob(jobId2, keys1, Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerJob(_					jobId2, keys2,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(2, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,list,permanent,blob,key,keys1,new,array,list,list,permanent,blob,key,keys2,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys1,add,server,put,permanent,job,id1,buf,buf,0,1,keys1,add,server,put,permanent,job,id1,buf,keys2,add,server,put,permanent,job,id2,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,new,string,0,cache,register,job,job,id1,cache,register,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,0,job,id1,cache,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id1,keys1,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,0,check,files,exist,job,id2,keys2,cache,false,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id2,keys2,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id2,assert,not,equals,class,loader1,class,loader2,try,lib,cache,register,job,job,id2,keys1,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,job,job,id2,keys2,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,2,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException;1517915730;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterJob(JobID)}.;@Test_	public void testLibraryCacheManagerJobCleanup() throws IOException, InterruptedException {__		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()__		List<PermanentBlobKey> keys1 = new ArrayList<>()__		List<PermanentBlobKey> keys2 = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(config, new VoidBlobStore(), serverAddress)___			keys1.add(server.putPermanent(jobId1, buf))__			buf[0] += 1__			keys1.add(server.putPermanent(jobId1, buf))__			keys2.add(server.putPermanent(jobId2, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0])__			cache.registerJob(jobId1)__			cache.registerJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(0, jobId1, cache)__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId1, keys1, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(0, checkFilesExist(jobId2, keys2, cache, false))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(0, jobId2, cache)___			libCache.registerJob(jobId2, keys2, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId2)__			assertNotEquals(classLoader1, classLoader2)___			try {_				libCache.registerJob(jobId2, keys1, Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerJob(_					jobId2, keys2,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(2, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			libCache.unregisterJob(jobId2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId1))__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId2))__			assertEquals(2, checkFilesExist(jobId1, keys1, cache, true))__			checkFileCountForJob(2, jobId1, server)__			checkFileCountForJob(2, jobId1, cache)__			assertEquals(1, checkFilesExist(jobId2, keys2, cache, true))__			checkFileCountForJob(1, jobId2, server)__			checkFileCountForJob(1, jobId2, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,job,job,id;test,public,void,test,library,cache,manager,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,list,permanent,blob,key,keys1,new,array,list,list,permanent,blob,key,keys2,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,config,new,void,blob,store,server,address,keys1,add,server,put,permanent,job,id1,buf,buf,0,1,keys1,add,server,put,permanent,job,id1,buf,keys2,add,server,put,permanent,job,id2,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,new,string,0,cache,register,job,job,id1,cache,register,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,0,job,id1,cache,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id1,keys1,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,0,check,files,exist,job,id2,keys2,cache,false,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,0,job,id2,cache,lib,cache,register,job,job,id2,keys2,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id2,assert,not,equals,class,loader1,class,loader2,try,lib,cache,register,job,job,id2,keys1,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,job,job,id2,keys2,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,2,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,lib,cache,unregister,job,job,id2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id1,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id2,assert,equals,2,check,files,exist,job,id1,keys1,cache,true,check,file,count,for,job,2,job,id1,server,check,file,count,for,job,2,job,id1,cache,assert,equals,1,check,files,exist,job,id2,keys2,cache,true,check,file,count,for,job,1,job,id2,server,check,file,count,for,job,1,job,id2,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException;1503041372;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<>()__		BlobServer server = null__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			BlobClient bc = new BlobClient(serverAddress, config)__			cache = new BlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(bc.put(jobId, buf))__			buf[0] += 1__			keys.add(bc.put(jobId, buf))___			bc.close()___			libCache = new BlobLibraryCacheManager(cache)__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerJob(jobId, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.<BlobKey>emptyList(),_					Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterJob(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,mixed,job,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,server,server,null,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,blob,client,bc,new,blob,client,server,address,config,cache,new,blob,cache,server,address,config,new,void,blob,store,keys,add,bc,put,job,id,buf,buf,0,1,keys,add,bc,put,job,id,buf,bc,close,lib,cache,new,blob,library,cache,manager,cache,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,job,job,id,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,blob,key,empty,list,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,job,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException;1505998908;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<>()__		BlobServer server = null__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			BlobClient bc = new BlobClient(serverAddress, config)__			cache = new BlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(bc.put(jobId, buf))__			buf[0] += 1__			keys.add(bc.put(jobId, buf))___			bc.close()___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerJob(jobId, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.<BlobKey>emptyList(),_					Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterJob(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,mixed,job,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,server,server,null,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,blob,client,bc,new,blob,client,server,address,config,cache,new,blob,cache,server,address,config,new,void,blob,store,keys,add,bc,put,job,id,buf,buf,0,1,keys,add,bc,put,job,id,buf,bc,close,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,job,job,id,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,blob,key,empty,list,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,job,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException;1507212387;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(server.putHA(jobId, buf))__			buf[0] += 1__			keys.add(server.putHA(jobId, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerJob(jobId, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.<BlobKey>emptyList(),_					Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterJob(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,mixed,job,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,ha,job,id,buf,buf,0,1,keys,add,server,put,ha,job,id,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,job,job,id,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,blob,key,empty,list,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,job,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException;1507212387;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerJob(jobId, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.emptyList(),_					Collections.emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterJob(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,mixed,job,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,job,job,id,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,empty,list,collections,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,job,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException;1508578816;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerJob(jobId, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.emptyList(),_					Collections.emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterJob(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,mixed,job,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,job,job,id,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,empty,list,collections,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,job,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException;1508939746;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0])__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerJob(jobId, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.emptyList(),_					Collections.emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterJob(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,mixed,job,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,new,string,0,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,job,job,id,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,empty,list,collections,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,job,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException;1517915730;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerMixedJobTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(config, new VoidBlobStore(), serverAddress)___			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0])__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerJob(jobId, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.emptyList(),_					Collections.emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterJob(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,mixed,job,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,config,new,void,blob,store,server,address,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,new,string,0,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,job,job,id,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,empty,list,collections,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,job,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> private int checkFilesExist( 			List<BlobKey> keys, BlobLibraryCacheManager libraryCacheManager, boolean doThrow) 			throws IOException;1499173045;Checks how many of the files given by blob keys are accessible.__@param keys_blob keys to check_@param libraryCacheManager_cache manager to use_@param doThrow_whether exceptions should be ignored (<tt>false</tt>), or throws (<tt>true</tt>)__@return number of files we were able to retrieve via {@link BlobLibraryCacheManager#getFile(BlobKey)};private int checkFilesExist(_			List<BlobKey> keys, BlobLibraryCacheManager libraryCacheManager, boolean doThrow)_			throws IOException {_		int numFiles = 0___		for (BlobKey key : keys) {_			try {_				libraryCacheManager.getFile(key)__				++numFiles__			} catch (IOException e) {_				if (doThrow) {_					throw e__				}_			}_		}__		return numFiles__	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,keys,blob,keys,to,check,param,library,cache,manager,cache,manager,to,use,param,do,throw,whether,exceptions,should,be,ignored,tt,false,tt,or,throws,tt,true,tt,return,number,of,files,we,were,able,to,retrieve,via,link,blob,library,cache,manager,get,file,blob,key;private,int,check,files,exist,list,blob,key,keys,blob,library,cache,manager,library,cache,manager,boolean,do,throw,throws,ioexception,int,num,files,0,for,blob,key,key,keys,try,library,cache,manager,get,file,key,num,files,catch,ioexception,e,if,do,throw,throw,e,return,num,files
BlobLibraryCacheManagerTest -> private int checkFilesExist( 			List<BlobKey> keys, BlobLibraryCacheManager libraryCacheManager, boolean doThrow) 			throws IOException;1499789965;Checks how many of the files given by blob keys are accessible.__@param keys_blob keys to check_@param libraryCacheManager_cache manager to use_@param doThrow_whether exceptions should be ignored (<tt>false</tt>), or throws (<tt>true</tt>)__@return number of files we were able to retrieve via {@link BlobLibraryCacheManager#getFile(BlobKey)};private int checkFilesExist(_			List<BlobKey> keys, BlobLibraryCacheManager libraryCacheManager, boolean doThrow)_			throws IOException {_		int numFiles = 0___		for (BlobKey key : keys) {_			try {_				libraryCacheManager.getFile(key)__				++numFiles__			} catch (IOException e) {_				if (doThrow) {_					throw e__				}_			}_		}__		return numFiles__	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,keys,blob,keys,to,check,param,library,cache,manager,cache,manager,to,use,param,do,throw,whether,exceptions,should,be,ignored,tt,false,tt,or,throws,tt,true,tt,return,number,of,files,we,were,able,to,retrieve,via,link,blob,library,cache,manager,get,file,blob,key;private,int,check,files,exist,list,blob,key,keys,blob,library,cache,manager,library,cache,manager,boolean,do,throw,throws,ioexception,int,num,files,0,for,blob,key,key,keys,try,library,cache,manager,get,file,key,num,files,catch,ioexception,e,if,do,throw,throw,e,return,num,files
BlobLibraryCacheManagerTest -> private int checkFilesExist( 			List<BlobKey> keys, BlobLibraryCacheManager libraryCacheManager, boolean doThrow) 			throws IOException;1502100084;Checks how many of the files given by blob keys are accessible.__@param keys_blob keys to check_@param libraryCacheManager_cache manager to use_@param doThrow_whether exceptions should be ignored (<tt>false</tt>), or throws (<tt>true</tt>)__@return number of files we were able to retrieve via {@link BlobLibraryCacheManager#getFile(BlobKey)};private int checkFilesExist(_			List<BlobKey> keys, BlobLibraryCacheManager libraryCacheManager, boolean doThrow)_			throws IOException {_		int numFiles = 0___		for (BlobKey key : keys) {_			try {_				libraryCacheManager.getFile(key)__				++numFiles__			} catch (IOException e) {_				if (doThrow) {_					throw e__				}_			}_		}__		return numFiles__	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,keys,blob,keys,to,check,param,library,cache,manager,cache,manager,to,use,param,do,throw,whether,exceptions,should,be,ignored,tt,false,tt,or,throws,tt,true,tt,return,number,of,files,we,were,able,to,retrieve,via,link,blob,library,cache,manager,get,file,blob,key;private,int,check,files,exist,list,blob,key,keys,blob,library,cache,manager,library,cache,manager,boolean,do,throw,throws,ioexception,int,num,files,0,for,blob,key,key,keys,try,library,cache,manager,get,file,key,num,files,catch,ioexception,e,if,do,throw,throw,e,return,num,files
BlobLibraryCacheManagerTest -> private static int checkFilesExist( 		List<BlobKey> keys, BlobService blobService, boolean doThrow) 			throws IOException;1502201311;Checks how many of the files given by blob keys are accessible.__@param keys_blob keys to check_@param blobService_BLOB store to use_@param doThrow_whether exceptions should be ignored (<tt>false</tt>), or throws (<tt>true</tt>)__@return number of files we were able to retrieve via {@link BlobService#getURL(BlobKey)};private static int checkFilesExist(_		List<BlobKey> keys, BlobService blobService, boolean doThrow)_			throws IOException {_		int numFiles = 0___		for (BlobKey key : keys) {_			try {_				blobService.getURL(key)__				++numFiles__			} catch (IOException e) {_				if (doThrow) {_					throw e__				}_			}_		}__		return numFiles__	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,keys,blob,keys,to,check,param,blob,service,blob,store,to,use,param,do,throw,whether,exceptions,should,be,ignored,tt,false,tt,or,throws,tt,true,tt,return,number,of,files,we,were,able,to,retrieve,via,link,blob,service,get,url,blob,key;private,static,int,check,files,exist,list,blob,key,keys,blob,service,blob,service,boolean,do,throw,throws,ioexception,int,num,files,0,for,blob,key,key,keys,try,blob,service,get,url,key,num,files,catch,ioexception,e,if,do,throw,throw,e,return,num,files
BlobLibraryCacheManagerTest -> private static int checkFilesExist( 		List<BlobKey> keys, BlobService blobService, boolean doThrow) 			throws IOException;1502692653;Checks how many of the files given by blob keys are accessible.__@param keys_blob keys to check_@param blobService_BLOB store to use_@param doThrow_whether exceptions should be ignored (<tt>false</tt>), or throws (<tt>true</tt>)__@return number of files we were able to retrieve via {@link BlobService#getFile(BlobKey)};private static int checkFilesExist(_		List<BlobKey> keys, BlobService blobService, boolean doThrow)_			throws IOException {_		int numFiles = 0___		for (BlobKey key : keys) {_			try {_				blobService.getFile(key)__				++numFiles__			} catch (IOException e) {_				if (doThrow) {_					throw e__				}_			}_		}__		return numFiles__	};checks,how,many,of,the,files,given,by,blob,keys,are,accessible,param,keys,blob,keys,to,check,param,blob,service,blob,store,to,use,param,do,throw,whether,exceptions,should,be,ignored,tt,false,tt,or,throws,tt,true,tt,return,number,of,files,we,were,able,to,retrieve,via,link,blob,service,get,file,blob,key;private,static,int,check,files,exist,list,blob,key,keys,blob,service,blob,service,boolean,do,throw,throws,ioexception,int,num,files,0,for,blob,key,key,keys,try,blob,service,get,file,key,num,files,catch,ioexception,e,if,do,throw,throw,e,return,num,files
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1499173045;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		ExecutionAttemptID executionId1 = new ExecutionAttemptID()__		ExecutionAttemptID executionId2 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			keys.add(bc.put(buf))__			buf[0] += 1__			keys.add(bc.put(buf))__			bc.put(jid, "test", buf)___			long cleanupInterval = 1000l__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerTask(jid, executionId1, keys, Collections.<URL>emptyList())__			libraryCacheManager.registerTask(jid, executionId2, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(keys, libraryCacheManager, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(2, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId1)___			assertEquals(2, checkFilesExist(keys, libraryCacheManager, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId2)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(100)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_						System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(keys, libraryCacheManager, false))___			bc.close()__		} finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,execution,attempt,id,execution,id1,new,execution,attempt,id,execution,attempt,id,execution,id2,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,keys,add,bc,put,buf,buf,0,1,keys,add,bc,put,buf,bc,put,jid,test,buf,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,task,jid,execution,id1,keys,collections,url,empty,list,library,cache,manager,register,task,jid,execution,id2,keys,collections,url,empty,list,assert,equals,2,check,files,exist,keys,library,cache,manager,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,2,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id1,assert,equals,2,check,files,exist,keys,library,cache,manager,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id2,long,deadline,system,current,time,millis,30000,do,thread,sleep,100,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,keys,library,cache,manager,false,bc,close,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1499789965;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		ExecutionAttemptID executionId1 = new ExecutionAttemptID()__		ExecutionAttemptID executionId2 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			keys.add(bc.put(buf))__			buf[0] += 1__			keys.add(bc.put(buf))___			long cleanupInterval = 1000l__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerTask(jid, executionId1, keys, Collections.<URL>emptyList())__			libraryCacheManager.registerTask(jid, executionId2, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(keys, libraryCacheManager, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(2, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId1)___			assertEquals(2, checkFilesExist(keys, libraryCacheManager, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId2)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(100)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_						System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(keys, libraryCacheManager, false))___			bc.close()__		} finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,execution,attempt,id,execution,id1,new,execution,attempt,id,execution,attempt,id,execution,id2,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,keys,add,bc,put,buf,buf,0,1,keys,add,bc,put,buf,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,task,jid,execution,id1,keys,collections,url,empty,list,library,cache,manager,register,task,jid,execution,id2,keys,collections,url,empty,list,assert,equals,2,check,files,exist,keys,library,cache,manager,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,2,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id1,assert,equals,2,check,files,exist,keys,library,cache,manager,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id2,long,deadline,system,current,time,millis,30000,do,thread,sleep,100,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,keys,library,cache,manager,false,bc,close,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1502100084;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		ExecutionAttemptID executionId1 = new ExecutionAttemptID()__		ExecutionAttemptID executionId2 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			keys.add(bc.put(buf))__			buf[0] += 1__			keys.add(bc.put(buf))___			long cleanupInterval = 1000l__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerTask(jid, executionId1, keys, Collections.<URL>emptyList())__			libraryCacheManager.registerTask(jid, executionId2, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(keys, libraryCacheManager, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(2, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId1)___			assertEquals(2, checkFilesExist(keys, libraryCacheManager, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId2)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(100)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_						System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(keys, libraryCacheManager, false))___			bc.close()__		} finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,execution,attempt,id,execution,id1,new,execution,attempt,id,execution,attempt,id,execution,id2,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,keys,add,bc,put,buf,buf,0,1,keys,add,bc,put,buf,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,task,jid,execution,id1,keys,collections,url,empty,list,library,cache,manager,register,task,jid,execution,id2,keys,collections,url,empty,list,assert,equals,2,check,files,exist,keys,library,cache,manager,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,2,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id1,assert,equals,2,check,files,exist,keys,library,cache,manager,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id2,long,deadline,system,current,time,millis,30000,do,thread,sleep,100,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,keys,library,cache,manager,false,bc,close,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1502201311;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		ExecutionAttemptID executionId1 = new ExecutionAttemptID()__		ExecutionAttemptID executionId2 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			keys.add(bc.put(buf))__			buf[0] += 1__			keys.add(bc.put(buf))___			long cleanupInterval = 1000l__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerTask(jid, executionId1, keys, Collections.<URL>emptyList())__			libraryCacheManager.registerTask(jid, executionId2, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(keys, server, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(2, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId1)___			assertEquals(2, checkFilesExist(keys, server, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId2)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(100)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_						System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(keys, server, false))___			bc.close()__		} finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,execution,attempt,id,execution,id1,new,execution,attempt,id,execution,attempt,id,execution,id2,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,keys,add,bc,put,buf,buf,0,1,keys,add,bc,put,buf,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,task,jid,execution,id1,keys,collections,url,empty,list,library,cache,manager,register,task,jid,execution,id2,keys,collections,url,empty,list,assert,equals,2,check,files,exist,keys,server,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,2,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id1,assert,equals,2,check,files,exist,keys,server,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id2,long,deadline,system,current,time,millis,30000,do,thread,sleep,100,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,keys,server,false,bc,close,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1502692653;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		ExecutionAttemptID executionId1 = new ExecutionAttemptID()__		ExecutionAttemptID executionId2 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			keys.add(bc.put(buf))__			buf[0] += 1__			keys.add(bc.put(buf))___			long cleanupInterval = 1000l__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerTask(jid, executionId1, keys, Collections.<URL>emptyList())__			libraryCacheManager.registerTask(jid, executionId2, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(keys, server, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(2, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId1)___			assertEquals(2, checkFilesExist(keys, server, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId2)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(100)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_						System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(keys, server, false))___			bc.close()__		} finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,execution,attempt,id,execution,id1,new,execution,attempt,id,execution,attempt,id,execution,id2,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,keys,add,bc,put,buf,buf,0,1,keys,add,bc,put,buf,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,task,jid,execution,id1,keys,collections,url,empty,list,library,cache,manager,register,task,jid,execution,id2,keys,collections,url,empty,list,assert,equals,2,check,files,exist,keys,server,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,2,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id1,assert,equals,2,check,files,exist,keys,server,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id2,long,deadline,system,current,time,millis,30000,do,thread,sleep,100,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,keys,server,false,bc,close,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1502701584;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jid = new JobID()__		ExecutionAttemptID executionId1 = new ExecutionAttemptID()__		ExecutionAttemptID executionId2 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<BlobKey>()__		BlobServer server = null__		BlobLibraryCacheManager libraryCacheManager = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress blobSocketAddress = new InetSocketAddress(server.getPort())__			BlobClient bc = new BlobClient(blobSocketAddress, config)___			__			JobID jobId = null___			keys.add(bc.put(jobId, buf))__			buf[0] += 1__			keys.add(bc.put(jobId, buf))___			long cleanupInterval = 1000L__			libraryCacheManager = new BlobLibraryCacheManager(server, cleanupInterval)__			libraryCacheManager.registerTask(jid, executionId1, keys, Collections.<URL>emptyList())__			libraryCacheManager.registerTask(jid, executionId2, keys, Collections.<URL>emptyList())___			assertEquals(2, checkFilesExist(jobId, keys, server, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(2, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId1)___			assertEquals(2, checkFilesExist(jobId, keys, server, true))__			assertEquals(2, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(1, libraryCacheManager.getNumberOfReferenceHolders(jid))___			libraryCacheManager.unregisterTask(jid, executionId2)___			_			_			{_				long deadline = System.currentTimeMillis() + 30000__				do {_					Thread.sleep(100)__				}_				while (libraryCacheManager.getNumberOfCachedLibraries() > 0 &&_						System.currentTimeMillis() < deadline)__			}__			_			assertEquals(0, libraryCacheManager.getNumberOfCachedLibraries())__			assertEquals(0, libraryCacheManager.getNumberOfReferenceHolders(jid))___			_			assertEquals(0, checkFilesExist(jobId, keys, server, false))___			bc.close()__		} finally {_			if (server != null) {_				server.close()__			}__			if (libraryCacheManager != null) {_				try {_					libraryCacheManager.shutdown()__				}_				catch (IOException e) {_					e.printStackTrace()__				}_			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,jid,new,job,id,execution,attempt,id,execution,id1,new,execution,attempt,id,execution,attempt,id,execution,id2,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,key,blob,server,server,null,blob,library,cache,manager,library,cache,manager,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,server,new,blob,server,config,new,void,blob,store,inet,socket,address,blob,socket,address,new,inet,socket,address,server,get,port,blob,client,bc,new,blob,client,blob,socket,address,config,job,id,job,id,null,keys,add,bc,put,job,id,buf,buf,0,1,keys,add,bc,put,job,id,buf,long,cleanup,interval,1000l,library,cache,manager,new,blob,library,cache,manager,server,cleanup,interval,library,cache,manager,register,task,jid,execution,id1,keys,collections,url,empty,list,library,cache,manager,register,task,jid,execution,id2,keys,collections,url,empty,list,assert,equals,2,check,files,exist,job,id,keys,server,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,2,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id1,assert,equals,2,check,files,exist,job,id,keys,server,true,assert,equals,2,library,cache,manager,get,number,of,cached,libraries,assert,equals,1,library,cache,manager,get,number,of,reference,holders,jid,library,cache,manager,unregister,task,jid,execution,id2,long,deadline,system,current,time,millis,30000,do,thread,sleep,100,while,library,cache,manager,get,number,of,cached,libraries,0,system,current,time,millis,deadline,assert,equals,0,library,cache,manager,get,number,of,cached,libraries,assert,equals,0,library,cache,manager,get,number,of,reference,holders,jid,assert,equals,0,check,files,exist,job,id,keys,server,false,bc,close,finally,if,server,null,server,close,if,library,cache,manager,null,try,library,cache,manager,shutdown,catch,ioexception,e,e,print,stack,trace
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1503041372;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		ExecutionAttemptID attempt2 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<>()__		BlobServer server = null__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			BlobClient bc = new BlobClient(serverAddress, config)__			cache = new BlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(bc.put(jobId, buf))__			buf[0] += 1__			keys.add(bc.put(jobId, buf))___			bc.close()___			libCache = new BlobLibraryCacheManager(cache)__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt2, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.<BlobKey>emptyList(),_					Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,execution,attempt,id,attempt2,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,server,server,null,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,blob,client,bc,new,blob,client,server,address,config,cache,new,blob,cache,server,address,config,new,void,blob,store,keys,add,bc,put,job,id,buf,buf,0,1,keys,add,bc,put,job,id,buf,bc,close,lib,cache,new,blob,library,cache,manager,cache,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt2,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,blob,key,empty,list,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1505998908;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		ExecutionAttemptID attempt2 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<>()__		BlobServer server = null__		BlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			BlobClient bc = new BlobClient(serverAddress, config)__			cache = new BlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(bc.put(jobId, buf))__			buf[0] += 1__			keys.add(bc.put(jobId, buf))___			bc.close()___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt2, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.<BlobKey>emptyList(),_					Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,execution,attempt,id,attempt2,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,server,server,null,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,blob,client,bc,new,blob,client,server,address,config,cache,new,blob,cache,server,address,config,new,void,blob,store,keys,add,bc,put,job,id,buf,buf,0,1,keys,add,bc,put,job,id,buf,bc,close,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt2,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,blob,key,empty,list,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1507212387;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		ExecutionAttemptID attempt2 = new ExecutionAttemptID()__		List<BlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(server.putHA(jobId, buf))__			buf[0] += 1__			keys.add(server.putHA(jobId, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt2, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.<BlobKey>emptyList(),_					Collections.<URL>emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,execution,attempt,id,attempt2,new,execution,attempt,id,list,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,ha,job,id,buf,buf,0,1,keys,add,server,put,ha,job,id,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt2,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,blob,key,empty,list,collections,url,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1507212387;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		ExecutionAttemptID attempt2 = new ExecutionAttemptID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt2, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.emptyList(),_					Collections.emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,execution,attempt,id,attempt2,new,execution,attempt,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt2,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,empty,list,collections,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1508578816;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		ExecutionAttemptID attempt2 = new ExecutionAttemptID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST)__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt2, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.emptyList(),_					Collections.emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,execution,attempt,id,attempt2,new,execution,attempt,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt2,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,empty,list,collections,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1508939746;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		ExecutionAttemptID attempt2 = new ExecutionAttemptID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(serverAddress, config, new VoidBlobStore())___			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0])__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt2, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.emptyList(),_					Collections.emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,execution,attempt,id,attempt2,new,execution,attempt,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,server,address,config,new,void,blob,store,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,new,string,0,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt2,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,empty,list,collections,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
BlobLibraryCacheManagerTest -> @Test 	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException;1517915730;Tests that the {@link BlobLibraryCacheManager} cleans up after calling {@link_BlobLibraryCacheManager#unregisterTask(JobID, ExecutionAttemptID)}.;@Test_	public void testLibraryCacheManagerTaskCleanup() throws IOException, InterruptedException {__		JobID jobId = new JobID()__		ExecutionAttemptID attempt1 = new ExecutionAttemptID()__		ExecutionAttemptID attempt2 = new ExecutionAttemptID()__		List<PermanentBlobKey> keys = new ArrayList<>()__		BlobServer server = null__		PermanentBlobCache cache = null__		BlobLibraryCacheManager libCache = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())__			config.setLong(BlobServerOptions.CLEANUP_INTERVAL, 1L)___			server = new BlobServer(config, new VoidBlobStore())__			server.start()__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			cache = new PermanentBlobCache(config, new VoidBlobStore(), serverAddress)___			keys.add(server.putPermanent(jobId, buf))__			buf[0] += 1__			keys.add(server.putPermanent(jobId, buf))___			libCache = new BlobLibraryCacheManager(cache, FlinkUserCodeClassLoaders.ResolveOrder.CHILD_FIRST, new String[0])__			cache.registerJob(jobId)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(0, jobId, cache)___			libCache.registerTask(jobId, attempt1, keys, Collections.<URL>emptyList())__			ClassLoader classLoader1 = libCache.getClassLoader(jobId)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.registerTask(jobId, attempt2, keys, Collections.<URL>emptyList())__			ClassLoader classLoader2 = libCache.getClassLoader(jobId)__			assertEquals(classLoader1, classLoader2)___			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), Collections.emptyList(),_					Collections.emptyList())__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			try {_				libCache.registerTask(_					jobId, new ExecutionAttemptID(), keys,_					Collections.singletonList(new URL("file:///tmp/does-not-exist")))__				fail("Should fail with an IllegalStateException")__			}_			catch (IllegalStateException e) {_				_			}__			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(2, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt1)___			assertEquals(1, libCache.getNumberOfManagedJobs())__			assertEquals(1, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			libCache.unregisterTask(jobId, attempt2)___			assertEquals(0, libCache.getNumberOfManagedJobs())__			assertEquals(0, libCache.getNumberOfReferenceHolders(jobId))__			assertEquals(2, checkFilesExist(jobId, keys, cache, true))__			checkFileCountForJob(2, jobId, server)__			checkFileCountForJob(2, jobId, cache)___			_		}_		finally {_			if (libCache != null) {_				libCache.shutdown()__			}__			_			if (cache != null) {_				cache.close()__			}__			if (server != null) {_				server.close()__			}_		}_	};tests,that,the,link,blob,library,cache,manager,cleans,up,after,calling,link,blob,library,cache,manager,unregister,task,job,id,execution,attempt,id;test,public,void,test,library,cache,manager,task,cleanup,throws,ioexception,interrupted,exception,job,id,job,id,new,job,id,execution,attempt,id,attempt1,new,execution,attempt,id,execution,attempt,id,attempt2,new,execution,attempt,id,list,permanent,blob,key,keys,new,array,list,blob,server,server,null,permanent,blob,cache,cache,null,blob,library,cache,manager,lib,cache,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,config,set,long,blob,server,options,1l,server,new,blob,server,config,new,void,blob,store,server,start,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,cache,new,permanent,blob,cache,config,new,void,blob,store,server,address,keys,add,server,put,permanent,job,id,buf,buf,0,1,keys,add,server,put,permanent,job,id,buf,lib,cache,new,blob,library,cache,manager,cache,flink,user,code,class,loaders,resolve,order,new,string,0,cache,register,job,job,id,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,check,file,count,for,job,2,job,id,server,check,file,count,for,job,0,job,id,cache,lib,cache,register,task,job,id,attempt1,keys,collections,url,empty,list,class,loader,class,loader1,lib,cache,get,class,loader,job,id,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,register,task,job,id,attempt2,keys,collections,url,empty,list,class,loader,class,loader2,lib,cache,get,class,loader,job,id,assert,equals,class,loader1,class,loader2,try,lib,cache,register,task,job,id,new,execution,attempt,id,collections,empty,list,collections,empty,list,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,try,lib,cache,register,task,job,id,new,execution,attempt,id,keys,collections,singleton,list,new,url,file,tmp,does,not,exist,fail,should,fail,with,an,illegal,state,exception,catch,illegal,state,exception,e,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,2,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt1,assert,equals,1,lib,cache,get,number,of,managed,jobs,assert,equals,1,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,lib,cache,unregister,task,job,id,attempt2,assert,equals,0,lib,cache,get,number,of,managed,jobs,assert,equals,0,lib,cache,get,number,of,reference,holders,job,id,assert,equals,2,check,files,exist,job,id,keys,cache,true,check,file,count,for,job,2,job,id,server,check,file,count,for,job,2,job,id,cache,finally,if,lib,cache,null,lib,cache,shutdown,if,cache,null,cache,close,if,server,null,server,close
