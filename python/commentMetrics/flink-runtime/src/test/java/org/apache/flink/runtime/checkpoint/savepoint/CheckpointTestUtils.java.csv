# id;timestamp;commentText;codeText;commentWords;codeWords
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1493403095;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<OperatorState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			OperatorState taskState = new OperatorState(new OperatorID(), numSubtasksPerTask, 128)___			boolean hasNonPartitionableState = random.nextBoolean()__			boolean hasOperatorStateBackend = random.nextBoolean()__			boolean hasOperatorStateStream = random.nextBoolean()___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				StreamStateHandle nonPartitionableState = null__				StreamStateHandle operatorStateBackend =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))__				StreamStateHandle operatorStateStream =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))___				OperatorStateHandle operatorStateHandleBackend = null__				OperatorStateHandle operatorStateHandleStream = null__				_				Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__				offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___				if (hasNonPartitionableState) {_					nonPartitionableState =_						new TestByteStreamStateHandleDeepCompare("a", ("Hi").getBytes(ConfigConstants.DEFAULT_CHARSET))__				}__				if (hasOperatorStateBackend) {_					operatorStateHandleBackend = new OperatorStateHandle(offsetsMap, operatorStateBackend)__				}__				if (hasOperatorStateStream) {_					operatorStateHandleStream = new OperatorStateHandle(offsetsMap, operatorStateStream)__				}__				KeyGroupsStateHandle keyedStateBackend = null__				KeyGroupsStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					keyedStateBackend = new KeyGroupsStateHandle(_							new KeyGroupRangeOffsets(1, 1, new long[]{42}),_							new TestByteStreamStateHandleDeepCompare("c", "Hello"_									.getBytes(ConfigConstants.DEFAULT_CHARSET)))__				}__				if (hasKeyedStream) {_					keyedStateStream = new KeyGroupsStateHandle(_							new KeyGroupRangeOffsets(1, 1, new long[]{23}),_							new TestByteStreamStateHandleDeepCompare("d", "World"_									.getBytes(ConfigConstants.DEFAULT_CHARSET)))__				}__				taskState.putState(subtaskIdx, new OperatorSubtaskState(_						nonPartitionableState,_						operatorStateHandleBackend,_						operatorStateHandleStream,_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,operator,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,operator,state,task,state,new,operator,state,new,operator,id,num,subtasks,per,task,128,boolean,has,non,partitionable,state,random,next,boolean,boolean,has,operator,state,backend,random,next,boolean,boolean,has,operator,state,stream,random,next,boolean,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,stream,state,handle,non,partitionable,state,null,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,operator,state,handle,operator,state,handle,backend,null,operator,state,handle,operator,state,handle,stream,null,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,has,non,partitionable,state,non,partitionable,state,new,test,byte,stream,state,handle,deep,compare,a,hi,get,bytes,config,constants,if,has,operator,state,backend,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,if,has,operator,state,stream,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,key,groups,state,handle,keyed,state,backend,null,key,groups,state,handle,keyed,state,stream,null,if,has,keyed,backend,keyed,state,backend,new,key,groups,state,handle,new,key,group,range,offsets,1,1,new,long,42,new,test,byte,stream,state,handle,deep,compare,c,hello,get,bytes,config,constants,if,has,keyed,stream,keyed,state,stream,new,key,groups,state,handle,new,key,group,range,offsets,1,1,new,long,23,new,test,byte,stream,state,handle,deep,compare,d,world,get,bytes,config,constants,task,state,put,state,subtask,idx,new,operator,subtask,state,non,partitionable,state,operator,state,handle,backend,operator,state,handle,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1494762590;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<OperatorState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			OperatorState taskState = new OperatorState(new OperatorID(), numSubtasksPerTask, 128)___			boolean hasNonPartitionableState = random.nextBoolean()__			boolean hasOperatorStateBackend = random.nextBoolean()__			boolean hasOperatorStateStream = random.nextBoolean()___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0__			boolean isIncremental = random.nextInt(3) == 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				StreamStateHandle nonPartitionableState = null__				StreamStateHandle operatorStateBackend =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))__				StreamStateHandle operatorStateStream =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))___				OperatorStateHandle operatorStateHandleBackend = null__				OperatorStateHandle operatorStateHandleStream = null__				_				Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__				offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___				if (hasNonPartitionableState) {_					nonPartitionableState =_						new TestByteStreamStateHandleDeepCompare("a", ("Hi").getBytes(ConfigConstants.DEFAULT_CHARSET))__				}__				if (hasOperatorStateBackend) {_					operatorStateHandleBackend = new OperatorStateHandle(offsetsMap, operatorStateBackend)__				}__				if (hasOperatorStateStream) {_					operatorStateHandleStream = new OperatorStateHandle(offsetsMap, operatorStateStream)__				}__				KeyedStateHandle keyedStateBackend = null__				KeyedStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					if (isIncremental) {_						keyedStateBackend = createDummyIncrementalKeyedStateHandle(random)__					} else {_						keyedStateBackend = createDummyKeyGroupStateHandle(random)__					}_				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new OperatorSubtaskState(_						nonPartitionableState,_						operatorStateHandleBackend,_						operatorStateHandleStream,_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,operator,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,operator,state,task,state,new,operator,state,new,operator,id,num,subtasks,per,task,128,boolean,has,non,partitionable,state,random,next,boolean,boolean,has,operator,state,backend,random,next,boolean,boolean,has,operator,state,stream,random,next,boolean,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,boolean,is,incremental,random,next,int,3,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,stream,state,handle,non,partitionable,state,null,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,operator,state,handle,operator,state,handle,backend,null,operator,state,handle,operator,state,handle,stream,null,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,has,non,partitionable,state,non,partitionable,state,new,test,byte,stream,state,handle,deep,compare,a,hi,get,bytes,config,constants,if,has,operator,state,backend,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,if,has,operator,state,stream,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,keyed,state,handle,keyed,state,backend,null,keyed,state,handle,keyed,state,stream,null,if,has,keyed,backend,if,is,incremental,keyed,state,backend,create,dummy,incremental,keyed,state,handle,random,else,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,operator,subtask,state,non,partitionable,state,operator,state,handle,backend,operator,state,handle,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1495184252;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<OperatorState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			OperatorState taskState = new OperatorState(new OperatorID(), numSubtasksPerTask, 128)___			boolean hasNonPartitionableState = random.nextBoolean()__			boolean hasOperatorStateBackend = random.nextBoolean()__			boolean hasOperatorStateStream = random.nextBoolean()___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0__			boolean isIncremental = random.nextInt(3) == 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				StreamStateHandle nonPartitionableState = null__				StreamStateHandle operatorStateBackend =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))__				StreamStateHandle operatorStateStream =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))___				OperatorStateHandle operatorStateHandleBackend = null__				OperatorStateHandle operatorStateHandleStream = null__				_				Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__				offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___				if (hasNonPartitionableState) {_					nonPartitionableState =_						new TestByteStreamStateHandleDeepCompare("a", ("Hi").getBytes(ConfigConstants.DEFAULT_CHARSET))__				}__				if (hasOperatorStateBackend) {_					operatorStateHandleBackend = new OperatorStateHandle(offsetsMap, operatorStateBackend)__				}__				if (hasOperatorStateStream) {_					operatorStateHandleStream = new OperatorStateHandle(offsetsMap, operatorStateStream)__				}__				KeyedStateHandle keyedStateBackend = null__				KeyedStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					if (isIncremental) {_						keyedStateBackend = createDummyIncrementalKeyedStateHandle(random)__					} else {_						keyedStateBackend = createDummyKeyGroupStateHandle(random)__					}_				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new OperatorSubtaskState(_						nonPartitionableState,_						operatorStateHandleBackend,_						operatorStateHandleStream,_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,operator,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,operator,state,task,state,new,operator,state,new,operator,id,num,subtasks,per,task,128,boolean,has,non,partitionable,state,random,next,boolean,boolean,has,operator,state,backend,random,next,boolean,boolean,has,operator,state,stream,random,next,boolean,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,boolean,is,incremental,random,next,int,3,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,stream,state,handle,non,partitionable,state,null,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,operator,state,handle,operator,state,handle,backend,null,operator,state,handle,operator,state,handle,stream,null,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,has,non,partitionable,state,non,partitionable,state,new,test,byte,stream,state,handle,deep,compare,a,hi,get,bytes,config,constants,if,has,operator,state,backend,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,if,has,operator,state,stream,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,keyed,state,handle,keyed,state,backend,null,keyed,state,handle,keyed,state,stream,null,if,has,keyed,backend,if,is,incremental,keyed,state,backend,create,dummy,incremental,keyed,state,handle,random,else,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,operator,subtask,state,non,partitionable,state,operator,state,handle,backend,operator,state,handle,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1500040329;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<OperatorState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			OperatorState taskState = new OperatorState(new OperatorID(), numSubtasksPerTask, 128)___			boolean hasNonPartitionableState = random.nextBoolean()__			boolean hasOperatorStateBackend = random.nextBoolean()__			boolean hasOperatorStateStream = random.nextBoolean()___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0__			boolean isIncremental = random.nextInt(3) == 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				StreamStateHandle nonPartitionableState = null__				StreamStateHandle operatorStateBackend =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))__				StreamStateHandle operatorStateStream =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))___				OperatorStateHandle operatorStateHandleBackend = null__				OperatorStateHandle operatorStateHandleStream = null__				_				Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__				offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___				if (hasNonPartitionableState) {_					nonPartitionableState =_						new TestByteStreamStateHandleDeepCompare("a", ("Hi").getBytes(ConfigConstants.DEFAULT_CHARSET))__				}__				if (hasOperatorStateBackend) {_					operatorStateHandleBackend = new OperatorStateHandle(offsetsMap, operatorStateBackend)__				}__				if (hasOperatorStateStream) {_					operatorStateHandleStream = new OperatorStateHandle(offsetsMap, operatorStateStream)__				}__				KeyedStateHandle keyedStateBackend = null__				KeyedStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					if (isIncremental) {_						keyedStateBackend = createDummyIncrementalKeyedStateHandle(random)__					} else {_						keyedStateBackend = createDummyKeyGroupStateHandle(random)__					}_				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new OperatorSubtaskState(_						nonPartitionableState,_						operatorStateHandleBackend,_						operatorStateHandleStream,_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,operator,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,operator,state,task,state,new,operator,state,new,operator,id,num,subtasks,per,task,128,boolean,has,non,partitionable,state,random,next,boolean,boolean,has,operator,state,backend,random,next,boolean,boolean,has,operator,state,stream,random,next,boolean,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,boolean,is,incremental,random,next,int,3,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,stream,state,handle,non,partitionable,state,null,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,operator,state,handle,operator,state,handle,backend,null,operator,state,handle,operator,state,handle,stream,null,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,has,non,partitionable,state,non,partitionable,state,new,test,byte,stream,state,handle,deep,compare,a,hi,get,bytes,config,constants,if,has,operator,state,backend,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,if,has,operator,state,stream,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,keyed,state,handle,keyed,state,backend,null,keyed,state,handle,keyed,state,stream,null,if,has,keyed,backend,if,is,incremental,keyed,state,backend,create,dummy,incremental,keyed,state,handle,random,else,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,operator,subtask,state,non,partitionable,state,operator,state,handle,backend,operator,state,handle,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1503598628;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<OperatorState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			OperatorState taskState = new OperatorState(new OperatorID(), numSubtasksPerTask, 128)___			boolean hasOperatorStateBackend = random.nextBoolean()__			boolean hasOperatorStateStream = random.nextBoolean()___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0__			boolean isIncremental = random.nextInt(3) == 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				StreamStateHandle operatorStateBackend =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))__				StreamStateHandle operatorStateStream =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))___				OperatorStateHandle operatorStateHandleBackend = null__				OperatorStateHandle operatorStateHandleStream = null__				_				Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__				offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___				if (hasOperatorStateBackend) {_					operatorStateHandleBackend = new OperatorStateHandle(offsetsMap, operatorStateBackend)__				}__				if (hasOperatorStateStream) {_					operatorStateHandleStream = new OperatorStateHandle(offsetsMap, operatorStateStream)__				}__				KeyedStateHandle keyedStateBackend = null__				KeyedStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					if (isIncremental) {_						keyedStateBackend = createDummyIncrementalKeyedStateHandle(random)__					} else {_						keyedStateBackend = createDummyKeyGroupStateHandle(random)__					}_				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new OperatorSubtaskState(_						operatorStateHandleBackend,_						operatorStateHandleStream,_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,operator,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,operator,state,task,state,new,operator,state,new,operator,id,num,subtasks,per,task,128,boolean,has,operator,state,backend,random,next,boolean,boolean,has,operator,state,stream,random,next,boolean,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,boolean,is,incremental,random,next,int,3,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,operator,state,handle,operator,state,handle,backend,null,operator,state,handle,operator,state,handle,stream,null,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,has,operator,state,backend,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,if,has,operator,state,stream,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,keyed,state,handle,keyed,state,backend,null,keyed,state,handle,keyed,state,stream,null,if,has,keyed,backend,if,is,incremental,keyed,state,backend,create,dummy,incremental,keyed,state,handle,random,else,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,operator,subtask,state,operator,state,handle,backend,operator,state,handle,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1518008821;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<OperatorState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			OperatorState taskState = new OperatorState(new OperatorID(), numSubtasksPerTask, 128)___			boolean hasOperatorStateBackend = random.nextBoolean()__			boolean hasOperatorStateStream = random.nextBoolean()___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0__			boolean isIncremental = random.nextInt(3) == 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				StreamStateHandle operatorStateBackend =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))__				StreamStateHandle operatorStateStream =_					new TestByteStreamStateHandleDeepCompare("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))___				OperatorStateHandle operatorStateHandleBackend = null__				OperatorStateHandle operatorStateHandleStream = null__				_				Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__				offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.UNION))___				if (hasOperatorStateBackend) {_					operatorStateHandleBackend = new OperatorStateHandle(offsetsMap, operatorStateBackend)__				}__				if (hasOperatorStateStream) {_					operatorStateHandleStream = new OperatorStateHandle(offsetsMap, operatorStateStream)__				}__				KeyedStateHandle keyedStateBackend = null__				KeyedStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					if (isIncremental) {_						keyedStateBackend = createDummyIncrementalKeyedStateHandle(random)__					} else {_						keyedStateBackend = createDummyKeyGroupStateHandle(random)__					}_				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new OperatorSubtaskState(_						operatorStateHandleBackend,_						operatorStateHandleStream,_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,operator,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,operator,state,task,state,new,operator,state,new,operator,id,num,subtasks,per,task,128,boolean,has,operator,state,backend,random,next,boolean,boolean,has,operator,state,stream,random,next,boolean,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,boolean,is,incremental,random,next,int,3,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,beautiful,get,bytes,config,constants,operator,state,handle,operator,state,handle,backend,null,operator,state,handle,operator,state,handle,stream,null,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,union,if,has,operator,state,backend,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,if,has,operator,state,stream,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,keyed,state,handle,keyed,state,backend,null,keyed,state,handle,keyed,state,stream,null,if,has,keyed,backend,if,is,incremental,keyed,state,backend,create,dummy,incremental,keyed,state,handle,random,else,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,operator,subtask,state,operator,state,handle,backend,operator,state,handle,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1519568061;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<OperatorState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			OperatorState taskState = new OperatorState(new OperatorID(), numSubtasksPerTask, 128)___			boolean hasOperatorStateBackend = random.nextBoolean()__			boolean hasOperatorStateStream = random.nextBoolean()___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0__			boolean isIncremental = random.nextInt(3) == 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				StreamStateHandle operatorStateBackend =_					new ByteStreamStateHandle("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))__				StreamStateHandle operatorStateStream =_					new ByteStreamStateHandle("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))___				OperatorStateHandle operatorStateHandleBackend = null__				OperatorStateHandle operatorStateHandleStream = null__				_				Map<String, OperatorStateHandle.StateMetaInfo> offsetsMap = new HashMap<>()__				offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.UNION))___				if (hasOperatorStateBackend) {_					operatorStateHandleBackend = new OperatorStreamStateHandle(offsetsMap, operatorStateBackend)__				}__				if (hasOperatorStateStream) {_					operatorStateHandleStream = new OperatorStreamStateHandle(offsetsMap, operatorStateStream)__				}__				KeyedStateHandle keyedStateBackend = null__				KeyedStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					if (isIncremental) {_						keyedStateBackend = createDummyIncrementalKeyedStateHandle(random)__					} else {_						keyedStateBackend = createDummyKeyGroupStateHandle(random)__					}_				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new OperatorSubtaskState(_						operatorStateHandleBackend,_						operatorStateHandleStream,_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,operator,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,operator,state,task,state,new,operator,state,new,operator,id,num,subtasks,per,task,128,boolean,has,operator,state,backend,random,next,boolean,boolean,has,operator,state,stream,random,next,boolean,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,boolean,is,incremental,random,next,int,3,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,stream,state,handle,operator,state,backend,new,byte,stream,state,handle,b,beautiful,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,byte,stream,state,handle,b,beautiful,get,bytes,config,constants,operator,state,handle,operator,state,handle,backend,null,operator,state,handle,operator,state,handle,stream,null,map,string,operator,state,handle,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,union,if,has,operator,state,backend,operator,state,handle,backend,new,operator,stream,state,handle,offsets,map,operator,state,backend,if,has,operator,state,stream,operator,state,handle,stream,new,operator,stream,state,handle,offsets,map,operator,state,stream,keyed,state,handle,keyed,state,backend,null,keyed,state,handle,keyed,state,stream,null,if,has,keyed,backend,if,is,incremental,keyed,state,backend,create,dummy,incremental,keyed,state,handle,random,else,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,operator,subtask,state,operator,state,handle,backend,operator,state,handle,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1551262623;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<OperatorState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			OperatorState taskState = new OperatorState(new OperatorID(), numSubtasksPerTask, 128)___			boolean hasOperatorStateBackend = random.nextBoolean()__			boolean hasOperatorStateStream = random.nextBoolean()___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0__			boolean isIncremental = random.nextInt(3) == 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				StreamStateHandle operatorStateBackend =_					new ByteStreamStateHandle("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))__				StreamStateHandle operatorStateStream =_					new ByteStreamStateHandle("b", ("Beautiful").getBytes(ConfigConstants.DEFAULT_CHARSET))___				OperatorStateHandle operatorStateHandleBackend = null__				OperatorStateHandle operatorStateHandleStream = null__				_				Map<String, OperatorStateHandle.StateMetaInfo> offsetsMap = new HashMap<>()__				offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__				offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.UNION))___				if (hasOperatorStateBackend) {_					operatorStateHandleBackend = new OperatorStreamStateHandle(offsetsMap, operatorStateBackend)__				}__				if (hasOperatorStateStream) {_					operatorStateHandleStream = new OperatorStreamStateHandle(offsetsMap, operatorStateStream)__				}__				KeyedStateHandle keyedStateBackend = null__				KeyedStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					if (isIncremental) {_						keyedStateBackend = createDummyIncrementalKeyedStateHandle(random)__					} else {_						keyedStateBackend = createDummyKeyGroupStateHandle(random)__					}_				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new OperatorSubtaskState(_						operatorStateHandleBackend,_						operatorStateHandleStream,_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,operator,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,operator,state,task,state,new,operator,state,new,operator,id,num,subtasks,per,task,128,boolean,has,operator,state,backend,random,next,boolean,boolean,has,operator,state,stream,random,next,boolean,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,boolean,is,incremental,random,next,int,3,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,stream,state,handle,operator,state,backend,new,byte,stream,state,handle,b,beautiful,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,byte,stream,state,handle,b,beautiful,get,bytes,config,constants,operator,state,handle,operator,state,handle,backend,null,operator,state,handle,operator,state,handle,stream,null,map,string,operator,state,handle,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,union,if,has,operator,state,backend,operator,state,handle,backend,new,operator,stream,state,handle,offsets,map,operator,state,backend,if,has,operator,state,stream,operator,state,handle,stream,new,operator,stream,state,handle,offsets,map,operator,state,stream,keyed,state,handle,keyed,state,backend,null,keyed,state,handle,keyed,state,stream,null,if,has,keyed,backend,if,is,incremental,keyed,state,backend,create,dummy,incremental,keyed,state,handle,random,else,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,operator,subtask,state,operator,state,handle,backend,operator,state,handle,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static void assertMasterStateEquality(MasterState a, MasterState b);1493236605;Asserts that two MasterStates are equal.__<p>The MasterState avoids overriding {@code equals()} on purpose, because equality is not well_defined in the raw contents.;public static void assertMasterStateEquality(MasterState a, MasterState b) {_		assertEquals(a.version(), b.version())__		assertEquals(a.name(), b.name())__		assertArrayEquals(a.bytes(), b.bytes())___	};asserts,that,two,master,states,are,equal,p,the,master,state,avoids,overriding,code,equals,on,purpose,because,equality,is,not,well,defined,in,the,raw,contents;public,static,void,assert,master,state,equality,master,state,a,master,state,b,assert,equals,a,version,b,version,assert,equals,a,name,b,name,assert,array,equals,a,bytes,b,bytes
CheckpointTestUtils -> public static void assertMasterStateEquality(MasterState a, MasterState b);1493403095;Asserts that two MasterStates are equal.__<p>The MasterState avoids overriding {@code equals()} on purpose, because equality is not well_defined in the raw contents.;public static void assertMasterStateEquality(MasterState a, MasterState b) {_		assertEquals(a.version(), b.version())__		assertEquals(a.name(), b.name())__		assertArrayEquals(a.bytes(), b.bytes())___	};asserts,that,two,master,states,are,equal,p,the,master,state,avoids,overriding,code,equals,on,purpose,because,equality,is,not,well,defined,in,the,raw,contents;public,static,void,assert,master,state,equality,master,state,a,master,state,b,assert,equals,a,version,b,version,assert,equals,a,name,b,name,assert,array,equals,a,bytes,b,bytes
CheckpointTestUtils -> public static void assertMasterStateEquality(MasterState a, MasterState b);1494762590;Asserts that two MasterStates are equal.__<p>The MasterState avoids overriding {@code equals()} on purpose, because equality is not well_defined in the raw contents.;public static void assertMasterStateEquality(MasterState a, MasterState b) {_		assertEquals(a.version(), b.version())__		assertEquals(a.name(), b.name())__		assertArrayEquals(a.bytes(), b.bytes())___	};asserts,that,two,master,states,are,equal,p,the,master,state,avoids,overriding,code,equals,on,purpose,because,equality,is,not,well,defined,in,the,raw,contents;public,static,void,assert,master,state,equality,master,state,a,master,state,b,assert,equals,a,version,b,version,assert,equals,a,name,b,name,assert,array,equals,a,bytes,b,bytes
CheckpointTestUtils -> public static void assertMasterStateEquality(MasterState a, MasterState b);1495184252;Asserts that two MasterStates are equal.__<p>The MasterState avoids overriding {@code equals()} on purpose, because equality is not well_defined in the raw contents.;public static void assertMasterStateEquality(MasterState a, MasterState b) {_		assertEquals(a.version(), b.version())__		assertEquals(a.name(), b.name())__		assertArrayEquals(a.bytes(), b.bytes())___	};asserts,that,two,master,states,are,equal,p,the,master,state,avoids,overriding,code,equals,on,purpose,because,equality,is,not,well,defined,in,the,raw,contents;public,static,void,assert,master,state,equality,master,state,a,master,state,b,assert,equals,a,version,b,version,assert,equals,a,name,b,name,assert,array,equals,a,bytes,b,bytes
CheckpointTestUtils -> public static void assertMasterStateEquality(MasterState a, MasterState b);1500040329;Asserts that two MasterStates are equal.__<p>The MasterState avoids overriding {@code equals()} on purpose, because equality is not well_defined in the raw contents.;public static void assertMasterStateEquality(MasterState a, MasterState b) {_		assertEquals(a.version(), b.version())__		assertEquals(a.name(), b.name())__		assertArrayEquals(a.bytes(), b.bytes())___	};asserts,that,two,master,states,are,equal,p,the,master,state,avoids,overriding,code,equals,on,purpose,because,equality,is,not,well,defined,in,the,raw,contents;public,static,void,assert,master,state,equality,master,state,a,master,state,b,assert,equals,a,version,b,version,assert,equals,a,name,b,name,assert,array,equals,a,bytes,b,bytes
CheckpointTestUtils -> public static void assertMasterStateEquality(MasterState a, MasterState b);1503598628;Asserts that two MasterStates are equal.__<p>The MasterState avoids overriding {@code equals()} on purpose, because equality is not well_defined in the raw contents.;public static void assertMasterStateEquality(MasterState a, MasterState b) {_		assertEquals(a.version(), b.version())__		assertEquals(a.name(), b.name())__		assertArrayEquals(a.bytes(), b.bytes())___	};asserts,that,two,master,states,are,equal,p,the,master,state,avoids,overriding,code,equals,on,purpose,because,equality,is,not,well,defined,in,the,raw,contents;public,static,void,assert,master,state,equality,master,state,a,master,state,b,assert,equals,a,version,b,version,assert,equals,a,name,b,name,assert,array,equals,a,bytes,b,bytes
CheckpointTestUtils -> public static void assertMasterStateEquality(MasterState a, MasterState b);1518008821;Asserts that two MasterStates are equal.__<p>The MasterState avoids overriding {@code equals()} on purpose, because equality is not well_defined in the raw contents.;public static void assertMasterStateEquality(MasterState a, MasterState b) {_		assertEquals(a.version(), b.version())__		assertEquals(a.name(), b.name())__		assertArrayEquals(a.bytes(), b.bytes())___	};asserts,that,two,master,states,are,equal,p,the,master,state,avoids,overriding,code,equals,on,purpose,because,equality,is,not,well,defined,in,the,raw,contents;public,static,void,assert,master,state,equality,master,state,a,master,state,b,assert,equals,a,version,b,version,assert,equals,a,name,b,name,assert,array,equals,a,bytes,b,bytes
CheckpointTestUtils -> public static void assertMasterStateEquality(MasterState a, MasterState b);1519568061;Asserts that two MasterStates are equal.__<p>The MasterState avoids overriding {@code equals()} on purpose, because equality is not well_defined in the raw contents.;public static void assertMasterStateEquality(MasterState a, MasterState b) {_		assertEquals(a.version(), b.version())__		assertEquals(a.name(), b.name())__		assertArrayEquals(a.bytes(), b.bytes())___	};asserts,that,two,master,states,are,equal,p,the,master,state,avoids,overriding,code,equals,on,purpose,because,equality,is,not,well,defined,in,the,raw,contents;public,static,void,assert,master,state,equality,master,state,a,master,state,b,assert,equals,a,version,b,version,assert,equals,a,name,b,name,assert,array,equals,a,bytes,b,bytes
CheckpointTestUtils -> public static void assertMasterStateEquality(MasterState a, MasterState b);1551262623;Asserts that two MasterStates are equal.__<p>The MasterState avoids overriding {@code equals()} on purpose, because equality is not well_defined in the raw contents.;public static void assertMasterStateEquality(MasterState a, MasterState b) {_		assertEquals(a.version(), b.version())__		assertEquals(a.name(), b.name())__		assertArrayEquals(a.bytes(), b.bytes())___	};asserts,that,two,master,states,are,equal,p,the,master,state,avoids,overriding,code,equals,on,purpose,because,equality,is,not,well,defined,in,the,raw,contents;public,static,void,assert,master,state,equality,master,state,a,master,state,b,assert,equals,a,version,b,version,assert,equals,a,name,b,name,assert,array,equals,a,bytes,b,bytes
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask);1493236605;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask) {_		return createTaskStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,int,num,task,states,int,num,subtasks,per,task,return,create,task,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask);1493403095;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask) {_		return createTaskStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,int,num,task,states,int,num,subtasks,per,task,return,create,task,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask);1494762590;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask) {_		return createTaskStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,int,num,task,states,int,num,subtasks,per,task,return,create,task,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask);1495184252;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask) {_		return createTaskStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,int,num,task,states,int,num,subtasks,per,task,return,create,task,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask);1500040329;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask) {_		return createTaskStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,int,num,task,states,int,num,subtasks,per,task,return,create,task,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask);1503598628;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask) {_		return createTaskStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,int,num,task,states,int,num,subtasks,per,task,return,create,task,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask);1518008821;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask) {_		return createTaskStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,int,num,task,states,int,num,subtasks,per,task,return,create,task,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask);1519568061;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask) {_		return createTaskStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,int,num,task,states,int,num,subtasks,per,task,return,create,task,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask);1551262623;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(int numTaskStates, int numSubtasksPerTask) {_		return createTaskStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,int,num,task,states,int,num,subtasks,per,task,return,create,task,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask);1493403095;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask) {_		return createOperatorStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,int,num,task,states,int,num,subtasks,per,task,return,create,operator,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask);1494762590;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask) {_		return createOperatorStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,int,num,task,states,int,num,subtasks,per,task,return,create,operator,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask);1495184252;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask) {_		return createOperatorStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,int,num,task,states,int,num,subtasks,per,task,return,create,operator,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask);1500040329;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask) {_		return createOperatorStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,int,num,task,states,int,num,subtasks,per,task,return,create,operator,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask);1503598628;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask) {_		return createOperatorStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,int,num,task,states,int,num,subtasks,per,task,return,create,operator,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask);1518008821;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask) {_		return createOperatorStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,int,num,task,states,int,num,subtasks,per,task,return,create,operator,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask);1519568061;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask) {_		return createOperatorStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,int,num,task,states,int,num,subtasks,per,task,return,create,operator,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask);1551262623;Creates a random collection of OperatorState objects containing various types of state handles.;public static Collection<OperatorState> createOperatorStates(int numTaskStates, int numSubtasksPerTask) {_		return createOperatorStates(new Random(), numTaskStates, numSubtasksPerTask)__	};creates,a,random,collection,of,operator,state,objects,containing,various,types,of,state,handles;public,static,collection,operator,state,create,operator,states,int,num,task,states,int,num,subtasks,per,task,return,create,operator,states,new,random,num,task,states,num,subtasks,per,task
CheckpointTestUtils -> public static Collection<MasterState> createRandomMasterStates(Random random, int num);1493236605;Creates a bunch of random master states.;public static Collection<MasterState> createRandomMasterStates(Random random, int num) {_		final ArrayList<MasterState> states = new ArrayList<>(num)___		for (int i = 0_ i < num_ i++) {_			int version = random.nextInt(10)__			String name = StringUtils.getRandomString(random, 5, 500)__			byte[] bytes = new byte[random.nextInt(5000) + 1]__			random.nextBytes(bytes)___			states.add(new MasterState(name, bytes, version))__		}__		return states__	};creates,a,bunch,of,random,master,states;public,static,collection,master,state,create,random,master,states,random,random,int,num,final,array,list,master,state,states,new,array,list,num,for,int,i,0,i,num,i,int,version,random,next,int,10,string,name,string,utils,get,random,string,random,5,500,byte,bytes,new,byte,random,next,int,5000,1,random,next,bytes,bytes,states,add,new,master,state,name,bytes,version,return,states
CheckpointTestUtils -> public static Collection<MasterState> createRandomMasterStates(Random random, int num);1493403095;Creates a bunch of random master states.;public static Collection<MasterState> createRandomMasterStates(Random random, int num) {_		final ArrayList<MasterState> states = new ArrayList<>(num)___		for (int i = 0_ i < num_ i++) {_			int version = random.nextInt(10)__			String name = StringUtils.getRandomString(random, 5, 500)__			byte[] bytes = new byte[random.nextInt(5000) + 1]__			random.nextBytes(bytes)___			states.add(new MasterState(name, bytes, version))__		}__		return states__	};creates,a,bunch,of,random,master,states;public,static,collection,master,state,create,random,master,states,random,random,int,num,final,array,list,master,state,states,new,array,list,num,for,int,i,0,i,num,i,int,version,random,next,int,10,string,name,string,utils,get,random,string,random,5,500,byte,bytes,new,byte,random,next,int,5000,1,random,next,bytes,bytes,states,add,new,master,state,name,bytes,version,return,states
CheckpointTestUtils -> public static Collection<MasterState> createRandomMasterStates(Random random, int num);1494762590;Creates a bunch of random master states.;public static Collection<MasterState> createRandomMasterStates(Random random, int num) {_		final ArrayList<MasterState> states = new ArrayList<>(num)___		for (int i = 0_ i < num_ i++) {_			int version = random.nextInt(10)__			String name = StringUtils.getRandomString(random, 5, 500)__			byte[] bytes = new byte[random.nextInt(5000) + 1]__			random.nextBytes(bytes)___			states.add(new MasterState(name, bytes, version))__		}__		return states__	};creates,a,bunch,of,random,master,states;public,static,collection,master,state,create,random,master,states,random,random,int,num,final,array,list,master,state,states,new,array,list,num,for,int,i,0,i,num,i,int,version,random,next,int,10,string,name,string,utils,get,random,string,random,5,500,byte,bytes,new,byte,random,next,int,5000,1,random,next,bytes,bytes,states,add,new,master,state,name,bytes,version,return,states
CheckpointTestUtils -> public static Collection<MasterState> createRandomMasterStates(Random random, int num);1495184252;Creates a bunch of random master states.;public static Collection<MasterState> createRandomMasterStates(Random random, int num) {_		final ArrayList<MasterState> states = new ArrayList<>(num)___		for (int i = 0_ i < num_ i++) {_			int version = random.nextInt(10)__			String name = StringUtils.getRandomString(random, 5, 500)__			byte[] bytes = new byte[random.nextInt(5000) + 1]__			random.nextBytes(bytes)___			states.add(new MasterState(name, bytes, version))__		}__		return states__	};creates,a,bunch,of,random,master,states;public,static,collection,master,state,create,random,master,states,random,random,int,num,final,array,list,master,state,states,new,array,list,num,for,int,i,0,i,num,i,int,version,random,next,int,10,string,name,string,utils,get,random,string,random,5,500,byte,bytes,new,byte,random,next,int,5000,1,random,next,bytes,bytes,states,add,new,master,state,name,bytes,version,return,states
CheckpointTestUtils -> public static Collection<MasterState> createRandomMasterStates(Random random, int num);1500040329;Creates a bunch of random master states.;public static Collection<MasterState> createRandomMasterStates(Random random, int num) {_		final ArrayList<MasterState> states = new ArrayList<>(num)___		for (int i = 0_ i < num_ i++) {_			int version = random.nextInt(10)__			String name = StringUtils.getRandomString(random, 5, 500)__			byte[] bytes = new byte[random.nextInt(5000) + 1]__			random.nextBytes(bytes)___			states.add(new MasterState(name, bytes, version))__		}__		return states__	};creates,a,bunch,of,random,master,states;public,static,collection,master,state,create,random,master,states,random,random,int,num,final,array,list,master,state,states,new,array,list,num,for,int,i,0,i,num,i,int,version,random,next,int,10,string,name,string,utils,get,random,string,random,5,500,byte,bytes,new,byte,random,next,int,5000,1,random,next,bytes,bytes,states,add,new,master,state,name,bytes,version,return,states
CheckpointTestUtils -> public static Collection<MasterState> createRandomMasterStates(Random random, int num);1503598628;Creates a bunch of random master states.;public static Collection<MasterState> createRandomMasterStates(Random random, int num) {_		final ArrayList<MasterState> states = new ArrayList<>(num)___		for (int i = 0_ i < num_ i++) {_			int version = random.nextInt(10)__			String name = StringUtils.getRandomString(random, 5, 500)__			byte[] bytes = new byte[random.nextInt(5000) + 1]__			random.nextBytes(bytes)___			states.add(new MasterState(name, bytes, version))__		}__		return states__	};creates,a,bunch,of,random,master,states;public,static,collection,master,state,create,random,master,states,random,random,int,num,final,array,list,master,state,states,new,array,list,num,for,int,i,0,i,num,i,int,version,random,next,int,10,string,name,string,utils,get,random,string,random,5,500,byte,bytes,new,byte,random,next,int,5000,1,random,next,bytes,bytes,states,add,new,master,state,name,bytes,version,return,states
CheckpointTestUtils -> public static Collection<MasterState> createRandomMasterStates(Random random, int num);1518008821;Creates a bunch of random master states.;public static Collection<MasterState> createRandomMasterStates(Random random, int num) {_		final ArrayList<MasterState> states = new ArrayList<>(num)___		for (int i = 0_ i < num_ i++) {_			int version = random.nextInt(10)__			String name = StringUtils.getRandomString(random, 5, 500)__			byte[] bytes = new byte[random.nextInt(5000) + 1]__			random.nextBytes(bytes)___			states.add(new MasterState(name, bytes, version))__		}__		return states__	};creates,a,bunch,of,random,master,states;public,static,collection,master,state,create,random,master,states,random,random,int,num,final,array,list,master,state,states,new,array,list,num,for,int,i,0,i,num,i,int,version,random,next,int,10,string,name,string,utils,get,random,string,random,5,500,byte,bytes,new,byte,random,next,int,5000,1,random,next,bytes,bytes,states,add,new,master,state,name,bytes,version,return,states
CheckpointTestUtils -> public static Collection<MasterState> createRandomMasterStates(Random random, int num);1519568061;Creates a bunch of random master states.;public static Collection<MasterState> createRandomMasterStates(Random random, int num) {_		final ArrayList<MasterState> states = new ArrayList<>(num)___		for (int i = 0_ i < num_ i++) {_			int version = random.nextInt(10)__			String name = StringUtils.getRandomString(random, 5, 500)__			byte[] bytes = new byte[random.nextInt(5000) + 1]__			random.nextBytes(bytes)___			states.add(new MasterState(name, bytes, version))__		}__		return states__	};creates,a,bunch,of,random,master,states;public,static,collection,master,state,create,random,master,states,random,random,int,num,final,array,list,master,state,states,new,array,list,num,for,int,i,0,i,num,i,int,version,random,next,int,10,string,name,string,utils,get,random,string,random,5,500,byte,bytes,new,byte,random,next,int,5000,1,random,next,bytes,bytes,states,add,new,master,state,name,bytes,version,return,states
CheckpointTestUtils -> public static Collection<MasterState> createRandomMasterStates(Random random, int num);1551262623;Creates a bunch of random master states.;public static Collection<MasterState> createRandomMasterStates(Random random, int num) {_		final ArrayList<MasterState> states = new ArrayList<>(num)___		for (int i = 0_ i < num_ i++) {_			int version = random.nextInt(10)__			String name = StringUtils.getRandomString(random, 5, 500)__			byte[] bytes = new byte[random.nextInt(5000) + 1]__			random.nextBytes(bytes)___			states.add(new MasterState(name, bytes, version))__		}__		return states__	};creates,a,bunch,of,random,master,states;public,static,collection,master,state,create,random,master,states,random,random,int,num,final,array,list,master,state,states,new,array,list,num,for,int,i,0,i,num,i,int,version,random,next,int,10,string,name,string,utils,get,random,string,random,5,500,byte,bytes,new,byte,random,next,int,5000,1,random,next,bytes,bytes,states,add,new,master,state,name,bytes,version,return,states
CheckpointTestUtils -> private CheckpointTestUtils();1493236605;utility class, not meant to be instantiated;private CheckpointTestUtils() {};utility,class,not,meant,to,be,instantiated;private,checkpoint,test,utils
CheckpointTestUtils -> private CheckpointTestUtils();1493403095;utility class, not meant to be instantiated;private CheckpointTestUtils() {};utility,class,not,meant,to,be,instantiated;private,checkpoint,test,utils
CheckpointTestUtils -> private CheckpointTestUtils();1494762590;utility class, not meant to be instantiated;private CheckpointTestUtils() {};utility,class,not,meant,to,be,instantiated;private,checkpoint,test,utils
CheckpointTestUtils -> private CheckpointTestUtils();1495184252;utility class, not meant to be instantiated;private CheckpointTestUtils() {};utility,class,not,meant,to,be,instantiated;private,checkpoint,test,utils
CheckpointTestUtils -> private CheckpointTestUtils();1500040329;utility class, not meant to be instantiated;private CheckpointTestUtils() {};utility,class,not,meant,to,be,instantiated;private,checkpoint,test,utils
CheckpointTestUtils -> private CheckpointTestUtils();1503598628;utility class, not meant to be instantiated;private CheckpointTestUtils() {};utility,class,not,meant,to,be,instantiated;private,checkpoint,test,utils
CheckpointTestUtils -> private CheckpointTestUtils();1518008821;utility class, not meant to be instantiated;private CheckpointTestUtils() {};utility,class,not,meant,to,be,instantiated;private,checkpoint,test,utils
CheckpointTestUtils -> private CheckpointTestUtils();1519568061;utility class, not meant to be instantiated;private CheckpointTestUtils() {};utility,class,not,meant,to,be,instantiated;private,checkpoint,test,utils
CheckpointTestUtils -> private CheckpointTestUtils();1551262623;utility class, not meant to be instantiated;private CheckpointTestUtils() {};utility,class,not,meant,to,be,instantiated;private,checkpoint,test,utils
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1493236605;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<TaskState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			int chainLength = 1 + random.nextInt(8)___			TaskState taskState = new TaskState(new JobVertexID(), numSubtasksPerTask, 128, chainLength)___			int noNonPartitionableStateAtIndex = random.nextInt(chainLength)__			int noOperatorStateBackendAtIndex = random.nextInt(chainLength)__			int noOperatorStateStreamAtIndex = random.nextInt(chainLength)___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				List<StreamStateHandle> nonPartitionableStates = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesBackend = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesStream = new ArrayList<>(chainLength)___				for (int chainIdx = 0_ chainIdx < chainLength_ ++chainIdx) {__					StreamStateHandle nonPartitionableState =_							new TestByteStreamStateHandleDeepCompare("a-" + chainIdx, ("Hi-" + chainIdx).getBytes(_									ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateBackend =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateStream =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__					offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___					if (chainIdx != noNonPartitionableStateAtIndex) {_						nonPartitionableStates.add(nonPartitionableState)__					}__					if (chainIdx != noOperatorStateBackendAtIndex) {_						OperatorStateHandle operatorStateHandleBackend =_								new OperatorStateHandle(offsetsMap, operatorStateBackend)__						operatorStatesBackend.add(operatorStateHandleBackend)__					}__					if (chainIdx != noOperatorStateStreamAtIndex) {_						OperatorStateHandle operatorStateHandleStream =_								new OperatorStateHandle(offsetsMap, operatorStateStream)__						operatorStatesStream.add(operatorStateHandleStream)__					}_				}__				KeyGroupsStateHandle keyedStateBackend = null__				KeyGroupsStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					keyedStateBackend = new KeyGroupsStateHandle(_							new KeyGroupRangeOffsets(1, 1, new long[]{42}),_							new TestByteStreamStateHandleDeepCompare("c", "Hello"_									.getBytes(ConfigConstants.DEFAULT_CHARSET)))__				}__				if (hasKeyedStream) {_					keyedStateStream = new KeyGroupsStateHandle(_							new KeyGroupRangeOffsets(1, 1, new long[]{23}),_							new TestByteStreamStateHandleDeepCompare("d", "World"_									.getBytes(ConfigConstants.DEFAULT_CHARSET)))__				}__				taskState.putState(subtaskIdx, new SubtaskState(_						new ChainedStateHandle<>(nonPartitionableStates),_						new ChainedStateHandle<>(operatorStatesBackend),_						new ChainedStateHandle<>(operatorStatesStream),_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,task,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,int,chain,length,1,random,next,int,8,task,state,task,state,new,task,state,new,job,vertex,id,num,subtasks,per,task,128,chain,length,int,no,non,partitionable,state,at,index,random,next,int,chain,length,int,no,operator,state,backend,at,index,random,next,int,chain,length,int,no,operator,state,stream,at,index,random,next,int,chain,length,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,list,stream,state,handle,non,partitionable,states,new,array,list,chain,length,list,operator,state,handle,operator,states,backend,new,array,list,chain,length,list,operator,state,handle,operator,states,stream,new,array,list,chain,length,for,int,chain,idx,0,chain,idx,chain,length,chain,idx,stream,state,handle,non,partitionable,state,new,test,byte,stream,state,handle,deep,compare,a,chain,idx,hi,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,chain,idx,no,non,partitionable,state,at,index,non,partitionable,states,add,non,partitionable,state,if,chain,idx,no,operator,state,backend,at,index,operator,state,handle,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,operator,states,backend,add,operator,state,handle,backend,if,chain,idx,no,operator,state,stream,at,index,operator,state,handle,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,operator,states,stream,add,operator,state,handle,stream,key,groups,state,handle,keyed,state,backend,null,key,groups,state,handle,keyed,state,stream,null,if,has,keyed,backend,keyed,state,backend,new,key,groups,state,handle,new,key,group,range,offsets,1,1,new,long,42,new,test,byte,stream,state,handle,deep,compare,c,hello,get,bytes,config,constants,if,has,keyed,stream,keyed,state,stream,new,key,groups,state,handle,new,key,group,range,offsets,1,1,new,long,23,new,test,byte,stream,state,handle,deep,compare,d,world,get,bytes,config,constants,task,state,put,state,subtask,idx,new,subtask,state,new,chained,state,handle,non,partitionable,states,new,chained,state,handle,operator,states,backend,new,chained,state,handle,operator,states,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1493403095;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<TaskState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			int chainLength = 1 + random.nextInt(8)___			TaskState taskState = new TaskState(new JobVertexID(), numSubtasksPerTask, 128, chainLength)___			int noNonPartitionableStateAtIndex = random.nextInt(chainLength)__			int noOperatorStateBackendAtIndex = random.nextInt(chainLength)__			int noOperatorStateStreamAtIndex = random.nextInt(chainLength)___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				List<StreamStateHandle> nonPartitionableStates = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesBackend = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesStream = new ArrayList<>(chainLength)___				for (int chainIdx = 0_ chainIdx < chainLength_ ++chainIdx) {__					StreamStateHandle nonPartitionableState =_							new TestByteStreamStateHandleDeepCompare("a-" + chainIdx, ("Hi-" + chainIdx).getBytes(_								ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateBackend =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateStream =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__					offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___					if (chainIdx != noNonPartitionableStateAtIndex) {_						nonPartitionableStates.add(nonPartitionableState)__					}__					if (chainIdx != noOperatorStateBackendAtIndex) {_						OperatorStateHandle operatorStateHandleBackend =_								new OperatorStateHandle(offsetsMap, operatorStateBackend)__						operatorStatesBackend.add(operatorStateHandleBackend)__					}__					if (chainIdx != noOperatorStateStreamAtIndex) {_						OperatorStateHandle operatorStateHandleStream =_								new OperatorStateHandle(offsetsMap, operatorStateStream)__						operatorStatesStream.add(operatorStateHandleStream)__					}_				}__				KeyGroupsStateHandle keyedStateBackend = null__				KeyGroupsStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					keyedStateBackend = new KeyGroupsStateHandle(_							new KeyGroupRangeOffsets(1, 1, new long[]{42}),_							new TestByteStreamStateHandleDeepCompare("c", "Hello"_								.getBytes(ConfigConstants.DEFAULT_CHARSET)))__				}__				if (hasKeyedStream) {_					keyedStateStream = new KeyGroupsStateHandle(_							new KeyGroupRangeOffsets(1, 1, new long[]{23}),_							new TestByteStreamStateHandleDeepCompare("d", "World"_								.getBytes(ConfigConstants.DEFAULT_CHARSET)))__				}__				taskState.putState(subtaskIdx, new SubtaskState(_						new ChainedStateHandle<>(nonPartitionableStates),_						new ChainedStateHandle<>(operatorStatesBackend),_						new ChainedStateHandle<>(operatorStatesStream),_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,task,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,int,chain,length,1,random,next,int,8,task,state,task,state,new,task,state,new,job,vertex,id,num,subtasks,per,task,128,chain,length,int,no,non,partitionable,state,at,index,random,next,int,chain,length,int,no,operator,state,backend,at,index,random,next,int,chain,length,int,no,operator,state,stream,at,index,random,next,int,chain,length,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,list,stream,state,handle,non,partitionable,states,new,array,list,chain,length,list,operator,state,handle,operator,states,backend,new,array,list,chain,length,list,operator,state,handle,operator,states,stream,new,array,list,chain,length,for,int,chain,idx,0,chain,idx,chain,length,chain,idx,stream,state,handle,non,partitionable,state,new,test,byte,stream,state,handle,deep,compare,a,chain,idx,hi,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,chain,idx,no,non,partitionable,state,at,index,non,partitionable,states,add,non,partitionable,state,if,chain,idx,no,operator,state,backend,at,index,operator,state,handle,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,operator,states,backend,add,operator,state,handle,backend,if,chain,idx,no,operator,state,stream,at,index,operator,state,handle,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,operator,states,stream,add,operator,state,handle,stream,key,groups,state,handle,keyed,state,backend,null,key,groups,state,handle,keyed,state,stream,null,if,has,keyed,backend,keyed,state,backend,new,key,groups,state,handle,new,key,group,range,offsets,1,1,new,long,42,new,test,byte,stream,state,handle,deep,compare,c,hello,get,bytes,config,constants,if,has,keyed,stream,keyed,state,stream,new,key,groups,state,handle,new,key,group,range,offsets,1,1,new,long,23,new,test,byte,stream,state,handle,deep,compare,d,world,get,bytes,config,constants,task,state,put,state,subtask,idx,new,subtask,state,new,chained,state,handle,non,partitionable,states,new,chained,state,handle,operator,states,backend,new,chained,state,handle,operator,states,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1494762590;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<TaskState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			int chainLength = 1 + random.nextInt(8)___			TaskState taskState = new TaskState(new JobVertexID(), numSubtasksPerTask, 128, chainLength)___			int noNonPartitionableStateAtIndex = random.nextInt(chainLength)__			int noOperatorStateBackendAtIndex = random.nextInt(chainLength)__			int noOperatorStateStreamAtIndex = random.nextInt(chainLength)___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				List<StreamStateHandle> nonPartitionableStates = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesBackend = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesStream = new ArrayList<>(chainLength)___				for (int chainIdx = 0_ chainIdx < chainLength_ ++chainIdx) {__					StreamStateHandle nonPartitionableState =_							new TestByteStreamStateHandleDeepCompare("a-" + chainIdx, ("Hi-" + chainIdx).getBytes(_								ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateBackend =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateStream =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__					offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___					if (chainIdx != noNonPartitionableStateAtIndex) {_						nonPartitionableStates.add(nonPartitionableState)__					}__					if (chainIdx != noOperatorStateBackendAtIndex) {_						OperatorStateHandle operatorStateHandleBackend =_								new OperatorStateHandle(offsetsMap, operatorStateBackend)__						operatorStatesBackend.add(operatorStateHandleBackend)__					}__					if (chainIdx != noOperatorStateStreamAtIndex) {_						OperatorStateHandle operatorStateHandleStream =_								new OperatorStateHandle(offsetsMap, operatorStateStream)__						operatorStatesStream.add(operatorStateHandleStream)__					}_				}__				KeyGroupsStateHandle keyedStateBackend = null__				KeyGroupsStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					keyedStateBackend = createDummyKeyGroupStateHandle(random)__				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new SubtaskState(_						new ChainedStateHandle<>(nonPartitionableStates),_						new ChainedStateHandle<>(operatorStatesBackend),_						new ChainedStateHandle<>(operatorStatesStream),_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,task,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,int,chain,length,1,random,next,int,8,task,state,task,state,new,task,state,new,job,vertex,id,num,subtasks,per,task,128,chain,length,int,no,non,partitionable,state,at,index,random,next,int,chain,length,int,no,operator,state,backend,at,index,random,next,int,chain,length,int,no,operator,state,stream,at,index,random,next,int,chain,length,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,list,stream,state,handle,non,partitionable,states,new,array,list,chain,length,list,operator,state,handle,operator,states,backend,new,array,list,chain,length,list,operator,state,handle,operator,states,stream,new,array,list,chain,length,for,int,chain,idx,0,chain,idx,chain,length,chain,idx,stream,state,handle,non,partitionable,state,new,test,byte,stream,state,handle,deep,compare,a,chain,idx,hi,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,chain,idx,no,non,partitionable,state,at,index,non,partitionable,states,add,non,partitionable,state,if,chain,idx,no,operator,state,backend,at,index,operator,state,handle,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,operator,states,backend,add,operator,state,handle,backend,if,chain,idx,no,operator,state,stream,at,index,operator,state,handle,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,operator,states,stream,add,operator,state,handle,stream,key,groups,state,handle,keyed,state,backend,null,key,groups,state,handle,keyed,state,stream,null,if,has,keyed,backend,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,subtask,state,new,chained,state,handle,non,partitionable,states,new,chained,state,handle,operator,states,backend,new,chained,state,handle,operator,states,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1495184252;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<TaskState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			int chainLength = 1 + random.nextInt(8)___			TaskState taskState = new TaskState(new JobVertexID(), numSubtasksPerTask, 128, chainLength)___			int noNonPartitionableStateAtIndex = random.nextInt(chainLength)__			int noOperatorStateBackendAtIndex = random.nextInt(chainLength)__			int noOperatorStateStreamAtIndex = random.nextInt(chainLength)___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				List<StreamStateHandle> nonPartitionableStates = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesBackend = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesStream = new ArrayList<>(chainLength)___				for (int chainIdx = 0_ chainIdx < chainLength_ ++chainIdx) {__					StreamStateHandle nonPartitionableState =_							new TestByteStreamStateHandleDeepCompare("a-" + chainIdx, ("Hi-" + chainIdx).getBytes(_								ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateBackend =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateStream =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__					offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___					if (chainIdx != noNonPartitionableStateAtIndex) {_						nonPartitionableStates.add(nonPartitionableState)__					}__					if (chainIdx != noOperatorStateBackendAtIndex) {_						OperatorStateHandle operatorStateHandleBackend =_								new OperatorStateHandle(offsetsMap, operatorStateBackend)__						operatorStatesBackend.add(operatorStateHandleBackend)__					}__					if (chainIdx != noOperatorStateStreamAtIndex) {_						OperatorStateHandle operatorStateHandleStream =_								new OperatorStateHandle(offsetsMap, operatorStateStream)__						operatorStatesStream.add(operatorStateHandleStream)__					}_				}__				KeyGroupsStateHandle keyedStateBackend = null__				KeyGroupsStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					keyedStateBackend = createDummyKeyGroupStateHandle(random)__				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new SubtaskState(_						new ChainedStateHandle<>(nonPartitionableStates),_						new ChainedStateHandle<>(operatorStatesBackend),_						new ChainedStateHandle<>(operatorStatesStream),_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,task,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,int,chain,length,1,random,next,int,8,task,state,task,state,new,task,state,new,job,vertex,id,num,subtasks,per,task,128,chain,length,int,no,non,partitionable,state,at,index,random,next,int,chain,length,int,no,operator,state,backend,at,index,random,next,int,chain,length,int,no,operator,state,stream,at,index,random,next,int,chain,length,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,list,stream,state,handle,non,partitionable,states,new,array,list,chain,length,list,operator,state,handle,operator,states,backend,new,array,list,chain,length,list,operator,state,handle,operator,states,stream,new,array,list,chain,length,for,int,chain,idx,0,chain,idx,chain,length,chain,idx,stream,state,handle,non,partitionable,state,new,test,byte,stream,state,handle,deep,compare,a,chain,idx,hi,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,chain,idx,no,non,partitionable,state,at,index,non,partitionable,states,add,non,partitionable,state,if,chain,idx,no,operator,state,backend,at,index,operator,state,handle,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,operator,states,backend,add,operator,state,handle,backend,if,chain,idx,no,operator,state,stream,at,index,operator,state,handle,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,operator,states,stream,add,operator,state,handle,stream,key,groups,state,handle,keyed,state,backend,null,key,groups,state,handle,keyed,state,stream,null,if,has,keyed,backend,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,subtask,state,new,chained,state,handle,non,partitionable,states,new,chained,state,handle,operator,states,backend,new,chained,state,handle,operator,states,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1500040329;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<TaskState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			int chainLength = 1 + random.nextInt(8)___			TaskState taskState = new TaskState(new JobVertexID(), numSubtasksPerTask, 128, chainLength)___			int noNonPartitionableStateAtIndex = random.nextInt(chainLength)__			int noOperatorStateBackendAtIndex = random.nextInt(chainLength)__			int noOperatorStateStreamAtIndex = random.nextInt(chainLength)___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				List<StreamStateHandle> nonPartitionableStates = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesBackend = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesStream = new ArrayList<>(chainLength)___				for (int chainIdx = 0_ chainIdx < chainLength_ ++chainIdx) {__					StreamStateHandle nonPartitionableState =_							new TestByteStreamStateHandleDeepCompare("a-" + chainIdx, ("Hi-" + chainIdx).getBytes(_								ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateBackend =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateStream =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__					offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___					if (chainIdx != noNonPartitionableStateAtIndex) {_						nonPartitionableStates.add(nonPartitionableState)__					}__					if (chainIdx != noOperatorStateBackendAtIndex) {_						OperatorStateHandle operatorStateHandleBackend =_								new OperatorStateHandle(offsetsMap, operatorStateBackend)__						operatorStatesBackend.add(operatorStateHandleBackend)__					}__					if (chainIdx != noOperatorStateStreamAtIndex) {_						OperatorStateHandle operatorStateHandleStream =_								new OperatorStateHandle(offsetsMap, operatorStateStream)__						operatorStatesStream.add(operatorStateHandleStream)__					}_				}__				KeyGroupsStateHandle keyedStateBackend = null__				KeyGroupsStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					keyedStateBackend = createDummyKeyGroupStateHandle(random)__				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new SubtaskState(_						new ChainedStateHandle<>(nonPartitionableStates),_						new ChainedStateHandle<>(operatorStatesBackend),_						new ChainedStateHandle<>(operatorStatesStream),_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,task,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,int,chain,length,1,random,next,int,8,task,state,task,state,new,task,state,new,job,vertex,id,num,subtasks,per,task,128,chain,length,int,no,non,partitionable,state,at,index,random,next,int,chain,length,int,no,operator,state,backend,at,index,random,next,int,chain,length,int,no,operator,state,stream,at,index,random,next,int,chain,length,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,list,stream,state,handle,non,partitionable,states,new,array,list,chain,length,list,operator,state,handle,operator,states,backend,new,array,list,chain,length,list,operator,state,handle,operator,states,stream,new,array,list,chain,length,for,int,chain,idx,0,chain,idx,chain,length,chain,idx,stream,state,handle,non,partitionable,state,new,test,byte,stream,state,handle,deep,compare,a,chain,idx,hi,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,chain,idx,no,non,partitionable,state,at,index,non,partitionable,states,add,non,partitionable,state,if,chain,idx,no,operator,state,backend,at,index,operator,state,handle,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,operator,states,backend,add,operator,state,handle,backend,if,chain,idx,no,operator,state,stream,at,index,operator,state,handle,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,operator,states,stream,add,operator,state,handle,stream,key,groups,state,handle,keyed,state,backend,null,key,groups,state,handle,keyed,state,stream,null,if,has,keyed,backend,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,subtask,state,new,chained,state,handle,non,partitionable,states,new,chained,state,handle,operator,states,backend,new,chained,state,handle,operator,states,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1503598628;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<TaskState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			int chainLength = 1 + random.nextInt(8)___			TaskState taskState = new TaskState(new JobVertexID(), numSubtasksPerTask, 128, chainLength)___			int noNonPartitionableStateAtIndex = random.nextInt(chainLength)__			int noOperatorStateBackendAtIndex = random.nextInt(chainLength)__			int noOperatorStateStreamAtIndex = random.nextInt(chainLength)___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				List<OperatorStateHandle> operatorStatesBackend = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesStream = new ArrayList<>(chainLength)___				for (int chainIdx = 0_ chainIdx < chainLength_ ++chainIdx) {__					StreamStateHandle operatorStateBackend =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateStream =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__					offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.BROADCAST))___					if (chainIdx != noOperatorStateBackendAtIndex) {_						OperatorStateHandle operatorStateHandleBackend =_								new OperatorStateHandle(offsetsMap, operatorStateBackend)__						operatorStatesBackend.add(operatorStateHandleBackend)__					}__					if (chainIdx != noOperatorStateStreamAtIndex) {_						OperatorStateHandle operatorStateHandleStream =_								new OperatorStateHandle(offsetsMap, operatorStateStream)__						operatorStatesStream.add(operatorStateHandleStream)__					}_				}__				KeyGroupsStateHandle keyedStateBackend = null__				KeyGroupsStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					keyedStateBackend = createDummyKeyGroupStateHandle(random)__				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new SubtaskState(_						new ChainedStateHandle<>(operatorStatesBackend),_						new ChainedStateHandle<>(operatorStatesStream),_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,task,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,int,chain,length,1,random,next,int,8,task,state,task,state,new,task,state,new,job,vertex,id,num,subtasks,per,task,128,chain,length,int,no,non,partitionable,state,at,index,random,next,int,chain,length,int,no,operator,state,backend,at,index,random,next,int,chain,length,int,no,operator,state,stream,at,index,random,next,int,chain,length,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,list,operator,state,handle,operator,states,backend,new,array,list,chain,length,list,operator,state,handle,operator,states,stream,new,array,list,chain,length,for,int,chain,idx,0,chain,idx,chain,length,chain,idx,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,broadcast,if,chain,idx,no,operator,state,backend,at,index,operator,state,handle,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,operator,states,backend,add,operator,state,handle,backend,if,chain,idx,no,operator,state,stream,at,index,operator,state,handle,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,operator,states,stream,add,operator,state,handle,stream,key,groups,state,handle,keyed,state,backend,null,key,groups,state,handle,keyed,state,stream,null,if,has,keyed,backend,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,subtask,state,new,chained,state,handle,operator,states,backend,new,chained,state,handle,operator,states,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1518008821;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<TaskState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			int chainLength = 1 + random.nextInt(8)___			TaskState taskState = new TaskState(new JobVertexID(), numSubtasksPerTask, 128, chainLength)___			int noNonPartitionableStateAtIndex = random.nextInt(chainLength)__			int noOperatorStateBackendAtIndex = random.nextInt(chainLength)__			int noOperatorStateStreamAtIndex = random.nextInt(chainLength)___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				List<OperatorStateHandle> operatorStatesBackend = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesStream = new ArrayList<>(chainLength)___				for (int chainIdx = 0_ chainIdx < chainLength_ ++chainIdx) {__					StreamStateHandle operatorStateBackend =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateStream =_							new TestByteStreamStateHandleDeepCompare("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					Map<String, StateMetaInfo> offsetsMap = new HashMap<>()__					offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.UNION))___					if (chainIdx != noOperatorStateBackendAtIndex) {_						OperatorStateHandle operatorStateHandleBackend =_								new OperatorStateHandle(offsetsMap, operatorStateBackend)__						operatorStatesBackend.add(operatorStateHandleBackend)__					}__					if (chainIdx != noOperatorStateStreamAtIndex) {_						OperatorStateHandle operatorStateHandleStream =_								new OperatorStateHandle(offsetsMap, operatorStateStream)__						operatorStatesStream.add(operatorStateHandleStream)__					}_				}__				KeyGroupsStateHandle keyedStateBackend = null__				KeyGroupsStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					keyedStateBackend = createDummyKeyGroupStateHandle(random)__				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new SubtaskState(_						new ChainedStateHandle<>(operatorStatesBackend),_						new ChainedStateHandle<>(operatorStatesStream),_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,task,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,int,chain,length,1,random,next,int,8,task,state,task,state,new,task,state,new,job,vertex,id,num,subtasks,per,task,128,chain,length,int,no,non,partitionable,state,at,index,random,next,int,chain,length,int,no,operator,state,backend,at,index,random,next,int,chain,length,int,no,operator,state,stream,at,index,random,next,int,chain,length,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,list,operator,state,handle,operator,states,backend,new,array,list,chain,length,list,operator,state,handle,operator,states,stream,new,array,list,chain,length,for,int,chain,idx,0,chain,idx,chain,length,chain,idx,stream,state,handle,operator,state,backend,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,test,byte,stream,state,handle,deep,compare,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,map,string,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,union,if,chain,idx,no,operator,state,backend,at,index,operator,state,handle,operator,state,handle,backend,new,operator,state,handle,offsets,map,operator,state,backend,operator,states,backend,add,operator,state,handle,backend,if,chain,idx,no,operator,state,stream,at,index,operator,state,handle,operator,state,handle,stream,new,operator,state,handle,offsets,map,operator,state,stream,operator,states,stream,add,operator,state,handle,stream,key,groups,state,handle,keyed,state,backend,null,key,groups,state,handle,keyed,state,stream,null,if,has,keyed,backend,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,subtask,state,new,chained,state,handle,operator,states,backend,new,chained,state,handle,operator,states,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1519568061;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<TaskState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			int chainLength = 1 + random.nextInt(8)___			TaskState taskState = new TaskState(new JobVertexID(), numSubtasksPerTask, 128, chainLength)___			int noNonPartitionableStateAtIndex = random.nextInt(chainLength)__			int noOperatorStateBackendAtIndex = random.nextInt(chainLength)__			int noOperatorStateStreamAtIndex = random.nextInt(chainLength)___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				List<OperatorStateHandle> operatorStatesBackend = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesStream = new ArrayList<>(chainLength)___				for (int chainIdx = 0_ chainIdx < chainLength_ ++chainIdx) {__					StreamStateHandle operatorStateBackend =_							new ByteStreamStateHandle("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateStream =_							new ByteStreamStateHandle("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					Map<String, OperatorStateHandle.StateMetaInfo> offsetsMap = new HashMap<>()__					offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.UNION))___					if (chainIdx != noOperatorStateBackendAtIndex) {_						OperatorStateHandle operatorStateHandleBackend =_								new OperatorStreamStateHandle(offsetsMap, operatorStateBackend)__						operatorStatesBackend.add(operatorStateHandleBackend)__					}__					if (chainIdx != noOperatorStateStreamAtIndex) {_						OperatorStateHandle operatorStateHandleStream =_								new OperatorStreamStateHandle(offsetsMap, operatorStateStream)__						operatorStatesStream.add(operatorStateHandleStream)__					}_				}__				KeyGroupsStateHandle keyedStateBackend = null__				KeyGroupsStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					keyedStateBackend = createDummyKeyGroupStateHandle(random)__				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new SubtaskState(_						new ChainedStateHandle<>(operatorStatesBackend),_						new ChainedStateHandle<>(operatorStatesStream),_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,task,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,int,chain,length,1,random,next,int,8,task,state,task,state,new,task,state,new,job,vertex,id,num,subtasks,per,task,128,chain,length,int,no,non,partitionable,state,at,index,random,next,int,chain,length,int,no,operator,state,backend,at,index,random,next,int,chain,length,int,no,operator,state,stream,at,index,random,next,int,chain,length,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,list,operator,state,handle,operator,states,backend,new,array,list,chain,length,list,operator,state,handle,operator,states,stream,new,array,list,chain,length,for,int,chain,idx,0,chain,idx,chain,length,chain,idx,stream,state,handle,operator,state,backend,new,byte,stream,state,handle,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,byte,stream,state,handle,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,map,string,operator,state,handle,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,union,if,chain,idx,no,operator,state,backend,at,index,operator,state,handle,operator,state,handle,backend,new,operator,stream,state,handle,offsets,map,operator,state,backend,operator,states,backend,add,operator,state,handle,backend,if,chain,idx,no,operator,state,stream,at,index,operator,state,handle,operator,state,handle,stream,new,operator,stream,state,handle,offsets,map,operator,state,stream,operator,states,stream,add,operator,state,handle,stream,key,groups,state,handle,keyed,state,backend,null,key,groups,state,handle,keyed,state,stream,null,if,has,keyed,backend,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,subtask,state,new,chained,state,handle,operator,states,backend,new,chained,state,handle,operator,states,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
CheckpointTestUtils -> public static Collection<TaskState> createTaskStates( 			Random random, 			int numTaskStates, 			int numSubtasksPerTask);1551262623;Creates a random collection of TaskState objects containing various types of state handles.;public static Collection<TaskState> createTaskStates(_			Random random,_			int numTaskStates,_			int numSubtasksPerTask) {__		List<TaskState> taskStates = new ArrayList<>(numTaskStates)___		for (int stateIdx = 0_ stateIdx < numTaskStates_ ++stateIdx) {__			int chainLength = 1 + random.nextInt(8)___			TaskState taskState = new TaskState(new JobVertexID(), numSubtasksPerTask, 128, chainLength)___			int noNonPartitionableStateAtIndex = random.nextInt(chainLength)__			int noOperatorStateBackendAtIndex = random.nextInt(chainLength)__			int noOperatorStateStreamAtIndex = random.nextInt(chainLength)___			boolean hasKeyedBackend = random.nextInt(4) != 0__			boolean hasKeyedStream = random.nextInt(4) != 0___			for (int subtaskIdx = 0_ subtaskIdx < numSubtasksPerTask_ subtaskIdx++) {__				List<OperatorStateHandle> operatorStatesBackend = new ArrayList<>(chainLength)__				List<OperatorStateHandle> operatorStatesStream = new ArrayList<>(chainLength)___				for (int chainIdx = 0_ chainIdx < chainLength_ ++chainIdx) {__					StreamStateHandle operatorStateBackend =_							new ByteStreamStateHandle("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					StreamStateHandle operatorStateStream =_							new ByteStreamStateHandle("b-" + chainIdx, ("Beautiful-" + chainIdx).getBytes(ConfigConstants.DEFAULT_CHARSET))__					Map<String, OperatorStateHandle.StateMetaInfo> offsetsMap = new HashMap<>()__					offsetsMap.put("A", new OperatorStateHandle.StateMetaInfo(new long[]{0, 10, 20}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("B", new OperatorStateHandle.StateMetaInfo(new long[]{30, 40, 50}, OperatorStateHandle.Mode.SPLIT_DISTRIBUTE))__					offsetsMap.put("C", new OperatorStateHandle.StateMetaInfo(new long[]{60, 70, 80}, OperatorStateHandle.Mode.UNION))___					if (chainIdx != noOperatorStateBackendAtIndex) {_						OperatorStateHandle operatorStateHandleBackend =_								new OperatorStreamStateHandle(offsetsMap, operatorStateBackend)__						operatorStatesBackend.add(operatorStateHandleBackend)__					}__					if (chainIdx != noOperatorStateStreamAtIndex) {_						OperatorStateHandle operatorStateHandleStream =_								new OperatorStreamStateHandle(offsetsMap, operatorStateStream)__						operatorStatesStream.add(operatorStateHandleStream)__					}_				}__				KeyGroupsStateHandle keyedStateBackend = null__				KeyGroupsStateHandle keyedStateStream = null___				if (hasKeyedBackend) {_					keyedStateBackend = createDummyKeyGroupStateHandle(random)__				}__				if (hasKeyedStream) {_					keyedStateStream = createDummyKeyGroupStateHandle(random)__				}__				taskState.putState(subtaskIdx, new SubtaskState(_						new ChainedStateHandle<>(operatorStatesBackend),_						new ChainedStateHandle<>(operatorStatesStream),_						keyedStateStream,_						keyedStateBackend))__			}__			taskStates.add(taskState)__		}__		return taskStates__	};creates,a,random,collection,of,task,state,objects,containing,various,types,of,state,handles;public,static,collection,task,state,create,task,states,random,random,int,num,task,states,int,num,subtasks,per,task,list,task,state,task,states,new,array,list,num,task,states,for,int,state,idx,0,state,idx,num,task,states,state,idx,int,chain,length,1,random,next,int,8,task,state,task,state,new,task,state,new,job,vertex,id,num,subtasks,per,task,128,chain,length,int,no,non,partitionable,state,at,index,random,next,int,chain,length,int,no,operator,state,backend,at,index,random,next,int,chain,length,int,no,operator,state,stream,at,index,random,next,int,chain,length,boolean,has,keyed,backend,random,next,int,4,0,boolean,has,keyed,stream,random,next,int,4,0,for,int,subtask,idx,0,subtask,idx,num,subtasks,per,task,subtask,idx,list,operator,state,handle,operator,states,backend,new,array,list,chain,length,list,operator,state,handle,operator,states,stream,new,array,list,chain,length,for,int,chain,idx,0,chain,idx,chain,length,chain,idx,stream,state,handle,operator,state,backend,new,byte,stream,state,handle,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,stream,state,handle,operator,state,stream,new,byte,stream,state,handle,b,chain,idx,beautiful,chain,idx,get,bytes,config,constants,map,string,operator,state,handle,state,meta,info,offsets,map,new,hash,map,offsets,map,put,a,new,operator,state,handle,state,meta,info,new,long,0,10,20,operator,state,handle,mode,offsets,map,put,b,new,operator,state,handle,state,meta,info,new,long,30,40,50,operator,state,handle,mode,offsets,map,put,c,new,operator,state,handle,state,meta,info,new,long,60,70,80,operator,state,handle,mode,union,if,chain,idx,no,operator,state,backend,at,index,operator,state,handle,operator,state,handle,backend,new,operator,stream,state,handle,offsets,map,operator,state,backend,operator,states,backend,add,operator,state,handle,backend,if,chain,idx,no,operator,state,stream,at,index,operator,state,handle,operator,state,handle,stream,new,operator,stream,state,handle,offsets,map,operator,state,stream,operator,states,stream,add,operator,state,handle,stream,key,groups,state,handle,keyed,state,backend,null,key,groups,state,handle,keyed,state,stream,null,if,has,keyed,backend,keyed,state,backend,create,dummy,key,group,state,handle,random,if,has,keyed,stream,keyed,state,stream,create,dummy,key,group,state,handle,random,task,state,put,state,subtask,idx,new,subtask,state,new,chained,state,handle,operator,states,backend,new,chained,state,handle,operator,states,stream,keyed,state,stream,keyed,state,backend,task,states,add,task,state,return,task,states
