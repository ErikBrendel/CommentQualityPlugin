# id;timestamp;commentText;codeText;commentWords;codeWords
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1430123107;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final AbstractJobVertex sender = new AbstractJobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final AbstractJobVertex receiver = new AbstractJobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_				sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph(_				"Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_				sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		JobClient.submitJobAndWait(_				jobClient,_				flink.getJobManager(),_				jobGraph,_				TestingUtils.TESTING_DURATION(),_				false)__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,abstract,job,vertex,sender,new,abstract,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,abstract,job,vertex,receiver,new,abstract,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,job,client,submit,job,and,wait,job,client,flink,get,job,manager,job,graph,testing,utils,false
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1434467925;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_				sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph(_				"Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_				sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		JobClient.submitJobAndWait(_				jobClient,_				flink.getJobManager(),_				jobGraph,_				TestingUtils.TESTING_DURATION(),_				false)__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,job,client,submit,job,and,wait,job,client,flink,get,job,manager,job,graph,testing,utils,false
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1437665997;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_				sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph(_				"Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_				sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		JobClient.submitJobAndWait(_				jobClient,_				flink.getJobManagerGateway(),_				jobGraph,_				TestingUtils.TESTING_DURATION(),_				false)__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,job,client,submit,job,and,wait,job,client,flink,get,job,manager,gateway,job,graph,testing,utils,false
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1440951699;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_				sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph(_				"Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_				sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		JobClient.submitJobAndWait(_				jobClient,_				flink.getJobManagerGateway(),_				jobGraph,_				TestingUtils.TESTING_DURATION(),_				false, this.getClass().getClassLoader())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,job,client,submit,job,and,wait,job,client,flink,get,job,manager,gateway,job,graph,testing,utils,false,this,get,class,get,class,loader
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1441011751;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_				sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph(_				"Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_				sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		JobClient.submitJobAndWait(_				jobClient,_				flink.getLeaderGateway(TestingUtils.TESTING_DURATION()),_				jobGraph,_				TestingUtils.TESTING_DURATION(),_				false, this.getClass().getClassLoader())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,job,client,submit,job,and,wait,job,client,flink,get,leader,gateway,testing,utils,job,graph,testing,utils,false,this,get,class,get,class,loader
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1442944546;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_				sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph(_				"Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_				sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		JobClient.submitJobAndWait(_				jobClient,_				flink.getLeaderGateway(TestingUtils.TESTING_DURATION()),_				jobGraph,_				TestingUtils.TESTING_DURATION(),_				false,_				this.getClass().getClassLoader())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,job,client,submit,job,and,wait,job,client,flink,get,leader,gateway,testing,utils,job,graph,testing,utils,false,this,get,class,get,class,loader
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1445293012;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_				sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph(_				"Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_				sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1453902315;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_				sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph(_				"Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_				sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1457737669;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_				sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph(_				"Partial Consume of Pipelined Result", new ExecutionConfig(), sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_				sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,new,execution,config,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1463155298;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_				sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_				sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1480624969;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1482522862;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1491500150;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1495477702;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1513201052;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1515519059;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1516285878;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1519039287;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1519039300;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1519039301;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1524570317;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.submitJobAndWait(jobGraph, false, TestingUtils.TESTING_DURATION())__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,submit,job,and,wait,job,graph,false,testing,utils
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1524570476;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.executeJobBlocking(jobGraph)__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,execute,job,blocking,job,graph
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1526494919;Tests a fix for FLINK-1930.__<p> When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early.  If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.executeJobBlocking(jobGraph)__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,execute,job,blocking,job,graph
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1537385496;Tests a fix for FLINK-1930.__<p>When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early. If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		flink.executeJobBlocking(jobGraph)__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,flink,execute,job,blocking,job,graph
PartialConsumePipelinedResultTest -> @Test 	public void testPartialConsumePipelinedResultReceiver() throws Exception;1540389860;Tests a fix for FLINK-1930.__<p>When consuming a pipelined result only partially, is is possible that local channels_release the buffer pool, which is associated with the result partition, too early. If the_producer is still producing data when this happens, it runs into an IllegalStateException,_because of the destroyed buffer pool.__@see <a href="https://issues.apache.org/jira/browse/FLINK-1930">FLINK-1930</a>;@Test_	public void testPartialConsumePipelinedResultReceiver() throws Exception {_		final JobVertex sender = new JobVertex("Sender")__		sender.setInvokableClass(SlowBufferSender.class)__		sender.setParallelism(PARALLELISM)___		final JobVertex receiver = new JobVertex("Receiver")__		receiver.setInvokableClass(SingleBufferReceiver.class)__		receiver.setParallelism(PARALLELISM)___		_		_		receiver.connectNewDataSetAsInput(_			sender, DistributionPattern.POINTWISE, ResultPartitionType.PIPELINED)___		final JobGraph jobGraph = new JobGraph("Partial Consume of Pipelined Result", sender, receiver)___		final SlotSharingGroup slotSharingGroup = new SlotSharingGroup(_			sender.getID(), receiver.getID())___		sender.setSlotSharingGroup(slotSharingGroup)__		receiver.setSlotSharingGroup(slotSharingGroup)___		MINI_CLUSTER_RESOURCE.getMiniCluster().executeJobBlocking(jobGraph)__	};tests,a,fix,for,flink,1930,p,when,consuming,a,pipelined,result,only,partially,is,is,possible,that,local,channels,release,the,buffer,pool,which,is,associated,with,the,result,partition,too,early,if,the,producer,is,still,producing,data,when,this,happens,it,runs,into,an,illegal,state,exception,because,of,the,destroyed,buffer,pool,see,a,href,https,issues,apache,org,jira,browse,flink,1930,flink,1930,a;test,public,void,test,partial,consume,pipelined,result,receiver,throws,exception,final,job,vertex,sender,new,job,vertex,sender,sender,set,invokable,class,slow,buffer,sender,class,sender,set,parallelism,parallelism,final,job,vertex,receiver,new,job,vertex,receiver,receiver,set,invokable,class,single,buffer,receiver,class,receiver,set,parallelism,parallelism,receiver,connect,new,data,set,as,input,sender,distribution,pattern,pointwise,result,partition,type,pipelined,final,job,graph,job,graph,new,job,graph,partial,consume,of,pipelined,result,sender,receiver,final,slot,sharing,group,slot,sharing,group,new,slot,sharing,group,sender,get,id,receiver,get,id,sender,set,slot,sharing,group,slot,sharing,group,receiver,set,slot,sharing,group,slot,sharing,group,get,mini,cluster,execute,job,blocking,job,graph
