# id;timestamp;commentText;codeText;commentWords;codeWords
BlobServerDeleteTest -> private void testDeleteTransient(@Nullable JobID jobId1, @Nullable JobID jobId2) 			throws IOException;1507212387;Uploads a (different) byte array for each of the given jobs and verifies that deleting one of_them (via the {@link BlobServer}) does not influence the other.__@param jobId1_first job id_@param jobId2_second job id;private void testDeleteTransient(@Nullable JobID jobId1, @Nullable JobID jobId2)_			throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			_			BlobKey key1 = put(server, jobId1, data, false)__			assertNotNull(key1)___			_			BlobKey key2a = put(server, jobId2, data, false)__			assertNotNull(key2a)__			assertEquals(key1, key2a)__			BlobKey key2b = put(server, jobId2, data2, false)__			assertNotNull(key2b)___			_			assertTrue(delete(server, jobId1, key1))___			verifyDeleted(server, jobId1, key1, false)__			_			if ((jobId1 == null && jobId2 != null) || (jobId1 != null && !jobId1.equals(jobId2))) {_				verifyContents(server, jobId2, key2a, data, false)__			}_			verifyContents(server, jobId2, key2b, data2, false)___			_			assertTrue(delete(server, jobId2, key2a))__			verifyDeleted(server, jobId2, key2a, false)__			verifyContents(server, jobId2, key2b, data2, false)___			_			assertTrue(delete(server, jobId2, key2a))__			verifyDeleted(server, jobId2, key2a, false)__			verifyContents(server, jobId2, key2b, data2, false)__		}_	};uploads,a,different,byte,array,for,each,of,the,given,jobs,and,verifies,that,deleting,one,of,them,via,the,link,blob,server,does,not,influence,the,other,param,job,id1,first,job,id,param,job,id2,second,job,id;private,void,test,delete,transient,nullable,job,id,job,id1,nullable,job,id,job,id2,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,data,data,length,data2,0,1,blob,key,key1,put,server,job,id1,data,false,assert,not,null,key1,blob,key,key2a,put,server,job,id2,data,false,assert,not,null,key2a,assert,equals,key1,key2a,blob,key,key2b,put,server,job,id2,data2,false,assert,not,null,key2b,assert,true,delete,server,job,id1,key1,verify,deleted,server,job,id1,key1,false,if,job,id1,null,job,id2,null,job,id1,null,job,id1,equals,job,id2,verify,contents,server,job,id2,key2a,data,false,verify,contents,server,job,id2,key2b,data2,false,assert,true,delete,server,job,id2,key2a,verify,deleted,server,job,id2,key2a,false,verify,contents,server,job,id2,key2b,data2,false,assert,true,delete,server,job,id2,key2a,verify,deleted,server,job,id2,key2a,false,verify,contents,server,job,id2,key2b,data2,false
BlobServerDeleteTest -> private void testDeleteTransient(@Nullable JobID jobId1, @Nullable JobID jobId2) 			throws IOException;1507212387;Uploads a (different) byte array for each of the given jobs and verifies that deleting one of_them (via the {@link BlobServer}) does not influence the other.__@param jobId1_first job id_@param jobId2_second job id;private void testDeleteTransient(@Nullable JobID jobId1, @Nullable JobID jobId2)_			throws IOException {_		final boolean sameJobId = (jobId1 == jobId2) || (jobId1 != null && jobId1.equals(jobId2))___		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			_			TransientBlobKey key1 = (TransientBlobKey) put(server, jobId1, data, TRANSIENT_BLOB)__			assertNotNull(key1)___			_			TransientBlobKey key2a = (TransientBlobKey) put(server, jobId2, data, TRANSIENT_BLOB)__			assertNotNull(key2a)__			assertEquals(key1, key2a)__			TransientBlobKey key2b = (TransientBlobKey) put(server, jobId2, data2, TRANSIENT_BLOB)__			assertNotNull(key2b)___			_			assertTrue(delete(server, jobId1, key1))___			verifyDeleted(server, jobId1, key1)__			_			if (!sameJobId) {_				verifyContents(server, jobId2, key2a, data)__			}_			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(server, jobId2, key2a))__			verifyDeleted(server, jobId2, key2a)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(server, jobId2, key2b))__			verifyDeleted(server, jobId2, key2b)__		}_	};uploads,a,different,byte,array,for,each,of,the,given,jobs,and,verifies,that,deleting,one,of,them,via,the,link,blob,server,does,not,influence,the,other,param,job,id1,first,job,id,param,job,id2,second,job,id;private,void,test,delete,transient,nullable,job,id,job,id1,nullable,job,id,job,id2,throws,ioexception,final,boolean,same,job,id,job,id1,job,id2,job,id1,null,job,id1,equals,job,id2,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,data,data,length,data2,0,1,transient,blob,key,key1,transient,blob,key,put,server,job,id1,data,assert,not,null,key1,transient,blob,key,key2a,transient,blob,key,put,server,job,id2,data,assert,not,null,key2a,assert,equals,key1,key2a,transient,blob,key,key2b,transient,blob,key,put,server,job,id2,data2,assert,not,null,key2b,assert,true,delete,server,job,id1,key1,verify,deleted,server,job,id1,key1,if,same,job,id,verify,contents,server,job,id2,key2a,data,verify,contents,server,job,id2,key2b,data2,assert,true,delete,server,job,id2,key2a,verify,deleted,server,job,id2,key2a,verify,contents,server,job,id2,key2b,data2,assert,true,delete,server,job,id2,key2b,verify,deleted,server,job,id2,key2b
BlobServerDeleteTest -> private void testDeleteTransient(@Nullable JobID jobId1, @Nullable JobID jobId2) 			throws IOException;1508138617;Uploads a (different) byte array for each of the given jobs and verifies that deleting one of_them (via the {@link BlobServer}) does not influence the other.__@param jobId1_first job id_@param jobId2_second job id;private void testDeleteTransient(@Nullable JobID jobId1, @Nullable JobID jobId2)_			throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			_			TransientBlobKey key1 = (TransientBlobKey) put(server, jobId1, data, TRANSIENT_BLOB)__			assertNotNull(key1)___			_			TransientBlobKey key2a = (TransientBlobKey) put(server, jobId2, data, TRANSIENT_BLOB)__			assertNotNull(key2a)__			verifyKeyDifferentHashEquals(key1, key2a)__			TransientBlobKey key2b = (TransientBlobKey) put(server, jobId2, data2, TRANSIENT_BLOB)__			assertNotNull(key2b)___			_			assertTrue(delete(server, jobId1, key1))___			verifyDeleted(server, jobId1, key1)__			_			_			verifyContents(server, jobId2, key2a, data)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(server, jobId2, key2a))__			verifyDeleted(server, jobId2, key2a)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(server, jobId2, key2b))__			verifyDeleted(server, jobId2, key2b)__		}_	};uploads,a,different,byte,array,for,each,of,the,given,jobs,and,verifies,that,deleting,one,of,them,via,the,link,blob,server,does,not,influence,the,other,param,job,id1,first,job,id,param,job,id2,second,job,id;private,void,test,delete,transient,nullable,job,id,job,id1,nullable,job,id,job,id2,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,data,data,length,data2,0,1,transient,blob,key,key1,transient,blob,key,put,server,job,id1,data,assert,not,null,key1,transient,blob,key,key2a,transient,blob,key,put,server,job,id2,data,assert,not,null,key2a,verify,key,different,hash,equals,key1,key2a,transient,blob,key,key2b,transient,blob,key,put,server,job,id2,data2,assert,not,null,key2b,assert,true,delete,server,job,id1,key1,verify,deleted,server,job,id1,key1,verify,contents,server,job,id2,key2a,data,verify,contents,server,job,id2,key2b,data2,assert,true,delete,server,job,id2,key2a,verify,deleted,server,job,id2,key2a,verify,contents,server,job,id2,key2b,data2,assert,true,delete,server,job,id2,key2b,verify,deleted,server,job,id2,key2b
BlobServerDeleteTest -> private void testDeleteTransient(@Nullable JobID jobId1, @Nullable JobID jobId2) 			throws IOException;1508578816;Uploads a (different) byte array for each of the given jobs and verifies that deleting one of_them (via the {@link BlobServer}) does not influence the other.__@param jobId1_first job id_@param jobId2_second job id;private void testDeleteTransient(@Nullable JobID jobId1, @Nullable JobID jobId2)_			throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			_			TransientBlobKey key1 = (TransientBlobKey) put(server, jobId1, data, TRANSIENT_BLOB)__			assertNotNull(key1)___			_			TransientBlobKey key2a = (TransientBlobKey) put(server, jobId2, data, TRANSIENT_BLOB)__			assertNotNull(key2a)__			verifyKeyDifferentHashEquals(key1, key2a)__			TransientBlobKey key2b = (TransientBlobKey) put(server, jobId2, data2, TRANSIENT_BLOB)__			assertNotNull(key2b)___			_			assertTrue(delete(server, jobId1, key1))___			verifyDeleted(server, jobId1, key1)__			_			_			verifyContents(server, jobId2, key2a, data)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(server, jobId2, key2a))__			verifyDeleted(server, jobId2, key2a)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(server, jobId2, key2b))__			verifyDeleted(server, jobId2, key2b)__		}_	};uploads,a,different,byte,array,for,each,of,the,given,jobs,and,verifies,that,deleting,one,of,them,via,the,link,blob,server,does,not,influence,the,other,param,job,id1,first,job,id,param,job,id2,second,job,id;private,void,test,delete,transient,nullable,job,id,job,id1,nullable,job,id,job,id2,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,data,data,length,data2,0,1,transient,blob,key,key1,transient,blob,key,put,server,job,id1,data,assert,not,null,key1,transient,blob,key,key2a,transient,blob,key,put,server,job,id2,data,assert,not,null,key2a,verify,key,different,hash,equals,key1,key2a,transient,blob,key,key2b,transient,blob,key,put,server,job,id2,data2,assert,not,null,key2b,assert,true,delete,server,job,id1,key1,verify,deleted,server,job,id1,key1,verify,contents,server,job,id2,key2a,data,verify,contents,server,job,id2,key2b,data2,assert,true,delete,server,job,id2,key2a,verify,deleted,server,job,id2,key2a,verify,contents,server,job,id2,key2b,data2,assert,true,delete,server,job,id2,key2b,verify,deleted,server,job,id2,key2b
BlobServerDeleteTest -> private void testDeleteTransient(@Nullable JobID jobId1, @Nullable JobID jobId2) 			throws IOException;1526549506;Uploads a (different) byte array for each of the given jobs and verifies that deleting one of_them (via the {@link BlobServer}) does not influence the other.__@param jobId1_first job id_@param jobId2_second job id;private void testDeleteTransient(@Nullable JobID jobId1, @Nullable JobID jobId2)_			throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			_			TransientBlobKey key1 = (TransientBlobKey) put(server, jobId1, data, TRANSIENT_BLOB)__			assertNotNull(key1)___			_			TransientBlobKey key2a = (TransientBlobKey) put(server, jobId2, data, TRANSIENT_BLOB)__			assertNotNull(key2a)__			verifyKeyDifferentHashEquals(key1, key2a)__			TransientBlobKey key2b = (TransientBlobKey) put(server, jobId2, data2, TRANSIENT_BLOB)__			assertNotNull(key2b)___			_			assertTrue(delete(server, jobId1, key1))___			verifyDeleted(server, jobId1, key1)__			_			_			verifyContents(server, jobId2, key2a, data)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(server, jobId2, key2a))__			verifyDeleted(server, jobId2, key2a)__			verifyContents(server, jobId2, key2b, data2)___			_			assertTrue(delete(server, jobId2, key2b))__			verifyDeleted(server, jobId2, key2b)__		}_	};uploads,a,different,byte,array,for,each,of,the,given,jobs,and,verifies,that,deleting,one,of,them,via,the,link,blob,server,does,not,influence,the,other,param,job,id1,first,job,id,param,job,id2,second,job,id;private,void,test,delete,transient,nullable,job,id,job,id1,nullable,job,id,job,id2,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,byte,data2,arrays,copy,of,data,data,length,data2,0,1,transient,blob,key,key1,transient,blob,key,put,server,job,id1,data,assert,not,null,key1,transient,blob,key,key2a,transient,blob,key,put,server,job,id2,data,assert,not,null,key2a,verify,key,different,hash,equals,key1,key2a,transient,blob,key,key2b,transient,blob,key,put,server,job,id2,data2,assert,not,null,key2b,assert,true,delete,server,job,id1,key1,verify,deleted,server,job,id1,key1,verify,contents,server,job,id2,key2a,data,verify,contents,server,job,id2,key2b,data2,assert,true,delete,server,job,id2,key2a,verify,deleted,server,job,id2,key2a,verify,contents,server,job,id2,key2b,data2,assert,true,delete,server,job,id2,key2b,verify,deleted,server,job,id2,key2b
BlobServerDeleteTest -> private void testDeleteTransientFails(@Nullable final JobID jobId) throws IOException;1507212387;Uploads a byte array for the given job and verifies that a delete operation (via the {@link_BlobServer}) does not fail even if the file is not deletable, e.g. via restricting the_permissions.__@param jobId_job id;private void testDeleteTransientFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				BlobKey key = put(server, jobId, data, false)__				assertNotNull(key)___				blobFile = server.getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				assertFalse(delete(server, jobId, key))___				_				verifyContents(server, jobId, key, data, false)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,delete,operation,via,the,link,blob,server,does,not,fail,even,if,the,file,is,not,deletable,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,delete,transient,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,key,put,server,job,id,data,false,assert,not,null,key,blob,file,server,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,assert,false,delete,server,job,id,key,verify,contents,server,job,id,key,data,false,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobServerDeleteTest -> private void testDeleteTransientFails(@Nullable final JobID jobId) throws IOException;1507212387;Uploads a byte array for the given job and verifies that a delete operation (via the {@link_BlobServer}) does not fail even if the file is not deletable, e.g. via restricting the_permissions.__@param jobId_job id;private void testDeleteTransientFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				blobFile = server.getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				assertFalse(delete(server, jobId, key))___				_				verifyContents(server, jobId, key, data)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,delete,operation,via,the,link,blob,server,does,not,fail,even,if,the,file,is,not,deletable,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,delete,transient,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,blob,file,server,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,assert,false,delete,server,job,id,key,verify,contents,server,job,id,key,data,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobServerDeleteTest -> private void testDeleteTransientFails(@Nullable final JobID jobId) throws IOException;1508138617;Uploads a byte array for the given job and verifies that a delete operation (via the {@link_BlobServer}) does not fail even if the file is not deletable, e.g. via restricting the_permissions.__@param jobId_job id;private void testDeleteTransientFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				blobFile = server.getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				assertFalse(delete(server, jobId, key))___				_				verifyContents(server, jobId, key, data)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,delete,operation,via,the,link,blob,server,does,not,fail,even,if,the,file,is,not,deletable,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,delete,transient,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,blob,file,server,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,assert,false,delete,server,job,id,key,verify,contents,server,job,id,key,data,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobServerDeleteTest -> private void testDeleteTransientFails(@Nullable final JobID jobId) throws IOException;1508578816;Uploads a byte array for the given job and verifies that a delete operation (via the {@link_BlobServer}) does not fail even if the file is not deletable, e.g. via restricting the_permissions.__@param jobId_job id;private void testDeleteTransientFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				blobFile = server.getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				assertFalse(delete(server, jobId, key))___				_				verifyContents(server, jobId, key, data)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,delete,operation,via,the,link,blob,server,does,not,fail,even,if,the,file,is,not,deletable,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,delete,transient,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,blob,file,server,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,assert,false,delete,server,job,id,key,verify,contents,server,job,id,key,data,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobServerDeleteTest -> private void testDeleteTransientFails(@Nullable final JobID jobId) throws IOException;1526549506;Uploads a byte array for the given job and verifies that a delete operation (via the {@link_BlobServer}) does not fail even if the file is not deletable, e.g. via restricting the_permissions.__@param jobId_job id;private void testDeleteTransientFails(@Nullable final JobID jobId) throws IOException {_		assumeTrue(!OperatingSystem.isWindows())_ __		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		File blobFile = null__		File directory = null___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			try {_				byte[] data = new byte[2000000]__				rnd.nextBytes(data)___				_				TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__				assertNotNull(key)___				blobFile = server.getStorageLocation(jobId, key)__				directory = blobFile.getParentFile()___				assertTrue(blobFile.setWritable(false, false))__				assertTrue(directory.setWritable(false, false))___				_				assertFalse(delete(server, jobId, key))___				_				verifyContents(server, jobId, key, data)__			} finally {_				if (blobFile != null && directory != null) {_					_					blobFile.setWritable(true, false)__					_					directory.setWritable(true, false)__				}_			}_		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,a,delete,operation,via,the,link,blob,server,does,not,fail,even,if,the,file,is,not,deletable,e,g,via,restricting,the,permissions,param,job,id,job,id;private,void,test,delete,transient,fails,nullable,final,job,id,job,id,throws,ioexception,assume,true,operating,system,is,windows,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,file,blob,file,null,file,directory,null,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,try,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,blob,file,server,get,storage,location,job,id,key,directory,blob,file,get,parent,file,assert,true,blob,file,set,writable,false,false,assert,true,directory,set,writable,false,false,assert,false,delete,server,job,id,key,verify,contents,server,job,id,key,data,finally,if,blob,file,null,directory,null,blob,file,set,writable,true,false,directory,set,writable,true,false
BlobServerDeleteTest -> static boolean delete(BlobService service, @Nullable JobID jobId, TransientBlobKey key);1507212387;Deletes a transient BLOB from the given BLOB service.__@param service_blob service_@param jobId_job ID (or <tt>null</tt> if job-unrelated)_@param key_blob key__@return delete success;static boolean delete(BlobService service, @Nullable JobID jobId, TransientBlobKey key) {_		if (jobId == null) {_			return service.getTransientBlobService().deleteFromCache(key)__		} else {_			return service.getTransientBlobService().deleteFromCache(jobId, key)__		}_	};deletes,a,transient,blob,from,the,given,blob,service,param,service,blob,service,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,key,blob,key,return,delete,success;static,boolean,delete,blob,service,service,nullable,job,id,job,id,transient,blob,key,key,if,job,id,null,return,service,get,transient,blob,service,delete,from,cache,key,else,return,service,get,transient,blob,service,delete,from,cache,job,id,key
BlobServerDeleteTest -> static boolean delete(BlobService service, @Nullable JobID jobId, TransientBlobKey key);1508138617;Deletes a transient BLOB from the given BLOB service.__@param service_blob service_@param jobId_job ID (or <tt>null</tt> if job-unrelated)_@param key_blob key__@return delete success;static boolean delete(BlobService service, @Nullable JobID jobId, TransientBlobKey key) {_		if (jobId == null) {_			return service.getTransientBlobService().deleteFromCache(key)__		} else {_			return service.getTransientBlobService().deleteFromCache(jobId, key)__		}_	};deletes,a,transient,blob,from,the,given,blob,service,param,service,blob,service,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,key,blob,key,return,delete,success;static,boolean,delete,blob,service,service,nullable,job,id,job,id,transient,blob,key,key,if,job,id,null,return,service,get,transient,blob,service,delete,from,cache,key,else,return,service,get,transient,blob,service,delete,from,cache,job,id,key
BlobServerDeleteTest -> static boolean delete(BlobService service, @Nullable JobID jobId, TransientBlobKey key);1508578816;Deletes a transient BLOB from the given BLOB service.__@param service_blob service_@param jobId_job ID (or <tt>null</tt> if job-unrelated)_@param key_blob key__@return delete success;static boolean delete(BlobService service, @Nullable JobID jobId, TransientBlobKey key) {_		if (jobId == null) {_			return service.getTransientBlobService().deleteFromCache(key)__		} else {_			return service.getTransientBlobService().deleteFromCache(jobId, key)__		}_	};deletes,a,transient,blob,from,the,given,blob,service,param,service,blob,service,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,key,blob,key,return,delete,success;static,boolean,delete,blob,service,service,nullable,job,id,job,id,transient,blob,key,key,if,job,id,null,return,service,get,transient,blob,service,delete,from,cache,key,else,return,service,get,transient,blob,service,delete,from,cache,job,id,key
BlobServerDeleteTest -> static boolean delete(BlobService service, @Nullable JobID jobId, TransientBlobKey key);1526549506;Deletes a transient BLOB from the given BLOB service.__@param service_blob service_@param jobId_job ID (or <tt>null</tt> if job-unrelated)_@param key_blob key__@return delete success;static boolean delete(BlobService service, @Nullable JobID jobId, TransientBlobKey key) {_		if (jobId == null) {_			return service.getTransientBlobService().deleteFromCache(key)__		} else {_			return service.getTransientBlobService().deleteFromCache(jobId, key)__		}_	};deletes,a,transient,blob,from,the,given,blob,service,param,service,blob,service,param,job,id,job,id,or,tt,null,tt,if,job,unrelated,param,key,blob,key,return,delete,success;static,boolean,delete,blob,service,service,nullable,job,id,job,id,transient,blob,key,key,if,job,id,null,return,service,get,transient,blob,service,delete,from,cache,key,else,return,service,get,transient,blob,service,delete,from,cache,job,id,key
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperationsForJob() throws IOException, ExecutionException, InterruptedException;1502701584;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperationsForJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentDeleteOperations(new JobID())__	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,for,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,delete,operations,new,job,id
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperationsForJob() throws IOException, ExecutionException, InterruptedException;1503041358;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperationsForJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentDeleteOperations(new JobID())__	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,for,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,delete,operations,new,job,id
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperationsForJob() throws IOException, ExecutionException, InterruptedException;1503041372;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperationsForJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentDeleteOperations(new JobID())__	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,for,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,delete,operations,new,job,id
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperationsForJob() throws IOException, ExecutionException, InterruptedException;1506417942;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperationsForJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentDeleteOperations(new JobID())__	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,for,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,delete,operations,new,job,id
BlobServerDeleteTest -> private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException;1507212387;Uploads a byte array for the given job and verifies that deleting it (via the {@link_BlobServer}) does not fail independent of whether the file exists.__@param jobId_job id;private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			BlobKey key = put(server, jobId, data, false)__			assertNotNull(key)___			File blobFile = server.getStorageLocation(jobId, key)__			assertTrue(blobFile.delete())___			_			assertTrue(delete(server, jobId, key))__			verifyDeleted(server, jobId, key, false)___			_			assertTrue(delete(server, jobId, key))__			verifyDeleted(server, jobId, key, false)__		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,deleting,it,via,the,link,blob,server,does,not,fail,independent,of,whether,the,file,exists,param,job,id,job,id;private,void,test,delete,transient,already,deleted,nullable,final,job,id,job,id,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,blob,key,key,put,server,job,id,data,false,assert,not,null,key,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,assert,true,delete,server,job,id,key,verify,deleted,server,job,id,key,false,assert,true,delete,server,job,id,key,verify,deleted,server,job,id,key,false
BlobServerDeleteTest -> private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException;1507212387;Uploads a byte array for the given job and verifies that deleting it (via the {@link_BlobServer}) does not fail independent of whether the file exists.__@param jobId_job id;private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			assertNotNull(key)___			File blobFile = server.getStorageLocation(jobId, key)__			assertTrue(blobFile.delete())___			_			assertTrue(delete(server, jobId, key))__			verifyDeleted(server, jobId, key)___			_			assertTrue(delete(server, jobId, key))__			verifyDeleted(server, jobId, key)__		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,deleting,it,via,the,link,blob,server,does,not,fail,independent,of,whether,the,file,exists,param,job,id,job,id;private,void,test,delete,transient,already,deleted,nullable,final,job,id,job,id,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,assert,true,delete,server,job,id,key,verify,deleted,server,job,id,key,assert,true,delete,server,job,id,key,verify,deleted,server,job,id,key
BlobServerDeleteTest -> private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException;1508138617;Uploads a byte array for the given job and verifies that deleting it (via the {@link_BlobServer}) does not fail independent of whether the file exists.__@param jobId_job id;private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			assertNotNull(key)___			File blobFile = server.getStorageLocation(jobId, key)__			assertTrue(blobFile.delete())___			_			assertTrue(delete(server, jobId, key))__			verifyDeleted(server, jobId, key)___			_			assertTrue(delete(server, jobId, key))__			verifyDeleted(server, jobId, key)__		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,deleting,it,via,the,link,blob,server,does,not,fail,independent,of,whether,the,file,exists,param,job,id,job,id;private,void,test,delete,transient,already,deleted,nullable,final,job,id,job,id,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,assert,true,delete,server,job,id,key,verify,deleted,server,job,id,key,assert,true,delete,server,job,id,key,verify,deleted,server,job,id,key
BlobServerDeleteTest -> private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException;1508578816;Uploads a byte array for the given job and verifies that deleting it (via the {@link_BlobServer}) does not fail independent of whether the file exists.__@param jobId_job id;private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			assertNotNull(key)___			File blobFile = server.getStorageLocation(jobId, key)__			assertTrue(blobFile.delete())___			_			assertTrue(delete(server, jobId, key))__			verifyDeleted(server, jobId, key)___			_			assertTrue(delete(server, jobId, key))__			verifyDeleted(server, jobId, key)__		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,deleting,it,via,the,link,blob,server,does,not,fail,independent,of,whether,the,file,exists,param,job,id,job,id;private,void,test,delete,transient,already,deleted,nullable,final,job,id,job,id,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,assert,true,delete,server,job,id,key,verify,deleted,server,job,id,key,assert,true,delete,server,job,id,key,verify,deleted,server,job,id,key
BlobServerDeleteTest -> private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException;1526549506;Uploads a byte array for the given job and verifies that deleting it (via the {@link_BlobServer}) does not fail independent of whether the file exists.__@param jobId_job id;private void testDeleteTransientAlreadyDeleted(@Nullable final JobID jobId) throws IOException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			byte[] data = new byte[2000000]__			rnd.nextBytes(data)___			_			TransientBlobKey key = (TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)__			assertNotNull(key)___			File blobFile = server.getStorageLocation(jobId, key)__			assertTrue(blobFile.delete())___			_			assertTrue(delete(server, jobId, key))__			verifyDeleted(server, jobId, key)___			_			assertTrue(delete(server, jobId, key))__			verifyDeleted(server, jobId, key)__		}_	};uploads,a,byte,array,for,the,given,job,and,verifies,that,deleting,it,via,the,link,blob,server,does,not,fail,independent,of,whether,the,file,exists,param,job,id,job,id;private,void,test,delete,transient,already,deleted,nullable,final,job,id,job,id,throws,ioexception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,byte,data,new,byte,2000000,rnd,next,bytes,data,transient,blob,key,key,transient,blob,key,put,server,job,id,data,assert,not,null,key,file,blob,file,server,get,storage,location,job,id,key,assert,true,blob,file,delete,assert,true,delete,server,job,id,key,verify,deleted,server,job,id,key,assert,true,delete,server,job,id,key,verify,deleted,server,job,id,key
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException;1495001945;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException {_		final Configuration configuration = new Configuration()__		final BlobStore blobStore = mock(BlobStore.class)___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<Future<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer blobServer = new BlobServer(configuration, blobStore)) {__			final BlobKey blobKey___			try (BlobClient client = blobServer.createClient()) {_				blobKey = client.put(data)__			}__			assertTrue(blobServer.getStorageLocation(blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				Future<Void> deleteFuture = FlinkCompletableFuture.supplyAsync(new Callable<Void>() {_					@Override_					public Void call() throws Exception {_						try (BlobClient blobClient = blobServer.createClient()) {_							blobClient.delete(blobKey)__						}__						return null__					}_				}, executor)___				deleteFutures.add(deleteFuture)__			}__			Future<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(blobServer.getStorageLocation(blobKey).exists())__		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,throws,ioexception,execution,exception,interrupted,exception,final,configuration,configuration,new,configuration,final,blob,store,blob,store,mock,blob,store,class,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,blob,server,new,blob,server,configuration,blob,store,final,blob,key,blob,key,try,blob,client,client,blob,server,create,client,blob,key,client,put,data,assert,true,blob,server,get,storage,location,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,future,void,delete,future,flink,completable,future,supply,async,new,callable,void,override,public,void,call,throws,exception,try,blob,client,blob,client,blob,server,create,client,blob,client,delete,blob,key,return,null,executor,delete,futures,add,delete,future,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,blob,server,get,storage,location,blob,key,exists,finally,executor,shutdown,now
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException;1499173045;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException {_		final Configuration configuration = new Configuration()__		final BlobStore blobStore = mock(BlobStore.class)___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<Future<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer blobServer = new BlobServer(configuration, blobStore)) {__			final BlobKey blobKey___			try (BlobClient client = blobServer.createClient()) {_				blobKey = client.put(data)__			}__			assertTrue(blobServer.getStorageLocation(blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				Future<Void> deleteFuture = FlinkCompletableFuture.supplyAsync(new Callable<Void>() {_					@Override_					public Void call() throws Exception {_						try (BlobClient blobClient = blobServer.createClient()) {_							blobClient.delete(blobKey)__						}__						return null__					}_				}, executor)___				deleteFutures.add(deleteFuture)__			}__			Future<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(blobServer.getStorageLocation(blobKey).exists())__		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,throws,ioexception,execution,exception,interrupted,exception,final,configuration,configuration,new,configuration,final,blob,store,blob,store,mock,blob,store,class,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,blob,server,new,blob,server,configuration,blob,store,final,blob,key,blob,key,try,blob,client,client,blob,server,create,client,blob,key,client,put,data,assert,true,blob,server,get,storage,location,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,future,void,delete,future,flink,completable,future,supply,async,new,callable,void,override,public,void,call,throws,exception,try,blob,client,blob,client,blob,server,create,client,blob,client,delete,blob,key,return,null,executor,delete,futures,add,delete,future,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,blob,server,get,storage,location,blob,key,exists,finally,executor,shutdown,now
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException;1499789965;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException {_		final Configuration configuration = new Configuration()__		final BlobStore blobStore = mock(BlobStore.class)___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<Future<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer blobServer = new BlobServer(configuration, blobStore)) {__			final BlobKey blobKey___			try (BlobClient client = blobServer.createClient()) {_				blobKey = client.put(data)__			}__			assertTrue(blobServer.getStorageLocation(blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				Future<Void> deleteFuture = FlinkCompletableFuture.supplyAsync(new Callable<Void>() {_					@Override_					public Void call() throws Exception {_						try (BlobClient blobClient = blobServer.createClient()) {_							blobClient.delete(blobKey)__						}__						return null__					}_				}, executor)___				deleteFutures.add(deleteFuture)__			}__			Future<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(blobServer.getStorageLocation(blobKey).exists())__		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,throws,ioexception,execution,exception,interrupted,exception,final,configuration,configuration,new,configuration,final,blob,store,blob,store,mock,blob,store,class,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,blob,server,new,blob,server,configuration,blob,store,final,blob,key,blob,key,try,blob,client,client,blob,server,create,client,blob,key,client,put,data,assert,true,blob,server,get,storage,location,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,future,void,delete,future,flink,completable,future,supply,async,new,callable,void,override,public,void,call,throws,exception,try,blob,client,blob,client,blob,server,create,client,blob,client,delete,blob,key,return,null,executor,delete,futures,add,delete,future,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,blob,server,get,storage,location,blob,key,exists,finally,executor,shutdown,now
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException;1501622876;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException {_		final Configuration configuration = new Configuration()__		final BlobStore blobStore = mock(BlobStore.class)___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer blobServer = new BlobServer(configuration, blobStore)) {__			final BlobKey blobKey___			try (BlobClient client = blobServer.createClient()) {_				blobKey = client.put(data)__			}__			assertTrue(blobServer.getStorageLocation(blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture.supplyAsync(_					() -> {_						try (BlobClient blobClient = blobServer.createClient()) {_							blobClient.delete(blobKey)__						} catch (IOException e) {_							throw new FlinkFutureException("Could not delete the given blob key " + blobKey + '.', e)__						}__						return null__					},_					executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(blobServer.getStorageLocation(blobKey).exists())__		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,throws,ioexception,execution,exception,interrupted,exception,final,configuration,configuration,new,configuration,final,blob,store,blob,store,mock,blob,store,class,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,blob,server,new,blob,server,configuration,blob,store,final,blob,key,blob,key,try,blob,client,client,blob,server,create,client,blob,key,client,put,data,assert,true,blob,server,get,storage,location,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,blob,client,blob,client,blob,server,create,client,blob,client,delete,blob,key,catch,ioexception,e,throw,new,flink,future,exception,could,not,delete,the,given,blob,key,blob,key,e,return,null,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,blob,server,get,storage,location,blob,key,exists,finally,executor,shutdown,now
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException;1502100084;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException {_		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final BlobStore blobStore = mock(BlobStore.class)___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer blobServer = new BlobServer(config, blobStore)) {__			final BlobKey blobKey___			try (BlobClient client = blobServer.createClient()) {_				blobKey = client.put(data)__			}__			assertTrue(blobServer.getStorageLocation(blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture.supplyAsync(_					() -> {_						try (BlobClient blobClient = blobServer.createClient()) {_							blobClient.delete(blobKey)__						} catch (IOException e) {_							throw new FlinkFutureException("Could not delete the given blob key " + blobKey + '.', e)__						}__						return null__					},_					executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(blobServer.getStorageLocation(blobKey).exists())__		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,throws,ioexception,execution,exception,interrupted,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,blob,store,blob,store,mock,blob,store,class,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,blob,server,new,blob,server,config,blob,store,final,blob,key,blob,key,try,blob,client,client,blob,server,create,client,blob,key,client,put,data,assert,true,blob,server,get,storage,location,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,blob,client,blob,client,blob,server,create,client,blob,client,delete,blob,key,catch,ioexception,e,throw,new,flink,future,exception,could,not,delete,the,given,blob,key,blob,key,e,return,null,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,blob,server,get,storage,location,blob,key,exists,finally,executor,shutdown,now
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException;1502692653;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperations() throws IOException, ExecutionException, InterruptedException {_		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final BlobStore blobStore = mock(BlobStore.class)___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer blobServer = new BlobServer(config, blobStore)) {__			final BlobKey blobKey___			try (BlobClient client = blobServer.createClient()) {_				blobKey = client.put(data)__			}__			assertTrue(blobServer.getStorageLocation(blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture.supplyAsync(_					() -> {_						try (BlobClient blobClient = blobServer.createClient()) {_							blobClient.delete(blobKey)__						} catch (IOException e) {_							throw new FlinkFutureException("Could not delete the given blob key " + blobKey + '.', e)__						}__						return null__					},_					executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(blobServer.getStorageLocation(blobKey).exists())__		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,throws,ioexception,execution,exception,interrupted,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,blob,store,blob,store,mock,blob,store,class,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,blob,server,new,blob,server,config,blob,store,final,blob,key,blob,key,try,blob,client,client,blob,server,create,client,blob,key,client,put,data,assert,true,blob,server,get,storage,location,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,blob,client,blob,client,blob,server,create,client,blob,client,delete,blob,key,catch,ioexception,e,throw,new,flink,future,exception,could,not,delete,the,given,blob,key,blob,key,e,return,null,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,blob,server,get,storage,location,blob,key,exists,finally,executor,shutdown,now
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperationsNoJob() throws IOException, ExecutionException, InterruptedException;1502701584;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperationsNoJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentDeleteOperations(null)__	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,no,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,delete,operations,null
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperationsNoJob() throws IOException, ExecutionException, InterruptedException;1503041358;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperationsNoJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentDeleteOperations(null)__	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,no,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,delete,operations,null
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperationsNoJob() throws IOException, ExecutionException, InterruptedException;1503041372;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperationsNoJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentDeleteOperations(null)__	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,no,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,delete,operations,null
BlobServerDeleteTest -> @Test 	public void testConcurrentDeleteOperationsNoJob() throws IOException, ExecutionException, InterruptedException;1506417942;FLINK-6020__Tests that concurrent delete operations don't interfere with each other.__Note: The test checks that there cannot be two threads which have checked whether a given blob file exist_and then one of them fails deleting it. Without the introduced lock, this situation should rarely happen_and make this test fail. Thus, if this test should become "unstable", then the delete atomicity is most likely_broken.;@Test_	public void testConcurrentDeleteOperationsNoJob() throws IOException, ExecutionException, InterruptedException {_		testConcurrentDeleteOperations(null)__	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,note,the,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken;test,public,void,test,concurrent,delete,operations,no,job,throws,ioexception,execution,exception,interrupted,exception,test,concurrent,delete,operations,null
BlobServerDeleteTest -> private void testJobCleanup(BlobKey.BlobType blobType) throws IOException;1507212387;Tests that {@link BlobServer} cleans up after calling {@link BlobServer#cleanupJob(JobID)}.__@param blobType_whether the BLOB should become permanent or transient;private void testJobCleanup(BlobKey.BlobType blobType) throws IOException {_		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			final byte[] data = new byte[128]__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			BlobKey key1a = put(server, jobId1, data, blobType)__			BlobKey key2 = put(server, jobId2, data, blobType)__			assertEquals(key1a, key2)___			BlobKey key1b = put(server, jobId1, data2, blobType)___			verifyContents(server, jobId1, key1a, data)__			verifyContents(server, jobId1, key1b, data2)__			checkFileCountForJob(2, jobId1, server)___			verifyContents(server, jobId2, key2, data)__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId1)___			verifyDeleted(server, jobId1, key1a)__			verifyDeleted(server, jobId1, key1b)__			checkFileCountForJob(0, jobId1, server)__			verifyContents(server, jobId2, key2, data)__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId2)___			checkFileCountForJob(0, jobId1, server)__			verifyDeleted(server, jobId2, key2)__			checkFileCountForJob(0, jobId2, server)___			_			server.cleanupJob(jobId2)__		}_	};tests,that,link,blob,server,cleans,up,after,calling,link,blob,server,cleanup,job,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,job,cleanup,blob,key,blob,type,blob,type,throws,ioexception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,final,byte,data,new,byte,128,byte,data2,arrays,copy,of,data,data,length,data2,0,1,blob,key,key1a,put,server,job,id1,data,blob,type,blob,key,key2,put,server,job,id2,data,blob,type,assert,equals,key1a,key2,blob,key,key1b,put,server,job,id1,data2,blob,type,verify,contents,server,job,id1,key1a,data,verify,contents,server,job,id1,key1b,data2,check,file,count,for,job,2,job,id1,server,verify,contents,server,job,id2,key2,data,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id1,verify,deleted,server,job,id1,key1a,verify,deleted,server,job,id1,key1b,check,file,count,for,job,0,job,id1,server,verify,contents,server,job,id2,key2,data,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id2,check,file,count,for,job,0,job,id1,server,verify,deleted,server,job,id2,key2,check,file,count,for,job,0,job,id2,server,server,cleanup,job,job,id2
BlobServerDeleteTest -> private void testJobCleanup(BlobKey.BlobType blobType) throws IOException;1508138617;Tests that {@link BlobServer} cleans up after calling {@link BlobServer#cleanupJob(JobID)}.__@param blobType_whether the BLOB should become permanent or transient;private void testJobCleanup(BlobKey.BlobType blobType) throws IOException {_		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			final byte[] data = new byte[128]__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			BlobKey key1a = put(server, jobId1, data, blobType)__			BlobKey key2 = put(server, jobId2, data, blobType)__			assertArrayEquals(key1a.getHash(), key2.getHash())___			BlobKey key1b = put(server, jobId1, data2, blobType)___			verifyContents(server, jobId1, key1a, data)__			verifyContents(server, jobId1, key1b, data2)__			checkFileCountForJob(2, jobId1, server)___			verifyContents(server, jobId2, key2, data)__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId1)___			verifyDeleted(server, jobId1, key1a)__			verifyDeleted(server, jobId1, key1b)__			checkFileCountForJob(0, jobId1, server)__			verifyContents(server, jobId2, key2, data)__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId2)___			checkFileCountForJob(0, jobId1, server)__			verifyDeleted(server, jobId2, key2)__			checkFileCountForJob(0, jobId2, server)___			_			server.cleanupJob(jobId2)__		}_	};tests,that,link,blob,server,cleans,up,after,calling,link,blob,server,cleanup,job,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,job,cleanup,blob,key,blob,type,blob,type,throws,ioexception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,final,byte,data,new,byte,128,byte,data2,arrays,copy,of,data,data,length,data2,0,1,blob,key,key1a,put,server,job,id1,data,blob,type,blob,key,key2,put,server,job,id2,data,blob,type,assert,array,equals,key1a,get,hash,key2,get,hash,blob,key,key1b,put,server,job,id1,data2,blob,type,verify,contents,server,job,id1,key1a,data,verify,contents,server,job,id1,key1b,data2,check,file,count,for,job,2,job,id1,server,verify,contents,server,job,id2,key2,data,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id1,verify,deleted,server,job,id1,key1a,verify,deleted,server,job,id1,key1b,check,file,count,for,job,0,job,id1,server,verify,contents,server,job,id2,key2,data,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id2,check,file,count,for,job,0,job,id1,server,verify,deleted,server,job,id2,key2,check,file,count,for,job,0,job,id2,server,server,cleanup,job,job,id2
BlobServerDeleteTest -> private void testJobCleanup(BlobKey.BlobType blobType) throws IOException;1508578816;Tests that {@link BlobServer} cleans up after calling {@link BlobServer#cleanupJob(JobID)}.__@param blobType_whether the BLOB should become permanent or transient;private void testJobCleanup(BlobKey.BlobType blobType) throws IOException {_		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			final byte[] data = new byte[128]__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			BlobKey key1a = put(server, jobId1, data, blobType)__			BlobKey key2 = put(server, jobId2, data, blobType)__			assertArrayEquals(key1a.getHash(), key2.getHash())___			BlobKey key1b = put(server, jobId1, data2, blobType)___			verifyContents(server, jobId1, key1a, data)__			verifyContents(server, jobId1, key1b, data2)__			checkFileCountForJob(2, jobId1, server)___			verifyContents(server, jobId2, key2, data)__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId1)___			verifyDeleted(server, jobId1, key1a)__			verifyDeleted(server, jobId1, key1b)__			checkFileCountForJob(0, jobId1, server)__			verifyContents(server, jobId2, key2, data)__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId2)___			checkFileCountForJob(0, jobId1, server)__			verifyDeleted(server, jobId2, key2)__			checkFileCountForJob(0, jobId2, server)___			_			server.cleanupJob(jobId2)__		}_	};tests,that,link,blob,server,cleans,up,after,calling,link,blob,server,cleanup,job,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,job,cleanup,blob,key,blob,type,blob,type,throws,ioexception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,final,byte,data,new,byte,128,byte,data2,arrays,copy,of,data,data,length,data2,0,1,blob,key,key1a,put,server,job,id1,data,blob,type,blob,key,key2,put,server,job,id2,data,blob,type,assert,array,equals,key1a,get,hash,key2,get,hash,blob,key,key1b,put,server,job,id1,data2,blob,type,verify,contents,server,job,id1,key1a,data,verify,contents,server,job,id1,key1b,data2,check,file,count,for,job,2,job,id1,server,verify,contents,server,job,id2,key2,data,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id1,verify,deleted,server,job,id1,key1a,verify,deleted,server,job,id1,key1b,check,file,count,for,job,0,job,id1,server,verify,contents,server,job,id2,key2,data,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id2,check,file,count,for,job,0,job,id1,server,verify,deleted,server,job,id2,key2,check,file,count,for,job,0,job,id2,server,server,cleanup,job,job,id2
BlobServerDeleteTest -> private void testJobCleanup(BlobKey.BlobType blobType) throws IOException;1526549506;Tests that {@link BlobServer} cleans up after calling {@link BlobServer#cleanupJob(JobID)}.__@param blobType_whether the BLOB should become permanent or transient;private void testJobCleanup(BlobKey.BlobType blobType) throws IOException {_		JobID jobId1 = new JobID()__		JobID jobId2 = new JobID()___		Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY,_			temporaryFolder.newFolder().getAbsolutePath())___		try (BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			final byte[] data = new byte[128]__			byte[] data2 = Arrays.copyOf(data, data.length)__			data2[0] ^= 1___			BlobKey key1a = put(server, jobId1, data, blobType)__			BlobKey key2 = put(server, jobId2, data, blobType)__			assertArrayEquals(key1a.getHash(), key2.getHash())___			BlobKey key1b = put(server, jobId1, data2, blobType)___			verifyContents(server, jobId1, key1a, data)__			verifyContents(server, jobId1, key1b, data2)__			checkFileCountForJob(2, jobId1, server)___			verifyContents(server, jobId2, key2, data)__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId1, true)___			verifyDeleted(server, jobId1, key1a)__			verifyDeleted(server, jobId1, key1b)__			checkFileCountForJob(0, jobId1, server)__			verifyContents(server, jobId2, key2, data)__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId2, true)___			checkFileCountForJob(0, jobId1, server)__			verifyDeleted(server, jobId2, key2)__			checkFileCountForJob(0, jobId2, server)___			_			server.cleanupJob(jobId2, true)__		}_	};tests,that,link,blob,server,cleans,up,after,calling,link,blob,server,cleanup,job,job,id,param,blob,type,whether,the,blob,should,become,permanent,or,transient;private,void,test,job,cleanup,blob,key,blob,type,blob,type,throws,ioexception,job,id,job,id1,new,job,id,job,id,job,id2,new,job,id,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,try,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,final,byte,data,new,byte,128,byte,data2,arrays,copy,of,data,data,length,data2,0,1,blob,key,key1a,put,server,job,id1,data,blob,type,blob,key,key2,put,server,job,id2,data,blob,type,assert,array,equals,key1a,get,hash,key2,get,hash,blob,key,key1b,put,server,job,id1,data2,blob,type,verify,contents,server,job,id1,key1a,data,verify,contents,server,job,id1,key1b,data2,check,file,count,for,job,2,job,id1,server,verify,contents,server,job,id2,key2,data,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id1,true,verify,deleted,server,job,id1,key1a,verify,deleted,server,job,id1,key1b,check,file,count,for,job,0,job,id1,server,verify,contents,server,job,id2,key2,data,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id2,true,check,file,count,for,job,0,job,id1,server,verify,deleted,server,job,id2,key2,check,file,count,for,job,0,job,id2,server,server,cleanup,job,job,id2,true
BlobServerDeleteTest -> @Test 	public void testJobCleanup() throws IOException, InterruptedException;1503041372;Tests that {@link BlobServer} cleans up after calling {@link BlobServer#cleanupJob(JobID)}.;@Test_	public void testJobCleanup() throws IOException, InterruptedException {__		JobID jobId1 = new JobID()__		List<BlobKey> keys1 = new ArrayList<BlobKey>()__		JobID jobId2 = new JobID()__		List<BlobKey> keys2 = new ArrayList<BlobKey>()__		BlobServer server = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			BlobClient bc = new BlobClient(serverAddress, config)___			keys1.add(bc.put(jobId1, buf))__			keys2.add(bc.put(jobId2, buf))__			assertEquals(keys2.get(0), keys1.get(0))___			buf[0] += 1__			keys1.add(bc.put(jobId1, buf))___			bc.close()___			assertEquals(2, checkFilesExist(jobId1, keys1, server, true))__			checkFileCountForJob(2, jobId1, server)__			assertEquals(1, checkFilesExist(jobId2, keys2, server, true))__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId1)___			checkFileCountForJob(0, jobId1, server)__			assertEquals(1, checkFilesExist(jobId2, keys2, server, true))__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId2)___			checkFileCountForJob(0, jobId1, server)__			checkFileCountForJob(0, jobId2, server)___			_			server.cleanupJob(jobId2)__		}_		finally {_			if (server != null) {_				server.close()__			}_		}_	};tests,that,link,blob,server,cleans,up,after,calling,link,blob,server,cleanup,job,job,id;test,public,void,test,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id1,new,job,id,list,blob,key,keys1,new,array,list,blob,key,job,id,job,id2,new,job,id,list,blob,key,keys2,new,array,list,blob,key,blob,server,server,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,blob,client,bc,new,blob,client,server,address,config,keys1,add,bc,put,job,id1,buf,keys2,add,bc,put,job,id2,buf,assert,equals,keys2,get,0,keys1,get,0,buf,0,1,keys1,add,bc,put,job,id1,buf,bc,close,assert,equals,2,check,files,exist,job,id1,keys1,server,true,check,file,count,for,job,2,job,id1,server,assert,equals,1,check,files,exist,job,id2,keys2,server,true,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id1,check,file,count,for,job,0,job,id1,server,assert,equals,1,check,files,exist,job,id2,keys2,server,true,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id2,check,file,count,for,job,0,job,id1,server,check,file,count,for,job,0,job,id2,server,server,cleanup,job,job,id2,finally,if,server,null,server,close
BlobServerDeleteTest -> @Test 	public void testJobCleanup() throws IOException, InterruptedException;1506417942;Tests that {@link BlobServer} cleans up after calling {@link BlobServer#cleanupJob(JobID)}.;@Test_	public void testJobCleanup() throws IOException, InterruptedException {__		JobID jobId1 = new JobID()__		List<BlobKey> keys1 = new ArrayList<BlobKey>()__		JobID jobId2 = new JobID()__		List<BlobKey> keys2 = new ArrayList<BlobKey>()__		BlobServer server = null___		final byte[] buf = new byte[128]___		try {_			Configuration config = new Configuration()__			config.setString(BlobServerOptions.STORAGE_DIRECTORY,_				temporaryFolder.newFolder().getAbsolutePath())___			server = new BlobServer(config, new VoidBlobStore())__			InetSocketAddress serverAddress = new InetSocketAddress("localhost", server.getPort())__			BlobClient bc = new BlobClient(serverAddress, config)___			keys1.add(bc.put(jobId1, buf))__			keys2.add(bc.put(jobId2, buf))__			assertEquals(keys2.get(0), keys1.get(0))___			buf[0] += 1__			keys1.add(bc.put(jobId1, buf))___			bc.close()___			assertEquals(2, checkFilesExist(jobId1, keys1, server, true))__			checkFileCountForJob(2, jobId1, server)__			assertEquals(1, checkFilesExist(jobId2, keys2, server, true))__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId1)___			checkFileCountForJob(0, jobId1, server)__			assertEquals(1, checkFilesExist(jobId2, keys2, server, true))__			checkFileCountForJob(1, jobId2, server)___			server.cleanupJob(jobId2)___			checkFileCountForJob(0, jobId1, server)__			checkFileCountForJob(0, jobId2, server)___			_			server.cleanupJob(jobId2)__		}_		finally {_			if (server != null) {_				server.close()__			}_		}_	};tests,that,link,blob,server,cleans,up,after,calling,link,blob,server,cleanup,job,job,id;test,public,void,test,job,cleanup,throws,ioexception,interrupted,exception,job,id,job,id1,new,job,id,list,blob,key,keys1,new,array,list,blob,key,job,id,job,id2,new,job,id,list,blob,key,keys2,new,array,list,blob,key,blob,server,server,null,final,byte,buf,new,byte,128,try,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,server,new,blob,server,config,new,void,blob,store,inet,socket,address,server,address,new,inet,socket,address,localhost,server,get,port,blob,client,bc,new,blob,client,server,address,config,keys1,add,bc,put,job,id1,buf,keys2,add,bc,put,job,id2,buf,assert,equals,keys2,get,0,keys1,get,0,buf,0,1,keys1,add,bc,put,job,id1,buf,bc,close,assert,equals,2,check,files,exist,job,id1,keys1,server,true,check,file,count,for,job,2,job,id1,server,assert,equals,1,check,files,exist,job,id2,keys2,server,true,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id1,check,file,count,for,job,0,job,id1,server,assert,equals,1,check,files,exist,job,id2,keys2,server,true,check,file,count,for,job,1,job,id2,server,server,cleanup,job,job,id2,check,file,count,for,job,0,job,id1,server,check,file,count,for,job,0,job,id2,server,server,cleanup,job,job,id2,finally,if,server,null,server,close
BlobServerDeleteTest -> private void testConcurrentDeleteOperations(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1507212387;[FLINK-6020] Tests that concurrent delete operations don't interfere with each other.__<p>Note: This test checks that there cannot be two threads which have checked whether a given_blob file exist and then one of them fails deleting it. Without the introduced lock, this_situation should rarely happen and make this test fail. Thus, if this test should become_"unstable", then the delete atomicity is most likely broken.__@param jobId_job ID to use (or <tt>null</tt> if job-unrelated);private void testConcurrentDeleteOperations(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			final BlobKey blobKey = put(server, jobId, data, false)___			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture.supplyAsync(_					() -> {_						try {_							assertTrue(delete(server, jobId, blobKey))__							assertFalse(server.getStorageLocation(jobId, blobKey).exists())__							return null__						} catch (IOException e) {_							throw new CompletionException(new FlinkException(_								"Could not delete the given blob key " + blobKey + '.'))__						}_					},_				executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(server.getStorageLocation(jobId, blobKey).exists())___		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,p,note,this,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated;private,void,test,concurrent,delete,operations,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,final,blob,key,blob,key,put,server,job,id,data,false,assert,true,server,get,storage,location,job,id,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,assert,true,delete,server,job,id,blob,key,assert,false,server,get,storage,location,job,id,blob,key,exists,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,delete,the,given,blob,key,blob,key,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,server,get,storage,location,job,id,blob,key,exists,finally,executor,shutdown,now
BlobServerDeleteTest -> private void testConcurrentDeleteOperations(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1507212387;[FLINK-6020] Tests that concurrent delete operations don't interfere with each other.__<p>Note: This test checks that there cannot be two threads which have checked whether a given_blob file exist and then one of them fails deleting it. Without the introduced lock, this_situation should rarely happen and make this test fail. Thus, if this test should become_"unstable", then the delete atomicity is most likely broken.__@param jobId_job ID to use (or <tt>null</tt> if job-unrelated);private void testConcurrentDeleteOperations(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			final TransientBlobKey blobKey =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)___			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture.supplyAsync(_					() -> {_						try {_							assertTrue(delete(server, jobId, blobKey))__							assertFalse(server.getStorageLocation(jobId, blobKey).exists())__							return null__						} catch (IOException e) {_							throw new CompletionException(new FlinkException(_								"Could not delete the given blob key " + blobKey + '.'))__						}_					},_				executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(server.getStorageLocation(jobId, blobKey).exists())___		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,p,note,this,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated;private,void,test,concurrent,delete,operations,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,final,transient,blob,key,blob,key,transient,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,assert,true,delete,server,job,id,blob,key,assert,false,server,get,storage,location,job,id,blob,key,exists,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,delete,the,given,blob,key,blob,key,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,server,get,storage,location,job,id,blob,key,exists,finally,executor,shutdown,now
BlobServerDeleteTest -> private void testConcurrentDeleteOperations(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1508138617;[FLINK-6020] Tests that concurrent delete operations don't interfere with each other.__<p>Note: This test checks that there cannot be two threads which have checked whether a given_blob file exist and then one of them fails deleting it. Without the introduced lock, this_situation should rarely happen and make this test fail. Thus, if this test should become_"unstable", then the delete atomicity is most likely broken.__@param jobId_job ID to use (or <tt>null</tt> if job-unrelated);private void testConcurrentDeleteOperations(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			final TransientBlobKey blobKey =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)___			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture.supplyAsync(_					() -> {_						try {_							assertTrue(delete(server, jobId, blobKey))__							assertFalse(server.getStorageLocation(jobId, blobKey).exists())__							return null__						} catch (IOException e) {_							throw new CompletionException(new FlinkException(_								"Could not delete the given blob key " + blobKey + '.'))__						}_					},_				executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(server.getStorageLocation(jobId, blobKey).exists())___		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,p,note,this,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated;private,void,test,concurrent,delete,operations,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,final,transient,blob,key,blob,key,transient,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,assert,true,delete,server,job,id,blob,key,assert,false,server,get,storage,location,job,id,blob,key,exists,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,delete,the,given,blob,key,blob,key,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,server,get,storage,location,job,id,blob,key,exists,finally,executor,shutdown,now
BlobServerDeleteTest -> private void testConcurrentDeleteOperations(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1508578816;[FLINK-6020] Tests that concurrent delete operations don't interfere with each other.__<p>Note: This test checks that there cannot be two threads which have checked whether a given_blob file exist and then one of them fails deleting it. Without the introduced lock, this_situation should rarely happen and make this test fail. Thus, if this test should become_"unstable", then the delete atomicity is most likely broken.__@param jobId_job ID to use (or <tt>null</tt> if job-unrelated);private void testConcurrentDeleteOperations(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			final TransientBlobKey blobKey =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)___			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture.supplyAsync(_					() -> {_						try {_							assertTrue(delete(server, jobId, blobKey))__							assertFalse(server.getStorageLocation(jobId, blobKey).exists())__							return null__						} catch (IOException e) {_							throw new CompletionException(new FlinkException(_								"Could not delete the given blob key " + blobKey + '.'))__						}_					},_				executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(server.getStorageLocation(jobId, blobKey).exists())___		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,p,note,this,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated;private,void,test,concurrent,delete,operations,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,final,transient,blob,key,blob,key,transient,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,assert,true,delete,server,job,id,blob,key,assert,false,server,get,storage,location,job,id,blob,key,exists,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,delete,the,given,blob,key,blob,key,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,server,get,storage,location,job,id,blob,key,exists,finally,executor,shutdown,now
BlobServerDeleteTest -> private void testConcurrentDeleteOperations(@Nullable final JobID jobId) 			throws IOException, InterruptedException, ExecutionException;1526549506;[FLINK-6020] Tests that concurrent delete operations don't interfere with each other.__<p>Note: This test checks that there cannot be two threads which have checked whether a given_blob file exist and then one of them fails deleting it. Without the introduced lock, this_situation should rarely happen and make this test fail. Thus, if this test should become_"unstable", then the delete atomicity is most likely broken.__@param jobId_job ID to use (or <tt>null</tt> if job-unrelated);private void testConcurrentDeleteOperations(@Nullable final JobID jobId)_			throws IOException, InterruptedException, ExecutionException {__		final Configuration config = new Configuration()__		config.setString(BlobServerOptions.STORAGE_DIRECTORY, temporaryFolder.newFolder().getAbsolutePath())___		final int concurrentDeleteOperations = 3__		final ExecutorService executor = Executors.newFixedThreadPool(concurrentDeleteOperations)___		final List<CompletableFuture<Void>> deleteFutures = new ArrayList<>(concurrentDeleteOperations)___		final byte[] data = {1, 2, 3}___		try (final BlobServer server = new BlobServer(config, new VoidBlobStore())) {__			server.start()___			final TransientBlobKey blobKey =_				(TransientBlobKey) put(server, jobId, data, TRANSIENT_BLOB)___			assertTrue(server.getStorageLocation(jobId, blobKey).exists())___			for (int i = 0_ i < concurrentDeleteOperations_ i++) {_				CompletableFuture<Void> deleteFuture = CompletableFuture.supplyAsync(_					() -> {_						try {_							assertTrue(delete(server, jobId, blobKey))__							assertFalse(server.getStorageLocation(jobId, blobKey).exists())__							return null__						} catch (IOException e) {_							throw new CompletionException(new FlinkException(_								"Could not delete the given blob key " + blobKey + '.'))__						}_					},_				executor)___				deleteFutures.add(deleteFuture)__			}__			CompletableFuture<Void> waitFuture = FutureUtils.waitForAll(deleteFutures)___			_			_			waitFuture.get()___			assertFalse(server.getStorageLocation(jobId, blobKey).exists())___		} finally {_			executor.shutdownNow()__		}_	};flink,6020,tests,that,concurrent,delete,operations,don,t,interfere,with,each,other,p,note,this,test,checks,that,there,cannot,be,two,threads,which,have,checked,whether,a,given,blob,file,exist,and,then,one,of,them,fails,deleting,it,without,the,introduced,lock,this,situation,should,rarely,happen,and,make,this,test,fail,thus,if,this,test,should,become,unstable,then,the,delete,atomicity,is,most,likely,broken,param,job,id,job,id,to,use,or,tt,null,tt,if,job,unrelated;private,void,test,concurrent,delete,operations,nullable,final,job,id,job,id,throws,ioexception,interrupted,exception,execution,exception,final,configuration,config,new,configuration,config,set,string,blob,server,options,temporary,folder,new,folder,get,absolute,path,final,int,concurrent,delete,operations,3,final,executor,service,executor,executors,new,fixed,thread,pool,concurrent,delete,operations,final,list,completable,future,void,delete,futures,new,array,list,concurrent,delete,operations,final,byte,data,1,2,3,try,final,blob,server,server,new,blob,server,config,new,void,blob,store,server,start,final,transient,blob,key,blob,key,transient,blob,key,put,server,job,id,data,assert,true,server,get,storage,location,job,id,blob,key,exists,for,int,i,0,i,concurrent,delete,operations,i,completable,future,void,delete,future,completable,future,supply,async,try,assert,true,delete,server,job,id,blob,key,assert,false,server,get,storage,location,job,id,blob,key,exists,return,null,catch,ioexception,e,throw,new,completion,exception,new,flink,exception,could,not,delete,the,given,blob,key,blob,key,executor,delete,futures,add,delete,future,completable,future,void,wait,future,future,utils,wait,for,all,delete,futures,wait,future,get,assert,false,server,get,storage,location,job,id,blob,key,exists,finally,executor,shutdown,now
