# id;timestamp;commentText;codeText;commentWords;codeWords
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1432625417;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferProvider.class)))_					.thenReturn(new InfiniteSubpartitionView(outboundBuffers, sync))___			PartitionRequestProtocol protocol = new PartitionRequestProtocol(_					partitions, mock(TaskEventDispatcher.class), mock(NetworkBufferPool.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID())).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}_		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,provider,class,then,return,new,infinite,subpartition,view,outbound,buffers,sync,partition,request,protocol,protocol,new,partition,request,protocol,partitions,mock,task,event,dispatcher,class,mock,network,buffer,pool,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1433143315;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferProvider.class)))_					.thenReturn(view)___			PartitionRequestProtocol protocol = new PartitionRequestProtocol(_					partitions, mock(TaskEventDispatcher.class), mock(NetworkBufferPool.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID())).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,provider,class,then,return,view,partition,request,protocol,protocol,new,partition,request,protocol,partitions,mock,task,event,dispatcher,class,mock,network,buffer,pool,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1433143315;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferProvider.class)))_					.thenReturn(view)___			PartitionRequestProtocol protocol = new PartitionRequestProtocol(_					partitions, mock(TaskEventDispatcher.class), mock(NetworkBufferPool.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID())).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,provider,class,then,return,view,partition,request,protocol,protocol,new,partition,request,protocol,partitions,mock,task,event,dispatcher,class,mock,network,buffer,pool,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1465991918;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferProvider.class)))_					.thenReturn(view)___			PartitionRequestProtocol protocol = new PartitionRequestProtocol(_					partitions, mock(TaskEventDispatcher.class), mock(NetworkBufferPool.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID())).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,provider,class,then,return,view,partition,request,protocol,protocol,new,partition,request,protocol,partitions,mock,task,event,dispatcher,class,mock,network,buffer,pool,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1480624969;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferProvider.class), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[3]__						listener.notifyBuffersAvailable(Long.MAX_VALUE)__						return view__					}_				})___			PartitionRequestProtocol protocol = new PartitionRequestProtocol(_					partitions, mock(TaskEventDispatcher.class), mock(NetworkBufferPool.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID())).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,provider,class,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,3,listener,notify,buffers,available,long,return,view,partition,request,protocol,protocol,new,partition,request,protocol,partitions,mock,task,event,dispatcher,class,mock,network,buffer,pool,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1493724918;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyBuffersAvailable(Long.MAX_VALUE)__						return view__					}_				})___			PartitionRequestProtocol protocol = new PartitionRequestProtocol(_					partitions, mock(TaskEventDispatcher.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID())).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,buffers,available,long,return,view,partition,request,protocol,protocol,new,partition,request,protocol,partitions,mock,task,event,dispatcher,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1502111816;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyBuffersAvailable(Long.MAX_VALUE)__						return view__					}_				})___			PartitionRequestProtocol protocol = new PartitionRequestProtocol(_					partitions, mock(TaskEventDispatcher.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID())).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,buffers,available,long,return,view,partition,request,protocol,protocol,new,partition,request,protocol,partitions,mock,task,event,dispatcher,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1507752418;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyBuffersAvailable(Long.MAX_VALUE)__						return view__					}_				})___			PartitionRequestProtocol protocol = new PartitionRequestProtocol(_					partitions, mock(TaskEventDispatcher.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID(), 2)).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,buffers,available,long,return,view,partition,request,protocol,protocol,new,partition,request,protocol,partitions,mock,task,event,dispatcher,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,2,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1515160618;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyBuffersAvailable(Long.MAX_VALUE)__						return view__					}_				})___			NettyProtocol protocol = new NettyProtocol(_					partitions, mock(TaskEventDispatcher.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID(), 2)).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,buffers,available,long,return,view,netty,protocol,protocol,new,netty,protocol,partitions,mock,task,event,dispatcher,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,2,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1515510677;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyBuffersAvailable(Long.MAX_VALUE)__						return view__					}_				})___			NettyProtocol protocol = new NettyProtocol(_					partitions, mock(TaskEventDispatcher.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID(), 2)).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,buffers,available,long,return,view,netty,protocol,protocol,new,netty,protocol,partitions,mock,task,event,dispatcher,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,2,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1516285456;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyBuffersAvailable(Long.MAX_VALUE)__						return view__					}_				})___			NettyProtocol protocol = new NettyProtocol(_					partitions, mock(TaskEventDispatcher.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID(), 2)).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,buffers,available,long,return,view,netty,protocol,protocol,new,netty,protocol,partitions,mock,task,event,dispatcher,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,2,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1518785736;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyBuffersAvailable(Long.MAX_VALUE)__						return view__					}_				})___			NettyProtocol protocol = new NettyProtocol(_					partitions, mock(TaskEventDispatcher.class))___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID(), Integer.MAX_VALUE)).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,buffers,available,long,return,view,netty,protocol,protocol,new,netty,protocol,partitions,mock,task,event,dispatcher,class,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,integer,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1518785736;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyBuffersAvailable(Long.MAX_VALUE)__						return view__					}_				})___			NettyProtocol protocol = new NettyProtocol(_					partitions, mock(TaskEventDispatcher.class), true)___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID(), Integer.MAX_VALUE)).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,buffers,available,long,return,view,netty,protocol,protocol,new,netty,protocol,partitions,mock,task,event,dispatcher,class,true,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,integer,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1519039292;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyBuffersAvailable(Long.MAX_VALUE)__						return view__					}_				})___			NettyProtocol protocol = new NettyProtocol(_					partitions, mock(TaskEventDispatcher.class), true)___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID(), Integer.MAX_VALUE)).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,buffers,available,long,return,view,netty,protocol,protocol,new,netty,protocol,partitions,mock,task,event,dispatcher,class,true,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,integer,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1519039301;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyDataAvailable()__						return view__					}_				})___			NettyProtocol protocol = new NettyProtocol(_					partitions, mock(TaskEventDispatcher.class), true)___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID(), Integer.MAX_VALUE)).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,data,available,return,view,netty,protocol,protocol,new,netty,protocol,partitions,mock,task,event,dispatcher,class,true,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,integer,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
CancelPartitionRequestTest -> @Test 	public void testCancelPartitionRequest() throws Exception;1519834372;Verifies that requests for non-existing (failed/cancelled) input channels are properly_cancelled. The receiver receives data, but there is no input channel to receive the data._This should cancel the request.;@Test_	public void testCancelPartitionRequest() throws Exception {__		NettyServerAndClient serverAndClient = null___		try {_			TestPooledBufferProvider outboundBuffers = new TestPooledBufferProvider(16)___			ResultPartitionManager partitions = mock(ResultPartitionManager.class)___			ResultPartitionID pid = new ResultPartitionID()___			CountDownLatch sync = new CountDownLatch(1)___			final ResultSubpartitionView view = spy(new InfiniteSubpartitionView(outboundBuffers, sync))___			_			when(partitions.createSubpartitionView(eq(pid), eq(0), any(BufferAvailabilityListener.class)))_				.thenAnswer(new Answer<ResultSubpartitionView>() {_					@Override_					public ResultSubpartitionView answer(InvocationOnMock invocationOnMock) throws Throwable {_						BufferAvailabilityListener listener = (BufferAvailabilityListener) invocationOnMock.getArguments()[2]__						listener.notifyDataAvailable()__						return view__					}_				})___			NettyProtocol protocol = new NettyProtocol(_					partitions, mock(TaskEventDispatcher.class), true)___			serverAndClient = initServerAndClient(protocol)___			Channel ch = connect(serverAndClient)___			_			ch.writeAndFlush(new PartitionRequest(pid, 0, new InputChannelID(), Integer.MAX_VALUE)).await()___			_			if (!sync.await(TestingUtils.TESTING_DURATION().toMillis(), TimeUnit.MILLISECONDS)) {_				fail("Timed out after waiting for " + TestingUtils.TESTING_DURATION().toMillis() +_						" ms to be notified about cancelled partition.")__			}__			verify(view, times(1)).releaseAllResources()__			verify(view, times(0)).notifySubpartitionConsumed()__		}_		finally {_			shutdown(serverAndClient)__		}_	};verifies,that,requests,for,non,existing,failed,cancelled,input,channels,are,properly,cancelled,the,receiver,receives,data,but,there,is,no,input,channel,to,receive,the,data,this,should,cancel,the,request;test,public,void,test,cancel,partition,request,throws,exception,netty,server,and,client,server,and,client,null,try,test,pooled,buffer,provider,outbound,buffers,new,test,pooled,buffer,provider,16,result,partition,manager,partitions,mock,result,partition,manager,class,result,partition,id,pid,new,result,partition,id,count,down,latch,sync,new,count,down,latch,1,final,result,subpartition,view,view,spy,new,infinite,subpartition,view,outbound,buffers,sync,when,partitions,create,subpartition,view,eq,pid,eq,0,any,buffer,availability,listener,class,then,answer,new,answer,result,subpartition,view,override,public,result,subpartition,view,answer,invocation,on,mock,invocation,on,mock,throws,throwable,buffer,availability,listener,listener,buffer,availability,listener,invocation,on,mock,get,arguments,2,listener,notify,data,available,return,view,netty,protocol,protocol,new,netty,protocol,partitions,mock,task,event,dispatcher,class,true,server,and,client,init,server,and,client,protocol,channel,ch,connect,server,and,client,ch,write,and,flush,new,partition,request,pid,0,new,input,channel,id,integer,await,if,sync,await,testing,utils,to,millis,time,unit,milliseconds,fail,timed,out,after,waiting,for,testing,utils,to,millis,ms,to,be,notified,about,cancelled,partition,verify,view,times,1,release,all,resources,verify,view,times,0,notify,subpartition,consumed,finally,shutdown,server,and,client
