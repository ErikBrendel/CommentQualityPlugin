# id;timestamp;commentText;codeText;commentWords;codeWords
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1440164487;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1441108151;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1443564120;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1446112342;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1447771085;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1452880737;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1454679829;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1455101486;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1458743533;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1460755044;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1460990858;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1462899491;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1489671807;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction);1500387265;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction) {__		return sample(input, withReplacement, fraction, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,return,sample,input,with,replacement,fraction,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1435486274;Method that takes a set of subtask index, total number of elements mappings_and assigns ids to all the elements from the input data set.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			_			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariable("counts")___				Collections.sort(offsets, new Comparator<Tuple2<Integer, Long>>() {_					@Override_					public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_						return compareInts(o1.f0, o2.f0)__					}_				})___				for(int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for(T value: values) {_					out.collect(new Tuple2<Long, T>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,takes,a,set,of,subtask,index,total,number,of,elements,mappings,and,assigns,ids,to,all,the,elements,from,the,input,data,set,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,counts,collections,sort,offsets,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,compare,ints,o1,f0,o2,f0,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,long,t,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1435872343;Method that takes a set of subtask index, total number of elements mappings_and assigns ids to all the elements from the input data set.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			_			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariable("counts")___				Collections.sort(offsets, new Comparator<Tuple2<Integer, Long>>() {_					@Override_					public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_						return compareInts(o1.f0, o2.f0)__					}_				})___				for(int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for(T value: values) {_					out.collect(new Tuple2<Long, T>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,takes,a,set,of,subtask,index,total,number,of,elements,mappings,and,assigns,ids,to,all,the,elements,from,the,input,data,set,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,counts,collections,sort,offsets,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,compare,ints,o1,f0,o2,f0,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,long,t,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1440164487;Method that takes a set of subtask index, total number of elements mappings_and assigns ids to all the elements from the input data set.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			_			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariable("counts")___				Collections.sort(offsets, new Comparator<Tuple2<Integer, Long>>() {_					@Override_					public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_						return compareInts(o1.f0, o2.f0)__					}_				})___				for(int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for(T value: values) {_					out.collect(new Tuple2<Long, T>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,takes,a,set,of,subtask,index,total,number,of,elements,mappings,and,assigns,ids,to,all,the,elements,from,the,input,data,set,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,counts,collections,sort,offsets,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,compare,ints,o1,f0,o2,f0,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,long,t,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1441108151;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = Lists.newArrayList(data)__								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<Long, T>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,lists,new,array,list,data,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,long,t,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1443564120;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = Lists.newArrayList(data)__								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<Long, T>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,lists,new,array,list,data,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,long,t,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1446112342;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = Lists.newArrayList(data)__								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<Long, T>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,lists,new,array,list,data,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,long,t,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1447771085;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = Lists.newArrayList(data)__								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,lists,new,array,list,data,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1452880737;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = Lists.newArrayList(data)__								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,lists,new,array,list,data,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1454679829;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = Lists.newArrayList(data)__								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,lists,new,array,list,data,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1455101486;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = Lists.newArrayList(data)__								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,lists,new,array,list,data,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1458743533;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElements(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = Lists.newArrayList(data)__								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,lists,new,array,list,data,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1460755044;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElementsPerPartition(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = Lists.newArrayList(data)__								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,per,partition,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,lists,new,array,list,data,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1460990858;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElementsPerPartition(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = Lists.newArrayList(data)__								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,per,partition,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,lists,new,array,list,data,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1462899491;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElementsPerPartition(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = new ArrayList<>()__								for (Tuple2<Integer, Long> datum : data) {_									sortedData.add(datum)__								}_								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,per,partition,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,new,array,list,for,tuple2,integer,long,datum,data,sorted,data,add,datum,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1489671807;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElementsPerPartition(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = new ArrayList<>()__								for (Tuple2<Integer, Long> datum : data) {_									sortedData.add(datum)__								}_								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,per,partition,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,new,array,list,for,tuple2,integer,long,datum,data,sorted,data,add,datum,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input);1500387265;Method that assigns a unique {@link Long} value to all elements in the input data set. The generated values are_consecutive.__@param input the input data set_@return a data set of tuple 2 consisting of consecutive ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithIndex(DataSet<T> input) {__		DataSet<Tuple2<Integer, Long>> elementCount = countElementsPerPartition(input)___		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long start = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)___				List<Tuple2<Integer, Long>> offsets = getRuntimeContext().getBroadcastVariableWithInitializer(_						"counts",_						new BroadcastVariableInitializer<Tuple2<Integer, Long>, List<Tuple2<Integer, Long>>>() {_							@Override_							public List<Tuple2<Integer, Long>> initializeBroadcastVariable(Iterable<Tuple2<Integer, Long>> data) {_								_								List<Tuple2<Integer, Long>> sortedData = new ArrayList<>()__								for (Tuple2<Integer, Long> datum : data) {_									sortedData.add(datum)__								}_								Collections.sort(sortedData, new Comparator<Tuple2<Integer, Long>>() {_									@Override_									public int compare(Tuple2<Integer, Long> o1, Tuple2<Integer, Long> o2) {_										return o1.f0.compareTo(o2.f0)__									}_								})__								return sortedData__							}_						})___				_				for (int i = 0_ i < getRuntimeContext().getIndexOfThisSubtask()_ i++) {_					start += offsets.get(i).f1__				}_			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value: values) {_					out.collect(new Tuple2<>(start++, value))__				}_			}_		}).withBroadcastSet(elementCount, "counts")__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,the,generated,values,are,consecutive,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,consecutive,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,index,data,set,t,input,data,set,tuple2,integer,long,element,count,count,elements,per,partition,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,start,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,list,tuple2,integer,long,offsets,get,runtime,context,get,broadcast,variable,with,initializer,counts,new,broadcast,variable,initializer,tuple2,integer,long,list,tuple2,integer,long,override,public,list,tuple2,integer,long,initialize,broadcast,variable,iterable,tuple2,integer,long,data,list,tuple2,integer,long,sorted,data,new,array,list,for,tuple2,integer,long,datum,data,sorted,data,add,datum,collections,sort,sorted,data,new,comparator,tuple2,integer,long,override,public,int,compare,tuple2,integer,long,o1,tuple2,integer,long,o2,return,o1,f0,compare,to,o2,f0,return,sorted,data,for,int,i,0,i,get,runtime,context,get,index,of,this,subtask,i,start,offsets,get,i,f1,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,out,collect,new,tuple2,start,value,with,broadcast,set,element,count,counts
DataSetUtils -> public static <T> DataSet<Tuple2<Integer, Long>> countElementsPerPartition(DataSet<T> input);1460755044;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;public static <T> DataSet<Tuple2<Integer, Long>> countElementsPerPartition(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}_				out.collect(new Tuple2<>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;public,static,t,data,set,tuple2,integer,long,count,elements,per,partition,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> public static <T> DataSet<Tuple2<Integer, Long>> countElementsPerPartition(DataSet<T> input);1460990858;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;public static <T> DataSet<Tuple2<Integer, Long>> countElementsPerPartition(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}_				out.collect(new Tuple2<>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;public,static,t,data,set,tuple2,integer,long,count,elements,per,partition,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> public static <T> DataSet<Tuple2<Integer, Long>> countElementsPerPartition(DataSet<T> input);1462899491;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;public static <T> DataSet<Tuple2<Integer, Long>> countElementsPerPartition(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}_				out.collect(new Tuple2<>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;public,static,t,data,set,tuple2,integer,long,count,elements,per,partition,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> public static <T> DataSet<Tuple2<Integer, Long>> countElementsPerPartition(DataSet<T> input);1489671807;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;public static <T> DataSet<Tuple2<Integer, Long>> countElementsPerPartition(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}_				out.collect(new Tuple2<>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;public,static,t,data,set,tuple2,integer,long,count,elements,per,partition,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> public static <T> DataSet<Tuple2<Integer, Long>> countElementsPerPartition(DataSet<T> input);1500387265;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;public static <T> DataSet<Tuple2<Integer, Long>> countElementsPerPartition(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}_				out.collect(new Tuple2<>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;public,static,t,data,set,tuple2,integer,long,count,elements,per,partition,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1440164487;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1441108151;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1443564120;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1446112342;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1447771085;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1452880737;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1454679829;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1455101486;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1458743533;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1460755044;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1460990858;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1462899491;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1489671807;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> MapPartitionOperator<T, T> sample( 		DataSet <T> input, 		final boolean withReplacement, 		final double fraction, 		final long seed);1500387265;Generate a sample of DataSet by the probability fraction of each element.__@param withReplacement Whether element can be selected more than once._@param fraction        Probability that each element is chosen, should be [0,1] without replacement,_and [0, ∞) with replacement. While fraction is larger than 1, the elements are_expected to be selected multi times into sample on average._@param seed            random number generator seed._@return The sampled DataSet;public static <T> MapPartitionOperator<T, T> sample(_		DataSet <T> input,_		final boolean withReplacement,_		final double fraction,_		final long seed) {__		return input.mapPartition(new SampleWithFraction<T>(withReplacement, fraction, seed))__	};generate,a,sample,of,data,set,by,the,probability,fraction,of,each,element,param,with,replacement,whether,element,can,be,selected,more,than,once,param,fraction,probability,that,each,element,is,chosen,should,be,0,1,without,replacement,and,0,with,replacement,while,fraction,is,larger,than,1,the,elements,are,expected,to,be,selected,multi,times,into,sample,on,average,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,map,partition,operator,t,t,sample,data,set,t,input,final,boolean,with,replacement,final,double,fraction,final,long,seed,return,input,map,partition,new,sample,with,fraction,t,with,replacement,fraction,seed
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSample);1440164487;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._<p/>__@param withReplacement Whether element can be selected more than once._@param numSample       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSample) {__		return sampleWithSize(input, withReplacement, numSample, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,sample,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,sample,return,sample,with,size,input,with,replacement,num,sample,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSample);1441108151;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._<p/>__@param withReplacement Whether element can be selected more than once._@param numSample       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSample) {__		return sampleWithSize(input, withReplacement, numSample, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,sample,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,sample,return,sample,with,size,input,with,replacement,num,sample,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSample);1443564120;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._<p/>__@param withReplacement Whether element can be selected more than once._@param numSample       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSample) {__		return sampleWithSize(input, withReplacement, numSample, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,sample,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,sample,return,sample,with,size,input,with,replacement,num,sample,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSample);1446112342;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSample       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSample) {__		return sampleWithSize(input, withReplacement, numSample, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,sample,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,sample,return,sample,with,size,input,with,replacement,num,sample,utils,rng,next,long
DataSetUtils -> public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception;1452880737;Convenience method to get the count (number of elements) of a DataSet_as well as the checksum (sum over element hashes).__@return A ChecksumHashCode that represents the count and checksum of elements in the data set.;public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception {_		final String id = new AbstractID().toString()___		input.output(new Utils.ChecksumHashCodeHelper<T>(id)).name("ChecksumHashCode")___		JobExecutionResult res = input.getExecutionEnvironment().execute()__		return res.<Utils.ChecksumHashCode> getAccumulatorResult(id)__	};convenience,method,to,get,the,count,number,of,elements,of,a,data,set,as,well,as,the,checksum,sum,over,element,hashes,return,a,checksum,hash,code,that,represents,the,count,and,checksum,of,elements,in,the,data,set;public,static,t,utils,checksum,hash,code,checksum,hash,code,data,set,t,input,throws,exception,final,string,id,new,abstract,id,to,string,input,output,new,utils,checksum,hash,code,helper,t,id,name,checksum,hash,code,job,execution,result,res,input,get,execution,environment,execute,return,res,utils,checksum,hash,code,get,accumulator,result,id
DataSetUtils -> public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception;1454679829;Convenience method to get the count (number of elements) of a DataSet_as well as the checksum (sum over element hashes).__@return A ChecksumHashCode that represents the count and checksum of elements in the data set.;public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception {_		final String id = new AbstractID().toString()___		input.output(new Utils.ChecksumHashCodeHelper<T>(id)).name("ChecksumHashCode")___		JobExecutionResult res = input.getExecutionEnvironment().execute()__		return res.<Utils.ChecksumHashCode> getAccumulatorResult(id)__	};convenience,method,to,get,the,count,number,of,elements,of,a,data,set,as,well,as,the,checksum,sum,over,element,hashes,return,a,checksum,hash,code,that,represents,the,count,and,checksum,of,elements,in,the,data,set;public,static,t,utils,checksum,hash,code,checksum,hash,code,data,set,t,input,throws,exception,final,string,id,new,abstract,id,to,string,input,output,new,utils,checksum,hash,code,helper,t,id,name,checksum,hash,code,job,execution,result,res,input,get,execution,environment,execute,return,res,utils,checksum,hash,code,get,accumulator,result,id
DataSetUtils -> public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception;1455101486;Convenience method to get the count (number of elements) of a DataSet_as well as the checksum (sum over element hashes).__@return A ChecksumHashCode that represents the count and checksum of elements in the data set.;public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception {_		final String id = new AbstractID().toString()___		input.output(new Utils.ChecksumHashCodeHelper<T>(id)).name("ChecksumHashCode")___		JobExecutionResult res = input.getExecutionEnvironment().execute()__		return res.<Utils.ChecksumHashCode> getAccumulatorResult(id)__	};convenience,method,to,get,the,count,number,of,elements,of,a,data,set,as,well,as,the,checksum,sum,over,element,hashes,return,a,checksum,hash,code,that,represents,the,count,and,checksum,of,elements,in,the,data,set;public,static,t,utils,checksum,hash,code,checksum,hash,code,data,set,t,input,throws,exception,final,string,id,new,abstract,id,to,string,input,output,new,utils,checksum,hash,code,helper,t,id,name,checksum,hash,code,job,execution,result,res,input,get,execution,environment,execute,return,res,utils,checksum,hash,code,get,accumulator,result,id
DataSetUtils -> public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception;1458743533;Convenience method to get the count (number of elements) of a DataSet_as well as the checksum (sum over element hashes).__@return A ChecksumHashCode that represents the count and checksum of elements in the data set.;public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception {_		final String id = new AbstractID().toString()___		input.output(new Utils.ChecksumHashCodeHelper<T>(id)).name("ChecksumHashCode")___		JobExecutionResult res = input.getExecutionEnvironment().execute()__		return res.<Utils.ChecksumHashCode> getAccumulatorResult(id)__	};convenience,method,to,get,the,count,number,of,elements,of,a,data,set,as,well,as,the,checksum,sum,over,element,hashes,return,a,checksum,hash,code,that,represents,the,count,and,checksum,of,elements,in,the,data,set;public,static,t,utils,checksum,hash,code,checksum,hash,code,data,set,t,input,throws,exception,final,string,id,new,abstract,id,to,string,input,output,new,utils,checksum,hash,code,helper,t,id,name,checksum,hash,code,job,execution,result,res,input,get,execution,environment,execute,return,res,utils,checksum,hash,code,get,accumulator,result,id
DataSetUtils -> public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception;1460755044;Convenience method to get the count (number of elements) of a DataSet_as well as the checksum (sum over element hashes).__@return A ChecksumHashCode that represents the count and checksum of elements in the data set.;public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception {_		final String id = new AbstractID().toString()___		input.output(new Utils.ChecksumHashCodeHelper<T>(id)).name("ChecksumHashCode")___		JobExecutionResult res = input.getExecutionEnvironment().execute()__		return res.<Utils.ChecksumHashCode> getAccumulatorResult(id)__	};convenience,method,to,get,the,count,number,of,elements,of,a,data,set,as,well,as,the,checksum,sum,over,element,hashes,return,a,checksum,hash,code,that,represents,the,count,and,checksum,of,elements,in,the,data,set;public,static,t,utils,checksum,hash,code,checksum,hash,code,data,set,t,input,throws,exception,final,string,id,new,abstract,id,to,string,input,output,new,utils,checksum,hash,code,helper,t,id,name,checksum,hash,code,job,execution,result,res,input,get,execution,environment,execute,return,res,utils,checksum,hash,code,get,accumulator,result,id
DataSetUtils -> public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception;1460990858;Convenience method to get the count (number of elements) of a DataSet_as well as the checksum (sum over element hashes).__@return A ChecksumHashCode that represents the count and checksum of elements in the data set.;public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception {_		final String id = new AbstractID().toString()___		input.output(new Utils.ChecksumHashCodeHelper<T>(id)).name("ChecksumHashCode")___		JobExecutionResult res = input.getExecutionEnvironment().execute()__		return res.<Utils.ChecksumHashCode> getAccumulatorResult(id)__	};convenience,method,to,get,the,count,number,of,elements,of,a,data,set,as,well,as,the,checksum,sum,over,element,hashes,return,a,checksum,hash,code,that,represents,the,count,and,checksum,of,elements,in,the,data,set;public,static,t,utils,checksum,hash,code,checksum,hash,code,data,set,t,input,throws,exception,final,string,id,new,abstract,id,to,string,input,output,new,utils,checksum,hash,code,helper,t,id,name,checksum,hash,code,job,execution,result,res,input,get,execution,environment,execute,return,res,utils,checksum,hash,code,get,accumulator,result,id
DataSetUtils -> public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception;1462899491;Convenience method to get the count (number of elements) of a DataSet_as well as the checksum (sum over element hashes).__@return A ChecksumHashCode that represents the count and checksum of elements in the data set.;public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception {_		final String id = new AbstractID().toString()___		input.output(new Utils.ChecksumHashCodeHelper<T>(id)).name("ChecksumHashCode")___		JobExecutionResult res = input.getExecutionEnvironment().execute()__		return res.<Utils.ChecksumHashCode> getAccumulatorResult(id)__	};convenience,method,to,get,the,count,number,of,elements,of,a,data,set,as,well,as,the,checksum,sum,over,element,hashes,return,a,checksum,hash,code,that,represents,the,count,and,checksum,of,elements,in,the,data,set;public,static,t,utils,checksum,hash,code,checksum,hash,code,data,set,t,input,throws,exception,final,string,id,new,abstract,id,to,string,input,output,new,utils,checksum,hash,code,helper,t,id,name,checksum,hash,code,job,execution,result,res,input,get,execution,environment,execute,return,res,utils,checksum,hash,code,get,accumulator,result,id
DataSetUtils -> public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor);1458743533;Range-partitions a DataSet using the specified key selector function.;public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor) {_		final TypeInformation<K> keyType = TypeExtractor.getKeySelectorTypes(keyExtractor, input.getType())__		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.SelectorFunctionKeys<>(input.clean(keyExtractor), input.getType(), keyType), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,using,the,specified,key,selector,function;public,static,t,k,extends,comparable,k,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,key,selector,t,k,key,extractor,final,type,information,k,key,type,type,extractor,get,key,selector,types,key,extractor,input,get,type,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,selector,function,keys,input,clean,key,extractor,input,get,type,key,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor);1460755044;Range-partitions a DataSet using the specified key selector function.;public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor) {_		final TypeInformation<K> keyType = TypeExtractor.getKeySelectorTypes(keyExtractor, input.getType())__		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.SelectorFunctionKeys<>(input.clean(keyExtractor), input.getType(), keyType), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,using,the,specified,key,selector,function;public,static,t,k,extends,comparable,k,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,key,selector,t,k,key,extractor,final,type,information,k,key,type,type,extractor,get,key,selector,types,key,extractor,input,get,type,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,selector,function,keys,input,clean,key,extractor,input,get,type,key,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor);1460990858;Range-partitions a DataSet using the specified key selector function.;public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor) {_		final TypeInformation<K> keyType = TypeExtractor.getKeySelectorTypes(keyExtractor, input.getType())__		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.SelectorFunctionKeys<>(input.clean(keyExtractor), input.getType(), keyType), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,using,the,specified,key,selector,function;public,static,t,k,extends,comparable,k,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,key,selector,t,k,key,extractor,final,type,information,k,key,type,type,extractor,get,key,selector,types,key,extractor,input,get,type,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,selector,function,keys,input,clean,key,extractor,input,get,type,key,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor);1462899491;Range-partitions a DataSet using the specified key selector function.;public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor) {_		final TypeInformation<K> keyType = TypeExtractor.getKeySelectorTypes(keyExtractor, input.getType())__		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.SelectorFunctionKeys<>(input.clean(keyExtractor), input.getType(), keyType), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,using,the,specified,key,selector,function;public,static,t,k,extends,comparable,k,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,key,selector,t,k,key,extractor,final,type,information,k,key,type,type,extractor,get,key,selector,types,key,extractor,input,get,type,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,selector,function,keys,input,clean,key,extractor,input,get,type,key,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor);1489671807;Range-partitions a DataSet using the specified key selector function.;public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor) {_		final TypeInformation<K> keyType = TypeExtractor.getKeySelectorTypes(keyExtractor, input.getType())__		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.SelectorFunctionKeys<>(input.clean(keyExtractor), input.getType(), keyType), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,using,the,specified,key,selector,function;public,static,t,k,extends,comparable,k,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,key,selector,t,k,key,extractor,final,type,information,k,key,type,type,extractor,get,key,selector,types,key,extractor,input,get,type,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,selector,function,keys,input,clean,key,extractor,input,get,type,key,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor);1500387265;Range-partitions a DataSet using the specified key selector function.;public static <T, K extends Comparable<K>> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, KeySelector<T, K> keyExtractor) {_		final TypeInformation<K> keyType = TypeExtractor.getKeySelectorTypes(keyExtractor, input.getType())__		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.SelectorFunctionKeys<>(input.clean(keyExtractor), input.getType(), keyType), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,using,the,specified,key,selector,function;public,static,t,k,extends,comparable,k,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,key,selector,t,k,key,extractor,final,type,information,k,key,type,type,extractor,get,key,selector,types,key,extractor,input,get,type,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,selector,function,keys,input,clean,key,extractor,input,get,type,key,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples, 		final long seed);1447771085;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples,_		final long seed) {__		SampleInPartition<T> sampleInPartition = new SampleInPartition<>(withReplacement, numSamples, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<>(withReplacement, numSamples, seed)__		return new GroupReduceOperator<>(mapPartitionOperator, input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,final,long,seed,sample,in,partition,t,sample,in,partition,new,sample,in,partition,with,replacement,num,samples,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,with,replacement,num,samples,seed,return,new,group,reduce,operator,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples, 		final long seed);1452880737;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples,_		final long seed) {__		SampleInPartition<T> sampleInPartition = new SampleInPartition<>(withReplacement, numSamples, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<>(withReplacement, numSamples, seed)__		return new GroupReduceOperator<>(mapPartitionOperator, input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,final,long,seed,sample,in,partition,t,sample,in,partition,new,sample,in,partition,with,replacement,num,samples,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,with,replacement,num,samples,seed,return,new,group,reduce,operator,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples, 		final long seed);1454679829;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples,_		final long seed) {__		SampleInPartition<T> sampleInPartition = new SampleInPartition<>(withReplacement, numSamples, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<>(withReplacement, numSamples, seed)__		return new GroupReduceOperator<>(mapPartitionOperator, input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,final,long,seed,sample,in,partition,t,sample,in,partition,new,sample,in,partition,with,replacement,num,samples,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,with,replacement,num,samples,seed,return,new,group,reduce,operator,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples, 		final long seed);1455101486;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples,_		final long seed) {__		SampleInPartition<T> sampleInPartition = new SampleInPartition<>(withReplacement, numSamples, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<>(withReplacement, numSamples, seed)__		return new GroupReduceOperator<>(mapPartitionOperator, input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,final,long,seed,sample,in,partition,t,sample,in,partition,new,sample,in,partition,with,replacement,num,samples,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,with,replacement,num,samples,seed,return,new,group,reduce,operator,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples, 		final long seed);1458743533;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples,_		final long seed) {__		SampleInPartition<T> sampleInPartition = new SampleInPartition<>(withReplacement, numSamples, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<>(withReplacement, numSamples, seed)__		return new GroupReduceOperator<>(mapPartitionOperator, input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,final,long,seed,sample,in,partition,t,sample,in,partition,new,sample,in,partition,with,replacement,num,samples,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,with,replacement,num,samples,seed,return,new,group,reduce,operator,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples, 		final long seed);1460755044;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples,_		final long seed) {__		SampleInPartition<T> sampleInPartition = new SampleInPartition<>(withReplacement, numSamples, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<>(withReplacement, numSamples, seed)__		return new GroupReduceOperator<>(mapPartitionOperator, input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,final,long,seed,sample,in,partition,t,sample,in,partition,new,sample,in,partition,with,replacement,num,samples,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,with,replacement,num,samples,seed,return,new,group,reduce,operator,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples, 		final long seed);1460990858;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples,_		final long seed) {__		SampleInPartition<T> sampleInPartition = new SampleInPartition<>(withReplacement, numSamples, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<>(withReplacement, numSamples, seed)__		return new GroupReduceOperator<>(mapPartitionOperator, input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,final,long,seed,sample,in,partition,t,sample,in,partition,new,sample,in,partition,with,replacement,num,samples,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,with,replacement,num,samples,seed,return,new,group,reduce,operator,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples, 		final long seed);1462899491;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples,_		final long seed) {__		SampleInPartition<T> sampleInPartition = new SampleInPartition<>(withReplacement, numSamples, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<>(withReplacement, numSamples, seed)__		return new GroupReduceOperator<>(mapPartitionOperator, input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,final,long,seed,sample,in,partition,t,sample,in,partition,new,sample,in,partition,with,replacement,num,samples,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,with,replacement,num,samples,seed,return,new,group,reduce,operator,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples, 		final long seed);1489671807;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples,_		final long seed) {__		SampleInPartition<T> sampleInPartition = new SampleInPartition<>(withReplacement, numSamples, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<>(withReplacement, numSamples, seed)__		return new GroupReduceOperator<>(mapPartitionOperator, input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,final,long,seed,sample,in,partition,t,sample,in,partition,new,sample,in,partition,with,replacement,num,samples,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,with,replacement,num,samples,seed,return,new,group,reduce,operator,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples, 		final long seed);1500387265;Generate a sample of DataSet which contains fixed size elements.__<p><strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision.__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples,_		final long seed) {__		SampleInPartition<T> sampleInPartition = new SampleInPartition<>(withReplacement, numSamples, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<>(withReplacement, numSamples, seed)__		return new GroupReduceOperator<>(mapPartitionOperator, input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,final,long,seed,sample,in,partition,t,sample,in,partition,new,sample,in,partition,with,replacement,num,samples,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,with,replacement,num,samples,seed,return,new,group,reduce,operator,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <R extends Tuple, T extends Tuple> R summarize(DataSet<T> input) throws Exception;1460990858;Summarize a DataSet of Tuples by collecting single pass statistics for all columns__Example usage:_<pre>_{@code_Dataset<Tuple3<Double, String, Boolean>> input = // [...]_Tuple3<NumericColumnSummary,StringColumnSummary, BooleanColumnSummary> summary = DataSetUtils.summarize(input)__summary.f0.getStandardDeviation()_summary.f1.getMaxLength()__</pre>_@return the summary as a Tuple the same width as input rows;public static <R extends Tuple, T extends Tuple> R summarize(DataSet<T> input) throws Exception {_		if( !input.getType().isTupleType()) {_			throw new IllegalArgumentException("summarize() is only implemented for DataSet's of Tuples")__		}_		final TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		DataSet<TupleSummaryAggregator<R>> result = input.mapPartition(new MapPartitionFunction<T, TupleSummaryAggregator<R>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<TupleSummaryAggregator<R>> out) throws Exception {_				TupleSummaryAggregator<R> aggregator = SummaryAggregatorFactory.create(inType)__				for (Tuple value: values) {_					aggregator.aggregate(value)__				}_				out.collect(aggregator)__			}_		}).reduce(new ReduceFunction<TupleSummaryAggregator<R>>() {_			@Override_			public TupleSummaryAggregator<R> reduce(TupleSummaryAggregator<R> agg1, TupleSummaryAggregator<R> agg2) throws Exception {_				agg1.combine(agg2)__				return agg1__			}_		})__		return result.collect().get(0).result()__	};summarize,a,data,set,of,tuples,by,collecting,single,pass,statistics,for,all,columns,example,usage,pre,code,dataset,tuple3,double,string,boolean,input,tuple3,numeric,column,summary,string,column,summary,boolean,column,summary,summary,data,set,utils,summarize,input,summary,f0,get,standard,deviation,summary,f1,get,max,length,pre,return,the,summary,as,a,tuple,the,same,width,as,input,rows;public,static,r,extends,tuple,t,extends,tuple,r,summarize,data,set,t,input,throws,exception,if,input,get,type,is,tuple,type,throw,new,illegal,argument,exception,summarize,is,only,implemented,for,data,set,s,of,tuples,final,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,data,set,tuple,summary,aggregator,r,result,input,map,partition,new,map,partition,function,t,tuple,summary,aggregator,r,override,public,void,map,partition,iterable,t,values,collector,tuple,summary,aggregator,r,out,throws,exception,tuple,summary,aggregator,r,aggregator,summary,aggregator,factory,create,in,type,for,tuple,value,values,aggregator,aggregate,value,out,collect,aggregator,reduce,new,reduce,function,tuple,summary,aggregator,r,override,public,tuple,summary,aggregator,r,reduce,tuple,summary,aggregator,r,agg1,tuple,summary,aggregator,r,agg2,throws,exception,agg1,combine,agg2,return,agg1,return,result,collect,get,0,result
DataSetUtils -> public static <R extends Tuple, T extends Tuple> R summarize(DataSet<T> input) throws Exception;1462899491;Summarize a DataSet of Tuples by collecting single pass statistics for all columns__Example usage:_<pre>_{@code_Dataset<Tuple3<Double, String, Boolean>> input = // [...]_Tuple3<NumericColumnSummary,StringColumnSummary, BooleanColumnSummary> summary = DataSetUtils.summarize(input)__summary.f0.getStandardDeviation()_summary.f1.getMaxLength()__</pre>_@return the summary as a Tuple the same width as input rows;public static <R extends Tuple, T extends Tuple> R summarize(DataSet<T> input) throws Exception {_		if( !input.getType().isTupleType()) {_			throw new IllegalArgumentException("summarize() is only implemented for DataSet's of Tuples")__		}_		final TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		DataSet<TupleSummaryAggregator<R>> result = input.mapPartition(new MapPartitionFunction<T, TupleSummaryAggregator<R>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<TupleSummaryAggregator<R>> out) throws Exception {_				TupleSummaryAggregator<R> aggregator = SummaryAggregatorFactory.create(inType)__				for (Tuple value: values) {_					aggregator.aggregate(value)__				}_				out.collect(aggregator)__			}_		}).reduce(new ReduceFunction<TupleSummaryAggregator<R>>() {_			@Override_			public TupleSummaryAggregator<R> reduce(TupleSummaryAggregator<R> agg1, TupleSummaryAggregator<R> agg2) throws Exception {_				agg1.combine(agg2)__				return agg1__			}_		})__		return result.collect().get(0).result()__	};summarize,a,data,set,of,tuples,by,collecting,single,pass,statistics,for,all,columns,example,usage,pre,code,dataset,tuple3,double,string,boolean,input,tuple3,numeric,column,summary,string,column,summary,boolean,column,summary,summary,data,set,utils,summarize,input,summary,f0,get,standard,deviation,summary,f1,get,max,length,pre,return,the,summary,as,a,tuple,the,same,width,as,input,rows;public,static,r,extends,tuple,t,extends,tuple,r,summarize,data,set,t,input,throws,exception,if,input,get,type,is,tuple,type,throw,new,illegal,argument,exception,summarize,is,only,implemented,for,data,set,s,of,tuples,final,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,data,set,tuple,summary,aggregator,r,result,input,map,partition,new,map,partition,function,t,tuple,summary,aggregator,r,override,public,void,map,partition,iterable,t,values,collector,tuple,summary,aggregator,r,out,throws,exception,tuple,summary,aggregator,r,aggregator,summary,aggregator,factory,create,in,type,for,tuple,value,values,aggregator,aggregate,value,out,collect,aggregator,reduce,new,reduce,function,tuple,summary,aggregator,r,override,public,tuple,summary,aggregator,r,reduce,tuple,summary,aggregator,r,agg1,tuple,summary,aggregator,r,agg2,throws,exception,agg1,combine,agg2,return,agg1,return,result,collect,get,0,result
DataSetUtils -> public static <R extends Tuple, T extends Tuple> R summarize(DataSet<T> input) throws Exception;1489671807;Summarize a DataSet of Tuples by collecting single pass statistics for all columns__Example usage:_<pre>_{@code_Dataset<Tuple3<Double, String, Boolean>> input = // [...]_Tuple3<NumericColumnSummary,StringColumnSummary, BooleanColumnSummary> summary = DataSetUtils.summarize(input)__summary.f0.getStandardDeviation()_summary.f1.getMaxLength()__</pre>_@return the summary as a Tuple the same width as input rows;public static <R extends Tuple, T extends Tuple> R summarize(DataSet<T> input) throws Exception {_		if( !input.getType().isTupleType()) {_			throw new IllegalArgumentException("summarize() is only implemented for DataSet's of Tuples")__		}_		final TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		DataSet<TupleSummaryAggregator<R>> result = input.mapPartition(new MapPartitionFunction<T, TupleSummaryAggregator<R>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<TupleSummaryAggregator<R>> out) throws Exception {_				TupleSummaryAggregator<R> aggregator = SummaryAggregatorFactory.create(inType)__				for (Tuple value: values) {_					aggregator.aggregate(value)__				}_				out.collect(aggregator)__			}_		}).reduce(new ReduceFunction<TupleSummaryAggregator<R>>() {_			@Override_			public TupleSummaryAggregator<R> reduce(TupleSummaryAggregator<R> agg1, TupleSummaryAggregator<R> agg2) throws Exception {_				agg1.combine(agg2)__				return agg1__			}_		})__		return result.collect().get(0).result()__	};summarize,a,data,set,of,tuples,by,collecting,single,pass,statistics,for,all,columns,example,usage,pre,code,dataset,tuple3,double,string,boolean,input,tuple3,numeric,column,summary,string,column,summary,boolean,column,summary,summary,data,set,utils,summarize,input,summary,f0,get,standard,deviation,summary,f1,get,max,length,pre,return,the,summary,as,a,tuple,the,same,width,as,input,rows;public,static,r,extends,tuple,t,extends,tuple,r,summarize,data,set,t,input,throws,exception,if,input,get,type,is,tuple,type,throw,new,illegal,argument,exception,summarize,is,only,implemented,for,data,set,s,of,tuples,final,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,data,set,tuple,summary,aggregator,r,result,input,map,partition,new,map,partition,function,t,tuple,summary,aggregator,r,override,public,void,map,partition,iterable,t,values,collector,tuple,summary,aggregator,r,out,throws,exception,tuple,summary,aggregator,r,aggregator,summary,aggregator,factory,create,in,type,for,tuple,value,values,aggregator,aggregate,value,out,collect,aggregator,reduce,new,reduce,function,tuple,summary,aggregator,r,override,public,tuple,summary,aggregator,r,reduce,tuple,summary,aggregator,r,agg1,tuple,summary,aggregator,r,agg2,throws,exception,agg1,combine,agg2,return,agg1,return,result,collect,get,0,result
DataSetUtils -> public static <R extends Tuple, T extends Tuple> R summarize(DataSet<T> input) throws Exception;1500387265;Summarize a DataSet of Tuples by collecting single pass statistics for all columns.__<p>Example usage:_<pre>_{@code_Dataset<Tuple3<Double, String, Boolean>> input = // [...]_Tuple3<NumericColumnSummary,StringColumnSummary, BooleanColumnSummary> summary = DataSetUtils.summarize(input)__summary.f0.getStandardDeviation()_summary.f1.getMaxLength()__</pre>_@return the summary as a Tuple the same width as input rows;public static <R extends Tuple, T extends Tuple> R summarize(DataSet<T> input) throws Exception {_		if (!input.getType().isTupleType()) {_			throw new IllegalArgumentException("summarize() is only implemented for DataSet's of Tuples")__		}_		final TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		DataSet<TupleSummaryAggregator<R>> result = input.mapPartition(new MapPartitionFunction<T, TupleSummaryAggregator<R>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<TupleSummaryAggregator<R>> out) throws Exception {_				TupleSummaryAggregator<R> aggregator = SummaryAggregatorFactory.create(inType)__				for (Tuple value : values) {_					aggregator.aggregate(value)__				}_				out.collect(aggregator)__			}_		}).reduce(new ReduceFunction<TupleSummaryAggregator<R>>() {_			@Override_			public TupleSummaryAggregator<R> reduce(TupleSummaryAggregator<R> agg1, TupleSummaryAggregator<R> agg2) throws Exception {_				agg1.combine(agg2)__				return agg1__			}_		})__		return result.collect().get(0).result()__	};summarize,a,data,set,of,tuples,by,collecting,single,pass,statistics,for,all,columns,p,example,usage,pre,code,dataset,tuple3,double,string,boolean,input,tuple3,numeric,column,summary,string,column,summary,boolean,column,summary,summary,data,set,utils,summarize,input,summary,f0,get,standard,deviation,summary,f1,get,max,length,pre,return,the,summary,as,a,tuple,the,same,width,as,input,rows;public,static,r,extends,tuple,t,extends,tuple,r,summarize,data,set,t,input,throws,exception,if,input,get,type,is,tuple,type,throw,new,illegal,argument,exception,summarize,is,only,implemented,for,data,set,s,of,tuples,final,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,data,set,tuple,summary,aggregator,r,result,input,map,partition,new,map,partition,function,t,tuple,summary,aggregator,r,override,public,void,map,partition,iterable,t,values,collector,tuple,summary,aggregator,r,out,throws,exception,tuple,summary,aggregator,r,aggregator,summary,aggregator,factory,create,in,type,for,tuple,value,values,aggregator,aggregate,value,out,collect,aggregator,reduce,new,reduce,function,tuple,summary,aggregator,r,override,public,tuple,summary,aggregator,r,reduce,tuple,summary,aggregator,r,agg1,tuple,summary,aggregator,r,agg2,throws,exception,agg1,combine,agg2,return,agg1,return,result,collect,get,0,result
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSample, 		final long seed);1440164487;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._<p/>__@param withReplacement Whether element can be selected more than once._@param numSample       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSample,_		final long seed) {__		SampleInPartition sampleInPartition = new SampleInPartition<T>(withReplacement, numSample, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<T>(withReplacement, numSample, seed)__		return new GroupReduceOperator<IntermediateSampleData<T>, T>(mapPartitionOperator,_			input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,sample,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,sample,final,long,seed,sample,in,partition,sample,in,partition,new,sample,in,partition,t,with,replacement,num,sample,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,t,with,replacement,num,sample,seed,return,new,group,reduce,operator,intermediate,sample,data,t,t,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSample, 		final long seed);1441108151;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._<p/>__@param withReplacement Whether element can be selected more than once._@param numSample       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSample,_		final long seed) {__		SampleInPartition sampleInPartition = new SampleInPartition<T>(withReplacement, numSample, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<T>(withReplacement, numSample, seed)__		return new GroupReduceOperator<IntermediateSampleData<T>, T>(mapPartitionOperator,_			input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,sample,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,sample,final,long,seed,sample,in,partition,sample,in,partition,new,sample,in,partition,t,with,replacement,num,sample,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,t,with,replacement,num,sample,seed,return,new,group,reduce,operator,intermediate,sample,data,t,t,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSample, 		final long seed);1443564120;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._<p/>__@param withReplacement Whether element can be selected more than once._@param numSample       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSample,_		final long seed) {__		SampleInPartition sampleInPartition = new SampleInPartition<T>(withReplacement, numSample, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<T>(withReplacement, numSample, seed)__		return new GroupReduceOperator<IntermediateSampleData<T>, T>(mapPartitionOperator,_			input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,sample,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,sample,final,long,seed,sample,in,partition,sample,in,partition,new,sample,in,partition,t,with,replacement,num,sample,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,t,with,replacement,num,sample,seed,return,new,group,reduce,operator,intermediate,sample,data,t,t,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSample, 		final long seed);1446112342;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSample       The expected sample size._@param seed            Random number generator seed._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSample,_		final long seed) {__		SampleInPartition sampleInPartition = new SampleInPartition<T>(withReplacement, numSample, seed)__		MapPartitionOperator mapPartitionOperator = input.mapPartition(sampleInPartition)___		_		String callLocation = Utils.getCallLocationName()__		SampleInCoordinator<T> sampleInCoordinator = new SampleInCoordinator<T>(withReplacement, numSample, seed)__		return new GroupReduceOperator<IntermediateSampleData<T>, T>(mapPartitionOperator,_			input.getType(), sampleInCoordinator, callLocation)__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,sample,the,expected,sample,size,param,seed,random,number,generator,seed,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,sample,final,long,seed,sample,in,partition,sample,in,partition,new,sample,in,partition,t,with,replacement,num,sample,seed,map,partition,operator,map,partition,operator,input,map,partition,sample,in,partition,string,call,location,utils,get,call,location,name,sample,in,coordinator,t,sample,in,coordinator,new,sample,in,coordinator,t,with,replacement,num,sample,seed,return,new,group,reduce,operator,intermediate,sample,data,t,t,map,partition,operator,input,get,type,sample,in,coordinator,call,location
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1435486274;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer,Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for(T value: values) {_					counter++__				}__				out.collect(new Tuple2<Integer, Long>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,integer,long,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1435872343;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer,Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for(T value: values) {_					counter++__				}__				out.collect(new Tuple2<Integer, Long>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,integer,long,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1440164487;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer,Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for(T value: values) {_					counter++__				}__				out.collect(new Tuple2<Integer, Long>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,integer,long,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1441108151;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}__				out.collect(new Tuple2<Integer, Long>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,integer,long,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1443564120;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}__				out.collect(new Tuple2<Integer, Long>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,integer,long,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1446112342;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}__				out.collect(new Tuple2<Integer, Long>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,integer,long,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1447771085;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}__				out.collect(new Tuple2<>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1452880737;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}__				out.collect(new Tuple2<>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1454679829;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}__				out.collect(new Tuple2<>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1455101486;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}__				out.collect(new Tuple2<>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input);1458743533;Method that goes over all the elements in each partition in order to retrieve_the total number of elements.__@param input the DataSet received as input_@return a data set containing tuples of subtask index, number of elements mappings.;private static <T> DataSet<Tuple2<Integer, Long>> countElements(DataSet<T> input) {_		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Integer, Long>>() {_			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Integer, Long>> out) throws Exception {_				long counter = 0__				for (T value : values) {_					counter++__				}__				out.collect(new Tuple2<>(getRuntimeContext().getIndexOfThisSubtask(), counter))__			}_		})__	};method,that,goes,over,all,the,elements,in,each,partition,in,order,to,retrieve,the,total,number,of,elements,param,input,the,data,set,received,as,input,return,a,data,set,containing,tuples,of,subtask,index,number,of,elements,mappings;private,static,t,data,set,tuple2,integer,long,count,elements,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,integer,long,override,public,void,map,partition,iterable,t,values,collector,tuple2,integer,long,out,throws,exception,long,counter,0,for,t,value,values,counter,out,collect,new,tuple2,get,runtime,context,get,index,of,this,subtask,counter
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields);1458743533;Range-partitions a DataSet on the specified fields.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType()), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,fields;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,string,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields);1460755044;Range-partitions a DataSet on the specified fields.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType()), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,fields;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,string,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields);1460990858;Range-partitions a DataSet on the specified fields.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType()), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,fields;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,string,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields);1462899491;Range-partitions a DataSet on the specified fields.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType()), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,fields;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,string,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields);1489671807;Range-partitions a DataSet on the specified fields.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType()), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,fields;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,string,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields);1500387265;Range-partitions a DataSet on the specified fields.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, String... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType()), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,fields;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,string,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,distribution,utils,get,call,location,name
DataSetUtils -> private DataSetUtils();1443564120;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1446112342;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1447771085;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1452880737;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1454679829;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1455101486;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1458743533;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1460755044;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1460990858;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1462899491;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1489671807;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> private DataSetUtils();1500387265;Private constructor to prevent instantiation.;private DataSetUtils() {_		throw new RuntimeException()__	};private,constructor,to,prevent,instantiation;private,data,set,utils,throw,new,runtime,exception
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples);1447771085;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples) {__		return sampleWithSize(input, withReplacement, numSamples, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,return,sample,with,size,input,with,replacement,num,samples,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples);1452880737;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples) {__		return sampleWithSize(input, withReplacement, numSamples, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,return,sample,with,size,input,with,replacement,num,samples,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples);1454679829;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples) {__		return sampleWithSize(input, withReplacement, numSamples, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,return,sample,with,size,input,with,replacement,num,samples,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples);1455101486;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples) {__		return sampleWithSize(input, withReplacement, numSamples, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,return,sample,with,size,input,with,replacement,num,samples,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples);1458743533;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples) {__		return sampleWithSize(input, withReplacement, numSamples, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,return,sample,with,size,input,with,replacement,num,samples,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples);1460755044;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples) {__		return sampleWithSize(input, withReplacement, numSamples, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,return,sample,with,size,input,with,replacement,num,samples,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples);1460990858;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples) {__		return sampleWithSize(input, withReplacement, numSamples, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,return,sample,with,size,input,with,replacement,num,samples,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples);1462899491;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples) {__		return sampleWithSize(input, withReplacement, numSamples, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,return,sample,with,size,input,with,replacement,num,samples,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples);1489671807;Generate a sample of DataSet which contains fixed size elements._<p>_<strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision._</p>__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples) {__		return sampleWithSize(input, withReplacement, numSamples, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,p,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,return,sample,with,size,input,with,replacement,num,samples,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<T> sampleWithSize( 		DataSet <T> input, 		final boolean withReplacement, 		final int numSamples);1500387265;Generate a sample of DataSet which contains fixed size elements.__<p><strong>NOTE:</strong> Sample with fixed size is not as efficient as sample with fraction, use sample with_fraction unless you need exact precision.__@param withReplacement Whether element can be selected more than once._@param numSamples       The expected sample size._@return The sampled DataSet;public static <T> DataSet<T> sampleWithSize(_		DataSet <T> input,_		final boolean withReplacement,_		final int numSamples) {__		return sampleWithSize(input, withReplacement, numSamples, Utils.RNG.nextLong())__	};generate,a,sample,of,data,set,which,contains,fixed,size,elements,p,strong,note,strong,sample,with,fixed,size,is,not,as,efficient,as,sample,with,fraction,use,sample,with,fraction,unless,you,need,exact,precision,param,with,replacement,whether,element,can,be,selected,more,than,once,param,num,samples,the,expected,sample,size,return,the,sampled,data,set;public,static,t,data,set,t,sample,with,size,data,set,t,input,final,boolean,with,replacement,final,int,num,samples,return,sample,with,size,input,with,replacement,num,samples,utils,rng,next,long
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1435872343;Method that assigns unique Long labels to all the elements in the input data set by making use of the_following abstractions:_<ul>_<li> a map function generates an n-bit (n - number of parallel tasks) ID based on its own index_<li> with each record, a counter c is increased_<li> the unique label is then produced by shifting the counter c by the n-bit mapper ID_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = log2(getRuntimeContext().getNumberOfParallelSubtasks())__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for(T value: values) {_					label = start << shifter + taskId___					if(log2(start) + shifter < log2(Long.MAX_VALUE)) {_						out.collect(new Tuple2<Long, T>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,unique,long,labels,to,all,the,elements,in,the,input,data,set,by,making,use,of,the,following,abstractions,ul,li,a,map,function,generates,an,n,bit,n,number,of,parallel,tasks,id,based,on,its,own,index,li,with,each,record,a,counter,c,is,increased,li,the,unique,label,is,then,produced,by,shifting,the,counter,c,by,the,n,bit,mapper,id,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,log2,get,runtime,context,get,number,of,parallel,subtasks,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,log2,start,shifter,log2,long,out,collect,new,tuple2,long,t,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1440164487;Method that assigns unique Long labels to all the elements in the input data set by making use of the_following abstractions:_<ul>_<li> a map function generates an n-bit (n - number of parallel tasks) ID based on its own index_<li> with each record, a counter c is increased_<li> the unique label is then produced by shifting the counter c by the n-bit mapper ID_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = log2(getRuntimeContext().getNumberOfParallelSubtasks())__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for(T value: values) {_					label = start << shifter + taskId___					if(log2(start) + shifter < log2(Long.MAX_VALUE)) {_						out.collect(new Tuple2<Long, T>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,unique,long,labels,to,all,the,elements,in,the,input,data,set,by,making,use,of,the,following,abstractions,ul,li,a,map,function,generates,an,n,bit,n,number,of,parallel,tasks,id,based,on,its,own,index,li,with,each,record,a,counter,c,is,increased,li,the,unique,label,is,then,produced,by,shifting,the,counter,c,by,the,n,bit,mapper,id,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,log2,get,runtime,context,get,number,of,parallel,subtasks,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,log2,start,shifter,log2,long,out,collect,new,tuple2,long,t,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1441108151;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<Long, T>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,long,t,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1443564120;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<Long, T>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,long,t,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1446112342;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<Long, T>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,long,t,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1447771085;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1452880737;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1454679829;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1455101486;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1458743533;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1460755044;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1460990858;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1462899491;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1489671807;Method that assigns a unique {@link Long} value to all elements in the input data set in the following way:_<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,in,the,following,way,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input);1500387265;Method that assigns a unique {@link Long} value to all elements in the input data set as described below._<ul>_<li> a map function is applied to the input data set_<li> each map task holds a counter c which is increased for each record_<li> c is shifted by n bits where n = log2(number of parallel tasks)_<li> to create a unique ID among all tasks, the task id is added to the counter_<li> for each record, the resulting counter is collected_</ul>__@param input the input data set_@return a data set of tuple 2 consisting of ids and initial values.;public static <T> DataSet<Tuple2<Long, T>> zipWithUniqueId (DataSet <T> input) {__		return input.mapPartition(new RichMapPartitionFunction<T, Tuple2<Long, T>>() {__			long maxBitSize = getBitSize(Long.MAX_VALUE)__			long shifter = 0__			long start = 0__			long taskId = 0__			long label = 0___			@Override_			public void open(Configuration parameters) throws Exception {_				super.open(parameters)__				shifter = getBitSize(getRuntimeContext().getNumberOfParallelSubtasks() - 1)__				taskId = getRuntimeContext().getIndexOfThisSubtask()__			}__			@Override_			public void mapPartition(Iterable<T> values, Collector<Tuple2<Long, T>> out) throws Exception {_				for (T value : values) {_					label = (start << shifter) + taskId___					if (getBitSize(start) + shifter < maxBitSize) {_						out.collect(new Tuple2<>(label, value))__						start++__					} else {_						throw new Exception("Exceeded Long value range while generating labels")__					}_				}_			}_		})__	};method,that,assigns,a,unique,link,long,value,to,all,elements,in,the,input,data,set,as,described,below,ul,li,a,map,function,is,applied,to,the,input,data,set,li,each,map,task,holds,a,counter,c,which,is,increased,for,each,record,li,c,is,shifted,by,n,bits,where,n,log2,number,of,parallel,tasks,li,to,create,a,unique,id,among,all,tasks,the,task,id,is,added,to,the,counter,li,for,each,record,the,resulting,counter,is,collected,ul,param,input,the,input,data,set,return,a,data,set,of,tuple,2,consisting,of,ids,and,initial,values;public,static,t,data,set,tuple2,long,t,zip,with,unique,id,data,set,t,input,return,input,map,partition,new,rich,map,partition,function,t,tuple2,long,t,long,max,bit,size,get,bit,size,long,long,shifter,0,long,start,0,long,task,id,0,long,label,0,override,public,void,open,configuration,parameters,throws,exception,super,open,parameters,shifter,get,bit,size,get,runtime,context,get,number,of,parallel,subtasks,1,task,id,get,runtime,context,get,index,of,this,subtask,override,public,void,map,partition,iterable,t,values,collector,tuple2,long,t,out,throws,exception,for,t,value,values,label,start,shifter,task,id,if,get,bit,size,start,shifter,max,bit,size,out,collect,new,tuple2,label,value,start,else,throw,new,exception,exceeded,long,value,range,while,generating,labels
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields);1458743533;Range-partitions a DataSet on the specified tuple field positions.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType(), false), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,tuple,field,positions;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,int,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,false,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields);1460755044;Range-partitions a DataSet on the specified tuple field positions.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType(), false), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,tuple,field,positions;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,int,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,false,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields);1460990858;Range-partitions a DataSet on the specified tuple field positions.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType(), false), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,tuple,field,positions;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,int,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,false,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields);1462899491;Range-partitions a DataSet on the specified tuple field positions.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType(), false), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,tuple,field,positions;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,int,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,false,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields);1489671807;Range-partitions a DataSet on the specified tuple field positions.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType(), false), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,tuple,field,positions;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,int,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,false,distribution,utils,get,call,location,name
DataSetUtils -> public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields);1500387265;Range-partitions a DataSet on the specified tuple field positions.;public static <T> PartitionOperator<T> partitionByRange(DataSet<T> input, DataDistribution distribution, int... fields) {_		return new PartitionOperator<>(input, PartitionOperatorBase.PartitionMethod.RANGE, new Keys.ExpressionKeys<>(fields, input.getType(), false), distribution, Utils.getCallLocationName())__	};range,partitions,a,data,set,on,the,specified,tuple,field,positions;public,static,t,partition,operator,t,partition,by,range,data,set,t,input,data,distribution,distribution,int,fields,return,new,partition,operator,input,partition,operator,base,partition,method,range,new,keys,expression,keys,fields,input,get,type,false,distribution,utils,get,call,location,name
DataSetUtils -> @Deprecated 	public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception;1489671807;Convenience method to get the count (number of elements) of a DataSet_as well as the checksum (sum over element hashes).__@return A ChecksumHashCode that represents the count and checksum of elements in the data set._@deprecated replaced with {@code org.apache.flink.graph.asm.dataset.ChecksumHashCode} in Gelly;@Deprecated_	public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception {_		final String id = new AbstractID().toString()___		input.output(new Utils.ChecksumHashCodeHelper<T>(id)).name("ChecksumHashCode")___		JobExecutionResult res = input.getExecutionEnvironment().execute()__		return res.<Utils.ChecksumHashCode> getAccumulatorResult(id)__	};convenience,method,to,get,the,count,number,of,elements,of,a,data,set,as,well,as,the,checksum,sum,over,element,hashes,return,a,checksum,hash,code,that,represents,the,count,and,checksum,of,elements,in,the,data,set,deprecated,replaced,with,code,org,apache,flink,graph,asm,dataset,checksum,hash,code,in,gelly;deprecated,public,static,t,utils,checksum,hash,code,checksum,hash,code,data,set,t,input,throws,exception,final,string,id,new,abstract,id,to,string,input,output,new,utils,checksum,hash,code,helper,t,id,name,checksum,hash,code,job,execution,result,res,input,get,execution,environment,execute,return,res,utils,checksum,hash,code,get,accumulator,result,id
DataSetUtils -> @Deprecated 	public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception;1500387265;Convenience method to get the count (number of elements) of a DataSet_as well as the checksum (sum over element hashes).__@return A ChecksumHashCode that represents the count and checksum of elements in the data set._@deprecated replaced with {@code org.apache.flink.graph.asm.dataset.ChecksumHashCode} in Gelly;@Deprecated_	public static <T> Utils.ChecksumHashCode checksumHashCode(DataSet<T> input) throws Exception {_		final String id = new AbstractID().toString()___		input.output(new Utils.ChecksumHashCodeHelper<T>(id)).name("ChecksumHashCode")___		JobExecutionResult res = input.getExecutionEnvironment().execute()__		return res.<Utils.ChecksumHashCode> getAccumulatorResult(id)__	};convenience,method,to,get,the,count,number,of,elements,of,a,data,set,as,well,as,the,checksum,sum,over,element,hashes,return,a,checksum,hash,code,that,represents,the,count,and,checksum,of,elements,in,the,data,set,deprecated,replaced,with,code,org,apache,flink,graph,asm,dataset,checksum,hash,code,in,gelly;deprecated,public,static,t,utils,checksum,hash,code,checksum,hash,code,data,set,t,input,throws,exception,final,string,id,new,abstract,id,to,string,input,output,new,utils,checksum,hash,code,helper,t,id,name,checksum,hash,code,job,execution,result,res,input,get,execution,environment,execute,return,res,utils,checksum,hash,code,get,accumulator,result,id
