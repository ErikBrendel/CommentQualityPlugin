# id;timestamp;commentText;codeText;commentWords;codeWords
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field);1405024514;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		_		Validate.notNull(function)__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field);1405090423;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		_		Validate.notNull(function)__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field);1406821655;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		_		Validate.notNull(function)__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field);1406853229;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		_		Validate.notNull(function)__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field);1410037686;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		_		Validate.notNull(function)__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field);1410044397;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		_		Validate.notNull(function)__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field);1411372797;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		_		Validate.notNull(function)__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field);1411372797;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		_		Validate.notNull(function)__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field);1411473593;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		_		Validate.notNull(function)__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field);1412761141;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		_		Validate.notNull(function)__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName);1415874087;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		Validate.notNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,string,aggregate,location,name,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName);1416309577;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		Validate.notNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,string,aggregate,location,name,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName);1427097830;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Validate.notNull(input).getDataSet(), input.getDataSet().getType())__		Validate.notNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,string,aggregate,location,name,super,validate,not,null,input,get,data,set,input,get,data,set,get,type,validate,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName);1431696388;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input).getDataSet(), input.getDataSet().getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,get,data,set,input,get,data,set,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName);1453803444;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input).getDataSet(), input.getDataSet().getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,get,data,set,input,get,data,set,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName);1453803455;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input).getInputDataSet(), input.getInputDataSet().getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getInputDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getInputDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,get,input,data,set,input,get,input,data,set,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,input,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,input,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName);1454428544;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input).getInputDataSet(), input.getInputDataSet().getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getInputDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getInputDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,get,input,data,set,input,get,input,data,set,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,input,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,input,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName);1454679829;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input).getInputDataSet(), input.getInputDataSet().getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getInputDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getInputDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,get,input,data,set,input,get,input,data,set,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,input,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,input,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName);1462899491;Grouped aggregation__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input).getInputDataSet(), input.getInputDataSet().getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getInputDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getInputDataSet().getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,get,input,data,set,input,get,input,data,set,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,input,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,input,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName);1500970016;Grouped aggregation.__@param input_@param function_@param field;public AggregateOperator(Grouping<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input).getInputDataSet(), input.getInputDataSet().getType())__		Preconditions.checkNotNull(function)___		this.aggregateLocationName = aggregateLocationName___		if (!input.getInputDataSet().getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getInputDataSet().getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = input__	};grouped,aggregation,param,input,param,function,param,field;public,aggregate,operator,grouping,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,get,input,data,set,input,get,input,data,set,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,input,data,set,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,input,data,set,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,input
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field);1405024514;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())__		_		Validate.notNull(function)__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field);1405090423;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())__		_		Validate.notNull(function)__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field);1406821655;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())__		_		Validate.notNull(function)__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field);1406853229;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())__		_		Validate.notNull(function)__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field);1410037686;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())__		_		Validate.notNull(function)__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field);1410044397;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())__		_		Validate.notNull(function)__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field);1411372797;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())__		_		Validate.notNull(function)__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfo<?> inType = (TupleTypeInfo<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,in,type,tuple,type,info,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field);1411372797;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())__		_		Validate.notNull(function)__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field);1411473593;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())__		_		Validate.notNull(function)__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field);1412761141;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field) {_		super(Validate.notNull(input), input.getType())__		_		Validate.notNull(function)__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,super,validate,not,null,input,input,get,type,validate,not,null,function,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName);1415874087;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Validate.notNull(input), input.getType())__		Validate.notNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,string,aggregate,location,name,super,validate,not,null,input,input,get,type,validate,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName);1416309577;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Validate.notNull(input), input.getType())__		Validate.notNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,string,aggregate,location,name,super,validate,not,null,input,input,get,type,validate,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName);1427097830;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Validate.notNull(input), input.getType())__		Validate.notNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,string,aggregate,location,name,super,validate,not,null,input,input,get,type,validate,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName);1431696388;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input), input.getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName);1453803444;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input), input.getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName);1453803455;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input), input.getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName);1454428544;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input), input.getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName);1454679829;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input), input.getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName);1462899491;<p>_Non grouped aggregation;public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input), input.getType())__		Preconditions.checkNotNull(function)__		_		this.aggregateLocationName = aggregateLocationName__		_		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}_		_		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()__		_		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}_		_		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())__		_		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};p,non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
AggregateOperator -> public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName);1500970016;Non grouped aggregation.;public AggregateOperator(DataSet<IN> input, Aggregations function, int field, String aggregateLocationName) {_		super(Preconditions.checkNotNull(input), input.getType())__		Preconditions.checkNotNull(function)___		this.aggregateLocationName = aggregateLocationName___		if (!input.getType().isTupleType()) {_			throw new InvalidProgramException("Aggregating on field positions is only possible on tuple data types.")__		}__		TupleTypeInfoBase<?> inType = (TupleTypeInfoBase<?>) input.getType()___		if (field < 0 || field >= inType.getArity()) {_			throw new IllegalArgumentException("Aggregation field position is out of range.")__		}__		AggregationFunctionFactory factory = function.getFactory()__		AggregationFunction<?> aggFunct = factory.createAggregationFunction(inType.getTypeAt(field).getTypeClass())___		_		this.aggregationFunctions.add(aggFunct)__		this.fields.add(field)__		this.grouping = null__	};non,grouped,aggregation;public,aggregate,operator,data,set,in,input,aggregations,function,int,field,string,aggregate,location,name,super,preconditions,check,not,null,input,input,get,type,preconditions,check,not,null,function,this,aggregate,location,name,aggregate,location,name,if,input,get,type,is,tuple,type,throw,new,invalid,program,exception,aggregating,on,field,positions,is,only,possible,on,tuple,data,types,tuple,type,info,base,in,type,tuple,type,info,base,input,get,type,if,field,0,field,in,type,get,arity,throw,new,illegal,argument,exception,aggregation,field,position,is,out,of,range,aggregation,function,factory,factory,function,get,factory,aggregation,function,agg,funct,factory,create,aggregation,function,in,type,get,type,at,field,get,type,class,this,aggregation,functions,add,agg,funct,this,fields,add,field,this,grouping,null
