# id;timestamp;commentText;codeText;commentWords;codeWords
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnInvoke() throws Throwable;1508928742;Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnInvoke() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.processElement(new StreamRecord<>("msg-2"))__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,invoke,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,invoke,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,process,element,new,stream,record,msg,2,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnInvoke() throws Throwable;1508928785;Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnInvoke() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.processElement(new StreamRecord<>("msg-2"))__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,invoke,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,invoke,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,process,element,new,stream,record,msg,2,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnInvoke() throws Throwable;1508928794;Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnInvoke() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.processElement(new StreamRecord<>("msg-2"))__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,invoke,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,invoke,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,process,element,new,stream,record,msg,2,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnInvoke() throws Throwable;1511347989;Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnInvoke() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.processElement(new StreamRecord<>("msg-2"))__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,invoke,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,invoke,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,process,element,new,stream,record,msg,2,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnInvoke() throws Throwable;1512029104;Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnInvoke() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.processElement(new StreamRecord<>("msg-2"))__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,invoke,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,invoke,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,process,element,new,stream,record,msg,2,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnInvoke() throws Throwable;1513572249;Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnInvoke() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.processElement(new StreamRecord<>("msg-2"))__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,invoke,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,invoke,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,process,element,new,stream,record,msg,2,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnInvoke() throws Throwable;1515177485;Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnInvoke() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.processElement(new StreamRecord<>("msg-2"))__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,invoke,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,invoke,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,process,element,new,stream,record,msg,2,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnInvoke() throws Throwable;1529652658;Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnInvoke() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.processElement(new StreamRecord<>("msg-2"))__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,invoke,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,invoke,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,process,element,new,stream,record,msg,2,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnInvoke() throws Throwable;1538998760;Test ensuring that if an invoke call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnInvoke() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.processElement(new StreamRecord<>("msg-2"))__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,invoke,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,invoke,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,process,element,new,stream,record,msg,2,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable;1508928742;Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.snapshot(123L, 123L)__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,a,snapshot,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,checkpoint,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,snapshot,123l,123l,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable;1508928785;Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.snapshot(123L, 123L)__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,a,snapshot,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,checkpoint,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,snapshot,123l,123l,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable;1508928794;Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.snapshot(123L, 123L)__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,a,snapshot,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,checkpoint,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,snapshot,123l,123l,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable;1511347989;Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.snapshot(123L, 123L)__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,a,snapshot,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,checkpoint,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,snapshot,123l,123l,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable;1512029104;Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.snapshot(123L, 123L)__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,a,snapshot,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,checkpoint,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,snapshot,123l,123l,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable;1513572249;Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.snapshot(123L, 123L)__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,a,snapshot,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,checkpoint,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,snapshot,123l,123l,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable;1515177485;Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.snapshot(123L, 123L)__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,a,snapshot,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,checkpoint,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,snapshot,123l,123l,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable;1529652658;Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.snapshot(123L, 123L)__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,a,snapshot,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,checkpoint,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,snapshot,123l,123l,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test 	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable;1538998760;Test ensuring that if a snapshot call happens right after an async exception is caught, it should be rethrown.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test_	public void testAsyncErrorRethrownOnCheckpoint() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))___		producer.getPendingRecordFutures().get(0).setException(new Exception("artificial async exception"))___		try {_			testHarness.snapshot(123L, 123L)__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async exception").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,a,snapshot,call,happens,right,after,an,async,exception,is,caught,it,should,be,rethrown;suppress,warnings,result,of,method,call,ignored,test,public,void,test,async,error,rethrown,on,checkpoint,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,producer,get,pending,record,futures,get,0,set,exception,new,exception,artificial,async,exception,try,test,harness,snapshot,123l,123l,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,exception,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"}) 	@Test(timeout = 10000) 	public void testAtLeastOnceProducer() throws Throwable;1508928742;Test ensuring that the producer is not dropping buffered records__we set a timeout because the test will not finish if the logic is broken.;@SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"})_	@Test(timeout = 10000)_	public void testAtLeastOnceProducer() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		_		producer.waitUntilFlushStarted()__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		producer.getPendingRecordFutures().get(0).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(1).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(2).set(result)___		_		snapshotThread.sync()___		testHarness.close()__	};test,ensuring,that,the,producer,is,not,dropping,buffered,records,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;suppress,warnings,unchecked,result,of,method,call,ignored,test,timeout,10000,public,void,test,at,least,once,producer,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,wait,until,flush,started,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,snapshot,thread,sync,test,harness,close
FlinkKinesisProducerTest -> @SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"}) 	@Test(timeout = 10000) 	public void testAtLeastOnceProducer() throws Throwable;1508928785;Test ensuring that the producer is not dropping buffered records__we set a timeout because the test will not finish if the logic is broken.;@SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"})_	@Test(timeout = 10000)_	public void testAtLeastOnceProducer() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		_		producer.waitUntilFlushStarted()__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		producer.getPendingRecordFutures().get(0).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(1).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(2).set(result)___		_		snapshotThread.sync()___		testHarness.close()__	};test,ensuring,that,the,producer,is,not,dropping,buffered,records,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;suppress,warnings,unchecked,result,of,method,call,ignored,test,timeout,10000,public,void,test,at,least,once,producer,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,wait,until,flush,started,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,snapshot,thread,sync,test,harness,close
FlinkKinesisProducerTest -> @SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"}) 	@Test(timeout = 10000) 	public void testAtLeastOnceProducer() throws Throwable;1508928794;Test ensuring that the producer is not dropping buffered records__we set a timeout because the test will not finish if the logic is broken.;@SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"})_	@Test(timeout = 10000)_	public void testAtLeastOnceProducer() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		_		producer.waitUntilFlushStarted()__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		producer.getPendingRecordFutures().get(0).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(1).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(2).set(result)___		_		snapshotThread.sync()___		testHarness.close()__	};test,ensuring,that,the,producer,is,not,dropping,buffered,records,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;suppress,warnings,unchecked,result,of,method,call,ignored,test,timeout,10000,public,void,test,at,least,once,producer,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,wait,until,flush,started,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,snapshot,thread,sync,test,harness,close
FlinkKinesisProducerTest -> @SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"}) 	@Test(timeout = 10000) 	public void testAtLeastOnceProducer() throws Throwable;1511347989;Test ensuring that the producer is not dropping buffered records__we set a timeout because the test will not finish if the logic is broken.;@SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"})_	@Test(timeout = 10000)_	public void testAtLeastOnceProducer() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		_		producer.waitUntilFlushStarted()__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		producer.getPendingRecordFutures().get(0).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(1).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(2).set(result)___		_		snapshotThread.sync()___		testHarness.close()__	};test,ensuring,that,the,producer,is,not,dropping,buffered,records,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;suppress,warnings,unchecked,result,of,method,call,ignored,test,timeout,10000,public,void,test,at,least,once,producer,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,wait,until,flush,started,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,snapshot,thread,sync,test,harness,close
FlinkKinesisProducerTest -> @SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"}) 	@Test(timeout = 10000) 	public void testAtLeastOnceProducer() throws Throwable;1512029104;Test ensuring that the producer is not dropping buffered records__we set a timeout because the test will not finish if the logic is broken.;@SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"})_	@Test(timeout = 10000)_	public void testAtLeastOnceProducer() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		_		producer.waitUntilFlushStarted()__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		producer.getPendingRecordFutures().get(0).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(1).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(2).set(result)___		_		snapshotThread.sync()___		testHarness.close()__	};test,ensuring,that,the,producer,is,not,dropping,buffered,records,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;suppress,warnings,unchecked,result,of,method,call,ignored,test,timeout,10000,public,void,test,at,least,once,producer,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,wait,until,flush,started,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,snapshot,thread,sync,test,harness,close
FlinkKinesisProducerTest -> @SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"}) 	@Test(timeout = 10000) 	public void testAtLeastOnceProducer() throws Throwable;1513572249;Test ensuring that the producer is not dropping buffered records__we set a timeout because the test will not finish if the logic is broken.;@SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"})_	@Test(timeout = 10000)_	public void testAtLeastOnceProducer() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		_		producer.waitUntilFlushStarted()__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		producer.getPendingRecordFutures().get(0).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(1).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(2).set(result)___		_		snapshotThread.sync()___		testHarness.close()__	};test,ensuring,that,the,producer,is,not,dropping,buffered,records,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;suppress,warnings,unchecked,result,of,method,call,ignored,test,timeout,10000,public,void,test,at,least,once,producer,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,wait,until,flush,started,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,snapshot,thread,sync,test,harness,close
FlinkKinesisProducerTest -> @SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"}) 	@Test(timeout = 10000) 	public void testAtLeastOnceProducer() throws Throwable;1515177485;Test ensuring that the producer is not dropping buffered records__we set a timeout because the test will not finish if the logic is broken.;@SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"})_	@Test(timeout = 10000)_	public void testAtLeastOnceProducer() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		_		producer.waitUntilFlushStarted()__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		producer.getPendingRecordFutures().get(0).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(1).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(2).set(result)___		_		snapshotThread.sync()___		testHarness.close()__	};test,ensuring,that,the,producer,is,not,dropping,buffered,records,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;suppress,warnings,unchecked,result,of,method,call,ignored,test,timeout,10000,public,void,test,at,least,once,producer,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,wait,until,flush,started,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,snapshot,thread,sync,test,harness,close
FlinkKinesisProducerTest -> @SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"}) 	@Test(timeout = 10000) 	public void testAtLeastOnceProducer() throws Throwable;1529652658;Test ensuring that the producer is not dropping buffered records__we set a timeout because the test will not finish if the logic is broken.;@SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"})_	@Test(timeout = 10000)_	public void testAtLeastOnceProducer() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		_		producer.waitUntilFlushStarted()__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		producer.getPendingRecordFutures().get(0).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(1).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(2).set(result)___		_		snapshotThread.sync()___		testHarness.close()__	};test,ensuring,that,the,producer,is,not,dropping,buffered,records,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;suppress,warnings,unchecked,result,of,method,call,ignored,test,timeout,10000,public,void,test,at,least,once,producer,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,wait,until,flush,started,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,snapshot,thread,sync,test,harness,close
FlinkKinesisProducerTest -> @SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"}) 	@Test(timeout = 10000) 	public void testAtLeastOnceProducer() throws Throwable;1538998760;Test ensuring that the producer is not dropping buffered records__we set a timeout because the test will not finish if the logic is broken.;@SuppressWarnings({"unchecked", "ResultOfMethodCallIgnored"})_	@Test(timeout = 10000)_	public void testAtLeastOnceProducer() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		_		producer.waitUntilFlushStarted()__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		producer.getPendingRecordFutures().get(0).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(1).set(result)__		Assert.assertTrue("Snapshot returned before all records were flushed", snapshotThread.isAlive())___		producer.getPendingRecordFutures().get(2).set(result)___		_		snapshotThread.sync()___		testHarness.close()__	};test,ensuring,that,the,producer,is,not,dropping,buffered,records,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;suppress,warnings,unchecked,result,of,method,call,ignored,test,timeout,10000,public,void,test,at,least,once,producer,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,wait,until,flush,started,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,assert,assert,true,snapshot,returned,before,all,records,were,flushed,snapshot,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,snapshot,thread,sync,test,harness,close
FlinkKinesisProducerTest -> @Test(timeout = 10000) 	public void testBackpressure() throws Throwable;1529652658;Test ensuring that the producer blocks if the queue limit is exceeded,_until the queue length drops below the limit__we set a timeout because the test will not finish if the logic is broken.;@Test(timeout = 10000)_	public void testBackpressure() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())__		producer.setQueueLimit(1)___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_				new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		CheckedThread msg1 = new CheckedThread() {_			@Override_			public void go() throws Exception {_				testHarness.processElement(new StreamRecord<>("msg-1"))__			}_		}__		msg1.start()__		msg1.trySync(100)__		assertFalse("Flush triggered before reaching queue limit", msg1.isAlive())___		_		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread msg2 = new CheckedThread() {_			@Override_			public void go() throws Exception {_				testHarness.processElement(new StreamRecord<>("msg-2"))__			}_		}__		msg2.start()__		msg2.trySync(100)__		assertFalse("Flush triggered before reaching queue limit", msg2.isAlive())___		CheckedThread moreElementsThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.processElement(new StreamRecord<>("msg-3"))__				_				testHarness.processElement(new StreamRecord<>("msg-4"))__			}_		}__		moreElementsThread.start()___		moreElementsThread.trySync(100)__		assertTrue("Producer should still block, but doesn't", moreElementsThread.isAlive())___		_		producer.getPendingRecordFutures().get(1).set(result)___		moreElementsThread.trySync(100)__		assertTrue("Producer should still block, but doesn't", moreElementsThread.isAlive())___		_		producer.getPendingRecordFutures().get(2).set(result)___		moreElementsThread.trySync(100)___		assertFalse("Prodcuer still blocks although the queue is flushed", moreElementsThread.isAlive())___		producer.getPendingRecordFutures().get(3).set(result)___		testHarness.close()__	};test,ensuring,that,the,producer,blocks,if,the,queue,limit,is,exceeded,until,the,queue,length,drops,below,the,limit,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;test,timeout,10000,public,void,test,backpressure,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,producer,set,queue,limit,1,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,checked,thread,msg1,new,checked,thread,override,public,void,go,throws,exception,test,harness,process,element,new,stream,record,msg,1,msg1,start,msg1,try,sync,100,assert,false,flush,triggered,before,reaching,queue,limit,msg1,is,alive,producer,get,pending,record,futures,get,0,set,result,checked,thread,msg2,new,checked,thread,override,public,void,go,throws,exception,test,harness,process,element,new,stream,record,msg,2,msg2,start,msg2,try,sync,100,assert,false,flush,triggered,before,reaching,queue,limit,msg2,is,alive,checked,thread,more,elements,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,process,element,new,stream,record,msg,3,test,harness,process,element,new,stream,record,msg,4,more,elements,thread,start,more,elements,thread,try,sync,100,assert,true,producer,should,still,block,but,doesn,t,more,elements,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,more,elements,thread,try,sync,100,assert,true,producer,should,still,block,but,doesn,t,more,elements,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,more,elements,thread,try,sync,100,assert,false,prodcuer,still,blocks,although,the,queue,is,flushed,more,elements,thread,is,alive,producer,get,pending,record,futures,get,3,set,result,test,harness,close
FlinkKinesisProducerTest -> @Test(timeout = 10000) 	public void testBackpressure() throws Throwable;1538998760;Test ensuring that the producer blocks if the queue limit is exceeded,_until the queue length drops below the limit__we set a timeout because the test will not finish if the logic is broken.;@Test(timeout = 10000)_	public void testBackpressure() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())__		producer.setQueueLimit(1)___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_				new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)___		CheckedThread msg1 = new CheckedThread() {_			@Override_			public void go() throws Exception {_				testHarness.processElement(new StreamRecord<>("msg-1"))__			}_		}__		msg1.start()__		msg1.trySync(100)__		assertFalse("Flush triggered before reaching queue limit", msg1.isAlive())___		_		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread msg2 = new CheckedThread() {_			@Override_			public void go() throws Exception {_				testHarness.processElement(new StreamRecord<>("msg-2"))__			}_		}__		msg2.start()__		msg2.trySync(100)__		assertFalse("Flush triggered before reaching queue limit", msg2.isAlive())___		CheckedThread moreElementsThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.processElement(new StreamRecord<>("msg-3"))__				_				testHarness.processElement(new StreamRecord<>("msg-4"))__			}_		}__		moreElementsThread.start()___		moreElementsThread.trySync(100)__		assertTrue("Producer should still block, but doesn't", moreElementsThread.isAlive())___		_		producer.getPendingRecordFutures().get(1).set(result)___		moreElementsThread.trySync(100)__		assertTrue("Producer should still block, but doesn't", moreElementsThread.isAlive())___		_		producer.getPendingRecordFutures().get(2).set(result)___		moreElementsThread.trySync(100)___		assertFalse("Prodcuer still blocks although the queue is flushed", moreElementsThread.isAlive())___		producer.getPendingRecordFutures().get(3).set(result)___		testHarness.close()__	};test,ensuring,that,the,producer,blocks,if,the,queue,limit,is,exceeded,until,the,queue,length,drops,below,the,limit,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken;test,timeout,10000,public,void,test,backpressure,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,producer,set,queue,limit,1,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,checked,thread,msg1,new,checked,thread,override,public,void,go,throws,exception,test,harness,process,element,new,stream,record,msg,1,msg1,start,msg1,try,sync,100,assert,false,flush,triggered,before,reaching,queue,limit,msg1,is,alive,producer,get,pending,record,futures,get,0,set,result,checked,thread,msg2,new,checked,thread,override,public,void,go,throws,exception,test,harness,process,element,new,stream,record,msg,2,msg2,start,msg2,try,sync,100,assert,false,flush,triggered,before,reaching,queue,limit,msg2,is,alive,checked,thread,more,elements,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,process,element,new,stream,record,msg,3,test,harness,process,element,new,stream,record,msg,4,more,elements,thread,start,more,elements,thread,try,sync,100,assert,true,producer,should,still,block,but,doesn,t,more,elements,thread,is,alive,producer,get,pending,record,futures,get,1,set,result,more,elements,thread,try,sync,100,assert,true,producer,should,still,block,but,doesn,t,more,elements,thread,is,alive,producer,get,pending,record,futures,get,2,set,result,more,elements,thread,try,sync,100,assert,false,prodcuer,still,blocks,although,the,queue,is,flushed,more,elements,thread,is,alive,producer,get,pending,record,futures,get,3,set,result,test,harness,close
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test(timeout = 10000) 	public void testAsyncErrorRethrownAfterFlush() throws Throwable;1508928742;Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,_it should be rethrown_ we set a timeout because the test will not finish if the logic is broken.__<p>Note that this test does not test the snapshot method is blocked correctly when there are pending recorrds._The test for that is covered in testAtLeastOnceProducer.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test(timeout = 10000)_	public void testAsyncErrorRethrownAfterFlush() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)__		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message"))__		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class))___		try {_			snapshotThread.sync()__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async failure for 2nd message").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,async,exception,is,caught,for,one,of,the,flushed,requests,on,checkpoint,it,should,be,rethrown,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken,p,note,that,this,test,does,not,test,the,snapshot,method,is,blocked,correctly,when,there,are,pending,recorrds,the,test,for,that,is,covered,in,test,at,least,once,producer;suppress,warnings,result,of,method,call,ignored,test,timeout,10000,public,void,test,async,error,rethrown,after,flush,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,get,pending,record,futures,get,1,set,exception,new,exception,artificial,async,failure,for,2nd,message,producer,get,pending,record,futures,get,2,set,mock,user,record,result,class,try,snapshot,thread,sync,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,failure,for,2nd,message,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test(timeout = 10000) 	public void testAsyncErrorRethrownAfterFlush() throws Throwable;1508928785;Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,_it should be rethrown_ we set a timeout because the test will not finish if the logic is broken.__<p>Note that this test does not test the snapshot method is blocked correctly when there are pending recorrds._The test for that is covered in testAtLeastOnceProducer.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test(timeout = 10000)_	public void testAsyncErrorRethrownAfterFlush() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)__		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message"))__		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class))___		try {_			snapshotThread.sync()__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async failure for 2nd message").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,async,exception,is,caught,for,one,of,the,flushed,requests,on,checkpoint,it,should,be,rethrown,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken,p,note,that,this,test,does,not,test,the,snapshot,method,is,blocked,correctly,when,there,are,pending,recorrds,the,test,for,that,is,covered,in,test,at,least,once,producer;suppress,warnings,result,of,method,call,ignored,test,timeout,10000,public,void,test,async,error,rethrown,after,flush,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,get,pending,record,futures,get,1,set,exception,new,exception,artificial,async,failure,for,2nd,message,producer,get,pending,record,futures,get,2,set,mock,user,record,result,class,try,snapshot,thread,sync,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,failure,for,2nd,message,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test(timeout = 10000) 	public void testAsyncErrorRethrownAfterFlush() throws Throwable;1508928794;Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,_it should be rethrown_ we set a timeout because the test will not finish if the logic is broken.__<p>Note that this test does not test the snapshot method is blocked correctly when there are pending recorrds._The test for that is covered in testAtLeastOnceProducer.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test(timeout = 10000)_	public void testAsyncErrorRethrownAfterFlush() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)__		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message"))__		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class))___		try {_			snapshotThread.sync()__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async failure for 2nd message").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,async,exception,is,caught,for,one,of,the,flushed,requests,on,checkpoint,it,should,be,rethrown,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken,p,note,that,this,test,does,not,test,the,snapshot,method,is,blocked,correctly,when,there,are,pending,recorrds,the,test,for,that,is,covered,in,test,at,least,once,producer;suppress,warnings,result,of,method,call,ignored,test,timeout,10000,public,void,test,async,error,rethrown,after,flush,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,get,pending,record,futures,get,1,set,exception,new,exception,artificial,async,failure,for,2nd,message,producer,get,pending,record,futures,get,2,set,mock,user,record,result,class,try,snapshot,thread,sync,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,failure,for,2nd,message,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test(timeout = 10000) 	public void testAsyncErrorRethrownAfterFlush() throws Throwable;1511347989;Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,_it should be rethrown_ we set a timeout because the test will not finish if the logic is broken.__<p>Note that this test does not test the snapshot method is blocked correctly when there are pending recorrds._The test for that is covered in testAtLeastOnceProducer.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test(timeout = 10000)_	public void testAsyncErrorRethrownAfterFlush() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)__		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message"))__		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class))___		try {_			snapshotThread.sync()__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async failure for 2nd message").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,async,exception,is,caught,for,one,of,the,flushed,requests,on,checkpoint,it,should,be,rethrown,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken,p,note,that,this,test,does,not,test,the,snapshot,method,is,blocked,correctly,when,there,are,pending,recorrds,the,test,for,that,is,covered,in,test,at,least,once,producer;suppress,warnings,result,of,method,call,ignored,test,timeout,10000,public,void,test,async,error,rethrown,after,flush,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,get,pending,record,futures,get,1,set,exception,new,exception,artificial,async,failure,for,2nd,message,producer,get,pending,record,futures,get,2,set,mock,user,record,result,class,try,snapshot,thread,sync,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,failure,for,2nd,message,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test(timeout = 10000) 	public void testAsyncErrorRethrownAfterFlush() throws Throwable;1512029104;Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,_it should be rethrown_ we set a timeout because the test will not finish if the logic is broken.__<p>Note that this test does not test the snapshot method is blocked correctly when there are pending recorrds._The test for that is covered in testAtLeastOnceProducer.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test(timeout = 10000)_	public void testAsyncErrorRethrownAfterFlush() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)__		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message"))__		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class))___		try {_			snapshotThread.sync()__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async failure for 2nd message").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,async,exception,is,caught,for,one,of,the,flushed,requests,on,checkpoint,it,should,be,rethrown,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken,p,note,that,this,test,does,not,test,the,snapshot,method,is,blocked,correctly,when,there,are,pending,recorrds,the,test,for,that,is,covered,in,test,at,least,once,producer;suppress,warnings,result,of,method,call,ignored,test,timeout,10000,public,void,test,async,error,rethrown,after,flush,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,get,pending,record,futures,get,1,set,exception,new,exception,artificial,async,failure,for,2nd,message,producer,get,pending,record,futures,get,2,set,mock,user,record,result,class,try,snapshot,thread,sync,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,failure,for,2nd,message,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test(timeout = 10000) 	public void testAsyncErrorRethrownAfterFlush() throws Throwable;1513572249;Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,_it should be rethrown_ we set a timeout because the test will not finish if the logic is broken.__<p>Note that this test does not test the snapshot method is blocked correctly when there are pending recorrds._The test for that is covered in testAtLeastOnceProducer.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test(timeout = 10000)_	public void testAsyncErrorRethrownAfterFlush() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)__		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message"))__		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class))___		try {_			snapshotThread.sync()__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async failure for 2nd message").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,async,exception,is,caught,for,one,of,the,flushed,requests,on,checkpoint,it,should,be,rethrown,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken,p,note,that,this,test,does,not,test,the,snapshot,method,is,blocked,correctly,when,there,are,pending,recorrds,the,test,for,that,is,covered,in,test,at,least,once,producer;suppress,warnings,result,of,method,call,ignored,test,timeout,10000,public,void,test,async,error,rethrown,after,flush,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,get,pending,record,futures,get,1,set,exception,new,exception,artificial,async,failure,for,2nd,message,producer,get,pending,record,futures,get,2,set,mock,user,record,result,class,try,snapshot,thread,sync,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,failure,for,2nd,message,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test(timeout = 10000) 	public void testAsyncErrorRethrownAfterFlush() throws Throwable;1515177485;Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,_it should be rethrown_ we set a timeout because the test will not finish if the logic is broken.__<p>Note that this test does not test the snapshot method is blocked correctly when there are pending records._The test for that is covered in testAtLeastOnceProducer.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test(timeout = 10000)_	public void testAsyncErrorRethrownAfterFlush() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)__		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message"))__		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class))___		try {_			snapshotThread.sync()__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async failure for 2nd message").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,async,exception,is,caught,for,one,of,the,flushed,requests,on,checkpoint,it,should,be,rethrown,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken,p,note,that,this,test,does,not,test,the,snapshot,method,is,blocked,correctly,when,there,are,pending,records,the,test,for,that,is,covered,in,test,at,least,once,producer;suppress,warnings,result,of,method,call,ignored,test,timeout,10000,public,void,test,async,error,rethrown,after,flush,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,get,pending,record,futures,get,1,set,exception,new,exception,artificial,async,failure,for,2nd,message,producer,get,pending,record,futures,get,2,set,mock,user,record,result,class,try,snapshot,thread,sync,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,failure,for,2nd,message,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test(timeout = 10000) 	public void testAsyncErrorRethrownAfterFlush() throws Throwable;1529652658;Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,_it should be rethrown_ we set a timeout because the test will not finish if the logic is broken.__<p>Note that this test does not test the snapshot method is blocked correctly when there are pending records._The test for that is covered in testAtLeastOnceProducer.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test(timeout = 10000)_	public void testAsyncErrorRethrownAfterFlush() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)__		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message"))__		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class))___		try {_			snapshotThread.sync()__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async failure for 2nd message").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,async,exception,is,caught,for,one,of,the,flushed,requests,on,checkpoint,it,should,be,rethrown,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken,p,note,that,this,test,does,not,test,the,snapshot,method,is,blocked,correctly,when,there,are,pending,records,the,test,for,that,is,covered,in,test,at,least,once,producer;suppress,warnings,result,of,method,call,ignored,test,timeout,10000,public,void,test,async,error,rethrown,after,flush,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,get,pending,record,futures,get,1,set,exception,new,exception,artificial,async,failure,for,2nd,message,producer,get,pending,record,futures,get,2,set,mock,user,record,result,class,try,snapshot,thread,sync,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,failure,for,2nd,message,is,present,return,assert,fail
FlinkKinesisProducerTest -> @SuppressWarnings("ResultOfMethodCallIgnored") 	@Test(timeout = 10000) 	public void testAsyncErrorRethrownAfterFlush() throws Throwable;1538998760;Test ensuring that if an async exception is caught for one of the flushed requests on checkpoint,_it should be rethrown_ we set a timeout because the test will not finish if the logic is broken.__<p>Note that this test does not test the snapshot method is blocked correctly when there are pending records._The test for that is covered in testAtLeastOnceProducer.;@SuppressWarnings("ResultOfMethodCallIgnored")_	@Test(timeout = 10000)_	public void testAsyncErrorRethrownAfterFlush() throws Throwable {_		final DummyFlinkKinesisProducer<String> producer = new DummyFlinkKinesisProducer<>(new SimpleStringSchema())___		OneInputStreamOperatorTestHarness<String, Object> testHarness =_			new OneInputStreamOperatorTestHarness<>(new StreamSink<>(producer))___		testHarness.open()___		testHarness.processElement(new StreamRecord<>("msg-1"))__		testHarness.processElement(new StreamRecord<>("msg-2"))__		testHarness.processElement(new StreamRecord<>("msg-3"))___		_		UserRecordResult result = mock(UserRecordResult.class)__		when(result.isSuccessful()).thenReturn(true)__		producer.getPendingRecordFutures().get(0).set(result)___		CheckedThread snapshotThread = new CheckedThread() {_			@Override_			public void go() throws Exception {_				_				testHarness.snapshot(123L, 123L)__			}_		}__		snapshotThread.start()___		_		producer.getPendingRecordFutures().get(1).setException(new Exception("artificial async failure for 2nd message"))__		producer.getPendingRecordFutures().get(2).set(mock(UserRecordResult.class))___		try {_			snapshotThread.sync()__		} catch (Exception e) {_			_			Assert.assertTrue(ExceptionUtils.findThrowableWithMessage(e, "artificial async failure for 2nd message").isPresent())___			_			return__		}__		Assert.fail()__	};test,ensuring,that,if,an,async,exception,is,caught,for,one,of,the,flushed,requests,on,checkpoint,it,should,be,rethrown,we,set,a,timeout,because,the,test,will,not,finish,if,the,logic,is,broken,p,note,that,this,test,does,not,test,the,snapshot,method,is,blocked,correctly,when,there,are,pending,records,the,test,for,that,is,covered,in,test,at,least,once,producer;suppress,warnings,result,of,method,call,ignored,test,timeout,10000,public,void,test,async,error,rethrown,after,flush,throws,throwable,final,dummy,flink,kinesis,producer,string,producer,new,dummy,flink,kinesis,producer,new,simple,string,schema,one,input,stream,operator,test,harness,string,object,test,harness,new,one,input,stream,operator,test,harness,new,stream,sink,producer,test,harness,open,test,harness,process,element,new,stream,record,msg,1,test,harness,process,element,new,stream,record,msg,2,test,harness,process,element,new,stream,record,msg,3,user,record,result,result,mock,user,record,result,class,when,result,is,successful,then,return,true,producer,get,pending,record,futures,get,0,set,result,checked,thread,snapshot,thread,new,checked,thread,override,public,void,go,throws,exception,test,harness,snapshot,123l,123l,snapshot,thread,start,producer,get,pending,record,futures,get,1,set,exception,new,exception,artificial,async,failure,for,2nd,message,producer,get,pending,record,futures,get,2,set,mock,user,record,result,class,try,snapshot,thread,sync,catch,exception,e,assert,assert,true,exception,utils,find,throwable,with,message,e,artificial,async,failure,for,2nd,message,is,present,return,assert,fail
