# id;timestamp;commentText;codeText;commentWords;codeWords
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1480685315;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1485238807;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1490934739;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1495787238;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1495923079;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1515757408;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)___				_				millisBehindLatest = getRecordsResult.getMillisBehindLatest()__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,millis,behind,latest,get,records,result,get,millis,behind,latest,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1515757408;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)___				_				shardMetricsReporter.setMillisBehindLatest(getRecordsResult.getMillisBehindLatest())__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,shard,metrics,reporter,set,millis,behind,latest,get,records,result,get,millis,behind,latest,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1515757408;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)___				_				shardMetricsReporter.setMillisBehindLatest(getRecordsResult.getMillisBehindLatest())__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,shard,metrics,reporter,set,millis,behind,latest,get,records,result,get,millis,behind,latest,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1531240106;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)___				_				shardMetricsReporter.setMillisBehindLatest(getRecordsResult.getMillisBehindLatest())__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,shard,metrics,reporter,set,millis,behind,latest,get,records,result,get,millis,behind,latest,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1531815464;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)___				_				shardMetricsReporter.setMillisBehindLatest(getRecordsResult.getMillisBehindLatest())__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,shard,metrics,reporter,set,millis,behind,latest,get,records,result,get,millis,behind,latest,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1533129233;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)___				_				shardMetricsReporter.setMillisBehindLatest(getRecordsResult.getMillisBehindLatest())__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,shard,metrics,reporter,set,millis,behind,latest,get,records,result,get,millis,behind,latest,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1533129233;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)___				_				shardMetricsReporter.setMillisBehindLatest(getRecordsResult.getMillisBehindLatest())__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,shard,metrics,reporter,set,millis,behind,latest,get,records,result,get,millis,behind,latest,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1534433916;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)___				_				shardMetricsReporter.setMillisBehindLatest(getRecordsResult.getMillisBehindLatest())__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,shard,metrics,reporter,set,millis,behind,latest,get,records,result,get,millis,behind,latest,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1534479217;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)___				_				shardMetricsReporter.setMillisBehindLatest(getRecordsResult.getMillisBehindLatest())__			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,shard,metrics,reporter,set,millis,behind,latest,get,records,result,get,millis,behind,latest,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException;1537435562;Calls {@link KinesisProxyInterface#getRecords(String, int)}, while also handling unexpected_AWS {@link ExpiredIteratorException}s to assure that we get results and don't just fail on_such occasions. The returned shard iterator within the successful {@link GetRecordsResult} should_be used for the next call to this method.__<p>Note: it is important that this method is not called again before all the records from the last result have been_fully collected with {@link ShardConsumer#deserializeRecordForCollectionAndUpdateState(UserRecord)}, otherwise_{@link ShardConsumer#lastSequenceNum} may refer to a sub-record in the middle of an aggregated record, leading to_incorrect shard iteration if the iterator had to be refreshed.__@param shardItr shard iterator to use_@param maxNumberOfRecords the maximum number of records to fetch for this getRecords attempt_@return get records result_@throws InterruptedException;private GetRecordsResult getRecords(String shardItr, int maxNumberOfRecords) throws InterruptedException {_		GetRecordsResult getRecordsResult = null__		while (getRecordsResult == null) {_			try {_				getRecordsResult = kinesis.getRecords(shardItr, maxNumberOfRecords)___				_				Long millisBehindLatest = getRecordsResult.getMillisBehindLatest()__				if (millisBehindLatest != null) {_					shardMetricsReporter.setMillisBehindLatest(millisBehindLatest)__				}_			} catch (ExpiredIteratorException eiEx) {_				LOG.warn("Encountered an unexpected expired iterator {} for shard {}_" +_					" refreshing the iterator ...", shardItr, subscribedShard)__				shardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				if (fetchIntervalMillis != 0) {_					Thread.sleep(fetchIntervalMillis)__				}_			}_		}_		return getRecordsResult__	};calls,link,kinesis,proxy,interface,get,records,string,int,while,also,handling,unexpected,aws,link,expired,iterator,exception,s,to,assure,that,we,get,results,and,don,t,just,fail,on,such,occasions,the,returned,shard,iterator,within,the,successful,link,get,records,result,should,be,used,for,the,next,call,to,this,method,p,note,it,is,important,that,this,method,is,not,called,again,before,all,the,records,from,the,last,result,have,been,fully,collected,with,link,shard,consumer,deserialize,record,for,collection,and,update,state,user,record,otherwise,link,shard,consumer,last,sequence,num,may,refer,to,a,sub,record,in,the,middle,of,an,aggregated,record,leading,to,incorrect,shard,iteration,if,the,iterator,had,to,be,refreshed,param,shard,itr,shard,iterator,to,use,param,max,number,of,records,the,maximum,number,of,records,to,fetch,for,this,get,records,attempt,return,get,records,result,throws,interrupted,exception;private,get,records,result,get,records,string,shard,itr,int,max,number,of,records,throws,interrupted,exception,get,records,result,get,records,result,null,while,get,records,result,null,try,get,records,result,kinesis,get,records,shard,itr,max,number,of,records,long,millis,behind,latest,get,records,result,get,millis,behind,latest,if,millis,behind,latest,null,shard,metrics,reporter,set,millis,behind,latest,millis,behind,latest,catch,expired,iterator,exception,ei,ex,log,warn,encountered,an,unexpected,expired,iterator,for,shard,refreshing,the,iterator,shard,itr,subscribed,shard,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,if,fetch,interval,millis,0,thread,sleep,fetch,interval,millis,return,get,records,result
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum);1495787238;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum) {_		this(fetcherRef,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			KinesisProxy.create(fetcherRef.getConsumerConfiguration()))__	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,this,fetcher,ref,subscribed,shard,state,index,subscribed,shard,last,sequence,num,kinesis,proxy,create,fetcher,ref,get,consumer,configuration
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum);1495923079;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum) {_		this(fetcherRef,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			KinesisProxy.create(fetcherRef.getConsumerConfiguration()))__	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,this,fetcher,ref,subscribed,shard,state,index,subscribed,shard,last,sequence,num,kinesis,proxy,create,fetcher,ref,get,consumer,configuration
ShardConsumer -> protected ShardConsumer(KinesisDataFetcher<T> fetcherRef, 							Integer subscribedShardStateIndex, 							StreamShardHandle subscribedShard, 							SequenceNumber lastSequenceNum, 							KinesisProxyInterface kinesis, 							ShardMetricsReporter shardMetricsReporter);1515757408;This constructor is exposed for testing purposes.;protected ShardConsumer(KinesisDataFetcher<T> fetcherRef,_							Integer subscribedShardStateIndex,_							StreamShardHandle subscribedShard,_							SequenceNumber lastSequenceNum,_							KinesisProxyInterface kinesis,_							ShardMetricsReporter shardMetricsReporter) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)___		this.shardMetricsReporter = checkNotNull(shardMetricsReporter)___		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};this,constructor,is,exposed,for,testing,purposes;protected,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,this,shard,metrics,reporter,check,not,null,shard,metrics,reporter,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> protected ShardConsumer(KinesisDataFetcher<T> fetcherRef, 							Integer subscribedShardStateIndex, 							StreamShardHandle subscribedShard, 							SequenceNumber lastSequenceNum, 							KinesisProxyInterface kinesis, 							ShardMetricsReporter shardMetricsReporter);1515757408;This constructor is exposed for testing purposes.;protected ShardConsumer(KinesisDataFetcher<T> fetcherRef,_							Integer subscribedShardStateIndex,_							StreamShardHandle subscribedShard,_							SequenceNumber lastSequenceNum,_							KinesisProxyInterface kinesis,_							ShardMetricsReporter shardMetricsReporter) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)___		this.shardMetricsReporter = checkNotNull(shardMetricsReporter)___		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};this,constructor,is,exposed,for,testing,purposes;protected,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,this,shard,metrics,reporter,check,not,null,shard,metrics,reporter,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> protected ShardConsumer(KinesisDataFetcher<T> fetcherRef, 							Integer subscribedShardStateIndex, 							StreamShardHandle subscribedShard, 							SequenceNumber lastSequenceNum, 							KinesisProxyInterface kinesis, 							ShardMetricsReporter shardMetricsReporter);1531240106;This constructor is exposed for testing purposes.;protected ShardConsumer(KinesisDataFetcher<T> fetcherRef,_							Integer subscribedShardStateIndex,_							StreamShardHandle subscribedShard,_							SequenceNumber lastSequenceNum,_							KinesisProxyInterface kinesis,_							ShardMetricsReporter shardMetricsReporter) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)___		this.shardMetricsReporter = checkNotNull(shardMetricsReporter)___		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};this,constructor,is,exposed,for,testing,purposes;protected,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,this,shard,metrics,reporter,check,not,null,shard,metrics,reporter,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> protected ShardConsumer(KinesisDataFetcher<T> fetcherRef, 							Integer subscribedShardStateIndex, 							StreamShardHandle subscribedShard, 							SequenceNumber lastSequenceNum, 							KinesisProxyInterface kinesis, 							ShardMetricsReporter shardMetricsReporter);1531815464;This constructor is exposed for testing purposes.;protected ShardConsumer(KinesisDataFetcher<T> fetcherRef,_							Integer subscribedShardStateIndex,_							StreamShardHandle subscribedShard,_							SequenceNumber lastSequenceNum,_							KinesisProxyInterface kinesis,_							ShardMetricsReporter shardMetricsReporter) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)___		this.shardMetricsReporter = checkNotNull(shardMetricsReporter)___		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))__		this.useAdaptiveReads = Boolean.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_USE_ADAPTIVE_READS,_			Boolean.toString(ConsumerConfigConstants.DEFAULT_SHARD_USE_ADAPTIVE_READS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};this,constructor,is,exposed,for,testing,purposes;protected,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,this,shard,metrics,reporter,check,not,null,shard,metrics,reporter,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,use,adaptive,reads,boolean,value,of,consumer,config,get,property,consumer,config,constants,boolean,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> protected ShardConsumer(KinesisDataFetcher<T> fetcherRef, 							Integer subscribedShardStateIndex, 							StreamShardHandle subscribedShard, 							SequenceNumber lastSequenceNum, 							KinesisProxyInterface kinesis, 							ShardMetricsReporter shardMetricsReporter);1533129233;This constructor is exposed for testing purposes.;protected ShardConsumer(KinesisDataFetcher<T> fetcherRef,_							Integer subscribedShardStateIndex,_							StreamShardHandle subscribedShard,_							SequenceNumber lastSequenceNum,_							KinesisProxyInterface kinesis,_							ShardMetricsReporter shardMetricsReporter) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)___		this.shardMetricsReporter = checkNotNull(shardMetricsReporter)___		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))__		this.useAdaptiveReads = Boolean.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_USE_ADAPTIVE_READS,_			Boolean.toString(ConsumerConfigConstants.DEFAULT_SHARD_USE_ADAPTIVE_READS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};this,constructor,is,exposed,for,testing,purposes;protected,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,this,shard,metrics,reporter,check,not,null,shard,metrics,reporter,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,use,adaptive,reads,boolean,value,of,consumer,config,get,property,consumer,config,constants,boolean,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum, 						ShardMetricsReporter shardMetricsReporter);1515757408;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param shardMetricsReporter the reporter to report metrics to;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum,_						ShardMetricsReporter shardMetricsReporter) {_		this(fetcherRef,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			KinesisProxy.create(fetcherRef.getConsumerConfiguration()),_			shardMetricsReporter)__	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,shard,metrics,reporter,the,reporter,to,report,metrics,to;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,subscribed,shard,state,index,subscribed,shard,last,sequence,num,kinesis,proxy,create,fetcher,ref,get,consumer,configuration,shard,metrics,reporter
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum, 						ShardMetricsReporter shardMetricsReporter);1515757408;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param shardMetricsReporter the reporter to report metrics to;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum,_						ShardMetricsReporter shardMetricsReporter) {_		this(fetcherRef,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			KinesisProxy.create(fetcherRef.getConsumerConfiguration()),_			shardMetricsReporter)__	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,shard,metrics,reporter,the,reporter,to,report,metrics,to;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,subscribed,shard,state,index,subscribed,shard,last,sequence,num,kinesis,proxy,create,fetcher,ref,get,consumer,configuration,shard,metrics,reporter
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum, 						ShardMetricsReporter shardMetricsReporter);1531240106;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param shardMetricsReporter the reporter to report metrics to;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum,_						ShardMetricsReporter shardMetricsReporter) {_		this(fetcherRef,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			KinesisProxy.create(fetcherRef.getConsumerConfiguration()),_			shardMetricsReporter)__	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,shard,metrics,reporter,the,reporter,to,report,metrics,to;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,subscribed,shard,state,index,subscribed,shard,last,sequence,num,kinesis,proxy,create,fetcher,ref,get,consumer,configuration,shard,metrics,reporter
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum, 						ShardMetricsReporter shardMetricsReporter);1531815464;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param shardMetricsReporter the reporter to report metrics to;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum,_						ShardMetricsReporter shardMetricsReporter) {_		this(fetcherRef,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			KinesisProxy.create(fetcherRef.getConsumerConfiguration()),_			shardMetricsReporter)__	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,shard,metrics,reporter,the,reporter,to,report,metrics,to;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,subscribed,shard,state,index,subscribed,shard,last,sequence,num,kinesis,proxy,create,fetcher,ref,get,consumer,configuration,shard,metrics,reporter
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum, 						ShardMetricsReporter shardMetricsReporter);1533129233;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param shardMetricsReporter the reporter to report metrics to;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum,_						ShardMetricsReporter shardMetricsReporter) {_		this(fetcherRef,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			KinesisProxy.create(fetcherRef.getConsumerConfiguration()),_			shardMetricsReporter)__	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,shard,metrics,reporter,the,reporter,to,report,metrics,to;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,subscribed,shard,state,index,subscribed,shard,last,sequence,num,kinesis,proxy,create,fetcher,ref,get,consumer,configuration,shard,metrics,reporter
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum, 						KinesisProxyInterface kinesis, 						ShardMetricsReporter shardMetricsReporter);1533129233;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param kinesis the proxy instance to interact with Kinesis_@param shardMetricsReporter the reporter to report metrics to;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum,_						KinesisProxyInterface kinesis,_						ShardMetricsReporter shardMetricsReporter) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)___		this.shardMetricsReporter = checkNotNull(shardMetricsReporter)___		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))__		this.useAdaptiveReads = Boolean.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_USE_ADAPTIVE_READS,_			Boolean.toString(ConsumerConfigConstants.DEFAULT_SHARD_USE_ADAPTIVE_READS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,kinesis,the,proxy,instance,to,interact,with,kinesis,param,shard,metrics,reporter,the,reporter,to,report,metrics,to;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,this,shard,metrics,reporter,check,not,null,shard,metrics,reporter,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,use,adaptive,reads,boolean,value,of,consumer,config,get,property,consumer,config,constants,boolean,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum, 						KinesisProxyInterface kinesis, 						ShardMetricsReporter shardMetricsReporter);1534433916;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param kinesis the proxy instance to interact with Kinesis_@param shardMetricsReporter the reporter to report metrics to;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum,_						KinesisProxyInterface kinesis,_						ShardMetricsReporter shardMetricsReporter) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)___		this.shardMetricsReporter = checkNotNull(shardMetricsReporter)___		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))__		this.useAdaptiveReads = Boolean.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_USE_ADAPTIVE_READS,_			Boolean.toString(ConsumerConfigConstants.DEFAULT_SHARD_USE_ADAPTIVE_READS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,kinesis,the,proxy,instance,to,interact,with,kinesis,param,shard,metrics,reporter,the,reporter,to,report,metrics,to;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,this,shard,metrics,reporter,check,not,null,shard,metrics,reporter,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,use,adaptive,reads,boolean,value,of,consumer,config,get,property,consumer,config,constants,boolean,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum, 						KinesisProxyInterface kinesis, 						ShardMetricsReporter shardMetricsReporter);1534479217;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param kinesis the proxy instance to interact with Kinesis_@param shardMetricsReporter the reporter to report metrics to;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum,_						KinesisProxyInterface kinesis,_						ShardMetricsReporter shardMetricsReporter) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)___		this.shardMetricsReporter = checkNotNull(shardMetricsReporter)___		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))__		this.useAdaptiveReads = Boolean.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_USE_ADAPTIVE_READS,_			Boolean.toString(ConsumerConfigConstants.DEFAULT_SHARD_USE_ADAPTIVE_READS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,kinesis,the,proxy,instance,to,interact,with,kinesis,param,shard,metrics,reporter,the,reporter,to,report,metrics,to;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,this,shard,metrics,reporter,check,not,null,shard,metrics,reporter,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,use,adaptive,reads,boolean,value,of,consumer,config,get,property,consumer,config,constants,boolean,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum, 						KinesisProxyInterface kinesis, 						ShardMetricsReporter shardMetricsReporter);1537435562;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param kinesis the proxy instance to interact with Kinesis_@param shardMetricsReporter the reporter to report metrics to;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum,_						KinesisProxyInterface kinesis,_						ShardMetricsReporter shardMetricsReporter) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)___		this.shardMetricsReporter = checkNotNull(shardMetricsReporter)___		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))__		this.useAdaptiveReads = Boolean.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_USE_ADAPTIVE_READS,_			Boolean.toString(ConsumerConfigConstants.DEFAULT_SHARD_USE_ADAPTIVE_READS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,kinesis,the,proxy,instance,to,interact,with,kinesis,param,shard,metrics,reporter,the,reporter,to,report,metrics,to;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,this,shard,metrics,reporter,check,not,null,shard,metrics,reporter,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,use,adaptive,reads,boolean,value,of,consumer,config,get,property,consumer,config,constants,boolean,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						StreamShardHandle subscribedShard, 						SequenceNumber lastSequenceNum, 						KinesisProxyInterface kinesis, 						ShardMetricsReporter shardMetricsReporter);1549276531;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming_@param kinesis the proxy instance to interact with Kinesis_@param shardMetricsReporter the reporter to report metrics to;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						StreamShardHandle subscribedShard,_						SequenceNumber lastSequenceNum,_						KinesisProxyInterface kinesis,_						ShardMetricsReporter shardMetricsReporter) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)___		this.shardMetricsReporter = checkNotNull(shardMetricsReporter)___		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))__		this.useAdaptiveReads = Boolean.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_USE_ADAPTIVE_READS,_			Boolean.toString(ConsumerConfigConstants.DEFAULT_SHARD_USE_ADAPTIVE_READS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming,param,kinesis,the,proxy,instance,to,interact,with,kinesis,param,shard,metrics,reporter,the,reporter,to,report,metrics,to;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,shard,metrics,reporter,shard,metrics,reporter,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,this,shard,metrics,reporter,check,not,null,shard,metrics,reporter,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,this,use,adaptive,reads,boolean,value,of,consumer,config,get,property,consumer,config,constants,boolean,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> protected ShardConsumer(KinesisDataFetcher<T> fetcherRef, 							Integer subscribedShardStateIndex, 							KinesisStreamShard subscribedShard, 							SequenceNumber lastSequenceNum, 							KinesisProxyInterface kinesis);1480685315;This constructor is exposed for testing purposes;protected ShardConsumer(KinesisDataFetcher<T> fetcherRef,_							Integer subscribedShardStateIndex,_							KinesisStreamShard subscribedShard,_							SequenceNumber lastSequenceNum,_							KinesisProxyInterface kinesis) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)__		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))__	};this,constructor,is,exposed,for,testing,purposes;protected,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,kinesis,stream,shard,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants
ShardConsumer -> protected ShardConsumer(KinesisDataFetcher<T> fetcherRef, 							Integer subscribedShardStateIndex, 							KinesisStreamShard subscribedShard, 							SequenceNumber lastSequenceNum, 							KinesisProxyInterface kinesis);1485238807;This constructor is exposed for testing purposes;protected ShardConsumer(KinesisDataFetcher<T> fetcherRef,_							Integer subscribedShardStateIndex,_							KinesisStreamShard subscribedShard,_							SequenceNumber lastSequenceNum,_							KinesisProxyInterface kinesis) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)__		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)__			try {_				this.initTimestamp = KinesisConfigUtil.initTimestampDateFormat.parse(timestamp)__			} catch (ParseException e) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};this,constructor,is,exposed,for,testing,purposes;protected,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,kinesis,stream,shard,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,this,init,timestamp,kinesis,config,util,init,timestamp,date,format,parse,timestamp,catch,parse,exception,e,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> protected ShardConsumer(KinesisDataFetcher<T> fetcherRef, 							Integer subscribedShardStateIndex, 							KinesisStreamShard subscribedShard, 							SequenceNumber lastSequenceNum, 							KinesisProxyInterface kinesis);1490934739;This constructor is exposed for testing purposes;protected ShardConsumer(KinesisDataFetcher<T> fetcherRef,_							Integer subscribedShardStateIndex,_							KinesisStreamShard subscribedShard,_							SequenceNumber lastSequenceNum,_							KinesisProxyInterface kinesis) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)__		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};this,constructor,is,exposed,for,testing,purposes;protected,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,kinesis,stream,shard,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos) 		throws InterruptedException;1533129233;Adjusts loop timing to match target frequency if specified._@param processingStartTimeNanos The start time of the run loop "work"_@param processingEndTimeNanos The end time of the run loop "work"_@return The System.nanoTime() after the sleep (if any)_@throws InterruptedException;protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos)_		throws InterruptedException {_		long endTimeNanos = processingEndTimeNanos__		if (fetchIntervalMillis != 0) {_			long processingTimeNanos = processingEndTimeNanos - processingStartTimeNanos__			long sleepTimeMillis = fetchIntervalMillis - (processingTimeNanos / 1_000_000)__			if (sleepTimeMillis > 0) {_				Thread.sleep(sleepTimeMillis)__				endTimeNanos = System.nanoTime()__			}_		}_		return endTimeNanos__	};adjusts,loop,timing,to,match,target,frequency,if,specified,param,processing,start,time,nanos,the,start,time,of,the,run,loop,work,param,processing,end,time,nanos,the,end,time,of,the,run,loop,work,return,the,system,nano,time,after,the,sleep,if,any,throws,interrupted,exception;protected,long,adjust,run,loop,frequency,long,processing,start,time,nanos,long,processing,end,time,nanos,throws,interrupted,exception,long,end,time,nanos,processing,end,time,nanos,if,fetch,interval,millis,0,long,processing,time,nanos,processing,end,time,nanos,processing,start,time,nanos,long,sleep,time,millis,fetch,interval,millis,processing,time,nanos,if,sleep,time,millis,0,thread,sleep,sleep,time,millis,end,time,nanos,system,nano,time,return,end,time,nanos
ShardConsumer -> protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos) 		throws InterruptedException;1533129233;Adjusts loop timing to match target frequency if specified._@param processingStartTimeNanos The start time of the run loop "work"_@param processingEndTimeNanos The end time of the run loop "work"_@return The System.nanoTime() after the sleep (if any)_@throws InterruptedException;protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos)_		throws InterruptedException {_		long endTimeNanos = processingEndTimeNanos__		if (fetchIntervalMillis != 0) {_			long processingTimeNanos = processingEndTimeNanos - processingStartTimeNanos__			long sleepTimeMillis = fetchIntervalMillis - (processingTimeNanos / 1_000_000)__			if (sleepTimeMillis > 0) {_				Thread.sleep(sleepTimeMillis)__				endTimeNanos = System.nanoTime()__			}_		}_		return endTimeNanos__	};adjusts,loop,timing,to,match,target,frequency,if,specified,param,processing,start,time,nanos,the,start,time,of,the,run,loop,work,param,processing,end,time,nanos,the,end,time,of,the,run,loop,work,return,the,system,nano,time,after,the,sleep,if,any,throws,interrupted,exception;protected,long,adjust,run,loop,frequency,long,processing,start,time,nanos,long,processing,end,time,nanos,throws,interrupted,exception,long,end,time,nanos,processing,end,time,nanos,if,fetch,interval,millis,0,long,processing,time,nanos,processing,end,time,nanos,processing,start,time,nanos,long,sleep,time,millis,fetch,interval,millis,processing,time,nanos,if,sleep,time,millis,0,thread,sleep,sleep,time,millis,end,time,nanos,system,nano,time,return,end,time,nanos
ShardConsumer -> protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos) 		throws InterruptedException;1534433916;Adjusts loop timing to match target frequency if specified._@param processingStartTimeNanos The start time of the run loop "work"_@param processingEndTimeNanos The end time of the run loop "work"_@return The System.nanoTime() after the sleep (if any)_@throws InterruptedException;protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos)_		throws InterruptedException {_		long endTimeNanos = processingEndTimeNanos__		if (fetchIntervalMillis != 0) {_			long processingTimeNanos = processingEndTimeNanos - processingStartTimeNanos__			long sleepTimeMillis = fetchIntervalMillis - (processingTimeNanos / 1_000_000)__			if (sleepTimeMillis > 0) {_				Thread.sleep(sleepTimeMillis)__				endTimeNanos = System.nanoTime()__			}_		}_		return endTimeNanos__	};adjusts,loop,timing,to,match,target,frequency,if,specified,param,processing,start,time,nanos,the,start,time,of,the,run,loop,work,param,processing,end,time,nanos,the,end,time,of,the,run,loop,work,return,the,system,nano,time,after,the,sleep,if,any,throws,interrupted,exception;protected,long,adjust,run,loop,frequency,long,processing,start,time,nanos,long,processing,end,time,nanos,throws,interrupted,exception,long,end,time,nanos,processing,end,time,nanos,if,fetch,interval,millis,0,long,processing,time,nanos,processing,end,time,nanos,processing,start,time,nanos,long,sleep,time,millis,fetch,interval,millis,processing,time,nanos,if,sleep,time,millis,0,thread,sleep,sleep,time,millis,end,time,nanos,system,nano,time,return,end,time,nanos
ShardConsumer -> protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos) 		throws InterruptedException;1534479217;Adjusts loop timing to match target frequency if specified._@param processingStartTimeNanos The start time of the run loop "work"_@param processingEndTimeNanos The end time of the run loop "work"_@return The System.nanoTime() after the sleep (if any)_@throws InterruptedException;protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos)_		throws InterruptedException {_		long endTimeNanos = processingEndTimeNanos__		if (fetchIntervalMillis != 0) {_			long processingTimeNanos = processingEndTimeNanos - processingStartTimeNanos__			long sleepTimeMillis = fetchIntervalMillis - (processingTimeNanos / 1_000_000)__			if (sleepTimeMillis > 0) {_				Thread.sleep(sleepTimeMillis)__				endTimeNanos = System.nanoTime()__				shardMetricsReporter.setSleepTimeMillis(sleepTimeMillis)__			}_		}_		return endTimeNanos__	};adjusts,loop,timing,to,match,target,frequency,if,specified,param,processing,start,time,nanos,the,start,time,of,the,run,loop,work,param,processing,end,time,nanos,the,end,time,of,the,run,loop,work,return,the,system,nano,time,after,the,sleep,if,any,throws,interrupted,exception;protected,long,adjust,run,loop,frequency,long,processing,start,time,nanos,long,processing,end,time,nanos,throws,interrupted,exception,long,end,time,nanos,processing,end,time,nanos,if,fetch,interval,millis,0,long,processing,time,nanos,processing,end,time,nanos,processing,start,time,nanos,long,sleep,time,millis,fetch,interval,millis,processing,time,nanos,if,sleep,time,millis,0,thread,sleep,sleep,time,millis,end,time,nanos,system,nano,time,shard,metrics,reporter,set,sleep,time,millis,sleep,time,millis,return,end,time,nanos
ShardConsumer -> protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos) 		throws InterruptedException;1537435562;Adjusts loop timing to match target frequency if specified._@param processingStartTimeNanos The start time of the run loop "work"_@param processingEndTimeNanos The end time of the run loop "work"_@return The System.nanoTime() after the sleep (if any)_@throws InterruptedException;protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos)_		throws InterruptedException {_		long endTimeNanos = processingEndTimeNanos__		if (fetchIntervalMillis != 0) {_			long processingTimeNanos = processingEndTimeNanos - processingStartTimeNanos__			long sleepTimeMillis = fetchIntervalMillis - (processingTimeNanos / 1_000_000)__			if (sleepTimeMillis > 0) {_				Thread.sleep(sleepTimeMillis)__				endTimeNanos = System.nanoTime()__				shardMetricsReporter.setSleepTimeMillis(sleepTimeMillis)__			}_		}_		return endTimeNanos__	};adjusts,loop,timing,to,match,target,frequency,if,specified,param,processing,start,time,nanos,the,start,time,of,the,run,loop,work,param,processing,end,time,nanos,the,end,time,of,the,run,loop,work,return,the,system,nano,time,after,the,sleep,if,any,throws,interrupted,exception;protected,long,adjust,run,loop,frequency,long,processing,start,time,nanos,long,processing,end,time,nanos,throws,interrupted,exception,long,end,time,nanos,processing,end,time,nanos,if,fetch,interval,millis,0,long,processing,time,nanos,processing,end,time,nanos,processing,start,time,nanos,long,sleep,time,millis,fetch,interval,millis,processing,time,nanos,if,sleep,time,millis,0,thread,sleep,sleep,time,millis,end,time,nanos,system,nano,time,shard,metrics,reporter,set,sleep,time,millis,sleep,time,millis,return,end,time,nanos
ShardConsumer -> protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos) 		throws InterruptedException;1549276531;Adjusts loop timing to match target frequency if specified._@param processingStartTimeNanos The start time of the run loop "work"_@param processingEndTimeNanos The end time of the run loop "work"_@return The System.nanoTime() after the sleep (if any)_@throws InterruptedException;protected long adjustRunLoopFrequency(long processingStartTimeNanos, long processingEndTimeNanos)_		throws InterruptedException {_		long endTimeNanos = processingEndTimeNanos__		if (fetchIntervalMillis != 0) {_			long processingTimeNanos = processingEndTimeNanos - processingStartTimeNanos__			long sleepTimeMillis = fetchIntervalMillis - (processingTimeNanos / 1_000_000)__			if (sleepTimeMillis > 0) {_				Thread.sleep(sleepTimeMillis)__				endTimeNanos = System.nanoTime()__				shardMetricsReporter.setSleepTimeMillis(sleepTimeMillis)__			}_		}_		return endTimeNanos__	};adjusts,loop,timing,to,match,target,frequency,if,specified,param,processing,start,time,nanos,the,start,time,of,the,run,loop,work,param,processing,end,time,nanos,the,end,time,of,the,run,loop,work,return,the,system,nano,time,after,the,sleep,if,any,throws,interrupted,exception;protected,long,adjust,run,loop,frequency,long,processing,start,time,nanos,long,processing,end,time,nanos,throws,interrupted,exception,long,end,time,nanos,processing,end,time,nanos,if,fetch,interval,millis,0,long,processing,time,nanos,processing,end,time,nanos,processing,start,time,nanos,long,sleep,time,millis,fetch,interval,millis,processing,time,nanos,if,sleep,time,millis,0,thread,sleep,sleep,time,millis,end,time,nanos,system,nano,time,shard,metrics,reporter,set,sleep,time,millis,sleep,time,millis,return,end,time,nanos
ShardConsumer -> private boolean isRunning();1480685315;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1485238807;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1490934739;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1495787238;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1495923079;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1515757408;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1515757408;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1515757408;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1531240106;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1531815464;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1533129233;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1533129233;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1534433916;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1534479217;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1537435562;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> private boolean isRunning();1549276531;The loop in run() checks this before fetching next batch of records. Since this runnable will be executed_by the ExecutorService {@link KinesisDataFetcher#shardConsumersExecutor}, the only way to close down this thread_would be by calling shutdownNow() on {@link KinesisDataFetcher#shardConsumersExecutor} and let the executor service_interrupt all currently running {@link ShardConsumer}s.;private boolean isRunning() {_		return !Thread.interrupted()__	};the,loop,in,run,checks,this,before,fetching,next,batch,of,records,since,this,runnable,will,be,executed,by,the,executor,service,link,kinesis,data,fetcher,shard,consumers,executor,the,only,way,to,close,down,this,thread,would,be,by,calling,shutdown,now,on,link,kinesis,data,fetcher,shard,consumers,executor,and,let,the,executor,service,interrupt,all,currently,running,link,shard,consumer,s;private,boolean,is,running,return,thread,interrupted
ShardConsumer -> protected ShardConsumer(KinesisDataFetcher<T> fetcherRef, 							Integer subscribedShardStateIndex, 							StreamShardHandle subscribedShard, 							SequenceNumber lastSequenceNum, 							KinesisProxyInterface kinesis);1495787238;This constructor is exposed for testing purposes;protected ShardConsumer(KinesisDataFetcher<T> fetcherRef,_							Integer subscribedShardStateIndex,_							StreamShardHandle subscribedShard,_							SequenceNumber lastSequenceNum,_							KinesisProxyInterface kinesis) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)__		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};this,constructor,is,exposed,for,testing,purposes;protected,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> protected ShardConsumer(KinesisDataFetcher<T> fetcherRef, 							Integer subscribedShardStateIndex, 							StreamShardHandle subscribedShard, 							SequenceNumber lastSequenceNum, 							KinesisProxyInterface kinesis);1495923079;This constructor is exposed for testing purposes.;protected ShardConsumer(KinesisDataFetcher<T> fetcherRef,_							Integer subscribedShardStateIndex,_							StreamShardHandle subscribedShard,_							SequenceNumber lastSequenceNum,_							KinesisProxyInterface kinesis) {_		this.fetcherRef = checkNotNull(fetcherRef)__		this.subscribedShardStateIndex = checkNotNull(subscribedShardStateIndex)__		this.subscribedShard = checkNotNull(subscribedShard)__		this.lastSequenceNum = checkNotNull(lastSequenceNum)__		checkArgument(_			!lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get()),_			"Should not start a ShardConsumer if the shard has already been completely read.")___		this.deserializer = fetcherRef.getClonedDeserializationSchema()___		Properties consumerConfig = fetcherRef.getConsumerConfiguration()__		this.kinesis = kinesis__		this.maxNumberOfRecordsPerFetch = Integer.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_MAX,_			Integer.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)))__		this.fetchIntervalMillis = Long.valueOf(consumerConfig.getProperty(_			ConsumerConfigConstants.SHARD_GETRECORDS_INTERVAL_MILLIS,_			Long.toString(ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_INTERVAL_MILLIS)))___		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			String timestamp = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_INITIAL_TIMESTAMP)___			try {_				String format = consumerConfig.getProperty(ConsumerConfigConstants.STREAM_TIMESTAMP_DATE_FORMAT,_					ConsumerConfigConstants.DEFAULT_STREAM_TIMESTAMP_DATE_FORMAT)__				SimpleDateFormat customDateFormat = new SimpleDateFormat(format)__				this.initTimestamp = customDateFormat.parse(timestamp)__			} catch (IllegalArgumentException | NullPointerException exception) {_				throw new IllegalArgumentException(exception)__			} catch (ParseException exception) {_				this.initTimestamp = new Date((long) (Double.parseDouble(timestamp) * 1000))__			}_		} else {_			this.initTimestamp = null__		}_	};this,constructor,is,exposed,for,testing,purposes;protected,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,stream,shard,handle,subscribed,shard,sequence,number,last,sequence,num,kinesis,proxy,interface,kinesis,this,fetcher,ref,check,not,null,fetcher,ref,this,subscribed,shard,state,index,check,not,null,subscribed,shard,state,index,this,subscribed,shard,check,not,null,subscribed,shard,this,last,sequence,num,check,not,null,last,sequence,num,check,argument,last,sequence,num,equals,sentinel,sequence,number,get,should,not,start,a,shard,consumer,if,the,shard,has,already,been,completely,read,this,deserializer,fetcher,ref,get,cloned,deserialization,schema,properties,consumer,config,fetcher,ref,get,consumer,configuration,this,kinesis,kinesis,this,max,number,of,records,per,fetch,integer,value,of,consumer,config,get,property,consumer,config,constants,integer,to,string,consumer,config,constants,this,fetch,interval,millis,long,value,of,consumer,config,get,property,consumer,config,constants,long,to,string,consumer,config,constants,if,last,sequence,num,equals,sentinel,sequence,number,get,string,timestamp,consumer,config,get,property,consumer,config,constants,try,string,format,consumer,config,get,property,consumer,config,constants,consumer,config,constants,simple,date,format,custom,date,format,new,simple,date,format,format,this,init,timestamp,custom,date,format,parse,timestamp,catch,illegal,argument,exception,null,pointer,exception,exception,throw,new,illegal,argument,exception,exception,catch,parse,exception,exception,this,init,timestamp,new,date,long,double,parse,double,timestamp,1000,else,this,init,timestamp,null
ShardConsumer -> protected String getInitialShardIterator() throws Exception;1533129233;Find the initial shard iterator to start getting records from._@return shard iterator_@throws Exception;protected String getInitialShardIterator() throws Exception {_		String nextShardItr___		__		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_LATEST_SEQUENCE_NUM.get())) {_			_			if (subscribedShard.isClosed()) {_				nextShardItr = null__			} else {_				nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.LATEST.toString(), null)__			}_		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())) {_			nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.TRIM_HORIZON.toString(), null)__		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_			nextShardItr = null__		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AT_TIMESTAMP.toString(), initTimestamp)__		} else {_			_			_			__			if (lastSequenceNum.isAggregated()) {_				String itrForLastAggregatedRecord =_					kinesis.getShardIterator(subscribedShard, ShardIteratorType.AT_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				GetRecordsResult getRecordsResult = getRecords(itrForLastAggregatedRecord, 1)___				List<UserRecord> fetchedRecords = deaggregateRecords(_					getRecordsResult.getRecords(),_					subscribedShard.getShard().getHashKeyRange().getStartingHashKey(),_					subscribedShard.getShard().getHashKeyRange().getEndingHashKey())___				long lastSubSequenceNum = lastSequenceNum.getSubSequenceNumber()__				for (UserRecord record : fetchedRecords) {_					_					_					if (record.getSubSequenceNumber() > lastSubSequenceNum) {_						deserializeRecordForCollectionAndUpdateState(record)__					}_				}__				_				nextShardItr = getRecordsResult.getNextShardIterator()__			} else {_				_				nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())__			}_		}_		return nextShardItr__	};find,the,initial,shard,iterator,to,start,getting,records,from,return,shard,iterator,throws,exception;protected,string,get,initial,shard,iterator,throws,exception,string,next,shard,itr,if,last,sequence,num,equals,sentinel,sequence,number,get,if,subscribed,shard,is,closed,next,shard,itr,null,else,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,latest,to,string,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,init,timestamp,else,if,last,sequence,num,is,aggregated,string,itr,for,last,aggregated,record,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,get,records,result,get,records,result,get,records,itr,for,last,aggregated,record,1,list,user,record,fetched,records,deaggregate,records,get,records,result,get,records,subscribed,shard,get,shard,get,hash,key,range,get,starting,hash,key,subscribed,shard,get,shard,get,hash,key,range,get,ending,hash,key,long,last,sub,sequence,num,last,sequence,num,get,sub,sequence,number,for,user,record,record,fetched,records,if,record,get,sub,sequence,number,last,sub,sequence,num,deserialize,record,for,collection,and,update,state,record,next,shard,itr,get,records,result,get,next,shard,iterator,else,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,return,next,shard,itr
ShardConsumer -> protected String getInitialShardIterator() throws Exception;1534433916;Find the initial shard iterator to start getting records from._@return shard iterator_@throws Exception;protected String getInitialShardIterator() throws Exception {_		String nextShardItr___		__		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_LATEST_SEQUENCE_NUM.get())) {_			_			if (subscribedShard.isClosed()) {_				nextShardItr = null__			} else {_				nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.LATEST.toString(), null)__			}_		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())) {_			nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.TRIM_HORIZON.toString(), null)__		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_			nextShardItr = null__		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AT_TIMESTAMP.toString(), initTimestamp)__		} else {_			_			_			__			if (lastSequenceNum.isAggregated()) {_				String itrForLastAggregatedRecord =_					kinesis.getShardIterator(subscribedShard, ShardIteratorType.AT_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				GetRecordsResult getRecordsResult = getRecords(itrForLastAggregatedRecord, 1)___				List<UserRecord> fetchedRecords = deaggregateRecords(_					getRecordsResult.getRecords(),_					subscribedShard.getShard().getHashKeyRange().getStartingHashKey(),_					subscribedShard.getShard().getHashKeyRange().getEndingHashKey())___				long lastSubSequenceNum = lastSequenceNum.getSubSequenceNumber()__				for (UserRecord record : fetchedRecords) {_					_					_					if (record.getSubSequenceNumber() > lastSubSequenceNum) {_						deserializeRecordForCollectionAndUpdateState(record)__					}_				}__				_				nextShardItr = getRecordsResult.getNextShardIterator()__			} else {_				_				nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())__			}_		}_		return nextShardItr__	};find,the,initial,shard,iterator,to,start,getting,records,from,return,shard,iterator,throws,exception;protected,string,get,initial,shard,iterator,throws,exception,string,next,shard,itr,if,last,sequence,num,equals,sentinel,sequence,number,get,if,subscribed,shard,is,closed,next,shard,itr,null,else,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,latest,to,string,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,init,timestamp,else,if,last,sequence,num,is,aggregated,string,itr,for,last,aggregated,record,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,get,records,result,get,records,result,get,records,itr,for,last,aggregated,record,1,list,user,record,fetched,records,deaggregate,records,get,records,result,get,records,subscribed,shard,get,shard,get,hash,key,range,get,starting,hash,key,subscribed,shard,get,shard,get,hash,key,range,get,ending,hash,key,long,last,sub,sequence,num,last,sequence,num,get,sub,sequence,number,for,user,record,record,fetched,records,if,record,get,sub,sequence,number,last,sub,sequence,num,deserialize,record,for,collection,and,update,state,record,next,shard,itr,get,records,result,get,next,shard,iterator,else,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,return,next,shard,itr
ShardConsumer -> protected String getInitialShardIterator() throws Exception;1534479217;Find the initial shard iterator to start getting records from._@return shard iterator_@throws Exception;protected String getInitialShardIterator() throws Exception {_		String nextShardItr___		__		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_LATEST_SEQUENCE_NUM.get())) {_			_			if (subscribedShard.isClosed()) {_				nextShardItr = null__			} else {_				nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.LATEST.toString(), null)__			}_		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())) {_			nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.TRIM_HORIZON.toString(), null)__		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_			nextShardItr = null__		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AT_TIMESTAMP.toString(), initTimestamp)__		} else {_			_			_			__			if (lastSequenceNum.isAggregated()) {_				String itrForLastAggregatedRecord =_					kinesis.getShardIterator(subscribedShard, ShardIteratorType.AT_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				GetRecordsResult getRecordsResult = getRecords(itrForLastAggregatedRecord, 1)___				List<UserRecord> fetchedRecords = deaggregateRecords(_					getRecordsResult.getRecords(),_					subscribedShard.getShard().getHashKeyRange().getStartingHashKey(),_					subscribedShard.getShard().getHashKeyRange().getEndingHashKey())___				long lastSubSequenceNum = lastSequenceNum.getSubSequenceNumber()__				for (UserRecord record : fetchedRecords) {_					_					_					if (record.getSubSequenceNumber() > lastSubSequenceNum) {_						deserializeRecordForCollectionAndUpdateState(record)__					}_				}__				_				nextShardItr = getRecordsResult.getNextShardIterator()__			} else {_				_				nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())__			}_		}_		return nextShardItr__	};find,the,initial,shard,iterator,to,start,getting,records,from,return,shard,iterator,throws,exception;protected,string,get,initial,shard,iterator,throws,exception,string,next,shard,itr,if,last,sequence,num,equals,sentinel,sequence,number,get,if,subscribed,shard,is,closed,next,shard,itr,null,else,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,latest,to,string,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,init,timestamp,else,if,last,sequence,num,is,aggregated,string,itr,for,last,aggregated,record,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,get,records,result,get,records,result,get,records,itr,for,last,aggregated,record,1,list,user,record,fetched,records,deaggregate,records,get,records,result,get,records,subscribed,shard,get,shard,get,hash,key,range,get,starting,hash,key,subscribed,shard,get,shard,get,hash,key,range,get,ending,hash,key,long,last,sub,sequence,num,last,sequence,num,get,sub,sequence,number,for,user,record,record,fetched,records,if,record,get,sub,sequence,number,last,sub,sequence,num,deserialize,record,for,collection,and,update,state,record,next,shard,itr,get,records,result,get,next,shard,iterator,else,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,return,next,shard,itr
ShardConsumer -> protected String getInitialShardIterator() throws Exception;1537435562;Find the initial shard iterator to start getting records from._@return shard iterator_@throws Exception;protected String getInitialShardIterator() throws Exception {_		String nextShardItr___		__		if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_LATEST_SEQUENCE_NUM.get())) {_			_			if (subscribedShard.isClosed()) {_				nextShardItr = null__			} else {_				nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.LATEST.toString(), null)__			}_		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_EARLIEST_SEQUENCE_NUM.get())) {_			nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.TRIM_HORIZON.toString(), null)__		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_SHARD_ENDING_SEQUENCE_NUM.get())) {_			nextShardItr = null__		} else if (lastSequenceNum.equals(SentinelSequenceNumber.SENTINEL_AT_TIMESTAMP_SEQUENCE_NUM.get())) {_			nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AT_TIMESTAMP.toString(), initTimestamp)__		} else {_			_			_			__			if (lastSequenceNum.isAggregated()) {_				String itrForLastAggregatedRecord =_					kinesis.getShardIterator(subscribedShard, ShardIteratorType.AT_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())___				_				GetRecordsResult getRecordsResult = getRecords(itrForLastAggregatedRecord, 1)___				List<UserRecord> fetchedRecords = deaggregateRecords(_					getRecordsResult.getRecords(),_					subscribedShard.getShard().getHashKeyRange().getStartingHashKey(),_					subscribedShard.getShard().getHashKeyRange().getEndingHashKey())___				long lastSubSequenceNum = lastSequenceNum.getSubSequenceNumber()__				for (UserRecord record : fetchedRecords) {_					_					_					if (record.getSubSequenceNumber() > lastSubSequenceNum) {_						deserializeRecordForCollectionAndUpdateState(record)__					}_				}__				_				nextShardItr = getRecordsResult.getNextShardIterator()__			} else {_				_				nextShardItr = kinesis.getShardIterator(subscribedShard, ShardIteratorType.AFTER_SEQUENCE_NUMBER.toString(), lastSequenceNum.getSequenceNumber())__			}_		}_		return nextShardItr__	};find,the,initial,shard,iterator,to,start,getting,records,from,return,shard,iterator,throws,exception;protected,string,get,initial,shard,iterator,throws,exception,string,next,shard,itr,if,last,sequence,num,equals,sentinel,sequence,number,get,if,subscribed,shard,is,closed,next,shard,itr,null,else,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,latest,to,string,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,null,else,if,last,sequence,num,equals,sentinel,sequence,number,get,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,init,timestamp,else,if,last,sequence,num,is,aggregated,string,itr,for,last,aggregated,record,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,get,records,result,get,records,result,get,records,itr,for,last,aggregated,record,1,list,user,record,fetched,records,deaggregate,records,get,records,result,get,records,subscribed,shard,get,shard,get,hash,key,range,get,starting,hash,key,subscribed,shard,get,shard,get,hash,key,range,get,ending,hash,key,long,last,sub,sequence,num,last,sequence,num,get,sub,sequence,number,for,user,record,record,fetched,records,if,record,get,sub,sequence,number,last,sub,sequence,num,deserialize,record,for,collection,and,update,state,record,next,shard,itr,get,records,result,get,next,shard,iterator,else,next,shard,itr,kinesis,get,shard,iterator,subscribed,shard,shard,iterator,type,to,string,last,sequence,num,get,sequence,number,return,next,shard,itr
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						KinesisStreamShard subscribedShard, 						SequenceNumber lastSequenceNum);1480685315;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						KinesisStreamShard subscribedShard,_						SequenceNumber lastSequenceNum) {_		this(fetcherRef,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			KinesisProxy.create(fetcherRef.getConsumerConfiguration()))__	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,kinesis,stream,shard,subscribed,shard,sequence,number,last,sequence,num,this,fetcher,ref,subscribed,shard,state,index,subscribed,shard,last,sequence,num,kinesis,proxy,create,fetcher,ref,get,consumer,configuration
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						KinesisStreamShard subscribedShard, 						SequenceNumber lastSequenceNum);1485238807;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						KinesisStreamShard subscribedShard,_						SequenceNumber lastSequenceNum) {_		this(fetcherRef,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			KinesisProxy.create(fetcherRef.getConsumerConfiguration()))__	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,kinesis,stream,shard,subscribed,shard,sequence,number,last,sequence,num,this,fetcher,ref,subscribed,shard,state,index,subscribed,shard,last,sequence,num,kinesis,proxy,create,fetcher,ref,get,consumer,configuration
ShardConsumer -> public ShardConsumer(KinesisDataFetcher<T> fetcherRef, 						Integer subscribedShardStateIndex, 						KinesisStreamShard subscribedShard, 						SequenceNumber lastSequenceNum);1490934739;Creates a shard consumer.__@param fetcherRef reference to the owning fetcher_@param subscribedShardStateIndex the state index of the shard this consumer is subscribed to_@param subscribedShard the shard this consumer is subscribed to_@param lastSequenceNum the sequence number in the shard to start consuming;public ShardConsumer(KinesisDataFetcher<T> fetcherRef,_						Integer subscribedShardStateIndex,_						KinesisStreamShard subscribedShard,_						SequenceNumber lastSequenceNum) {_		this(fetcherRef,_			subscribedShardStateIndex,_			subscribedShard,_			lastSequenceNum,_			KinesisProxy.create(fetcherRef.getConsumerConfiguration()))__	};creates,a,shard,consumer,param,fetcher,ref,reference,to,the,owning,fetcher,param,subscribed,shard,state,index,the,state,index,of,the,shard,this,consumer,is,subscribed,to,param,subscribed,shard,the,shard,this,consumer,is,subscribed,to,param,last,sequence,num,the,sequence,number,in,the,shard,to,start,consuming;public,shard,consumer,kinesis,data,fetcher,t,fetcher,ref,integer,subscribed,shard,state,index,kinesis,stream,shard,subscribed,shard,sequence,number,last,sequence,num,this,fetcher,ref,subscribed,shard,state,index,subscribed,shard,last,sequence,num,kinesis,proxy,create,fetcher,ref,get,consumer,configuration
ShardConsumer -> private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes, 			int maxNumberOfRecordsPerFetch);1533129233;Calculates how many records to read each time through the loop based on a target throughput_and the measured frequenecy of the loop._@param runLoopTimeNanos The total time of one pass through the loop_@param numRecords The number of records of the last read operation_@param recordBatchSizeBytes The total batch size of the last read operation_@param maxNumberOfRecordsPerFetch The current maxNumberOfRecordsPerFetch;private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes,_			int maxNumberOfRecordsPerFetch) {_		if (useAdaptiveReads && numRecords != 0 && runLoopTimeNanos != 0) {_			long averageRecordSizeBytes = recordBatchSizeBytes / numRecords__			_			_			double loopFrequencyHz = 1000000000.0d / runLoopTimeNanos__			double bytesPerRead = KINESIS_SHARD_BYTES_PER_SECOND_LIMIT / loopFrequencyHz__			maxNumberOfRecordsPerFetch = (int) (bytesPerRead / averageRecordSizeBytes)__			_			maxNumberOfRecordsPerFetch = Math.min(maxNumberOfRecordsPerFetch, ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)__		}_		return maxNumberOfRecordsPerFetch__	};calculates,how,many,records,to,read,each,time,through,the,loop,based,on,a,target,throughput,and,the,measured,frequenecy,of,the,loop,param,run,loop,time,nanos,the,total,time,of,one,pass,through,the,loop,param,num,records,the,number,of,records,of,the,last,read,operation,param,record,batch,size,bytes,the,total,batch,size,of,the,last,read,operation,param,max,number,of,records,per,fetch,the,current,max,number,of,records,per,fetch;private,int,adapt,records,to,read,long,run,loop,time,nanos,int,num,records,long,record,batch,size,bytes,int,max,number,of,records,per,fetch,if,use,adaptive,reads,num,records,0,run,loop,time,nanos,0,long,average,record,size,bytes,record,batch,size,bytes,num,records,double,loop,frequency,hz,1000000000,0d,run,loop,time,nanos,double,bytes,per,read,loop,frequency,hz,max,number,of,records,per,fetch,int,bytes,per,read,average,record,size,bytes,max,number,of,records,per,fetch,math,min,max,number,of,records,per,fetch,consumer,config,constants,return,max,number,of,records,per,fetch
ShardConsumer -> private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes, 			int maxNumberOfRecordsPerFetch);1533129233;Calculates how many records to read each time through the loop based on a target throughput_and the measured frequenecy of the loop._@param runLoopTimeNanos The total time of one pass through the loop_@param numRecords The number of records of the last read operation_@param recordBatchSizeBytes The total batch size of the last read operation_@param maxNumberOfRecordsPerFetch The current maxNumberOfRecordsPerFetch;private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes,_			int maxNumberOfRecordsPerFetch) {_		if (useAdaptiveReads && numRecords != 0 && runLoopTimeNanos != 0) {_			long averageRecordSizeBytes = recordBatchSizeBytes / numRecords__			_			_			double loopFrequencyHz = 1000000000.0d / runLoopTimeNanos__			double bytesPerRead = KINESIS_SHARD_BYTES_PER_SECOND_LIMIT / loopFrequencyHz__			maxNumberOfRecordsPerFetch = (int) (bytesPerRead / averageRecordSizeBytes)__			_			maxNumberOfRecordsPerFetch = Math.min(maxNumberOfRecordsPerFetch, ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX)__		}_		return maxNumberOfRecordsPerFetch__	};calculates,how,many,records,to,read,each,time,through,the,loop,based,on,a,target,throughput,and,the,measured,frequenecy,of,the,loop,param,run,loop,time,nanos,the,total,time,of,one,pass,through,the,loop,param,num,records,the,number,of,records,of,the,last,read,operation,param,record,batch,size,bytes,the,total,batch,size,of,the,last,read,operation,param,max,number,of,records,per,fetch,the,current,max,number,of,records,per,fetch;private,int,adapt,records,to,read,long,run,loop,time,nanos,int,num,records,long,record,batch,size,bytes,int,max,number,of,records,per,fetch,if,use,adaptive,reads,num,records,0,run,loop,time,nanos,0,long,average,record,size,bytes,record,batch,size,bytes,num,records,double,loop,frequency,hz,1000000000,0d,run,loop,time,nanos,double,bytes,per,read,loop,frequency,hz,max,number,of,records,per,fetch,int,bytes,per,read,average,record,size,bytes,max,number,of,records,per,fetch,math,min,max,number,of,records,per,fetch,consumer,config,constants,return,max,number,of,records,per,fetch
ShardConsumer -> private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes, 			int maxNumberOfRecordsPerFetch);1534433916;Calculates how many records to read each time through the loop based on a target throughput_and the measured frequenecy of the loop._@param runLoopTimeNanos The total time of one pass through the loop_@param numRecords The number of records of the last read operation_@param recordBatchSizeBytes The total batch size of the last read operation_@param maxNumberOfRecordsPerFetch The current maxNumberOfRecordsPerFetch;private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes,_			int maxNumberOfRecordsPerFetch) {_		if (useAdaptiveReads && numRecords != 0 && runLoopTimeNanos != 0) {_			long averageRecordSizeBytes = recordBatchSizeBytes / numRecords__			_			_			double loopFrequencyHz = 1000000000.0d / runLoopTimeNanos__			double bytesPerRead = KINESIS_SHARD_BYTES_PER_SECOND_LIMIT / loopFrequencyHz__			maxNumberOfRecordsPerFetch = (int) (bytesPerRead / averageRecordSizeBytes)__			_			maxNumberOfRecordsPerFetch = Math.max(1, Math.min(maxNumberOfRecordsPerFetch, ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX))__		}_		return maxNumberOfRecordsPerFetch__	};calculates,how,many,records,to,read,each,time,through,the,loop,based,on,a,target,throughput,and,the,measured,frequenecy,of,the,loop,param,run,loop,time,nanos,the,total,time,of,one,pass,through,the,loop,param,num,records,the,number,of,records,of,the,last,read,operation,param,record,batch,size,bytes,the,total,batch,size,of,the,last,read,operation,param,max,number,of,records,per,fetch,the,current,max,number,of,records,per,fetch;private,int,adapt,records,to,read,long,run,loop,time,nanos,int,num,records,long,record,batch,size,bytes,int,max,number,of,records,per,fetch,if,use,adaptive,reads,num,records,0,run,loop,time,nanos,0,long,average,record,size,bytes,record,batch,size,bytes,num,records,double,loop,frequency,hz,1000000000,0d,run,loop,time,nanos,double,bytes,per,read,loop,frequency,hz,max,number,of,records,per,fetch,int,bytes,per,read,average,record,size,bytes,max,number,of,records,per,fetch,math,max,1,math,min,max,number,of,records,per,fetch,consumer,config,constants,return,max,number,of,records,per,fetch
ShardConsumer -> private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes, 			int maxNumberOfRecordsPerFetch);1534479217;Calculates how many records to read each time through the loop based on a target throughput_and the measured frequenecy of the loop._@param runLoopTimeNanos The total time of one pass through the loop_@param numRecords The number of records of the last read operation_@param recordBatchSizeBytes The total batch size of the last read operation_@param maxNumberOfRecordsPerFetch The current maxNumberOfRecordsPerFetch;private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes,_			int maxNumberOfRecordsPerFetch) {_		if (useAdaptiveReads && numRecords != 0 && runLoopTimeNanos != 0) {_			long averageRecordSizeBytes = recordBatchSizeBytes / numRecords__			_			_			double loopFrequencyHz = 1000000000.0d / runLoopTimeNanos__			double bytesPerRead = KINESIS_SHARD_BYTES_PER_SECOND_LIMIT / loopFrequencyHz__			maxNumberOfRecordsPerFetch = (int) (bytesPerRead / averageRecordSizeBytes)__			_			maxNumberOfRecordsPerFetch = Math.max(1, Math.min(maxNumberOfRecordsPerFetch, ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX))___			_			shardMetricsReporter.setAverageRecordSizeBytes(averageRecordSizeBytes)__			shardMetricsReporter.setLoopFrequencyHz(loopFrequencyHz)__			shardMetricsReporter.setBytesPerRead(bytesPerRead)__		}_		return maxNumberOfRecordsPerFetch__	};calculates,how,many,records,to,read,each,time,through,the,loop,based,on,a,target,throughput,and,the,measured,frequenecy,of,the,loop,param,run,loop,time,nanos,the,total,time,of,one,pass,through,the,loop,param,num,records,the,number,of,records,of,the,last,read,operation,param,record,batch,size,bytes,the,total,batch,size,of,the,last,read,operation,param,max,number,of,records,per,fetch,the,current,max,number,of,records,per,fetch;private,int,adapt,records,to,read,long,run,loop,time,nanos,int,num,records,long,record,batch,size,bytes,int,max,number,of,records,per,fetch,if,use,adaptive,reads,num,records,0,run,loop,time,nanos,0,long,average,record,size,bytes,record,batch,size,bytes,num,records,double,loop,frequency,hz,1000000000,0d,run,loop,time,nanos,double,bytes,per,read,loop,frequency,hz,max,number,of,records,per,fetch,int,bytes,per,read,average,record,size,bytes,max,number,of,records,per,fetch,math,max,1,math,min,max,number,of,records,per,fetch,consumer,config,constants,shard,metrics,reporter,set,average,record,size,bytes,average,record,size,bytes,shard,metrics,reporter,set,loop,frequency,hz,loop,frequency,hz,shard,metrics,reporter,set,bytes,per,read,bytes,per,read,return,max,number,of,records,per,fetch
ShardConsumer -> private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes, 			int maxNumberOfRecordsPerFetch);1537435562;Calculates how many records to read each time through the loop based on a target throughput_and the measured frequenecy of the loop._@param runLoopTimeNanos The total time of one pass through the loop_@param numRecords The number of records of the last read operation_@param recordBatchSizeBytes The total batch size of the last read operation_@param maxNumberOfRecordsPerFetch The current maxNumberOfRecordsPerFetch;private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes,_			int maxNumberOfRecordsPerFetch) {_		if (useAdaptiveReads && numRecords != 0 && runLoopTimeNanos != 0) {_			long averageRecordSizeBytes = recordBatchSizeBytes / numRecords__			_			_			double loopFrequencyHz = 1000000000.0d / runLoopTimeNanos__			double bytesPerRead = KINESIS_SHARD_BYTES_PER_SECOND_LIMIT / loopFrequencyHz__			maxNumberOfRecordsPerFetch = (int) (bytesPerRead / averageRecordSizeBytes)__			_			maxNumberOfRecordsPerFetch = Math.max(1, Math.min(maxNumberOfRecordsPerFetch, ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX))___			_			shardMetricsReporter.setAverageRecordSizeBytes(averageRecordSizeBytes)__			shardMetricsReporter.setLoopFrequencyHz(loopFrequencyHz)__			shardMetricsReporter.setBytesPerRead(bytesPerRead)__		}_		return maxNumberOfRecordsPerFetch__	};calculates,how,many,records,to,read,each,time,through,the,loop,based,on,a,target,throughput,and,the,measured,frequenecy,of,the,loop,param,run,loop,time,nanos,the,total,time,of,one,pass,through,the,loop,param,num,records,the,number,of,records,of,the,last,read,operation,param,record,batch,size,bytes,the,total,batch,size,of,the,last,read,operation,param,max,number,of,records,per,fetch,the,current,max,number,of,records,per,fetch;private,int,adapt,records,to,read,long,run,loop,time,nanos,int,num,records,long,record,batch,size,bytes,int,max,number,of,records,per,fetch,if,use,adaptive,reads,num,records,0,run,loop,time,nanos,0,long,average,record,size,bytes,record,batch,size,bytes,num,records,double,loop,frequency,hz,1000000000,0d,run,loop,time,nanos,double,bytes,per,read,loop,frequency,hz,max,number,of,records,per,fetch,int,bytes,per,read,average,record,size,bytes,max,number,of,records,per,fetch,math,max,1,math,min,max,number,of,records,per,fetch,consumer,config,constants,shard,metrics,reporter,set,average,record,size,bytes,average,record,size,bytes,shard,metrics,reporter,set,loop,frequency,hz,loop,frequency,hz,shard,metrics,reporter,set,bytes,per,read,bytes,per,read,return,max,number,of,records,per,fetch
ShardConsumer -> private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes, 			int maxNumberOfRecordsPerFetch);1549276531;Calculates how many records to read each time through the loop based on a target throughput_and the measured frequenecy of the loop._@param runLoopTimeNanos The total time of one pass through the loop_@param numRecords The number of records of the last read operation_@param recordBatchSizeBytes The total batch size of the last read operation_@param maxNumberOfRecordsPerFetch The current maxNumberOfRecordsPerFetch;private int adaptRecordsToRead(long runLoopTimeNanos, int numRecords, long recordBatchSizeBytes,_			int maxNumberOfRecordsPerFetch) {_		if (useAdaptiveReads && numRecords != 0 && runLoopTimeNanos != 0) {_			long averageRecordSizeBytes = recordBatchSizeBytes / numRecords__			_			_			double loopFrequencyHz = 1000000000.0d / runLoopTimeNanos__			double bytesPerRead = KINESIS_SHARD_BYTES_PER_SECOND_LIMIT / loopFrequencyHz__			maxNumberOfRecordsPerFetch = (int) (bytesPerRead / averageRecordSizeBytes)__			_			maxNumberOfRecordsPerFetch = Math.max(1, Math.min(maxNumberOfRecordsPerFetch, ConsumerConfigConstants.DEFAULT_SHARD_GETRECORDS_MAX))___			_			shardMetricsReporter.setAverageRecordSizeBytes(averageRecordSizeBytes)__			shardMetricsReporter.setLoopFrequencyHz(loopFrequencyHz)__			shardMetricsReporter.setBytesPerRead(bytesPerRead)__		}_		return maxNumberOfRecordsPerFetch__	};calculates,how,many,records,to,read,each,time,through,the,loop,based,on,a,target,throughput,and,the,measured,frequenecy,of,the,loop,param,run,loop,time,nanos,the,total,time,of,one,pass,through,the,loop,param,num,records,the,number,of,records,of,the,last,read,operation,param,record,batch,size,bytes,the,total,batch,size,of,the,last,read,operation,param,max,number,of,records,per,fetch,the,current,max,number,of,records,per,fetch;private,int,adapt,records,to,read,long,run,loop,time,nanos,int,num,records,long,record,batch,size,bytes,int,max,number,of,records,per,fetch,if,use,adaptive,reads,num,records,0,run,loop,time,nanos,0,long,average,record,size,bytes,record,batch,size,bytes,num,records,double,loop,frequency,hz,1000000000,0d,run,loop,time,nanos,double,bytes,per,read,loop,frequency,hz,max,number,of,records,per,fetch,int,bytes,per,read,average,record,size,bytes,max,number,of,records,per,fetch,math,max,1,math,min,max,number,of,records,per,fetch,consumer,config,constants,shard,metrics,reporter,set,average,record,size,bytes,average,record,size,bytes,shard,metrics,reporter,set,loop,frequency,hz,loop,frequency,hz,shard,metrics,reporter,set,bytes,per,read,bytes,per,read,return,max,number,of,records,per,fetch
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1480685315;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1485238807;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1490934739;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1495787238;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1495923079;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1515757408;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1515757408;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1515757408;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1531240106;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1531815464;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1533129233;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1533129233;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1534433916;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1534479217;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1537435562;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
ShardConsumer -> private void deserializeRecordForCollectionAndUpdateState(UserRecord record) 		throws IOException;1549276531;Deserializes a record for collection, and accordingly updates the shard state in the fetcher. The last_successfully collected sequence number in this shard consumer is also updated so that_{@link ShardConsumer#getRecords(String, int)} may be able to use the correct sequence number to refresh shard_iterators if necessary.__<p>Note that the server-side Kinesis timestamp is attached to the record when collected. When the_user programs uses {@link TimeCharacteristic#EventTime}, this timestamp will be used by default.__@param record record to deserialize and collect_@throws IOException;private void deserializeRecordForCollectionAndUpdateState(UserRecord record)_		throws IOException {_		ByteBuffer recordData = record.getData()___		byte[] dataBytes = new byte[recordData.remaining()]__		recordData.get(dataBytes)___		final long approxArrivalTimestamp = record.getApproximateArrivalTimestamp().getTime()___		final T value = deserializer.deserialize(_			dataBytes,_			record.getPartitionKey(),_			record.getSequenceNumber(),_			approxArrivalTimestamp,_			subscribedShard.getStreamName(),_			subscribedShard.getShard().getShardId())___		SequenceNumber collectedSequenceNumber = (record.isAggregated())_			? new SequenceNumber(record.getSequenceNumber(), record.getSubSequenceNumber())_			: new SequenceNumber(record.getSequenceNumber())___		fetcherRef.emitRecordAndUpdateState(_			value,_			approxArrivalTimestamp,_			subscribedShardStateIndex,_			collectedSequenceNumber)___		lastSequenceNum = collectedSequenceNumber__	};deserializes,a,record,for,collection,and,accordingly,updates,the,shard,state,in,the,fetcher,the,last,successfully,collected,sequence,number,in,this,shard,consumer,is,also,updated,so,that,link,shard,consumer,get,records,string,int,may,be,able,to,use,the,correct,sequence,number,to,refresh,shard,iterators,if,necessary,p,note,that,the,server,side,kinesis,timestamp,is,attached,to,the,record,when,collected,when,the,user,programs,uses,link,time,characteristic,event,time,this,timestamp,will,be,used,by,default,param,record,record,to,deserialize,and,collect,throws,ioexception;private,void,deserialize,record,for,collection,and,update,state,user,record,record,throws,ioexception,byte,buffer,record,data,record,get,data,byte,data,bytes,new,byte,record,data,remaining,record,data,get,data,bytes,final,long,approx,arrival,timestamp,record,get,approximate,arrival,timestamp,get,time,final,t,value,deserializer,deserialize,data,bytes,record,get,partition,key,record,get,sequence,number,approx,arrival,timestamp,subscribed,shard,get,stream,name,subscribed,shard,get,shard,get,shard,id,sequence,number,collected,sequence,number,record,is,aggregated,new,sequence,number,record,get,sequence,number,record,get,sub,sequence,number,new,sequence,number,record,get,sequence,number,fetcher,ref,emit,record,and,update,state,value,approx,arrival,timestamp,subscribed,shard,state,index,collected,sequence,number,last,sequence,num,collected,sequence,number
