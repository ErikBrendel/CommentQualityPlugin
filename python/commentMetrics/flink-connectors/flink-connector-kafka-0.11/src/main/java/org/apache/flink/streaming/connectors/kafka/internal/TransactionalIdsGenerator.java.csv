# id;timestamp;commentText;codeText;commentWords;codeWords
TransactionalIdsGenerator -> public Set<String> generateIdsToAbort();1510130707;If we have to abort previous transactional id in case of restart after a failure BEFORE first checkpoint_completed, we don't know what was the parallelism used in previous attempt. In that case we must guess the ids_range to abort based on current configured pool size, current parallelism and safeScaleDownFactor.;public Set<String> generateIdsToAbort() {_		long abortTransactionalIdStart = subtaskIndex__		long abortTransactionalIdEnd = abortTransactionalIdStart + 1___		abortTransactionalIdStart *= poolSize * safeScaleDownFactor__		abortTransactionalIdEnd *= poolSize * safeScaleDownFactor__		return LongStream.range(abortTransactionalIdStart, abortTransactionalIdEnd)_			.mapToObj(this::generateTransactionalId)_			.collect(Collectors.toSet())__	};if,we,have,to,abort,previous,transactional,id,in,case,of,restart,after,a,failure,before,first,checkpoint,completed,we,don,t,know,what,was,the,parallelism,used,in,previous,attempt,in,that,case,we,must,guess,the,ids,range,to,abort,based,on,current,configured,pool,size,current,parallelism,and,safe,scale,down,factor;public,set,string,generate,ids,to,abort,long,abort,transactional,id,start,subtask,index,long,abort,transactional,id,end,abort,transactional,id,start,1,abort,transactional,id,start,pool,size,safe,scale,down,factor,abort,transactional,id,end,pool,size,safe,scale,down,factor,return,long,stream,range,abort,transactional,id,start,abort,transactional,id,end,map,to,obj,this,generate,transactional,id,collect,collectors,to,set
TransactionalIdsGenerator -> public Set<String> generateIdsToAbort();1510130714;If we have to abort previous transactional id in case of restart after a failure BEFORE first checkpoint_completed, we don't know what was the parallelism used in previous attempt. In that case we must guess the ids_range to abort based on current configured pool size, current parallelism and safeScaleDownFactor.;public Set<String> generateIdsToAbort() {_		Set<String> idsToAbort = new HashSet<>()__		for (int i = 0_ i < safeScaleDownFactor_ i++) {_			idsToAbort.addAll(generateIdsToUse(i * poolSize * totalNumberOfSubtasks))__		}_		return idsToAbort__	};if,we,have,to,abort,previous,transactional,id,in,case,of,restart,after,a,failure,before,first,checkpoint,completed,we,don,t,know,what,was,the,parallelism,used,in,previous,attempt,in,that,case,we,must,guess,the,ids,range,to,abort,based,on,current,configured,pool,size,current,parallelism,and,safe,scale,down,factor;public,set,string,generate,ids,to,abort,set,string,ids,to,abort,new,hash,set,for,int,i,0,i,safe,scale,down,factor,i,ids,to,abort,add,all,generate,ids,to,use,i,pool,size,total,number,of,subtasks,return,ids,to,abort
TransactionalIdsGenerator -> public Set<String> generateIdsToAbort();1515757409;If we have to abort previous transactional id in case of restart after a failure BEFORE first checkpoint_completed, we don't know what was the parallelism used in previous attempt. In that case we must guess the ids_range to abort based on current configured pool size, current parallelism and safeScaleDownFactor.;public Set<String> generateIdsToAbort() {_		Set<String> idsToAbort = new HashSet<>()__		for (int i = 0_ i < safeScaleDownFactor_ i++) {_			idsToAbort.addAll(generateIdsToUse(i * poolSize * totalNumberOfSubtasks))__		}_		return idsToAbort__	};if,we,have,to,abort,previous,transactional,id,in,case,of,restart,after,a,failure,before,first,checkpoint,completed,we,don,t,know,what,was,the,parallelism,used,in,previous,attempt,in,that,case,we,must,guess,the,ids,range,to,abort,based,on,current,configured,pool,size,current,parallelism,and,safe,scale,down,factor;public,set,string,generate,ids,to,abort,set,string,ids,to,abort,new,hash,set,for,int,i,0,i,safe,scale,down,factor,i,ids,to,abort,add,all,generate,ids,to,use,i,pool,size,total,number,of,subtasks,return,ids,to,abort
TransactionalIdsGenerator -> public Set<String> generateIdsToUse(long nextFreeTransactionalId);1510130707;Range of available transactional ids to use is:_[nextFreeTransactionalId, nextFreeTransactionalId + parallelism * kafkaProducersPoolSize)_loop below picks in a deterministic way a subrange of those available transactional ids based on index of_this subtask.;public Set<String> generateIdsToUse(long nextFreeTransactionalId) {_		Set<String> transactionalIds = new HashSet<>()__		for (int i = 0_ i < poolSize_ i++) {_			long transactionalId = nextFreeTransactionalId + subtaskIndex * poolSize + i__			transactionalIds.add(generateTransactionalId(transactionalId))__		}_		return transactionalIds__	};range,of,available,transactional,ids,to,use,is,next,free,transactional,id,next,free,transactional,id,parallelism,kafka,producers,pool,size,loop,below,picks,in,a,deterministic,way,a,subrange,of,those,available,transactional,ids,based,on,index,of,this,subtask;public,set,string,generate,ids,to,use,long,next,free,transactional,id,set,string,transactional,ids,new,hash,set,for,int,i,0,i,pool,size,i,long,transactional,id,next,free,transactional,id,subtask,index,pool,size,i,transactional,ids,add,generate,transactional,id,transactional,id,return,transactional,ids
TransactionalIdsGenerator -> public Set<String> generateIdsToUse(long nextFreeTransactionalId);1510130714;Range of available transactional ids to use is:_[nextFreeTransactionalId, nextFreeTransactionalId + parallelism * kafkaProducersPoolSize)_loop below picks in a deterministic way a subrange of those available transactional ids based on index of_this subtask.;public Set<String> generateIdsToUse(long nextFreeTransactionalId) {_		Set<String> transactionalIds = new HashSet<>()__		for (int i = 0_ i < poolSize_ i++) {_			long transactionalId = nextFreeTransactionalId + subtaskIndex * poolSize + i__			transactionalIds.add(generateTransactionalId(transactionalId))__		}_		return transactionalIds__	};range,of,available,transactional,ids,to,use,is,next,free,transactional,id,next,free,transactional,id,parallelism,kafka,producers,pool,size,loop,below,picks,in,a,deterministic,way,a,subrange,of,those,available,transactional,ids,based,on,index,of,this,subtask;public,set,string,generate,ids,to,use,long,next,free,transactional,id,set,string,transactional,ids,new,hash,set,for,int,i,0,i,pool,size,i,long,transactional,id,next,free,transactional,id,subtask,index,pool,size,i,transactional,ids,add,generate,transactional,id,transactional,id,return,transactional,ids
TransactionalIdsGenerator -> public Set<String> generateIdsToUse(long nextFreeTransactionalId);1515757409;Range of available transactional ids to use is:_[nextFreeTransactionalId, nextFreeTransactionalId + parallelism * kafkaProducersPoolSize)_loop below picks in a deterministic way a subrange of those available transactional ids based on index of_this subtask.;public Set<String> generateIdsToUse(long nextFreeTransactionalId) {_		Set<String> transactionalIds = new HashSet<>()__		for (int i = 0_ i < poolSize_ i++) {_			long transactionalId = nextFreeTransactionalId + subtaskIndex * poolSize + i__			transactionalIds.add(generateTransactionalId(transactionalId))__		}_		return transactionalIds__	};range,of,available,transactional,ids,to,use,is,next,free,transactional,id,next,free,transactional,id,parallelism,kafka,producers,pool,size,loop,below,picks,in,a,deterministic,way,a,subrange,of,those,available,transactional,ids,based,on,index,of,this,subtask;public,set,string,generate,ids,to,use,long,next,free,transactional,id,set,string,transactional,ids,new,hash,set,for,int,i,0,i,pool,size,i,long,transactional,id,next,free,transactional,id,subtask,index,pool,size,i,transactional,ids,add,generate,transactional,id,transactional,id,return,transactional,ids
