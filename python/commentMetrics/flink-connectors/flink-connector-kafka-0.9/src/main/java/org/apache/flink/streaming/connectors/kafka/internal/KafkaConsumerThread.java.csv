# id;timestamp;commentText;codeText;commentWords;codeWords
KafkaConsumerThread -> void setOffsetsToCommit( 			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit, 			@Nonnull KafkaCommitCallback commitCallback);1501249950;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded by newer ones.__@param offsetsToCommit The offsets to commit_@param commitCallback callback when Kafka commit completes;void setOffsetsToCommit(_			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit,_			@Nonnull KafkaCommitCallback commitCallback) {__		_		if (nextOffsetsToCommit.getAndSet(offsetsToCommit) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}_		this.offsetCommitCallback = commitCallback___		_		handover.wakeupProducer()___		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit,param,commit,callback,callback,when,kafka,commit,completes;void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,nonnull,kafka,commit,callback,commit,callback,if,next,offsets,to,commit,get,and,set,offsets,to,commit,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,this,offset,commit,callback,commit,callback,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> void setOffsetsToCommit( 			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit, 			@Nonnull KafkaCommitCallback commitCallback);1515757409;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded by newer ones.__@param offsetsToCommit The offsets to commit_@param commitCallback callback when Kafka commit completes;void setOffsetsToCommit(_			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit,_			@Nonnull KafkaCommitCallback commitCallback) {__		_		if (nextOffsetsToCommit.getAndSet(offsetsToCommit) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}_		this.offsetCommitCallback = commitCallback___		_		handover.wakeupProducer()___		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit,param,commit,callback,callback,when,kafka,commit,completes;void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,nonnull,kafka,commit,callback,commit,callback,if,next,offsets,to,commit,get,and,set,offsets,to,commit,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,this,offset,commit,callback,commit,callback,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> void setOffsetsToCommit( 			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit, 			@Nonnull KafkaCommitCallback commitCallback);1517943538;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded by newer ones.__@param offsetsToCommit The offsets to commit_@param commitCallback callback when Kafka commit completes;void setOffsetsToCommit(_			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit,_			@Nonnull KafkaCommitCallback commitCallback) {__		_		if (nextOffsetsToCommit.getAndSet(Tuple2.of(offsetsToCommit, commitCallback)) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()___		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit,param,commit,callback,callback,when,kafka,commit,completes;void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,nonnull,kafka,commit,callback,commit,callback,if,next,offsets,to,commit,get,and,set,tuple2,of,offsets,to,commit,commit,callback,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> void setOffsetsToCommit( 			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit, 			@Nonnull KafkaCommitCallback commitCallback);1517943538;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded by newer ones.__@param offsetsToCommit The offsets to commit_@param commitCallback callback when Kafka commit completes;void setOffsetsToCommit(_			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit,_			@Nonnull KafkaCommitCallback commitCallback) {__		_		if (nextOffsetsToCommit.getAndSet(Tuple2.of(offsetsToCommit, commitCallback)) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()___		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit,param,commit,callback,callback,when,kafka,commit,completes;void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,nonnull,kafka,commit,callback,commit,callback,if,next,offsets,to,commit,get,and,set,tuple2,of,offsets,to,commit,commit,callback,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> void setOffsetsToCommit( 			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit, 			@Nonnull KafkaCommitCallback commitCallback);1517943538;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded by newer ones.__@param offsetsToCommit The offsets to commit_@param commitCallback callback when Kafka commit completes;void setOffsetsToCommit(_			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit,_			@Nonnull KafkaCommitCallback commitCallback) {__		_		if (nextOffsetsToCommit.getAndSet(Tuple2.of(offsetsToCommit, commitCallback)) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()___		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit,param,commit,callback,callback,when,kafka,commit,completes;void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,nonnull,kafka,commit,callback,commit,callback,if,next,offsets,to,commit,get,and,set,tuple2,of,offsets,to,commit,commit,callback,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> void setOffsetsToCommit( 			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit, 			@Nonnull KafkaCommitCallback commitCallback);1519973085;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded by newer ones.__@param offsetsToCommit The offsets to commit_@param commitCallback callback when Kafka commit completes;void setOffsetsToCommit(_			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit,_			@Nonnull KafkaCommitCallback commitCallback) {__		_		if (nextOffsetsToCommit.getAndSet(Tuple2.of(offsetsToCommit, commitCallback)) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()___		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit,param,commit,callback,callback,when,kafka,commit,completes;void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,nonnull,kafka,commit,callback,commit,callback,if,next,offsets,to,commit,get,and,set,tuple2,of,offsets,to,commit,commit,callback,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> void setOffsetsToCommit( 			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit, 			@Nonnull KafkaCommitCallback commitCallback);1519973085;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded by newer ones.__@param offsetsToCommit The offsets to commit_@param commitCallback callback when Kafka commit completes;void setOffsetsToCommit(_			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit,_			@Nonnull KafkaCommitCallback commitCallback) {__		_		if (nextOffsetsToCommit.getAndSet(Tuple2.of(offsetsToCommit, commitCallback)) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()___		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit,param,commit,callback,callback,when,kafka,commit,completes;void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,nonnull,kafka,commit,callback,commit,callback,if,next,offsets,to,commit,get,and,set,tuple2,of,offsets,to,commit,commit,callback,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> void setOffsetsToCommit( 			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit, 			@Nonnull KafkaCommitCallback commitCallback);1539704473;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded by newer ones.__@param offsetsToCommit The offsets to commit_@param commitCallback callback when Kafka commit completes;void setOffsetsToCommit(_			Map<TopicPartition, OffsetAndMetadata> offsetsToCommit,_			@Nonnull KafkaCommitCallback commitCallback) {__		_		if (nextOffsetsToCommit.getAndSet(Tuple2.of(offsetsToCommit, commitCallback)) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()___		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit,param,commit,callback,callback,when,kafka,commit,completes;void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,nonnull,kafka,commit,callback,commit,callback,if,next,offsets,to,commit,get,and,set,tuple2,of,offsets,to,commit,commit,callback,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit);1480685315;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded  by newer ones.__@param offsetsToCommit The offsets to commit;public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit) {_		_		if (nextOffsetsToCommit.getAndSet(offsetsToCommit) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()__		if (consumer != null) {_			consumer.wakeup()__		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit;public,void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,if,next,offsets,to,commit,get,and,set,offsets,to,commit,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,if,consumer,null,consumer,wakeup
KafkaConsumerThread -> public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit);1487173364;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded  by newer ones.__@param offsetsToCommit The offsets to commit;public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit) {_		_		if (nextOffsetsToCommit.getAndSet(offsetsToCommit) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()__		if (consumer != null) {_			consumer.wakeup()__		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit;public,void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,if,next,offsets,to,commit,get,and,set,offsets,to,commit,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,if,consumer,null,consumer,wakeup
KafkaConsumerThread -> public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit);1488214488;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded  by newer ones.__@param offsetsToCommit The offsets to commit;public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit) {_		_		if (nextOffsetsToCommit.getAndSet(offsetsToCommit) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()__		if (consumer != null) {_			consumer.wakeup()__		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit;public,void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,if,next,offsets,to,commit,get,and,set,offsets,to,commit,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,if,consumer,null,consumer,wakeup
KafkaConsumerThread -> public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit);1495923077;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded  by newer ones.__@param offsetsToCommit The offsets to commit;public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit) {_		_		if (nextOffsetsToCommit.getAndSet(offsetsToCommit) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()__		if (consumer != null) {_			consumer.wakeup()__		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit;public,void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,if,next,offsets,to,commit,get,and,set,offsets,to,commit,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,if,consumer,null,consumer,wakeup
KafkaConsumerThread -> public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit);1498894422;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded  by newer ones.__@param offsetsToCommit The offsets to commit;public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit) {_		_		if (nextOffsetsToCommit.getAndSet(offsetsToCommit) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()___		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit;public,void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,if,next,offsets,to,commit,get,and,set,offsets,to,commit,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit);1500818418;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded  by newer ones.__@param offsetsToCommit The offsets to commit;public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit) {_		_		if (nextOffsetsToCommit.getAndSet(offsetsToCommit) != null) {_			log.warn("Committing offsets to Kafka takes longer than the checkpoint interval. " +_					"Skipping commit of previous offsets because newer complete checkpoint offsets are available. " +_					"This does not compromise Flink's checkpoint integrity.")__		}__		_		handover.wakeupProducer()___		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit;public,void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,if,next,offsets,to,commit,get,and,set,offsets,to,commit,null,log,warn,committing,offsets,to,kafka,takes,longer,than,the,checkpoint,interval,skipping,commit,of,previous,offsets,because,newer,complete,checkpoint,offsets,are,available,this,does,not,compromise,flink,s,checkpoint,integrity,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit);1501249950;Tells this thread to commit a set of offsets. This method does not block, the committing_operation will happen asynchronously.__<p>Only one commit operation may be pending at any time. If the committing takes longer than_the frequency with which this method is called, then some commits may be skipped due to being_superseded by newer ones.__@param offsetsToCommit The offsets to commit;public void setOffsetsToCommit(Map<TopicPartition, OffsetAndMetadata> offsetsToCommit) {_		setOffsetsToCommit(offsetsToCommit, null)__	};tells,this,thread,to,commit,a,set,of,offsets,this,method,does,not,block,the,committing,operation,will,happen,asynchronously,p,only,one,commit,operation,may,be,pending,at,any,time,if,the,committing,takes,longer,than,the,frequency,with,which,this,method,is,called,then,some,commits,may,be,skipped,due,to,being,superseded,by,newer,ones,param,offsets,to,commit,the,offsets,to,commit;public,void,set,offsets,to,commit,map,topic,partition,offset,and,metadata,offsets,to,commit,set,offsets,to,commit,offsets,to,commit,null
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1498894422;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1500818418;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		if (newPartitions.size() == 0) {_			return__		}_		hasAssignedPartitions = true__		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,if,new,partitions,size,0,return,has,assigned,partitions,true,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1501249950;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		if (newPartitions.size() == 0) {_			return__		}_		hasAssignedPartitions = true__		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,if,new,partitions,size,0,return,has,assigned,partitions,true,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1501249950;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		if (newPartitions.size() == 0) {_			return__		}_		hasAssignedPartitions = true__		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,if,new,partitions,size,0,return,has,assigned,partitions,true,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1515757409;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		if (newPartitions.size() == 0) {_			return__		}_		hasAssignedPartitions = true__		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,if,new,partitions,size,0,return,has,assigned,partitions,true,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1517943538;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		if (newPartitions.size() == 0) {_			return__		}_		hasAssignedPartitions = true__		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,if,new,partitions,size,0,return,has,assigned,partitions,true,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1517943538;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		if (newPartitions.size() == 0) {_			return__		}_		hasAssignedPartitions = true__		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,if,new,partitions,size,0,return,has,assigned,partitions,true,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1517943538;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		if (newPartitions.size() == 0) {_			return__		}_		hasAssignedPartitions = true__		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,if,new,partitions,size,0,return,has,assigned,partitions,true,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1519973085;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		if (newPartitions.size() == 0) {_			return__		}_		hasAssignedPartitions = true__		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.TIMESTAMP) {_					consumerCallBridge.seekPartitionToDate(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,if,new,partitions,size,0,return,has,assigned,partitions,true,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,timestamp,consumer,call,bridge,seek,partition,to,date,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1519973085;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		if (newPartitions.size() == 0) {_			return__		}_		hasAssignedPartitions = true__		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,if,new,partitions,size,0,return,has,assigned,partitions,true,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> @VisibleForTesting 	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception;1539704473;Reestablishes the assigned partitions for the consumer._The reassigned partitions consists of the provided new partitions and whatever partitions_was already previously assigned to the consumer.__<p>The reassignment process is protected against wakeup calls, so that after_this method returns, the consumer is either untouched or completely reassigned_with the correct offset positions.__<p>If the consumer was already woken-up prior to a reassignment resulting in an_interruption any time during the reassignment, the consumer is guaranteed_to roll back as if it was untouched. On the other hand, if there was an attempt_to wakeup the consumer during the reassignment, the wakeup call is "buffered"_until the reassignment completes.__<p>This method is exposed for testing purposes.;@VisibleForTesting_	void reassignPartitions(List<KafkaTopicPartitionState<TopicPartition>> newPartitions) throws Exception {_		if (newPartitions.size() == 0) {_			return__		}_		hasAssignedPartitions = true__		boolean reassignmentStarted = false___		_		_		_		final KafkaConsumer<byte[], byte[]> consumerTmp__		synchronized (consumerReassignmentLock) {_			consumerTmp = this.consumer__			this.consumer = null__		}__		final Map<TopicPartition, Long> oldPartitionAssignmentsToPosition = new HashMap<>()__		try {_			for (TopicPartition oldPartition : consumerTmp.assignment()) {_				oldPartitionAssignmentsToPosition.put(oldPartition, consumerTmp.position(oldPartition))__			}__			final List<TopicPartition> newPartitionAssignments =_				new ArrayList<>(newPartitions.size() + oldPartitionAssignmentsToPosition.size())__			newPartitionAssignments.addAll(oldPartitionAssignmentsToPosition.keySet())__			newPartitionAssignments.addAll(convertKafkaPartitions(newPartitions))___			_			consumerCallBridge.assignPartitions(consumerTmp, newPartitionAssignments)__			reassignmentStarted = true___			_			for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_				consumerTmp.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__			}__			_			_			_			_			_			_			for (KafkaTopicPartitionState<TopicPartition> newPartitionState : newPartitions) {_				if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.EARLIEST_OFFSET) {_					consumerCallBridge.seekPartitionToBeginning(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.LATEST_OFFSET) {_					consumerCallBridge.seekPartitionToEnd(consumerTmp, newPartitionState.getKafkaPartitionHandle())__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else if (newPartitionState.getOffset() == KafkaTopicPartitionStateSentinel.GROUP_OFFSET) {_					_					__					newPartitionState.setOffset(consumerTmp.position(newPartitionState.getKafkaPartitionHandle()) - 1)__				} else {_					consumerTmp.seek(newPartitionState.getKafkaPartitionHandle(), newPartitionState.getOffset() + 1)__				}_			}_		} catch (WakeupException e) {_			_			_			__			synchronized (consumerReassignmentLock) {_				this.consumer = consumerTmp___				_				_				if (reassignmentStarted) {_					consumerCallBridge.assignPartitions(_							this.consumer, new ArrayList<>(oldPartitionAssignmentsToPosition.keySet()))___					for (Map.Entry<TopicPartition, Long> oldPartitionToPosition : oldPartitionAssignmentsToPosition.entrySet()) {_						this.consumer.seek(oldPartitionToPosition.getKey(), oldPartitionToPosition.getValue())__					}_				}__				_				_				hasBufferedWakeup = false___				_				for (KafkaTopicPartitionState<TopicPartition> newPartition : newPartitions) {_					unassignedPartitionsQueue.add(newPartition)__				}__				_				throw new AbortedReassignmentException()__			}_		}__		_		synchronized (consumerReassignmentLock) {_			this.consumer = consumerTmp___			_			if (hasBufferedWakeup) {_				this.consumer.wakeup()__				hasBufferedWakeup = false__			}_		}_	};reestablishes,the,assigned,partitions,for,the,consumer,the,reassigned,partitions,consists,of,the,provided,new,partitions,and,whatever,partitions,was,already,previously,assigned,to,the,consumer,p,the,reassignment,process,is,protected,against,wakeup,calls,so,that,after,this,method,returns,the,consumer,is,either,untouched,or,completely,reassigned,with,the,correct,offset,positions,p,if,the,consumer,was,already,woken,up,prior,to,a,reassignment,resulting,in,an,interruption,any,time,during,the,reassignment,the,consumer,is,guaranteed,to,roll,back,as,if,it,was,untouched,on,the,other,hand,if,there,was,an,attempt,to,wakeup,the,consumer,during,the,reassignment,the,wakeup,call,is,buffered,until,the,reassignment,completes,p,this,method,is,exposed,for,testing,purposes;visible,for,testing,void,reassign,partitions,list,kafka,topic,partition,state,topic,partition,new,partitions,throws,exception,if,new,partitions,size,0,return,has,assigned,partitions,true,boolean,reassignment,started,false,final,kafka,consumer,byte,byte,consumer,tmp,synchronized,consumer,reassignment,lock,consumer,tmp,this,consumer,this,consumer,null,final,map,topic,partition,long,old,partition,assignments,to,position,new,hash,map,try,for,topic,partition,old,partition,consumer,tmp,assignment,old,partition,assignments,to,position,put,old,partition,consumer,tmp,position,old,partition,final,list,topic,partition,new,partition,assignments,new,array,list,new,partitions,size,old,partition,assignments,to,position,size,new,partition,assignments,add,all,old,partition,assignments,to,position,key,set,new,partition,assignments,add,all,convert,kafka,partitions,new,partitions,consumer,call,bridge,assign,partitions,consumer,tmp,new,partition,assignments,reassignment,started,true,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,consumer,tmp,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,for,kafka,topic,partition,state,topic,partition,new,partition,state,new,partitions,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,beginning,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,consumer,call,bridge,seek,partition,to,end,consumer,tmp,new,partition,state,get,kafka,partition,handle,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,if,new,partition,state,get,offset,kafka,topic,partition,state,sentinel,new,partition,state,set,offset,consumer,tmp,position,new,partition,state,get,kafka,partition,handle,1,else,consumer,tmp,seek,new,partition,state,get,kafka,partition,handle,new,partition,state,get,offset,1,catch,wakeup,exception,e,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,reassignment,started,consumer,call,bridge,assign,partitions,this,consumer,new,array,list,old,partition,assignments,to,position,key,set,for,map,entry,topic,partition,long,old,partition,to,position,old,partition,assignments,to,position,entry,set,this,consumer,seek,old,partition,to,position,get,key,old,partition,to,position,get,value,has,buffered,wakeup,false,for,kafka,topic,partition,state,topic,partition,new,partition,new,partitions,unassigned,partitions,queue,add,new,partition,throw,new,aborted,reassignment,exception,synchronized,consumer,reassignment,lock,this,consumer,consumer,tmp,if,has,buffered,wakeup,this,consumer,wakeup,has,buffered,wakeup,false
KafkaConsumerThread -> public void shutdown();1480685315;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		__		_		handover.wakeupProducer()___		_		if (consumer != null) {_			consumer.wakeup()__		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,handover,wakeup,producer,if,consumer,null,consumer,wakeup
KafkaConsumerThread -> public void shutdown();1487173364;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		__		_		handover.wakeupProducer()___		_		if (consumer != null) {_			consumer.wakeup()__		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,handover,wakeup,producer,if,consumer,null,consumer,wakeup
KafkaConsumerThread -> public void shutdown();1488214488;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		__		_		handover.wakeupProducer()___		_		if (consumer != null) {_			consumer.wakeup()__		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,handover,wakeup,producer,if,consumer,null,consumer,wakeup
KafkaConsumerThread -> public void shutdown();1495923077;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		__		_		handover.wakeupProducer()___		_		if (consumer != null) {_			consumer.wakeup()__		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,handover,wakeup,producer,if,consumer,null,consumer,wakeup
KafkaConsumerThread -> public void shutdown();1498894422;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void shutdown();1500818418;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		unassignedPartitionsQueue.close()___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,unassigned,partitions,queue,close,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void shutdown();1501249950;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		unassignedPartitionsQueue.close()___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,unassigned,partitions,queue,close,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void shutdown();1501249950;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		unassignedPartitionsQueue.close()___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,unassigned,partitions,queue,close,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void shutdown();1515757409;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		unassignedPartitionsQueue.close()___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,unassigned,partitions,queue,close,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void shutdown();1517943538;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		unassignedPartitionsQueue.close()___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,unassigned,partitions,queue,close,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void shutdown();1517943538;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		unassignedPartitionsQueue.close()___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,unassigned,partitions,queue,close,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void shutdown();1517943538;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		unassignedPartitionsQueue.close()___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,unassigned,partitions,queue,close,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void shutdown();1519973085;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		unassignedPartitionsQueue.close()___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,unassigned,partitions,queue,close,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void shutdown();1519973085;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		unassignedPartitionsQueue.close()___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,unassigned,partitions,queue,close,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
KafkaConsumerThread -> public void shutdown();1539704473;Shuts this thread down, waking up the thread gracefully if blocked (without Thread.interrupt() calls).;public void shutdown() {_		running = false___		_		unassignedPartitionsQueue.close()___		_		__		_		handover.wakeupProducer()___		_		synchronized (consumerReassignmentLock) {_			if (consumer != null) {_				consumer.wakeup()__			} else {_				_				_				hasBufferedWakeup = true__			}_		}_	};shuts,this,thread,down,waking,up,the,thread,gracefully,if,blocked,without,thread,interrupt,calls;public,void,shutdown,running,false,unassigned,partitions,queue,close,handover,wakeup,producer,synchronized,consumer,reassignment,lock,if,consumer,null,consumer,wakeup,else,has,buffered,wakeup,true
