# id;timestamp;commentText;codeText;commentWords;codeWords
DataStreamUtils -> public static <OUT> Iterator<OUT> collect(DataStream<OUT> stream) throws IOException;1518197017;Returns an iterator to iterate over the elements of the DataStream._@return The iterator;public static <OUT> Iterator<OUT> collect(DataStream<OUT> stream) throws IOException {__		TypeSerializer<OUT> serializer = stream.getType().createSerializer(_				stream.getExecutionEnvironment().getConfig())___		SocketStreamIterator<OUT> iter = new SocketStreamIterator<OUT>(serializer)___		_		StreamExecutionEnvironment env = stream.getExecutionEnvironment()__		InetAddress clientAddress___		if (env instanceof RemoteStreamEnvironment) {_			String host = ((RemoteStreamEnvironment) env).getHost()__			int port = ((RemoteStreamEnvironment) env).getPort()__			try {_				clientAddress = ConnectionUtils.findConnectingAddress(new InetSocketAddress(host, port), 2000, 400)__			}_			catch (Exception e) {_				throw new IOException("Could not determine an suitable network address to " +_						"receive back data from the streaming program.", e)__			}_		} else if (env instanceof LocalStreamEnvironment) {_			clientAddress = InetAddress.getLoopbackAddress()__		} else {_			try {_				clientAddress = InetAddress.getLocalHost()__			} catch (UnknownHostException e) {_				throw new IOException("Could not determine this machines own local address to " +_						"receive back data from the streaming program.", e)__			}_		}__		DataStreamSink<OUT> sink = stream.addSink(new CollectSink<OUT>(clientAddress, iter.getPort(), serializer))__		sink.setParallelism(1)_ __		(new CallExecute(env, iter)).start()___		return iter__	};returns,an,iterator,to,iterate,over,the,elements,of,the,data,stream,return,the,iterator;public,static,out,iterator,out,collect,data,stream,out,stream,throws,ioexception,type,serializer,out,serializer,stream,get,type,create,serializer,stream,get,execution,environment,get,config,socket,stream,iterator,out,iter,new,socket,stream,iterator,out,serializer,stream,execution,environment,env,stream,get,execution,environment,inet,address,client,address,if,env,instanceof,remote,stream,environment,string,host,remote,stream,environment,env,get,host,int,port,remote,stream,environment,env,get,port,try,client,address,connection,utils,find,connecting,address,new,inet,socket,address,host,port,2000,400,catch,exception,e,throw,new,ioexception,could,not,determine,an,suitable,network,address,to,receive,back,data,from,the,streaming,program,e,else,if,env,instanceof,local,stream,environment,client,address,inet,address,get,loopback,address,else,try,client,address,inet,address,get,local,host,catch,unknown,host,exception,e,throw,new,ioexception,could,not,determine,this,machines,own,local,address,to,receive,back,data,from,the,streaming,program,e,data,stream,sink,out,sink,stream,add,sink,new,collect,sink,out,client,address,iter,get,port,serializer,sink,set,parallelism,1,new,call,execute,env,iter,start,return,iter
DataStreamUtils -> public static <OUT> Iterator<OUT> collect(DataStream<OUT> stream) throws IOException;1518197017;Returns an iterator to iterate over the elements of the DataStream._@return The iterator;public static <OUT> Iterator<OUT> collect(DataStream<OUT> stream) throws IOException {__		TypeSerializer<OUT> serializer = stream.getType().createSerializer(_				stream.getExecutionEnvironment().getConfig())___		SocketStreamIterator<OUT> iter = new SocketStreamIterator<OUT>(serializer)___		_		StreamExecutionEnvironment env = stream.getExecutionEnvironment()__		InetAddress clientAddress___		if (env instanceof RemoteStreamEnvironment) {_			String host = ((RemoteStreamEnvironment) env).getHost()__			int port = ((RemoteStreamEnvironment) env).getPort()__			try {_				clientAddress = ConnectionUtils.findConnectingAddress(new InetSocketAddress(host, port), 2000, 400)__			}_			catch (Exception e) {_				throw new IOException("Could not determine an suitable network address to " +_						"receive back data from the streaming program.", e)__			}_		} else if (env instanceof LocalStreamEnvironment) {_			clientAddress = InetAddress.getLoopbackAddress()__		} else {_			try {_				clientAddress = InetAddress.getLocalHost()__			} catch (UnknownHostException e) {_				throw new IOException("Could not determine this machines own local address to " +_						"receive back data from the streaming program.", e)__			}_		}__		DataStreamSink<OUT> sink = stream.addSink(new CollectSink<OUT>(clientAddress, iter.getPort(), serializer))__		sink.setParallelism(1)_ __		(new CallExecute(env, iter)).start()___		return iter__	};returns,an,iterator,to,iterate,over,the,elements,of,the,data,stream,return,the,iterator;public,static,out,iterator,out,collect,data,stream,out,stream,throws,ioexception,type,serializer,out,serializer,stream,get,type,create,serializer,stream,get,execution,environment,get,config,socket,stream,iterator,out,iter,new,socket,stream,iterator,out,serializer,stream,execution,environment,env,stream,get,execution,environment,inet,address,client,address,if,env,instanceof,remote,stream,environment,string,host,remote,stream,environment,env,get,host,int,port,remote,stream,environment,env,get,port,try,client,address,connection,utils,find,connecting,address,new,inet,socket,address,host,port,2000,400,catch,exception,e,throw,new,ioexception,could,not,determine,an,suitable,network,address,to,receive,back,data,from,the,streaming,program,e,else,if,env,instanceof,local,stream,environment,client,address,inet,address,get,loopback,address,else,try,client,address,inet,address,get,local,host,catch,unknown,host,exception,e,throw,new,ioexception,could,not,determine,this,machines,own,local,address,to,receive,back,data,from,the,streaming,program,e,data,stream,sink,out,sink,stream,add,sink,new,collect,sink,out,client,address,iter,get,port,serializer,sink,set,parallelism,1,new,call,execute,env,iter,start,return,iter
DataStreamUtils -> public static <OUT> Iterator<OUT> collect(DataStream<OUT> stream) throws IOException;1523020981;Returns an iterator to iterate over the elements of the DataStream._@return The iterator;public static <OUT> Iterator<OUT> collect(DataStream<OUT> stream) throws IOException {__		TypeSerializer<OUT> serializer = stream.getType().createSerializer(_				stream.getExecutionEnvironment().getConfig())___		SocketStreamIterator<OUT> iter = new SocketStreamIterator<OUT>(serializer)___		_		StreamExecutionEnvironment env = stream.getExecutionEnvironment()__		InetAddress clientAddress___		if (env instanceof RemoteStreamEnvironment) {_			String host = ((RemoteStreamEnvironment) env).getHost()__			int port = ((RemoteStreamEnvironment) env).getPort()__			try {_				clientAddress = ConnectionUtils.findConnectingAddress(new InetSocketAddress(host, port), 2000, 400)__			}_			catch (Exception e) {_				throw new IOException("Could not determine an suitable network address to " +_						"receive back data from the streaming program.", e)__			}_		} else if (env instanceof LocalStreamEnvironment) {_			clientAddress = InetAddress.getLoopbackAddress()__		} else {_			try {_				clientAddress = InetAddress.getLocalHost()__			} catch (UnknownHostException e) {_				throw new IOException("Could not determine this machines own local address to " +_						"receive back data from the streaming program.", e)__			}_		}__		DataStreamSink<OUT> sink = stream.addSink(new CollectSink<OUT>(clientAddress, iter.getPort(), serializer))__		sink.setParallelism(1)_ __		(new CallExecute(env, iter)).start()___		return iter__	};returns,an,iterator,to,iterate,over,the,elements,of,the,data,stream,return,the,iterator;public,static,out,iterator,out,collect,data,stream,out,stream,throws,ioexception,type,serializer,out,serializer,stream,get,type,create,serializer,stream,get,execution,environment,get,config,socket,stream,iterator,out,iter,new,socket,stream,iterator,out,serializer,stream,execution,environment,env,stream,get,execution,environment,inet,address,client,address,if,env,instanceof,remote,stream,environment,string,host,remote,stream,environment,env,get,host,int,port,remote,stream,environment,env,get,port,try,client,address,connection,utils,find,connecting,address,new,inet,socket,address,host,port,2000,400,catch,exception,e,throw,new,ioexception,could,not,determine,an,suitable,network,address,to,receive,back,data,from,the,streaming,program,e,else,if,env,instanceof,local,stream,environment,client,address,inet,address,get,loopback,address,else,try,client,address,inet,address,get,local,host,catch,unknown,host,exception,e,throw,new,ioexception,could,not,determine,this,machines,own,local,address,to,receive,back,data,from,the,streaming,program,e,data,stream,sink,out,sink,stream,add,sink,new,collect,sink,out,client,address,iter,get,port,serializer,sink,set,parallelism,1,new,call,execute,env,iter,start,return,iter
DataStreamUtils -> public static <T, K> KeyedStream<T, K> reinterpretAsKeyedStream( 		DataStream<T> stream, 		KeySelector<T, K> keySelector);1518197017;Reinterprets the given {@link DataStream} as a {@link KeyedStream}, which extracts keys with the given_{@link KeySelector}.__<p>IMPORTANT: For every partition of the base stream, the keys of events in the base stream must be_partitioned exactly in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.__@param stream      The data stream to reinterpret. For every partition, this stream must be partitioned exactly_in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}._@param keySelector Function that defines how keys are extracted from the data stream._@param <T>         Type of events in the data stream._@param <K>         Type of the extracted keys._@return The reinterpretation of the {@link DataStream} as a {@link KeyedStream}.;public static <T, K> KeyedStream<T, K> reinterpretAsKeyedStream(_		DataStream<T> stream,_		KeySelector<T, K> keySelector) {__		return reinterpretAsKeyedStream(_			stream,_			keySelector,_			TypeExtractor.getKeySelectorTypes(keySelector, stream.getType()))__	};reinterprets,the,given,link,data,stream,as,a,link,keyed,stream,which,extracts,keys,with,the,given,link,key,selector,p,important,for,every,partition,of,the,base,stream,the,keys,of,events,in,the,base,stream,must,be,partitioned,exactly,in,the,same,way,as,if,it,was,created,through,a,link,data,stream,key,by,key,selector,param,stream,the,data,stream,to,reinterpret,for,every,partition,this,stream,must,be,partitioned,exactly,in,the,same,way,as,if,it,was,created,through,a,link,data,stream,key,by,key,selector,param,key,selector,function,that,defines,how,keys,are,extracted,from,the,data,stream,param,t,type,of,events,in,the,data,stream,param,k,type,of,the,extracted,keys,return,the,reinterpretation,of,the,link,data,stream,as,a,link,keyed,stream;public,static,t,k,keyed,stream,t,k,reinterpret,as,keyed,stream,data,stream,t,stream,key,selector,t,k,key,selector,return,reinterpret,as,keyed,stream,stream,key,selector,type,extractor,get,key,selector,types,key,selector,stream,get,type
DataStreamUtils -> public static <T, K> KeyedStream<T, K> reinterpretAsKeyedStream( 		DataStream<T> stream, 		KeySelector<T, K> keySelector);1523020981;Reinterprets the given {@link DataStream} as a {@link KeyedStream}, which extracts keys with the given_{@link KeySelector}.__<p>IMPORTANT: For every partition of the base stream, the keys of events in the base stream must be_partitioned exactly in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.__@param stream      The data stream to reinterpret. For every partition, this stream must be partitioned exactly_in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}._@param keySelector Function that defines how keys are extracted from the data stream._@param <T>         Type of events in the data stream._@param <K>         Type of the extracted keys._@return The reinterpretation of the {@link DataStream} as a {@link KeyedStream}.;public static <T, K> KeyedStream<T, K> reinterpretAsKeyedStream(_		DataStream<T> stream,_		KeySelector<T, K> keySelector) {__		return reinterpretAsKeyedStream(_			stream,_			keySelector,_			TypeExtractor.getKeySelectorTypes(keySelector, stream.getType()))__	};reinterprets,the,given,link,data,stream,as,a,link,keyed,stream,which,extracts,keys,with,the,given,link,key,selector,p,important,for,every,partition,of,the,base,stream,the,keys,of,events,in,the,base,stream,must,be,partitioned,exactly,in,the,same,way,as,if,it,was,created,through,a,link,data,stream,key,by,key,selector,param,stream,the,data,stream,to,reinterpret,for,every,partition,this,stream,must,be,partitioned,exactly,in,the,same,way,as,if,it,was,created,through,a,link,data,stream,key,by,key,selector,param,key,selector,function,that,defines,how,keys,are,extracted,from,the,data,stream,param,t,type,of,events,in,the,data,stream,param,k,type,of,the,extracted,keys,return,the,reinterpretation,of,the,link,data,stream,as,a,link,keyed,stream;public,static,t,k,keyed,stream,t,k,reinterpret,as,keyed,stream,data,stream,t,stream,key,selector,t,k,key,selector,return,reinterpret,as,keyed,stream,stream,key,selector,type,extractor,get,key,selector,types,key,selector,stream,get,type
DataStreamUtils -> private DataStreamUtils();1518197017;Private constructor to prevent instantiation.;private DataStreamUtils() {};private,constructor,to,prevent,instantiation;private,data,stream,utils
DataStreamUtils -> private DataStreamUtils();1518197017;Private constructor to prevent instantiation.;private DataStreamUtils() {};private,constructor,to,prevent,instantiation;private,data,stream,utils
DataStreamUtils -> private DataStreamUtils();1523020981;Private constructor to prevent instantiation.;private DataStreamUtils() {};private,constructor,to,prevent,instantiation;private,data,stream,utils
DataStreamUtils -> public static <T, K> KeyedStream<T, K> reinterpretAsKeyedStream( 		DataStream<T> stream, 		KeySelector<T, K> keySelector, 		TypeInformation<K> typeInfo);1518197017;Reinterprets the given {@link DataStream} as a {@link KeyedStream}, which extracts keys with the given_{@link KeySelector}.__<p>IMPORTANT: For every partition of the base stream, the keys of events in the base stream must be_partitioned exactly in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.__@param stream      The data stream to reinterpret. For every partition, this stream must be partitioned exactly_in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}._@param keySelector Function that defines how keys are extracted from the data stream._@param typeInfo    Explicit type information about the key type._@param <T>         Type of events in the data stream._@param <K>         Type of the extracted keys._@return The reinterpretation of the {@link DataStream} as a {@link KeyedStream}.;public static <T, K> KeyedStream<T, K> reinterpretAsKeyedStream(_		DataStream<T> stream,_		KeySelector<T, K> keySelector,_		TypeInformation<K> typeInfo) {__		PartitionTransformation<T> partitionTransformation = new PartitionTransformation<>(_			stream.getTransformation(),_			new ForwardPartitioner<>())___		return new KeyedStream<>(_			stream,_			partitionTransformation,_			keySelector,_			typeInfo)__	};reinterprets,the,given,link,data,stream,as,a,link,keyed,stream,which,extracts,keys,with,the,given,link,key,selector,p,important,for,every,partition,of,the,base,stream,the,keys,of,events,in,the,base,stream,must,be,partitioned,exactly,in,the,same,way,as,if,it,was,created,through,a,link,data,stream,key,by,key,selector,param,stream,the,data,stream,to,reinterpret,for,every,partition,this,stream,must,be,partitioned,exactly,in,the,same,way,as,if,it,was,created,through,a,link,data,stream,key,by,key,selector,param,key,selector,function,that,defines,how,keys,are,extracted,from,the,data,stream,param,type,info,explicit,type,information,about,the,key,type,param,t,type,of,events,in,the,data,stream,param,k,type,of,the,extracted,keys,return,the,reinterpretation,of,the,link,data,stream,as,a,link,keyed,stream;public,static,t,k,keyed,stream,t,k,reinterpret,as,keyed,stream,data,stream,t,stream,key,selector,t,k,key,selector,type,information,k,type,info,partition,transformation,t,partition,transformation,new,partition,transformation,stream,get,transformation,new,forward,partitioner,return,new,keyed,stream,stream,partition,transformation,key,selector,type,info
DataStreamUtils -> public static <T, K> KeyedStream<T, K> reinterpretAsKeyedStream( 		DataStream<T> stream, 		KeySelector<T, K> keySelector, 		TypeInformation<K> typeInfo);1523020981;Reinterprets the given {@link DataStream} as a {@link KeyedStream}, which extracts keys with the given_{@link KeySelector}.__<p>IMPORTANT: For every partition of the base stream, the keys of events in the base stream must be_partitioned exactly in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}.__@param stream      The data stream to reinterpret. For every partition, this stream must be partitioned exactly_in the same way as if it was created through a {@link DataStream#keyBy(KeySelector)}._@param keySelector Function that defines how keys are extracted from the data stream._@param typeInfo    Explicit type information about the key type._@param <T>         Type of events in the data stream._@param <K>         Type of the extracted keys._@return The reinterpretation of the {@link DataStream} as a {@link KeyedStream}.;public static <T, K> KeyedStream<T, K> reinterpretAsKeyedStream(_		DataStream<T> stream,_		KeySelector<T, K> keySelector,_		TypeInformation<K> typeInfo) {__		PartitionTransformation<T> partitionTransformation = new PartitionTransformation<>(_			stream.getTransformation(),_			new ForwardPartitioner<>())___		return new KeyedStream<>(_			stream,_			partitionTransformation,_			keySelector,_			typeInfo)__	};reinterprets,the,given,link,data,stream,as,a,link,keyed,stream,which,extracts,keys,with,the,given,link,key,selector,p,important,for,every,partition,of,the,base,stream,the,keys,of,events,in,the,base,stream,must,be,partitioned,exactly,in,the,same,way,as,if,it,was,created,through,a,link,data,stream,key,by,key,selector,param,stream,the,data,stream,to,reinterpret,for,every,partition,this,stream,must,be,partitioned,exactly,in,the,same,way,as,if,it,was,created,through,a,link,data,stream,key,by,key,selector,param,key,selector,function,that,defines,how,keys,are,extracted,from,the,data,stream,param,type,info,explicit,type,information,about,the,key,type,param,t,type,of,events,in,the,data,stream,param,k,type,of,the,extracted,keys,return,the,reinterpretation,of,the,link,data,stream,as,a,link,keyed,stream;public,static,t,k,keyed,stream,t,k,reinterpret,as,keyed,stream,data,stream,t,stream,key,selector,t,k,key,selector,type,information,k,type,info,partition,transformation,t,partition,transformation,new,partition,transformation,stream,get,transformation,new,forward,partitioner,return,new,keyed,stream,stream,partition,transformation,key,selector,type,info
