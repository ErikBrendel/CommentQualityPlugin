# id;timestamp;commentText;codeText;commentWords;codeWords
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException;1477570922;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(new Path(path))__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				Path filePath = status.getPath()__				long modificationTime = status.getModificationTime()__				if (!shouldIgnore(filePath, modificationTime)) {_					files.put(filePath, status)__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,new,path,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException;1478784006;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(new Path(path))__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				Path filePath = status.getPath()__				long modificationTime = status.getModificationTime()__				if (!shouldIgnore(filePath, modificationTime)) {_					files.put(filePath, status)__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,new,path,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException;1478869558;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(new Path(path))__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				Path filePath = status.getPath()__				long modificationTime = status.getModificationTime()__				if (!shouldIgnore(filePath, modificationTime)) {_					files.put(filePath, status)__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,new,path,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException;1481632698;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(new Path(path))__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				Path filePath = status.getPath()__				long modificationTime = status.getModificationTime()__				if (!shouldIgnore(filePath, modificationTime)) {_					files.put(filePath, status)__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,new,path,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException;1482246154;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(new Path(path))__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				Path filePath = status.getPath()__				long modificationTime = status.getModificationTime()__				if (!shouldIgnore(filePath, modificationTime)) {_					files.put(filePath, status)__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,new,path,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException;1483615698;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(new Path(path))__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				Path filePath = status.getPath()__				long modificationTime = status.getModificationTime()__				if (!shouldIgnore(filePath, modificationTime)) {_					files.put(filePath, status)__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,new,path,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException;1484866639;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(path)__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				if (!status.isDir()) {_					Path filePath = status.getPath()__					long modificationTime = status.getModificationTime()__					if (!shouldIgnore(filePath, modificationTime)) {_						files.put(filePath, status)__					}_				} else if (format.getNestedFileEnumeration() && format.acceptFile(status)){_					files.putAll(listEligibleFiles(fileSystem, status.getPath()))__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,path,path,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,if,status,is,dir,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,else,if,format,get,nested,file,enumeration,format,accept,file,status,files,put,all,list,eligible,files,file,system,status,get,path,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException;1492569128;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(path)__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				if (!status.isDir()) {_					Path filePath = status.getPath()__					long modificationTime = status.getModificationTime()__					if (!shouldIgnore(filePath, modificationTime)) {_						files.put(filePath, status)__					}_				} else if (format.getNestedFileEnumeration() && format.acceptFile(status)){_					files.putAll(listEligibleFiles(fileSystem, status.getPath()))__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,path,path,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,if,status,is,dir,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,else,if,format,get,nested,file,enumeration,format,accept,file,status,files,put,all,list,eligible,files,file,system,status,get,path,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException;1492678790;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(path)__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				if (!status.isDir()) {_					Path filePath = status.getPath()__					long modificationTime = status.getModificationTime()__					if (!shouldIgnore(filePath, modificationTime)) {_						files.put(filePath, status)__					}_				} else if (format.getNestedFileEnumeration() && format.acceptFile(status)){_					files.putAll(listEligibleFiles(fileSystem, status.getPath()))__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,path,path,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,if,status,is,dir,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,else,if,format,get,nested,file,enumeration,format,accept,file,status,files,put,all,list,eligible,files,file,system,status,get,path,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException;1493195810;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(path)__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				if (!status.isDir()) {_					Path filePath = status.getPath()__					long modificationTime = status.getModificationTime()__					if (!shouldIgnore(filePath, modificationTime)) {_						files.put(filePath, status)__					}_				} else if (format.getNestedFileEnumeration() && format.acceptFile(status)){_					files.putAll(listEligibleFiles(fileSystem, status.getPath()))__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,path,path,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,if,status,is,dir,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,else,if,format,get,nested,file,enumeration,format,accept,file,status,files,put,all,list,eligible,files,file,system,status,get,path,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException;1493195810;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(path)__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				if (!status.isDir()) {_					Path filePath = status.getPath()__					long modificationTime = status.getModificationTime()__					if (!shouldIgnore(filePath, modificationTime)) {_						files.put(filePath, status)__					}_				} else if (format.getNestedFileEnumeration() && format.acceptFile(status)){_					files.putAll(listEligibleFiles(fileSystem, status.getPath()))__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,path,path,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,if,status,is,dir,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,else,if,format,get,nested,file,enumeration,format,accept,file,status,files,put,all,list,eligible,files,file,system,status,get,path,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException;1493195810;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(path)__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				if (!status.isDir()) {_					Path filePath = status.getPath()__					long modificationTime = status.getModificationTime()__					if (!shouldIgnore(filePath, modificationTime)) {_						files.put(filePath, status)__					}_				} else if (format.getNestedFileEnumeration() && format.acceptFile(status)){_					files.putAll(listEligibleFiles(fileSystem, status.getPath()))__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,path,path,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,if,status,is,dir,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,else,if,format,get,nested,file,enumeration,format,accept,file,status,files,put,all,list,eligible,files,file,system,status,get,path,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException;1495484544;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(path)__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				if (!status.isDir()) {_					Path filePath = status.getPath()__					long modificationTime = status.getModificationTime()__					if (!shouldIgnore(filePath, modificationTime)) {_						files.put(filePath, status)__					}_				} else if (format.getNestedFileEnumeration() && format.acceptFile(status)){_					files.putAll(listEligibleFiles(fileSystem, status.getPath()))__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,path,path,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,if,status,is,dir,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,else,if,format,get,nested,file,enumeration,format,accept,file,status,files,put,all,list,eligible,files,file,system,status,get,path,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException;1503598628;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(path)__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				if (!status.isDir()) {_					Path filePath = status.getPath()__					long modificationTime = status.getModificationTime()__					if (!shouldIgnore(filePath, modificationTime)) {_						files.put(filePath, status)__					}_				} else if (format.getNestedFileEnumeration() && format.acceptFile(status)){_					files.putAll(listEligibleFiles(fileSystem, status.getPath()))__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,path,path,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,if,status,is,dir,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,else,if,format,get,nested,file,enumeration,format,accept,file,status,files,put,all,list,eligible,files,file,system,status,get,path,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException;1506603371;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(path)__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				if (!status.isDir()) {_					Path filePath = status.getPath()__					long modificationTime = status.getModificationTime()__					if (!shouldIgnore(filePath, modificationTime)) {_						files.put(filePath, status)__					}_				} else if (format.getNestedFileEnumeration() && format.acceptFile(status)){_					files.putAll(listEligibleFiles(fileSystem, status.getPath()))__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,path,path,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,if,status,is,dir,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,else,if,format,get,nested,file,enumeration,format,accept,file,status,files,put,all,list,eligible,files,file,system,status,get,path,return,files
ContinuousFileMonitoringFunction -> private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException;1518772855;Returns the paths of the files not yet processed._@param fileSystem The filesystem where the monitored directory resides.;private Map<Path, FileStatus> listEligibleFiles(FileSystem fileSystem, Path path) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(path)__		} catch (IOException e) {_			_			_			return Collections.emptyMap()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyMap()__		} else {_			Map<Path, FileStatus> files = new HashMap<>()__			_			for (FileStatus status : statuses) {_				if (!status.isDir()) {_					Path filePath = status.getPath()__					long modificationTime = status.getModificationTime()__					if (!shouldIgnore(filePath, modificationTime)) {_						files.put(filePath, status)__					}_				} else if (format.getNestedFileEnumeration() && format.acceptFile(status)){_					files.putAll(listEligibleFiles(fileSystem, status.getPath()))__				}_			}_			return files__		}_	};returns,the,paths,of,the,files,not,yet,processed,param,file,system,the,filesystem,where,the,monitored,directory,resides;private,map,path,file,status,list,eligible,files,file,system,file,system,path,path,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,path,catch,ioexception,e,return,collections,empty,map,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,map,else,map,path,file,status,files,new,hash,map,for,file,status,status,statuses,if,status,is,dir,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,put,file,path,status,else,if,format,get,nested,file,enumeration,format,accept,file,status,files,put,all,list,eligible,files,file,system,status,get,path,return,files
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1477570922;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1478784006;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1478869558;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1481632698;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1482246154;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1483615698;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1484866639;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1492569128;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1492678790;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1493195810;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1493195810;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1493195810;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1495484544;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1503598628;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1506603371;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime( 				Map<Path, FileStatus> eligibleFiles) throws IOException;1518772855;Creates the input splits to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Splits are sorted <b>by modification time</b> before_being forwarded and only splits belonging to files in the {@code eligibleFiles}_list will be processed._@param eligibleFiles The files to process.;private Map<Long, List<TimestampedFileInputSplit>> getInputSplitsSortedByModTime(_				Map<Path, FileStatus> eligibleFiles) throws IOException {__		Map<Long, List<TimestampedFileInputSplit>> splitsByModTime = new TreeMap<>()__		if (eligibleFiles.isEmpty()) {_			return splitsByModTime__		}__		for (FileInputSplit split: format.createInputSplits(readerParallelism)) {_			FileStatus fileStatus = eligibleFiles.get(split.getPath())__			if (fileStatus != null) {_				Long modTime = fileStatus.getModificationTime()__				List<TimestampedFileInputSplit> splitsToForward = splitsByModTime.get(modTime)__				if (splitsToForward == null) {_					splitsToForward = new ArrayList<>()__					splitsByModTime.put(modTime, splitsToForward)__				}_				splitsToForward.add(new TimestampedFileInputSplit(_					modTime, split.getSplitNumber(), split.getPath(),_					split.getStart(), split.getLength(), split.getHostnames()))__			}_		}_		return splitsByModTime__	};creates,the,input,splits,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,splits,are,sorted,b,by,modification,time,b,before,being,forwarded,and,only,splits,belonging,to,files,in,the,code,eligible,files,list,will,be,processed,param,eligible,files,the,files,to,process;private,map,long,list,timestamped,file,input,split,get,input,splits,sorted,by,mod,time,map,path,file,status,eligible,files,throws,ioexception,map,long,list,timestamped,file,input,split,splits,by,mod,time,new,tree,map,if,eligible,files,is,empty,return,splits,by,mod,time,for,file,input,split,split,format,create,input,splits,reader,parallelism,file,status,file,status,eligible,files,get,split,get,path,if,file,status,null,long,mod,time,file,status,get,modification,time,list,timestamped,file,input,split,splits,to,forward,splits,by,mod,time,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,array,list,splits,by,mod,time,put,mod,time,splits,to,forward,splits,to,forward,add,new,timestamped,file,input,split,mod,time,split,get,split,number,split,get,path,split,get,start,split,get,length,split,get,hostnames,return,splits,by,mod,time
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1465920682;Returns {@code true} if the file is NOT to be processed further._This happens in the following cases:__If the user-specified path filtering method returns {@code true} for the file,_or if the modification time of the file is smaller than the {@link #globalModificationTime}, which_is the time of the most recent modification found in any of the already processed files.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		boolean shouldIgnore = ((pathFilter != null && pathFilter.filterPath(filePath)) || modificationTime <= globalModificationTime)__		if (shouldIgnore) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime + " and global mod time= " + globalModificationTime)__		}_		return  shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,in,the,following,cases,if,the,user,specified,path,filtering,method,returns,code,true,for,the,file,or,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,which,is,the,time,of,the,most,recent,modification,found,in,any,of,the,already,processed,files;private,boolean,should,ignore,path,file,path,long,modification,time,boolean,should,ignore,path,filter,null,path,filter,filter,path,file,path,modification,time,global,modification,time,if,should,ignore,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1467290786;Returns {@code true} if the file is NOT to be processed further._This happens in the following cases:__If the user-specified path filtering method returns {@code true} for the file,_or if the modification time of the file is smaller than the {@link #globalModificationTime}, which_is the time of the most recent modification found in any of the already processed files.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = ((pathFilter != null && pathFilter.filterPath(filePath)) || modificationTime <= globalModificationTime)__		if (shouldIgnore) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime + " and global mod time= " + globalModificationTime)__		}_		return  shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,in,the,following,cases,if,the,user,specified,path,filtering,method,returns,code,true,for,the,file,or,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,which,is,the,time,of,the,most,recent,modification,found,in,any,of,the,already,processed,files;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,path,filter,null,path,filter,filter,path,file,path,modification,time,global,modification,time,if,should,ignore,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1472134098;Returns {@code true} if the file is NOT to be processed further._This happens in the following cases:__If the user-specified path filtering method returns {@code true} for the file,_or if the modification time of the file is smaller than the {@link #globalModificationTime}, which_is the time of the most recent modification found in any of the already processed files.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime + " and global mod time= " + globalModificationTime)__		}_		return  shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,in,the,following,cases,if,the,user,specified,path,filtering,method,returns,code,true,for,the,file,or,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,which,is,the,time,of,the,most,recent,modification,found,in,any,of,the,already,processed,files;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1476089389;Returns {@code true} if the file is NOT to be processed further._This happens in the following cases:__If the user-specified path filtering method returns {@code true} for the file,_or if the modification time of the file is smaller than the {@link #globalModificationTime}, which_is the time of the most recent modification found in any of the already processed files.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime + " and global mod time= " + globalModificationTime)__		}_		return  shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,in,the,following,cases,if,the,user,specified,path,filtering,method,returns,code,true,for,the,file,or,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,which,is,the,time,of,the,most,recent,modification,found,in,any,of,the,already,processed,files;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1477570922;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1478784006;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1478869558;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1481632698;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1482246154;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1483615698;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1484866639;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1492569128;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1492678790;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1493195810;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1493195810;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1493195810;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1495484544;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1503598628;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1506603371;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private boolean shouldIgnore(Path filePath, long modificationTime);1518772855;Returns {@code true} if the file is NOT to be processed further._This happens if the modification time of the file is smaller than_the {@link #globalModificationTime}._@param filePath the path of the file to check._@param modificationTime the modification time of the file.;private boolean shouldIgnore(Path filePath, long modificationTime) {_		assert (Thread.holdsLock(checkpointLock))__		boolean shouldIgnore = modificationTime <= globalModificationTime__		if (shouldIgnore && LOG.isDebugEnabled()) {_			LOG.debug("Ignoring " + filePath + ", with mod time= " + modificationTime +_				" and global mod time= " + globalModificationTime)__		}_		return shouldIgnore__	};returns,code,true,if,the,file,is,not,to,be,processed,further,this,happens,if,the,modification,time,of,the,file,is,smaller,than,the,link,global,modification,time,param,file,path,the,path,of,the,file,to,check,param,modification,time,the,modification,time,of,the,file;private,boolean,should,ignore,path,file,path,long,modification,time,assert,thread,holds,lock,checkpoint,lock,boolean,should,ignore,modification,time,global,modification,time,if,should,ignore,log,is,debug,enabled,log,debug,ignoring,file,path,with,mod,time,modification,time,and,global,mod,time,global,modification,time,return,should,ignore
ContinuousFileMonitoringFunction -> private Map<Long, List<FileInputSplit>> getInputSplits(List<FileStatus> eligibleFiles) throws IOException;1465920682;Creates the input splits for the path to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Those tasks are going to read their contents for further_processing. Splits belonging to files in the {@code eligibleFiles} list are the ones_that are shipped for further processing._@param eligibleFiles The files to process.;private Map<Long, List<FileInputSplit>> getInputSplits(List<FileStatus> eligibleFiles) throws IOException {_		if (eligibleFiles.isEmpty()) {_			return new HashMap<>()__		}__		FileInputSplit[] inputSplits = format.createInputSplits(readerParallelism)___		Map<Long, List<FileInputSplit>> splitsPerFile = new HashMap<>()__		for (FileInputSplit split: inputSplits) {_			for (FileStatus file: eligibleFiles) {_				if (file.getPath().equals(split.getPath())) {_					Long modTime = file.getModificationTime()___					List<FileInputSplit> splitsToForward = splitsPerFile.get(modTime)__					if (splitsToForward == null) {_						splitsToForward = new LinkedList<>()__						splitsPerFile.put(modTime, splitsToForward)__					}_					splitsToForward.add(split)__					break__				}_			}_		}_		return splitsPerFile__	};creates,the,input,splits,for,the,path,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,those,tasks,are,going,to,read,their,contents,for,further,processing,splits,belonging,to,files,in,the,code,eligible,files,list,are,the,ones,that,are,shipped,for,further,processing,param,eligible,files,the,files,to,process;private,map,long,list,file,input,split,get,input,splits,list,file,status,eligible,files,throws,ioexception,if,eligible,files,is,empty,return,new,hash,map,file,input,split,input,splits,format,create,input,splits,reader,parallelism,map,long,list,file,input,split,splits,per,file,new,hash,map,for,file,input,split,split,input,splits,for,file,status,file,eligible,files,if,file,get,path,equals,split,get,path,long,mod,time,file,get,modification,time,list,file,input,split,splits,to,forward,splits,per,file,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,linked,list,splits,per,file,put,mod,time,splits,to,forward,splits,to,forward,add,split,break,return,splits,per,file
ContinuousFileMonitoringFunction -> private Map<Long, List<FileInputSplit>> getInputSplits(List<FileStatus> eligibleFiles) throws IOException;1467290786;Creates the input splits for the path to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Those tasks are going to read their contents for further_processing. Splits belonging to files in the {@code eligibleFiles} list are the ones_that are shipped for further processing._@param eligibleFiles The files to process.;private Map<Long, List<FileInputSplit>> getInputSplits(List<FileStatus> eligibleFiles) throws IOException {_		if (eligibleFiles.isEmpty()) {_			return new HashMap<>()__		}__		FileInputSplit[] inputSplits = format.createInputSplits(readerParallelism)___		Map<Long, List<FileInputSplit>> splitsPerFile = new HashMap<>()__		for (FileInputSplit split: inputSplits) {_			for (FileStatus file: eligibleFiles) {_				if (file.getPath().equals(split.getPath())) {_					Long modTime = file.getModificationTime()___					List<FileInputSplit> splitsToForward = splitsPerFile.get(modTime)__					if (splitsToForward == null) {_						splitsToForward = new LinkedList<>()__						splitsPerFile.put(modTime, splitsToForward)__					}_					splitsToForward.add(split)__					break__				}_			}_		}_		return splitsPerFile__	};creates,the,input,splits,for,the,path,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,those,tasks,are,going,to,read,their,contents,for,further,processing,splits,belonging,to,files,in,the,code,eligible,files,list,are,the,ones,that,are,shipped,for,further,processing,param,eligible,files,the,files,to,process;private,map,long,list,file,input,split,get,input,splits,list,file,status,eligible,files,throws,ioexception,if,eligible,files,is,empty,return,new,hash,map,file,input,split,input,splits,format,create,input,splits,reader,parallelism,map,long,list,file,input,split,splits,per,file,new,hash,map,for,file,input,split,split,input,splits,for,file,status,file,eligible,files,if,file,get,path,equals,split,get,path,long,mod,time,file,get,modification,time,list,file,input,split,splits,to,forward,splits,per,file,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,linked,list,splits,per,file,put,mod,time,splits,to,forward,splits,to,forward,add,split,break,return,splits,per,file
ContinuousFileMonitoringFunction -> private Map<Long, List<FileInputSplit>> getInputSplits(List<FileStatus> eligibleFiles) throws IOException;1472134098;Creates the input splits for the path to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Those tasks are going to read their contents for further_processing. Splits belonging to files in the {@code eligibleFiles} list are the ones_that are shipped for further processing._@param eligibleFiles The files to process.;private Map<Long, List<FileInputSplit>> getInputSplits(List<FileStatus> eligibleFiles) throws IOException {_		if (eligibleFiles.isEmpty()) {_			return new HashMap<>()__		}__		FileInputSplit[] inputSplits = format.createInputSplits(readerParallelism)___		Map<Long, List<FileInputSplit>> splitsPerFile = new HashMap<>()__		for (FileInputSplit split: inputSplits) {_			for (FileStatus file: eligibleFiles) {_				if (file.getPath().equals(split.getPath())) {_					Long modTime = file.getModificationTime()___					List<FileInputSplit> splitsToForward = splitsPerFile.get(modTime)__					if (splitsToForward == null) {_						splitsToForward = new LinkedList<>()__						splitsPerFile.put(modTime, splitsToForward)__					}_					splitsToForward.add(split)__					break__				}_			}_		}_		return splitsPerFile__	};creates,the,input,splits,for,the,path,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,those,tasks,are,going,to,read,their,contents,for,further,processing,splits,belonging,to,files,in,the,code,eligible,files,list,are,the,ones,that,are,shipped,for,further,processing,param,eligible,files,the,files,to,process;private,map,long,list,file,input,split,get,input,splits,list,file,status,eligible,files,throws,ioexception,if,eligible,files,is,empty,return,new,hash,map,file,input,split,input,splits,format,create,input,splits,reader,parallelism,map,long,list,file,input,split,splits,per,file,new,hash,map,for,file,input,split,split,input,splits,for,file,status,file,eligible,files,if,file,get,path,equals,split,get,path,long,mod,time,file,get,modification,time,list,file,input,split,splits,to,forward,splits,per,file,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,linked,list,splits,per,file,put,mod,time,splits,to,forward,splits,to,forward,add,split,break,return,splits,per,file
ContinuousFileMonitoringFunction -> private Map<Long, List<FileInputSplit>> getInputSplits(List<FileStatus> eligibleFiles) throws IOException;1476089389;Creates the input splits for the path to be forwarded to the downstream tasks of the_{@link ContinuousFileReaderOperator}. Those tasks are going to read their contents for further_processing. Splits belonging to files in the {@code eligibleFiles} list are the ones_that are shipped for further processing._@param eligibleFiles The files to process.;private Map<Long, List<FileInputSplit>> getInputSplits(List<FileStatus> eligibleFiles) throws IOException {_		if (eligibleFiles.isEmpty()) {_			return new HashMap<>()__		}__		FileInputSplit[] inputSplits = format.createInputSplits(readerParallelism)___		Map<Long, List<FileInputSplit>> splitsPerFile = new HashMap<>()__		for (FileInputSplit split: inputSplits) {_			for (FileStatus file: eligibleFiles) {_				if (file.getPath().equals(split.getPath())) {_					Long modTime = file.getModificationTime()___					List<FileInputSplit> splitsToForward = splitsPerFile.get(modTime)__					if (splitsToForward == null) {_						splitsToForward = new LinkedList<>()__						splitsPerFile.put(modTime, splitsToForward)__					}_					splitsToForward.add(split)__					break__				}_			}_		}_		return splitsPerFile__	};creates,the,input,splits,for,the,path,to,be,forwarded,to,the,downstream,tasks,of,the,link,continuous,file,reader,operator,those,tasks,are,going,to,read,their,contents,for,further,processing,splits,belonging,to,files,in,the,code,eligible,files,list,are,the,ones,that,are,shipped,for,further,processing,param,eligible,files,the,files,to,process;private,map,long,list,file,input,split,get,input,splits,list,file,status,eligible,files,throws,ioexception,if,eligible,files,is,empty,return,new,hash,map,file,input,split,input,splits,format,create,input,splits,reader,parallelism,map,long,list,file,input,split,splits,per,file,new,hash,map,for,file,input,split,split,input,splits,for,file,status,file,eligible,files,if,file,get,path,equals,split,get,path,long,mod,time,file,get,modification,time,list,file,input,split,splits,to,forward,splits,per,file,get,mod,time,if,splits,to,forward,null,splits,to,forward,new,linked,list,splits,per,file,put,mod,time,splits,to,forward,splits,to,forward,add,split,break,return,splits,per,file
ContinuousFileMonitoringFunction -> private List<FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException;1465920682;Returns the files that have data to be processed. This method returns the_Paths to the aforementioned files. It is up to the {@link #processSplit(FileInputSplit, SourceContext)}_method to decide which parts of the file to be processed, and forward them downstream.;private List<FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException {_		List<FileStatus> files = new ArrayList<>()___		FileStatus[] statuses = fileSystem.listStatus(new Path(path))__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__		} else {_			_			for (FileStatus status : statuses) {_				Path filePath = status.getPath()__				long modificationTime = status.getModificationTime()__				if (!shouldIgnore(filePath, modificationTime)) {_					files.add(status)__				}_			}_		}_		return files__	};returns,the,files,that,have,data,to,be,processed,this,method,returns,the,paths,to,the,aforementioned,files,it,is,up,to,the,link,process,split,file,input,split,source,context,method,to,decide,which,parts,of,the,file,to,be,processed,and,forward,them,downstream;private,list,file,status,list,eligible,files,file,system,file,system,throws,ioexception,list,file,status,files,new,array,list,file,status,statuses,file,system,list,status,new,path,path,if,statuses,null,log,warn,path,does,not,exist,path,else,for,file,status,status,statuses,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,add,status,return,files
ContinuousFileMonitoringFunction -> private List<FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException;1467290786;Returns the files that have data to be processed. This method returns the_Paths to the aforementioned files. It is up to the {@link #processSplit(FileInputSplit, SourceContext)}_method to decide which parts of the file to be processed, and forward them downstream.;private List<FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException {_		List<FileStatus> files = new ArrayList<>()___		FileStatus[] statuses = fileSystem.listStatus(new Path(path))__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__		} else {_			_			for (FileStatus status : statuses) {_				Path filePath = status.getPath()__				long modificationTime = status.getModificationTime()__				if (!shouldIgnore(filePath, modificationTime)) {_					files.add(status)__				}_			}_		}_		return files__	};returns,the,files,that,have,data,to,be,processed,this,method,returns,the,paths,to,the,aforementioned,files,it,is,up,to,the,link,process,split,file,input,split,source,context,method,to,decide,which,parts,of,the,file,to,be,processed,and,forward,them,downstream;private,list,file,status,list,eligible,files,file,system,file,system,throws,ioexception,list,file,status,files,new,array,list,file,status,statuses,file,system,list,status,new,path,path,if,statuses,null,log,warn,path,does,not,exist,path,else,for,file,status,status,statuses,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,add,status,return,files
ContinuousFileMonitoringFunction -> private List<FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException;1472134098;Returns the files that have data to be processed. This method returns the_Paths to the aforementioned files. It is up to the {@link #processSplit(FileInputSplit, SourceContext)}_method to decide which parts of the file to be processed, and forward them downstream.;private List<FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException {_		List<FileStatus> files = new ArrayList<>()___		FileStatus[] statuses = fileSystem.listStatus(new Path(path))__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__		} else {_			_			for (FileStatus status : statuses) {_				Path filePath = status.getPath()__				long modificationTime = status.getModificationTime()__				if (!shouldIgnore(filePath, modificationTime)) {_					files.add(status)__				}_			}_		}_		return files__	};returns,the,files,that,have,data,to,be,processed,this,method,returns,the,paths,to,the,aforementioned,files,it,is,up,to,the,link,process,split,file,input,split,source,context,method,to,decide,which,parts,of,the,file,to,be,processed,and,forward,them,downstream;private,list,file,status,list,eligible,files,file,system,file,system,throws,ioexception,list,file,status,files,new,array,list,file,status,statuses,file,system,list,status,new,path,path,if,statuses,null,log,warn,path,does,not,exist,path,else,for,file,status,status,statuses,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,add,status,return,files
ContinuousFileMonitoringFunction -> private List<FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException;1476089389;Returns the files that have data to be processed. This method returns the_Paths to the aforementioned files. It is up to the {@link #processSplit(FileInputSplit, SourceContext)}_method to decide which parts of the file to be processed, and forward them downstream.;private List<FileStatus> listEligibleFiles(FileSystem fileSystem) throws IOException {__		final FileStatus[] statuses__		try {_			statuses = fileSystem.listStatus(new Path(path))__		} catch (IOException e) {_			_			_			return Collections.emptyList()__		}__		if (statuses == null) {_			LOG.warn("Path does not exist: {}", path)__			return Collections.emptyList()__		} else {_			List<FileStatus> files = new ArrayList<>()__			_			for (FileStatus status : statuses) {_				Path filePath = status.getPath()__				long modificationTime = status.getModificationTime()__				if (!shouldIgnore(filePath, modificationTime)) {_					files.add(status)__				}_			}_			return files__		}_	};returns,the,files,that,have,data,to,be,processed,this,method,returns,the,paths,to,the,aforementioned,files,it,is,up,to,the,link,process,split,file,input,split,source,context,method,to,decide,which,parts,of,the,file,to,be,processed,and,forward,them,downstream;private,list,file,status,list,eligible,files,file,system,file,system,throws,ioexception,final,file,status,statuses,try,statuses,file,system,list,status,new,path,path,catch,ioexception,e,return,collections,empty,list,if,statuses,null,log,warn,path,does,not,exist,path,return,collections,empty,list,else,list,file,status,files,new,array,list,for,file,status,status,statuses,path,file,path,status,get,path,long,modification,time,status,get,modification,time,if,should,ignore,file,path,modification,time,files,add,status,return,files
