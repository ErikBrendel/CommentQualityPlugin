# id;timestamp;commentText;codeText;commentWords;codeWords
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1445418103;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1455486690;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1474981121;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1478636079;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1478636134;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1484842591;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1493195810;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1493195810;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1493195810;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1495484544;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1516285456;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public void cleanup() throws IOException;1516285878;Cleans up all file resources held by this spilled sequence.__@throws IOException Thrown, if file channel closing or file deletion fail.;public void cleanup() throws IOException {_			fileChannel.close()__			if (!file.delete()) {_				throw new IOException("Cannot remove temp file for stream alignment writer")__			}_		};cleans,up,all,file,resources,held,by,this,spilled,sequence,throws,ioexception,thrown,if,file,channel,closing,or,file,deletion,fail;public,void,cleanup,throws,ioexception,file,channel,close,if,file,delete,throw,new,ioexception,cannot,remove,temp,file,for,stream,alignment,writer
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1445418103;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()__				_				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}_				_				buffer.flip()__			}_			_			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0__			_			_			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)__				_				int segPos = 0__				int bytesRemaining = length__				_				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}_					_					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}_				_				_				Buffer buf = new Buffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)__				_				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)__				_				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1455486690;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()__				_				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}_				_				buffer.flip()__			}_			_			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0__			_			_			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)__				_				int segPos = 0__				int bytesRemaining = length__				_				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}_					_					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}_				_				_				Buffer buf = new Buffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)__				_				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)__				_				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1474981121;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()__				_				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}_				_				buffer.flip()__			}_			_			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0__			_			_			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)__				_				int segPos = 0__				int bytesRemaining = length__				_				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}_					_					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}_				_				_				Buffer buf = new Buffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)__				_				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)__				_				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1478636079;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()__				_				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}_				_				buffer.flip()__			}_			_			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0__			_			_			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)__				_				int segPos = 0__				int bytesRemaining = length__				_				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}_					_					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}_				_				_				Buffer buf = new Buffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)__				_				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)__				_				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1478636134;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()__				_				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}_				_				buffer.flip()__			}_			_			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0__			_			_			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)__				_				int segPos = 0__				int bytesRemaining = length__				_				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}_					_					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}_				_				_				Buffer buf = new Buffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)__				_				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)__				_				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1484842591;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()__				_				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}_				_				buffer.flip()__			}_			_			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0__			_			_			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)__				_				int segPos = 0__				int bytesRemaining = length__				_				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}_					_					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}_				_				_				Buffer buf = new Buffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)__				_				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)__				_				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1493195810;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()__				_				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}_				_				buffer.flip()__			}_			_			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0__			_			_			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)__				_				int segPos = 0__				int bytesRemaining = length__				_				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}_					_					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}_				_				_				Buffer buf = new Buffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)__				_				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)__				_				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1493195810;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()___				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}__				buffer.flip()__			}__			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0____			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)___				int segPos = 0__				int bytesRemaining = length___				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}__					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}___				Buffer buf = new Buffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)___				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)___				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1493195810;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()___				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}__				buffer.flip()__			}__			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0____			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)___				int segPos = 0__				int bytesRemaining = length___				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}__					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}___				Buffer buf = new Buffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)___				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)___				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1495484544;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()___				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}__				buffer.flip()__			}__			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0___			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)___				int segPos = 0__				int bytesRemaining = length___				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}__					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}__				Buffer buf = new Buffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)___				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)___				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1516285456;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()___				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}__				buffer.flip()__			}__			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0___			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)___				int segPos = 0__				int bytesRemaining = length___				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}__					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}__				Buffer buf = new NetworkBuffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)___				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)___				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,network,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> SpilledBufferOrEventSequence -> public BufferOrEvent getNext() throws IOException;1516285878;Gets the next BufferOrEvent from the spilled sequence, or {@code null}, if the_sequence is exhausted.__@return The next BufferOrEvent from the spilled sequence, or {@code null} (end of sequence)._@throws IOException Thrown, if the reads failed, of if the byte stream is corrupt.;public BufferOrEvent getNext() throws IOException {_			if (buffer.remaining() < HEADER_LENGTH) {_				buffer.compact()___				while (buffer.position() < HEADER_LENGTH) {_					if (fileChannel.read(buffer) == -1) {_						if (buffer.position() == 0) {_							_							return null__						} else {_							throw new IOException("Found trailing incomplete buffer or event")__						}_					}_				}__				buffer.flip()__			}__			final int channel = buffer.getInt()__			final int length = buffer.getInt()__			final boolean isBuffer = buffer.get() == 0___			if (isBuffer) {_				_				if (length > pageSize) {_					throw new IOException(String.format(_							"Spilled buffer (%d bytes) is larger than page size of (%d bytes)", length, pageSize))__				}__				MemorySegment seg = MemorySegmentFactory.allocateUnpooledSegment(pageSize)___				int segPos = 0__				int bytesRemaining = length___				while (true) {_					int toCopy = Math.min(buffer.remaining(), bytesRemaining)__					if (toCopy > 0) {_						seg.put(segPos, buffer, toCopy)__						segPos += toCopy__						bytesRemaining -= toCopy__					}__					if (bytesRemaining == 0) {_						break__					}_					else {_						buffer.clear()__						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete buffer")__						}_						buffer.flip()__					}_				}__				Buffer buf = new NetworkBuffer(seg, FreeingBufferRecycler.INSTANCE)__				buf.setSize(length)___				return new BufferOrEvent(buf, channel)__			}_			else {_				_				if (length > buffer.capacity() - HEADER_LENGTH) {_					throw new IOException("Event is too large")__				}__				if (buffer.remaining() < length) {_					buffer.compact()___					while (buffer.position() < length) {_						if (fileChannel.read(buffer) == -1) {_							throw new IOException("Found trailing incomplete event")__						}_					}__					buffer.flip()__				}__				int oldLimit = buffer.limit()__				buffer.limit(buffer.position() + length)__				AbstractEvent evt = EventSerializer.fromSerializedEvent(buffer, getClass().getClassLoader())__				buffer.limit(oldLimit)___				return new BufferOrEvent(evt, channel)__			}_		};gets,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,if,the,sequence,is,exhausted,return,the,next,buffer,or,event,from,the,spilled,sequence,or,code,null,end,of,sequence,throws,ioexception,thrown,if,the,reads,failed,of,if,the,byte,stream,is,corrupt;public,buffer,or,event,get,next,throws,ioexception,if,buffer,remaining,buffer,compact,while,buffer,position,if,file,channel,read,buffer,1,if,buffer,position,0,return,null,else,throw,new,ioexception,found,trailing,incomplete,buffer,or,event,buffer,flip,final,int,channel,buffer,get,int,final,int,length,buffer,get,int,final,boolean,is,buffer,buffer,get,0,if,is,buffer,if,length,page,size,throw,new,ioexception,string,format,spilled,buffer,d,bytes,is,larger,than,page,size,of,d,bytes,length,page,size,memory,segment,seg,memory,segment,factory,allocate,unpooled,segment,page,size,int,seg,pos,0,int,bytes,remaining,length,while,true,int,to,copy,math,min,buffer,remaining,bytes,remaining,if,to,copy,0,seg,put,seg,pos,buffer,to,copy,seg,pos,to,copy,bytes,remaining,to,copy,if,bytes,remaining,0,break,else,buffer,clear,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,buffer,buffer,flip,buffer,buf,new,network,buffer,seg,freeing,buffer,recycler,instance,buf,set,size,length,return,new,buffer,or,event,buf,channel,else,if,length,buffer,capacity,throw,new,ioexception,event,is,too,large,if,buffer,remaining,length,buffer,compact,while,buffer,position,length,if,file,channel,read,buffer,1,throw,new,ioexception,found,trailing,incomplete,event,buffer,flip,int,old,limit,buffer,limit,buffer,limit,buffer,position,length,abstract,event,evt,event,serializer,from,serialized,event,buffer,get,class,get,class,loader,buffer,limit,old,limit,return,new,buffer,or,event,evt,channel
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1445418103;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1455486690;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1474981121;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1478636079;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1478636134;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1484842591;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1493195810;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1493195810;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1493195810;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1495484544;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1516285456;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException;1516285878;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>The SpilledBufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOverWithNewBuffer() throws IOException {_		return rollOverInternal(true)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,the,spilled,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,with,new,buffer,throws,ioexception,return,roll,over,internal,true
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1445418103;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		hasWritten = true__		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getMemorySegment().wrap(0, buf.getSize())__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}_			_			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()__			_			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,has,written,true,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,memory,segment,wrap,0,buf,get,size,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1455486690;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		hasWritten = true__		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getMemorySegment().wrap(0, buf.getSize())__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}_			_			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()__			_			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,has,written,true,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,memory,segment,wrap,0,buf,get,size,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1474981121;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getMemorySegment().wrap(0, buf.getSize())__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__				_			}_			_			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,memory,segment,wrap,0,buf,get,size,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1478636079;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getMemorySegment().wrap(0, buf.getSize())__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,memory,segment,wrap,0,buf,get,size,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1478636134;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getMemorySegment().wrap(0, buf.getSize())__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,memory,segment,wrap,0,buf,get,size,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1484842591;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getMemorySegment().wrap(0, buf.getSize())__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,memory,segment,wrap,0,buf,get,size,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1493195810;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getMemorySegment().wrap(0, buf.getSize())__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,memory,segment,wrap,0,buf,get,size,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1493195810;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getMemorySegment().wrap(0, buf.getSize())__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,memory,segment,wrap,0,buf,get,size,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1493195810;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getMemorySegment().wrap(0, buf.getSize())__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,memory,segment,wrap,0,buf,get,size,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1495484544;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getMemorySegment().wrap(0, buf.getSize())__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,memory,segment,wrap,0,buf,get,size,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1516285456;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getNioBufferReadable()__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycle()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,nio,buffer,readable,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle
BufferSpiller -> public void add(BufferOrEvent boe) throws IOException;1516285878;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getNioBufferReadable()__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycleBuffer()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,nio,buffer,readable,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle,buffer
BufferSpiller -> public void close() throws IOException;1445418103;Cleans up the current spilling channel and file.__Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1455486690;Cleans up the current spilling channel and file.__Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1474981121;Cleans up the current spilling channel and file.__Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1478636079;Cleans up the current spilling channel and file.__Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1478636134;Cleans up the current spilling channel and file.__Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1484842591;Cleans up the current spilling channel and file.__Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1493195810;Cleans up the current spilling channel and file.__<p>Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,p,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1493195810;Cleans up the current spilling channel and file.__<p>Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,p,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1493195810;Cleans up the current spilling channel and file.__<p>Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,p,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1495484544;Cleans up the current spilling channel and file.__<p>Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,p,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1516285456;Cleans up the current spilling channel and file.__<p>Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,p,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> public void close() throws IOException;1516285878;Cleans up the current spilling channel and file.__<p>Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver()}.__@throws IOException Thrown if channel closing or file deletion fail.;public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,p,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> @Override 	public void add(BufferOrEvent boe) throws IOException;1519306056;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;@Override_	public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getNioBufferReadable()__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycleBuffer()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;override,public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,nio,buffer,readable,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle,buffer
BufferSpiller -> @Override 	public void add(BufferOrEvent boe) throws IOException;1535964396;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;@Override_	public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getNioBufferReadable()__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			sources[1] = contents__			currentChannel.write(sources)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycleBuffer()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;override,public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,nio,buffer,readable,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,sources,1,contents,current,channel,write,sources,finally,if,boe,is,buffer,boe,get,buffer,recycle,buffer
BufferSpiller -> @Override 	public void add(BufferOrEvent boe) throws IOException;1539101596;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;@Override_	public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getNioBufferReadable()__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			FileUtils.writeCompletely(currentChannel, headBuffer)__			FileUtils.writeCompletely(currentChannel, contents)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycleBuffer()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;override,public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,nio,buffer,readable,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,file,utils,write,completely,current,channel,head,buffer,file,utils,write,completely,current,channel,contents,finally,if,boe,is,buffer,boe,get,buffer,recycle,buffer
BufferSpiller -> @Override 	public void add(BufferOrEvent boe) throws IOException;1546180287;Adds a buffer or event to the sequence of spilled buffers and events.__@param boe The buffer or event to add and spill._@throws IOException Thrown, if the buffer of event could not be spilled.;@Override_	public void add(BufferOrEvent boe) throws IOException {_		try {_			ByteBuffer contents__			if (boe.isBuffer()) {_				Buffer buf = boe.getBuffer()__				contents = buf.getNioBufferReadable()__			}_			else {_				contents = EventSerializer.toSerializedEvent(boe.getEvent())__			}__			headBuffer.clear()__			headBuffer.putInt(boe.getChannelIndex())__			headBuffer.putInt(contents.remaining())__			headBuffer.put((byte) (boe.isBuffer() ? 0 : 1))__			headBuffer.flip()___			bytesWritten += (headBuffer.remaining() + contents.remaining())___			FileUtils.writeCompletely(currentChannel, headBuffer)__			FileUtils.writeCompletely(currentChannel, contents)__		}_		finally {_			if (boe.isBuffer()) {_				boe.getBuffer().recycleBuffer()__			}_		}_	};adds,a,buffer,or,event,to,the,sequence,of,spilled,buffers,and,events,param,boe,the,buffer,or,event,to,add,and,spill,throws,ioexception,thrown,if,the,buffer,of,event,could,not,be,spilled;override,public,void,add,buffer,or,event,boe,throws,ioexception,try,byte,buffer,contents,if,boe,is,buffer,buffer,buf,boe,get,buffer,contents,buf,get,nio,buffer,readable,else,contents,event,serializer,to,serialized,event,boe,get,event,head,buffer,clear,head,buffer,put,int,boe,get,channel,index,head,buffer,put,int,contents,remaining,head,buffer,put,byte,boe,is,buffer,0,1,head,buffer,flip,bytes,written,head,buffer,remaining,contents,remaining,file,utils,write,completely,current,channel,head,buffer,file,utils,write,completely,current,channel,contents,finally,if,boe,is,buffer,boe,get,buffer,recycle,buffer
BufferSpiller -> public long getBytesWritten();1474981121;Gets the number of bytes written in the current spill file._@return the number of bytes written in the current spill file;public long getBytesWritten() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;public,long,get,bytes,written,return,bytes,written
BufferSpiller -> public long getBytesWritten();1478636079;Gets the number of bytes written in the current spill file._@return the number of bytes written in the current spill file;public long getBytesWritten() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;public,long,get,bytes,written,return,bytes,written
BufferSpiller -> public long getBytesWritten();1478636134;Gets the number of bytes written in the current spill file._@return the number of bytes written in the current spill file;public long getBytesWritten() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;public,long,get,bytes,written,return,bytes,written
BufferSpiller -> public long getBytesWritten();1484842591;Gets the number of bytes written in the current spill file._@return the number of bytes written in the current spill file;public long getBytesWritten() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;public,long,get,bytes,written,return,bytes,written
BufferSpiller -> public long getBytesWritten();1493195810;Gets the number of bytes written in the current spill file._@return the number of bytes written in the current spill file;public long getBytesWritten() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;public,long,get,bytes,written,return,bytes,written
BufferSpiller -> public long getBytesWritten();1493195810;Gets the number of bytes written in the current spill file._@return the number of bytes written in the current spill file;public long getBytesWritten() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;public,long,get,bytes,written,return,bytes,written
BufferSpiller -> public long getBytesWritten();1493195810;Gets the number of bytes written in the current spill file._@return the number of bytes written in the current spill file;public long getBytesWritten() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;public,long,get,bytes,written,return,bytes,written
BufferSpiller -> public long getBytesWritten();1495484544;Gets the number of bytes written in the current spill file._@return the number of bytes written in the current spill file;public long getBytesWritten() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;public,long,get,bytes,written,return,bytes,written
BufferSpiller -> public long getBytesWritten();1516285456;Gets the number of bytes written in the current spill file._@return the number of bytes written in the current spill file;public long getBytesWritten() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;public,long,get,bytes,written,return,bytes,written
BufferSpiller -> public long getBytesWritten();1516285878;Gets the number of bytes written in the current spill file._@return the number of bytes written in the current spill file;public long getBytesWritten() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;public,long,get,bytes,written,return,bytes,written
BufferSpiller -> SpilledBufferOrEventSequence -> public long size() throws IOException;1478636134;Gets the size of this spilled sequence.;public long size() throws IOException {_			return size__		};gets,the,size,of,this,spilled,sequence;public,long,size,throws,ioexception,return,size
BufferSpiller -> SpilledBufferOrEventSequence -> public long size() throws IOException;1484842591;Gets the size of this spilled sequence.;public long size() throws IOException {_			return size__		};gets,the,size,of,this,spilled,sequence;public,long,size,throws,ioexception,return,size
BufferSpiller -> SpilledBufferOrEventSequence -> public long size() throws IOException;1493195810;Gets the size of this spilled sequence.;public long size() throws IOException {_			return size__		};gets,the,size,of,this,spilled,sequence;public,long,size,throws,ioexception,return,size
BufferSpiller -> SpilledBufferOrEventSequence -> public long size() throws IOException;1493195810;Gets the size of this spilled sequence.;public long size() throws IOException {_			return size__		};gets,the,size,of,this,spilled,sequence;public,long,size,throws,ioexception,return,size
BufferSpiller -> SpilledBufferOrEventSequence -> public long size() throws IOException;1493195810;Gets the size of this spilled sequence.;public long size() throws IOException {_			return size__		};gets,the,size,of,this,spilled,sequence;public,long,size,throws,ioexception,return,size
BufferSpiller -> SpilledBufferOrEventSequence -> public long size() throws IOException;1495484544;Gets the size of this spilled sequence.;public long size() throws IOException {_			return size__		};gets,the,size,of,this,spilled,sequence;public,long,size,throws,ioexception,return,size
BufferSpiller -> SpilledBufferOrEventSequence -> public long size() throws IOException;1516285456;Gets the size of this spilled sequence.;public long size() throws IOException {_			return size__		};gets,the,size,of,this,spilled,sequence;public,long,size,throws,ioexception,return,size
BufferSpiller -> SpilledBufferOrEventSequence -> public long size() throws IOException;1516285878;Gets the size of this spilled sequence.;public long size() throws IOException {_			return size__		};gets,the,size,of,this,spilled,sequence;public,long,size,throws,ioexception,return,size
BufferSpiller -> @Override 	public BufferOrEventSequence rollOverWithoutReusingResources() throws IOException;1519306056;The BufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;@Override_	public BufferOrEventSequence rollOverWithoutReusingResources() throws IOException {_		return rollOver(true)__	};the,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;override,public,buffer,or,event,sequence,roll,over,without,reusing,resources,throws,ioexception,return,roll,over,true
BufferSpiller -> @Override 	public BufferOrEventSequence rollOverWithoutReusingResources() throws IOException;1535964396;The BufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;@Override_	public BufferOrEventSequence rollOverWithoutReusingResources() throws IOException {_		return rollOver(true)__	};the,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;override,public,buffer,or,event,sequence,roll,over,without,reusing,resources,throws,ioexception,return,roll,over,true
BufferSpiller -> @Override 	public BufferOrEventSequence rollOverWithoutReusingResources() throws IOException;1539101596;The BufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;@Override_	public BufferOrEventSequence rollOverWithoutReusingResources() throws IOException {_		return rollOver(true)__	};the,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;override,public,buffer,or,event,sequence,roll,over,without,reusing,resources,throws,ioexception,return,roll,over,true
BufferSpiller -> @Override 	public BufferOrEventSequence rollOverWithoutReusingResources() throws IOException;1546180287;The BufferOrEventSequence returned by this method is safe for concurrent consumption with_any previously returned sequence.__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;@Override_	public BufferOrEventSequence rollOverWithoutReusingResources() throws IOException {_		return rollOver(true)__	};the,buffer,or,event,sequence,returned,by,this,method,is,safe,for,concurrent,consumption,with,any,previously,returned,sequence,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;override,public,buffer,or,event,sequence,roll,over,without,reusing,resources,throws,ioexception,return,roll,over,true
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1478636134;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1484842591;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1493195810;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1493195810;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1493195810;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1495484544;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1516285456;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1516285878;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1519306056;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1535964396;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1539101596;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) 				throws IOException;1546180287;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize)_				throws IOException {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__			this.size = fileChannel.size()__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,throws,ioexception,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size,this,size,file,channel,size
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1445418103;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1455486690;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1474981121;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1478636079;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1478636134;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1484842591;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1493195810;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1493195810;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1493195810;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1495484544;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1516285456;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> public void open();1516285878;Initializes the sequence for reading._This method needs to be called before the first call to {@link #getNext()}. Otherwise_the results of {@link #getNext()} are not predictable.;public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};initializes,the,sequence,for,reading,this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize);1445418103;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize);1455486690;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize);1474981121;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size
BufferSpiller -> SpilledBufferOrEventSequence -> SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize);1478636079;Create a reader that reads a sequence of spilled buffers and events.__@param file The file with the data._@param fileChannel The file channel to read the data from._@param buffer The buffer used for bulk reading._@param pageSize The page size to use for the created memory segments.;SpilledBufferOrEventSequence(File file, FileChannel fileChannel, ByteBuffer buffer, int pageSize) {_			this.file = file__			this.fileChannel = fileChannel__			this.buffer = buffer__			this.pageSize = pageSize__		};create,a,reader,that,reads,a,sequence,of,spilled,buffers,and,events,param,file,the,file,with,the,data,param,file,channel,the,file,channel,to,read,the,data,from,param,buffer,the,buffer,used,for,bulk,reading,param,page,size,the,page,size,to,use,for,the,created,memory,segments;spilled,buffer,or,event,sequence,file,file,file,channel,file,channel,byte,buffer,buffer,int,page,size,this,file,file,this,file,channel,file,channel,this,buffer,buffer,this,page,size,page,size
BufferSpiller -> @Override 	public long getBytesBlocked();1519306056;Gets the number of bytes written in the current spill file.__@return the number of bytes written in the current spill file;@Override_	public long getBytesBlocked() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;override,public,long,get,bytes,blocked,return,bytes,written
BufferSpiller -> @Override 	public long getBytesBlocked();1535964396;Gets the number of bytes written in the current spill file.__@return the number of bytes written in the current spill file;@Override_	public long getBytesBlocked() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;override,public,long,get,bytes,blocked,return,bytes,written
BufferSpiller -> @Override 	public long getBytesBlocked();1539101596;Gets the number of bytes written in the current spill file.__@return the number of bytes written in the current spill file;@Override_	public long getBytesBlocked() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;override,public,long,get,bytes,blocked,return,bytes,written
BufferSpiller -> @Override 	public long getBytesBlocked();1546180287;Gets the number of bytes written in the current spill file.__@return the number of bytes written in the current spill file;@Override_	public long getBytesBlocked() {_		return bytesWritten__	};gets,the,number,of,bytes,written,in,the,current,spill,file,return,the,number,of,bytes,written,in,the,current,spill,file;override,public,long,get,bytes,blocked,return,bytes,written
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1445418103;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize__		_		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.sources = new ByteBuffer[] { this.headBuffer, null }__		_		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]__		_		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'__		_		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1455486690;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize__		_		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.sources = new ByteBuffer[] { this.headBuffer, null }__		_		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]__		_		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'__		_		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1474981121;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize__		_		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.sources = new ByteBuffer[] { this.headBuffer, null }__		_		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]__		_		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'__		_		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1478636079;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize__		_		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.sources = new ByteBuffer[] { this.headBuffer, null }__		_		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]__		_		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'__		_		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1478636134;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize__		_		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.sources = new ByteBuffer[] { this.headBuffer, null }__		_		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]__		_		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'__		_		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1484842591;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize__		_		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.sources = new ByteBuffer[] { this.headBuffer, null }__		_		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]__		_		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'__		_		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1493195810;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize__		_		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)__		_		this.sources = new ByteBuffer[] { this.headBuffer, null }__		_		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]__		_		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'__		_		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1493195810;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize___		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.sources = new ByteBuffer[] { this.headBuffer, null }___		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]___		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'___		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1493195810;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize___		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.sources = new ByteBuffer[] { this.headBuffer, null }___		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]___		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'___		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1495484544;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize___		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.sources = new ByteBuffer[] { this.headBuffer, null }___		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]___		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'___		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1516285456;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize___		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.sources = new ByteBuffer[] { this.headBuffer, null }___		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]___		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'___		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1516285878;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize___		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.sources = new ByteBuffer[] { this.headBuffer, null }___		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]___		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'___		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1519306056;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize___		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.sources = new ByteBuffer[] { this.headBuffer, null }___		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]___		byte[] rndBytes = new byte[32]__		new Random().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'___		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,new,random,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1535964396;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize___		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.sources = new ByteBuffer[] { this.headBuffer, null }___		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]___		byte[] rndBytes = new byte[32]__		ThreadLocalRandom.current().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'___		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,this,sources,new,byte,buffer,this,head,buffer,null,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,thread,local,random,current,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1539101596;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to teh temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize___		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)___		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]___		byte[] rndBytes = new byte[32]__		ThreadLocalRandom.current().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'___		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,teh,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,thread,local,random,current,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public BufferSpiller(IOManager ioManager, int pageSize) throws IOException;1546180287;Creates a new buffer spiller, spilling to one of the I/O manager's temp directories.__@param ioManager The I/O manager for access to the temp directories._@param pageSize The page size used to re-create spilled buffers._@throws IOException Thrown if the temp files for spilling cannot be initialized.;public BufferSpiller(IOManager ioManager, int pageSize) throws IOException {_		this.pageSize = pageSize___		this.readBuffer = ByteBuffer.allocateDirect(READ_BUFFER_SIZE)__		this.readBuffer.order(ByteOrder.LITTLE_ENDIAN)___		this.headBuffer = ByteBuffer.allocateDirect(16)__		this.headBuffer.order(ByteOrder.LITTLE_ENDIAN)___		File[] tempDirs = ioManager.getSpillingDirectories()__		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length]___		byte[] rndBytes = new byte[32]__		ThreadLocalRandom.current().nextBytes(rndBytes)__		this.spillFilePrefix = StringUtils.byteToHexString(rndBytes) + '.'___		_		createSpillingChannel()__	};creates,a,new,buffer,spiller,spilling,to,one,of,the,i,o,manager,s,temp,directories,param,io,manager,the,i,o,manager,for,access,to,the,temp,directories,param,page,size,the,page,size,used,to,re,create,spilled,buffers,throws,ioexception,thrown,if,the,temp,files,for,spilling,cannot,be,initialized;public,buffer,spiller,iomanager,io,manager,int,page,size,throws,ioexception,this,page,size,page,size,this,read,buffer,byte,buffer,allocate,direct,this,read,buffer,order,byte,order,this,head,buffer,byte,buffer,allocate,direct,16,this,head,buffer,order,byte,order,file,temp,dirs,io,manager,get,spilling,directories,this,temp,dir,temp,dirs,get,and,increment,temp,dirs,length,byte,rnd,bytes,new,byte,32,thread,local,random,current,next,bytes,rnd,bytes,this,spill,file,prefix,string,utils,byte,to,hex,string,rnd,bytes,create,spilling,channel
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1445418103;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1455486690;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1474981121;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1478636079;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1478636134;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1484842591;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1493195810;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1493195810;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1493195810;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1495484544;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1516285456;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> public SpilledBufferOrEventSequence rollOver() throws IOException;1516285878;Starts a new sequence of spilled buffers and event and returns the current sequence of spilled buffers_for reading. This method returns {@code null}, if nothing was added since the creation of the spiller, or the_last call to this method.__<p>NOTE: The SpilledBufferOrEventSequences created by this method all reuse the same_reading memory (to reduce overhead) and can consequently not be read concurrently with each other._To create a sequence that can be read concurrently with the previous SpilledBufferOrEventSequence, use the_{@link #rollOverWithNewBuffer()} method.</p>__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;public SpilledBufferOrEventSequence rollOver() throws IOException {_		return rollOverInternal(false)__	};starts,a,new,sequence,of,spilled,buffers,and,event,and,returns,the,current,sequence,of,spilled,buffers,for,reading,this,method,returns,code,null,if,nothing,was,added,since,the,creation,of,the,spiller,or,the,last,call,to,this,method,p,note,the,spilled,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,spilled,buffer,or,event,sequence,use,the,link,roll,over,with,new,buffer,method,p,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;public,spilled,buffer,or,event,sequence,roll,over,throws,ioexception,return,roll,over,internal,false
BufferSpiller -> SpilledBufferOrEventSequence -> @Override 		public void open();1519306056;This method needs to be called before the first call to {@link #getNext()}._Otherwise the results of {@link #getNext()} are not predictable.;@Override_		public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;override,public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> @Override 		public void open();1535964396;This method needs to be called before the first call to {@link #getNext()}._Otherwise the results of {@link #getNext()} are not predictable.;@Override_		public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;override,public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> @Override 		public void open();1539101596;This method needs to be called before the first call to {@link #getNext()}._Otherwise the results of {@link #getNext()} are not predictable.;@Override_		public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;override,public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> SpilledBufferOrEventSequence -> @Override 		public void open();1546180287;This method needs to be called before the first call to {@link #getNext()}._Otherwise the results of {@link #getNext()} are not predictable.;@Override_		public void open() {_			if (!opened) {_				opened = true__				buffer.position(0)__				buffer.limit(0)__			}_		};this,method,needs,to,be,called,before,the,first,call,to,link,get,next,otherwise,the,results,of,link,get,next,are,not,predictable;override,public,void,open,if,opened,opened,true,buffer,position,0,buffer,limit,0
BufferSpiller -> @Override 	public BufferOrEventSequence rollOverReusingResources() throws IOException;1519306056;NOTE: The BufferOrEventSequences created by this method all reuse the same reading memory_(to reduce overhead) and can consequently not be read concurrently with each other.__<p>To create a sequence that can be read concurrently with the previous BufferOrEventSequence,_use the {@link #rollOverWithoutReusingResources()} ()} method.__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;@Override_	public BufferOrEventSequence rollOverReusingResources() throws IOException {_		return rollOver(false)__	};note,the,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,p,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,buffer,or,event,sequence,use,the,link,roll,over,without,reusing,resources,method,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;override,public,buffer,or,event,sequence,roll,over,reusing,resources,throws,ioexception,return,roll,over,false
BufferSpiller -> @Override 	public BufferOrEventSequence rollOverReusingResources() throws IOException;1535964396;NOTE: The BufferOrEventSequences created by this method all reuse the same reading memory_(to reduce overhead) and can consequently not be read concurrently with each other.__<p>To create a sequence that can be read concurrently with the previous BufferOrEventSequence,_use the {@link #rollOverWithoutReusingResources()} ()} method.__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;@Override_	public BufferOrEventSequence rollOverReusingResources() throws IOException {_		return rollOver(false)__	};note,the,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,p,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,buffer,or,event,sequence,use,the,link,roll,over,without,reusing,resources,method,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;override,public,buffer,or,event,sequence,roll,over,reusing,resources,throws,ioexception,return,roll,over,false
BufferSpiller -> @Override 	public BufferOrEventSequence rollOverReusingResources() throws IOException;1539101596;NOTE: The BufferOrEventSequences created by this method all reuse the same reading memory_(to reduce overhead) and can consequently not be read concurrently with each other.__<p>To create a sequence that can be read concurrently with the previous BufferOrEventSequence,_use the {@link #rollOverWithoutReusingResources()} ()} method.__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;@Override_	public BufferOrEventSequence rollOverReusingResources() throws IOException {_		return rollOver(false)__	};note,the,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,p,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,buffer,or,event,sequence,use,the,link,roll,over,without,reusing,resources,method,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;override,public,buffer,or,event,sequence,roll,over,reusing,resources,throws,ioexception,return,roll,over,false
BufferSpiller -> @Override 	public BufferOrEventSequence rollOverReusingResources() throws IOException;1546180287;NOTE: The BufferOrEventSequences created by this method all reuse the same reading memory_(to reduce overhead) and can consequently not be read concurrently with each other.__<p>To create a sequence that can be read concurrently with the previous BufferOrEventSequence,_use the {@link #rollOverWithoutReusingResources()} ()} method.__@return The readable sequence of spilled buffers and events, or 'null', if nothing was added._@throws IOException Thrown, if the readable sequence could not be created, or no new spill_file could be created.;@Override_	public BufferOrEventSequence rollOverReusingResources() throws IOException {_		return rollOver(false)__	};note,the,buffer,or,event,sequences,created,by,this,method,all,reuse,the,same,reading,memory,to,reduce,overhead,and,can,consequently,not,be,read,concurrently,with,each,other,p,to,create,a,sequence,that,can,be,read,concurrently,with,the,previous,buffer,or,event,sequence,use,the,link,roll,over,without,reusing,resources,method,return,the,readable,sequence,of,spilled,buffers,and,events,or,null,if,nothing,was,added,throws,ioexception,thrown,if,the,readable,sequence,could,not,be,created,or,no,new,spill,file,could,be,created;override,public,buffer,or,event,sequence,roll,over,reusing,resources,throws,ioexception,return,roll,over,false
BufferSpiller -> @Override 	public void close() throws IOException;1519306056;Cleans up the current spilling channel and file.__<p>Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver(boolean false)}.__@throws IOException Thrown if channel closing or file deletion fail.;@Override_	public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,p,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,boolean,false,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;override,public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> @Override 	public void close() throws IOException;1535964396;Cleans up the current spilling channel and file.__<p>Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver(boolean false)}.__@throws IOException Thrown if channel closing or file deletion fail.;@Override_	public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,p,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,boolean,false,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;override,public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> @Override 	public void close() throws IOException;1539101596;Cleans up the current spilling channel and file.__<p>Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver(boolean false)}.__@throws IOException Thrown if channel closing or file deletion fail.;@Override_	public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,p,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,boolean,false,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;override,public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
BufferSpiller -> @Override 	public void close() throws IOException;1546180287;Cleans up the current spilling channel and file.__<p>Does not clean up the SpilledBufferOrEventSequences generated by calls to_{@link #rollOver(boolean false)}.__@throws IOException Thrown if channel closing or file deletion fail.;@Override_	public void close() throws IOException {_		currentChannel.close()__		if (!currentSpillFile.delete()) {_			throw new IOException("Cannot delete spill file")__		}_	};cleans,up,the,current,spilling,channel,and,file,p,does,not,clean,up,the,spilled,buffer,or,event,sequences,generated,by,calls,to,link,roll,over,boolean,false,throws,ioexception,thrown,if,channel,closing,or,file,deletion,fail;override,public,void,close,throws,ioexception,current,channel,close,if,current,spill,file,delete,throw,new,ioexception,cannot,delete,spill,file
