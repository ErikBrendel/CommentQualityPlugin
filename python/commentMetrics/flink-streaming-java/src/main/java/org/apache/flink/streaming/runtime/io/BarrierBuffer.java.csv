# id;timestamp;commentText;codeText;commentWords;codeWords
BarrierBuffer -> private void releaseBlocks() throws IOException;1445418103;Releases the blocks on all channels. Makes sure the just written data_is the next to be consumed.;private void releaseBlocks() throws IOException {_		if (LOG.isDebugEnabled()) {_			LOG.debug("Releasing blocks")__		}__		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}_		numBarriersReceived = 0___		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			_			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				currentBuffered = bufferedNow__			}_		}_	};releases,the,blocks,on,all,channels,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,throws,ioexception,if,log,is,debug,enabled,log,debug,releasing,blocks,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,num,barriers,received,0,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,current,buffered,buffered,now
BarrierBuffer -> private void releaseBlocks() throws IOException;1455486690;Releases the blocks on all channels. Makes sure the just written data_is the next to be consumed.;private void releaseBlocks() throws IOException {_		if (LOG.isDebugEnabled()) {_			LOG.debug("Releasing blocks")__		}__		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}_		numBarriersReceived = 0___		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			_			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				currentBuffered = bufferedNow__			}_		}_	};releases,the,blocks,on,all,channels,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,throws,ioexception,if,log,is,debug,enabled,log,debug,releasing,blocks,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,num,barriers,received,0,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,current,buffered,buffered,now
BarrierBuffer -> private void releaseBlocks() throws IOException;1474981121;Releases the blocks on all channels. Makes sure the just written data_is the next to be consumed.;private void releaseBlocks() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}_		numBarriersReceived = 0___		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			_			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				currentBuffered = bufferedNow__			}_		}__		final long now = System.nanoTime()__		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = now - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,num,barriers,received,0,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,current,buffered,buffered,now,final,long,now,system,nano,time,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,now,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocks() throws IOException;1475766252;Releases the blocks on all channels. Makes sure the just written data_is the next to be consumed.;private void releaseBlocks() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}_		numBarriersReceived = 0___		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			_			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				currentBuffered = bufferedNow__			}_		}__		final long now = System.nanoTime()__		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = now - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,num,barriers,received,0,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,current,buffered,buffered,now,final,long,now,system,nano,time,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,now,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> public long getCurrentCheckpointId();1445418103;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1455486690;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1474981121;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1475766252;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1478636079;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1478636134;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1478636134;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1479400449;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1481290875;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1484842591;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1487762095;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1487871589;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1493195810;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1493195810;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1493195810;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1495484544;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1515519059;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1519039300;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1519306056;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1534154906;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public long getCurrentCheckpointId();1548679693;Gets the ID defining the current pending, or just completed, checkpoint.__@return The ID of the pending of completed checkpoint.;public long getCurrentCheckpointId() {_		return this.currentCheckpointId__	};gets,the,id,defining,the,current,pending,or,just,completed,checkpoint,return,the,id,of,the,pending,of,completed,checkpoint;public,long,get,current,checkpoint,id,return,this,current,checkpoint,id
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker) throws IOException;1519306056;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param bufferBlocker The buffer blocker to hold the buffers and events for channels with barrier.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker) throws IOException {_		this (inputGate, bufferBlocker, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,buffer,blocker,the,buffer,blocker,to,hold,the,buffers,and,events,for,channels,with,barrier,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,buffer,blocker,buffer,blocker,throws,ioexception,this,input,gate,buffer,blocker,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker) throws IOException;1534154906;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param bufferBlocker The buffer blocker to hold the buffers and events for channels with barrier.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker) throws IOException {_		this (inputGate, bufferBlocker, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,buffer,blocker,the,buffer,blocker,to,hold,the,buffers,and,events,for,channels,with,barrier,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,buffer,blocker,buffer,blocker,throws,ioexception,this,input,gate,buffer,blocker,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker) throws IOException;1548679693;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param bufferBlocker The buffer blocker to hold the buffers and events for channels with barrier.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker) throws IOException {_		this (inputGate, bufferBlocker, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,buffer,blocker,the,buffer,blocker,to,hold,the,buffers,and,events,for,channels,with,barrier,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,buffer,blocker,buffer,blocker,throws,ioexception,this,input,gate,buffer,blocker,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1445418103;@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this.inputGate = inputGate__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]__		_		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,input,gate,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1455486690;@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this.inputGate = inputGate__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]__		_		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,input,gate,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1474981121;@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this.inputGate = inputGate__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]__		_		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,input,gate,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1475766252;@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this.inputGate = inputGate__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]__		_		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,input,gate,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1478636079;@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this.inputGate = inputGate__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,input,gate,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1478636134;@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this.inputGate = inputGate__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,input,gate,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1478636134;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1479400449;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1481290875;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1484842591;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1487762095;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1487871589;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1493195810;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1493195810;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1493195810;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1495484544;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1515519059;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException;1519039300;Creates a new checkpoint stream aligner.__<p>There is no limit to how much data may be buffered during an alignment.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {_		this (inputGate, ioManager, -1)__	};creates,a,new,checkpoint,stream,aligner,p,there,is,no,limit,to,how,much,data,may,be,buffered,during,an,alignment,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,throws,ioexception,this,input,gate,io,manager,1
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker, long maxBufferedBytes) 			throws IOException;1519306056;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param bufferBlocker The buffer blocker to hold the buffers and events for channels with barrier._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker, long maxBufferedBytes)_			throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferBlocker = checkNotNull(bufferBlocker)__		this.queuedBuffered = new ArrayDeque<BufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,buffer,blocker,the,buffer,blocker,to,hold,the,buffers,and,events,for,channels,with,barrier,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,buffer,blocker,buffer,blocker,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,blocker,check,not,null,buffer,blocker,this,queued,buffered,new,array,deque,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker, long maxBufferedBytes) 			throws IOException;1534154906;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param bufferBlocker The buffer blocker to hold the buffers and events for channels with barrier._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker, long maxBufferedBytes)_			throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferBlocker = checkNotNull(bufferBlocker)__		this.queuedBuffered = new ArrayDeque<BufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,buffer,blocker,the,buffer,blocker,to,hold,the,buffers,and,events,for,channels,with,barrier,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,buffer,blocker,buffer,blocker,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,blocker,check,not,null,buffer,blocker,this,queued,buffered,new,array,deque,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker, long maxBufferedBytes) 			throws IOException;1548679693;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param bufferBlocker The buffer blocker to hold the buffers and events for channels with barrier._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, BufferBlocker bufferBlocker, long maxBufferedBytes)_			throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferBlocker = checkNotNull(bufferBlocker)__		this.queuedBuffered = new ArrayDeque<BufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,buffer,blocker,the,buffer,blocker,to,hold,the,buffers,and,events,for,channels,with,barrier,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,buffer,blocker,buffer,blocker,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,blocker,check,not,null,buffer,blocker,this,queued,buffered,new,array,deque,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1478636134;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1479400449;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1481290875;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1484842591;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1487762095;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1487871589;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1493195810;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1493195810;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1493195810;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1495484544;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1515519059;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException;1519039300;Creates a new checkpoint stream aligner.__<p>The aligner will allow only alignments that buffer up to the given number of bytes._When that number is exceeded, it will stop the alignment and notify the task that the_checkpoint has been cancelled.__@param inputGate The input gate to draw the buffers and events from._@param ioManager The I/O manager that gives access to the temp directories._@param maxBufferedBytes The maximum bytes to be buffered before the checkpoint aborts.__@throws IOException Thrown, when the spilling to temp files cannot be initialized.;public BarrierBuffer(InputGate inputGate, IOManager ioManager, long maxBufferedBytes) throws IOException {_		checkArgument(maxBufferedBytes == -1 || maxBufferedBytes > 0)___		this.inputGate = inputGate__		this.maxBufferedBytes = maxBufferedBytes__		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels()__		this.blockedChannels = new boolean[this.totalNumberOfInputChannels]___		this.bufferSpiller = new BufferSpiller(ioManager, inputGate.getPageSize())__		this.queuedBuffered = new ArrayDeque<BufferSpiller.SpilledBufferOrEventSequence>()__	};creates,a,new,checkpoint,stream,aligner,p,the,aligner,will,allow,only,alignments,that,buffer,up,to,the,given,number,of,bytes,when,that,number,is,exceeded,it,will,stop,the,alignment,and,notify,the,task,that,the,checkpoint,has,been,cancelled,param,input,gate,the,input,gate,to,draw,the,buffers,and,events,from,param,io,manager,the,i,o,manager,that,gives,access,to,the,temp,directories,param,max,buffered,bytes,the,maximum,bytes,to,be,buffered,before,the,checkpoint,aborts,throws,ioexception,thrown,when,the,spilling,to,temp,files,cannot,be,initialized;public,barrier,buffer,input,gate,input,gate,iomanager,io,manager,long,max,buffered,bytes,throws,ioexception,check,argument,max,buffered,bytes,1,max,buffered,bytes,0,this,input,gate,input,gate,this,max,buffered,bytes,max,buffered,bytes,this,total,number,of,input,channels,input,gate,get,number,of,input,channels,this,blocked,channels,new,boolean,this,total,number,of,input,channels,this,buffer,spiller,new,buffer,spiller,io,manager,input,gate,get,page,size,this,queued,buffered,new,array,deque,buffer,spiller,spilled,buffer,or,event,sequence
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1445418103;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true__			numBarriersReceived++__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint and input stream")__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,and,input,stream
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1455486690;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true__			numBarriersReceived++__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint and input stream")__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,and,input,stream
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1474981121;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true__			numBarriersReceived++__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint and input stream")__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,and,input,stream
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1475766252;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true__			numBarriersReceived++__			_			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint and input stream")__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,and,input,stream
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1478636079;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1478636134;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1478636134;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1479400449;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1481290875;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1484842591;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1487762095;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1487871589;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1493195810;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1493195810;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1493195810;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1495484544;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1515519059;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1519039300;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1519306056;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("Received barrier from channel " + channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1534154906;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("{}: Received barrier from channel {}.",_					inputGate.getOwningTaskName(),_					channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,input,gate,get,owning,task,name,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void onBarrier(int channelIndex) throws IOException;1548679693;Blocks the given channel index, from which a barrier has been received.__@param channelIndex The channel index to block.;private void onBarrier(int channelIndex) throws IOException {_		if (!blockedChannels[channelIndex]) {_			blockedChannels[channelIndex] = true___			numBarriersReceived++___			if (LOG.isDebugEnabled()) {_				LOG.debug("{}: Received barrier from channel {}.",_					inputGate.getOwningTaskName(),_					channelIndex)__			}_		}_		else {_			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint on input " + channelIndex)__		}_	};blocks,the,given,channel,index,from,which,a,barrier,has,been,received,param,channel,index,the,channel,index,to,block;private,void,on,barrier,int,channel,index,throws,ioexception,if,blocked,channels,channel,index,blocked,channels,channel,index,true,num,barriers,received,if,log,is,debug,enabled,log,debug,received,barrier,from,channel,input,gate,get,owning,task,name,channel,index,else,throw,new,ioexception,stream,corrupt,repeated,barrier,for,same,checkpoint,on,input,channel,index
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1478636079;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			_			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				currentBuffered = bufferedNow__			}_		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,current,buffered,buffered,now,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1478636134;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			_			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				currentBuffered = bufferedNow__			}_		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,current,buffered,buffered,now,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1478636134;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			_			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1479400449;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1481290875;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1484842591;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1487762095;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1487871589;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1493195810;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1493195810;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1493195810;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1495484544;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1515519059;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1519039300;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferSpiller.rollOver()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferSpiller.SpilledBufferOrEventSequence bufferedNow = bufferSpiller.rollOverWithNewBuffer()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,spiller,roll,over,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,spiller,spilled,buffer,or,event,sequence,buffered,now,buffer,spiller,roll,over,with,new,buffer,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1519306056;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("End of stream alignment, feeding buffered data back")___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferBlocker.rollOverReusingResources()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.")___			_			BufferOrEventSequence bufferedNow = bufferBlocker.rollOverWithoutReusingResources()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("Size of buffered data: {} bytes",_					currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,blocker,roll,over,reusing,resources,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,buffer,or,event,sequence,buffered,now,buffer,blocker,roll,over,without,reusing,resources,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1534154906;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("{}: End of stream alignment, feeding buffered data back.",_			inputGate.getOwningTaskName())___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferBlocker.rollOverReusingResources()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("{}: Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.",_				inputGate.getOwningTaskName())___			_			BufferOrEventSequence bufferedNow = bufferBlocker.rollOverWithoutReusingResources()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("{}: Size of buffered data: {} bytes",_				inputGate.getOwningTaskName(),_				currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,input,gate,get,owning,task,name,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,blocker,roll,over,reusing,resources,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,input,gate,get,owning,task,name,buffer,or,event,sequence,buffered,now,buffer,blocker,roll,over,without,reusing,resources,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,input,gate,get,owning,task,name,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private void releaseBlocksAndResetBarriers() throws IOException;1548679693;Releases the blocks on all channels and resets the barrier count._Makes sure the just written data is the next to be consumed.;private void releaseBlocksAndResetBarriers() throws IOException {_		LOG.debug("{}: End of stream alignment, feeding buffered data back.",_			inputGate.getOwningTaskName())___		for (int i = 0_ i < blockedChannels.length_ i++) {_			blockedChannels[i] = false__		}__		if (currentBuffered == null) {_			_			currentBuffered = bufferBlocker.rollOverReusingResources()__			if (currentBuffered != null) {_				currentBuffered.open()__			}_		}_		else {_			_			_			LOG.debug("{}: Checkpoint skipped via buffered data:" +_					"Pushing back current alignment buffers and feeding back new alignment data first.",_				inputGate.getOwningTaskName())___			_			BufferOrEventSequence bufferedNow = bufferBlocker.rollOverWithoutReusingResources()__			if (bufferedNow != null) {_				bufferedNow.open()__				queuedBuffered.addFirst(currentBuffered)__				numQueuedBytes += currentBuffered.size()__				currentBuffered = bufferedNow__			}_		}__		if (LOG.isDebugEnabled()) {_			LOG.debug("{}: Size of buffered data: {} bytes",_				inputGate.getOwningTaskName(),_				currentBuffered == null ? 0L : currentBuffered.size())__		}__		_		numBarriersReceived = 0___		if (startOfAlignmentTimestamp > 0) {_			latestAlignmentDurationNanos = System.nanoTime() - startOfAlignmentTimestamp__			startOfAlignmentTimestamp = 0__		}_	};releases,the,blocks,on,all,channels,and,resets,the,barrier,count,makes,sure,the,just,written,data,is,the,next,to,be,consumed;private,void,release,blocks,and,reset,barriers,throws,ioexception,log,debug,end,of,stream,alignment,feeding,buffered,data,back,input,gate,get,owning,task,name,for,int,i,0,i,blocked,channels,length,i,blocked,channels,i,false,if,current,buffered,null,current,buffered,buffer,blocker,roll,over,reusing,resources,if,current,buffered,null,current,buffered,open,else,log,debug,checkpoint,skipped,via,buffered,data,pushing,back,current,alignment,buffers,and,feeding,back,new,alignment,data,first,input,gate,get,owning,task,name,buffer,or,event,sequence,buffered,now,buffer,blocker,roll,over,without,reusing,resources,if,buffered,now,null,buffered,now,open,queued,buffered,add,first,current,buffered,num,queued,bytes,current,buffered,size,current,buffered,buffered,now,if,log,is,debug,enabled,log,debug,size,of,buffered,data,bytes,input,gate,get,owning,task,name,current,buffered,null,0l,current,buffered,size,num,barriers,received,0,if,start,of,alignment,timestamp,0,latest,alignment,duration,nanos,system,nano,time,start,of,alignment,timestamp,start,of,alignment,timestamp,0
BarrierBuffer -> private boolean isBlocked(int channelIndex);1445418103;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1455486690;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1474981121;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1475766252;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1478636079;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1478636134;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1478636134;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1479400449;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1481290875;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1484842591;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1487762095;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1487871589;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1493195810;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1493195810;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1493195810;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1495484544;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1515519059;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1519039300;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1519306056;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1534154906;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
BarrierBuffer -> private boolean isBlocked(int channelIndex);1548679693;Checks whether the channel with the given index is blocked.__@param channelIndex The channel index to check._@return True if the channel is blocked, false if not.;private boolean isBlocked(int channelIndex) {_		return blockedChannels[channelIndex]__	};checks,whether,the,channel,with,the,given,index,is,blocked,param,channel,index,the,channel,index,to,check,return,true,if,the,channel,is,blocked,false,if,not;private,boolean,is,blocked,int,channel,index,return,blocked,channels,channel,index
