# id;timestamp;commentText;codeText;commentWords;codeWords
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, ProcessingTimeService processingTimeService, 			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval);1477069384;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@link AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@link NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@link ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic, ProcessingTimeService processingTimeService,_			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(checkpointLock, output)__				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(processingTimeService, checkpointLock, output, watermarkInterval)__				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,link,automatic,watermark,context,li,li,link,time,characteristic,processing,time,link,non,timestamp,context,li,li,link,time,characteristic,event,time,link,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,processing,time,service,processing,time,service,object,checkpoint,lock,output,stream,record,out,output,long,watermark,interval,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,checkpoint,lock,output,break,case,ingestion,time,ctx,new,automatic,watermark,context,processing,time,service,checkpoint,lock,output,watermark,interval,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, ProcessingTimeService processingTimeService, 			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval);1477069385;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@link AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@link NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@link ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic, ProcessingTimeService processingTimeService,_			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(checkpointLock, output)__				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(processingTimeService, checkpointLock, output, watermarkInterval)__				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,link,automatic,watermark,context,li,li,link,time,characteristic,processing,time,link,non,timestamp,context,li,li,link,time,characteristic,event,time,link,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,processing,time,service,processing,time,service,object,checkpoint,lock,output,stream,record,out,output,long,watermark,interval,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,checkpoint,lock,output,break,case,ingestion,time,ctx,new,automatic,watermark,context,processing,time,service,checkpoint,lock,output,watermark,interval,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, ProcessingTimeService processingTimeService, 			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval);1477069385;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@link AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@link NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@link ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic, ProcessingTimeService processingTimeService,_			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(checkpointLock, output)__				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(processingTimeService, checkpointLock, output, watermarkInterval)__				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,link,automatic,watermark,context,li,li,link,time,characteristic,processing,time,link,non,timestamp,context,li,li,link,time,characteristic,event,time,link,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,processing,time,service,processing,time,service,object,checkpoint,lock,output,stream,record,out,output,long,watermark,interval,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,checkpoint,lock,output,break,case,ingestion,time,ctx,new,automatic,watermark,context,processing,time,service,checkpoint,lock,output,watermark,interval,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, 			ProcessingTimeService processingTimeService, 			Object checkpointLock, 			StreamStatusMaintainer streamStatusMaintainer, 			Output<StreamRecord<OUT>> output, 			long watermarkInterval, 			long idleTimeout);1487783998;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@link AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@link NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@link ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic,_			ProcessingTimeService processingTimeService,_			Object checkpointLock,_			StreamStatusMaintainer streamStatusMaintainer,_			Output<StreamRecord<OUT>> output,_			long watermarkInterval,_			long idleTimeout) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(_					output,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(_					output,_					watermarkInterval,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,link,automatic,watermark,context,li,li,link,time,characteristic,processing,time,link,non,timestamp,context,li,li,link,time,characteristic,event,time,link,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,processing,time,service,processing,time,service,object,checkpoint,lock,stream,status,maintainer,stream,status,maintainer,output,stream,record,out,output,long,watermark,interval,long,idle,timeout,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,output,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,ingestion,time,ctx,new,automatic,watermark,context,output,watermark,interval,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, 			ProcessingTimeService processingTimeService, 			Object checkpointLock, 			StreamStatusMaintainer streamStatusMaintainer, 			Output<StreamRecord<OUT>> output, 			long watermarkInterval, 			long idleTimeout);1487868265;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@code AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@code NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@code ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic,_			ProcessingTimeService processingTimeService,_			Object checkpointLock,_			StreamStatusMaintainer streamStatusMaintainer,_			Output<StreamRecord<OUT>> output,_			long watermarkInterval,_			long idleTimeout) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(_					output,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(_					output,_					watermarkInterval,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,code,automatic,watermark,context,li,li,link,time,characteristic,processing,time,code,non,timestamp,context,li,li,link,time,characteristic,event,time,code,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,processing,time,service,processing,time,service,object,checkpoint,lock,stream,status,maintainer,stream,status,maintainer,output,stream,record,out,output,long,watermark,interval,long,idle,timeout,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,output,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,ingestion,time,ctx,new,automatic,watermark,context,output,watermark,interval,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, 			ProcessingTimeService processingTimeService, 			Object checkpointLock, 			StreamStatusMaintainer streamStatusMaintainer, 			Output<StreamRecord<OUT>> output, 			long watermarkInterval, 			long idleTimeout);1493195810;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@code AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@code NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@code ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic,_			ProcessingTimeService processingTimeService,_			Object checkpointLock,_			StreamStatusMaintainer streamStatusMaintainer,_			Output<StreamRecord<OUT>> output,_			long watermarkInterval,_			long idleTimeout) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(_					output,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(_					output,_					watermarkInterval,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,code,automatic,watermark,context,li,li,link,time,characteristic,processing,time,code,non,timestamp,context,li,li,link,time,characteristic,event,time,code,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,processing,time,service,processing,time,service,object,checkpoint,lock,stream,status,maintainer,stream,status,maintainer,output,stream,record,out,output,long,watermark,interval,long,idle,timeout,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,output,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,ingestion,time,ctx,new,automatic,watermark,context,output,watermark,interval,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, 			ProcessingTimeService processingTimeService, 			Object checkpointLock, 			StreamStatusMaintainer streamStatusMaintainer, 			Output<StreamRecord<OUT>> output, 			long watermarkInterval, 			long idleTimeout);1493195810;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@code AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@code NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@code ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic,_			ProcessingTimeService processingTimeService,_			Object checkpointLock,_			StreamStatusMaintainer streamStatusMaintainer,_			Output<StreamRecord<OUT>> output,_			long watermarkInterval,_			long idleTimeout) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(_					output,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(_					output,_					watermarkInterval,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,code,automatic,watermark,context,li,li,link,time,characteristic,processing,time,code,non,timestamp,context,li,li,link,time,characteristic,event,time,code,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,processing,time,service,processing,time,service,object,checkpoint,lock,stream,status,maintainer,stream,status,maintainer,output,stream,record,out,output,long,watermark,interval,long,idle,timeout,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,output,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,ingestion,time,ctx,new,automatic,watermark,context,output,watermark,interval,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, 			ProcessingTimeService processingTimeService, 			Object checkpointLock, 			StreamStatusMaintainer streamStatusMaintainer, 			Output<StreamRecord<OUT>> output, 			long watermarkInterval, 			long idleTimeout);1493195810;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@code AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@code NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@code ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic,_			ProcessingTimeService processingTimeService,_			Object checkpointLock,_			StreamStatusMaintainer streamStatusMaintainer,_			Output<StreamRecord<OUT>> output,_			long watermarkInterval,_			long idleTimeout) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(_					output,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(_					output,_					watermarkInterval,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,code,automatic,watermark,context,li,li,link,time,characteristic,processing,time,code,non,timestamp,context,li,li,link,time,characteristic,event,time,code,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,processing,time,service,processing,time,service,object,checkpoint,lock,stream,status,maintainer,stream,status,maintainer,output,stream,record,out,output,long,watermark,interval,long,idle,timeout,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,output,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,ingestion,time,ctx,new,automatic,watermark,context,output,watermark,interval,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, 			ProcessingTimeService processingTimeService, 			Object checkpointLock, 			StreamStatusMaintainer streamStatusMaintainer, 			Output<StreamRecord<OUT>> output, 			long watermarkInterval, 			long idleTimeout);1495484544;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@code AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@code NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@code ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic,_			ProcessingTimeService processingTimeService,_			Object checkpointLock,_			StreamStatusMaintainer streamStatusMaintainer,_			Output<StreamRecord<OUT>> output,_			long watermarkInterval,_			long idleTimeout) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(_					output,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(_					output,_					watermarkInterval,_					processingTimeService,_					checkpointLock,_					streamStatusMaintainer,_					idleTimeout)___				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,code,automatic,watermark,context,li,li,link,time,characteristic,processing,time,code,non,timestamp,context,li,li,link,time,characteristic,event,time,code,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,processing,time,service,processing,time,service,object,checkpoint,lock,stream,status,maintainer,stream,status,maintainer,output,stream,record,out,output,long,watermark,interval,long,idle,timeout,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,output,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,ingestion,time,ctx,new,automatic,watermark,context,output,watermark,interval,processing,time,service,checkpoint,lock,stream,status,maintainer,idle,timeout,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;1487783998;Process and collect record with timestamp.;protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;process,and,collect,record,with,timestamp;protected,abstract,void,process,and,collect,with,timestamp,t,element,long,timestamp
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;1487868265;Process and collect record with timestamp.;protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;process,and,collect,record,with,timestamp;protected,abstract,void,process,and,collect,with,timestamp,t,element,long,timestamp
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;1493195810;Process and collect record with timestamp.;protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;process,and,collect,record,with,timestamp;protected,abstract,void,process,and,collect,with,timestamp,t,element,long,timestamp
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;1493195810;Process and collect record with timestamp.;protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;process,and,collect,record,with,timestamp;protected,abstract,void,process,and,collect,with,timestamp,t,element,long,timestamp
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;1493195810;Process and collect record with timestamp.;protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;process,and,collect,record,with,timestamp;protected,abstract,void,process,and,collect,with,timestamp,t,element,long,timestamp
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;1495484544;Process and collect record with timestamp.;protected abstract void processAndCollectWithTimestamp(T element, long timestamp)_;process,and,collect,record,with,timestamp;protected,abstract,void,process,and,collect,with,timestamp,t,element,long,timestamp
StreamSourceContexts -> WatermarkContext -> protected abstract boolean allowWatermark(Watermark mark)_;1487783998;Whether or not a watermark should be allowed;protected abstract boolean allowWatermark(Watermark mark)_;whether,or,not,a,watermark,should,be,allowed;protected,abstract,boolean,allow,watermark,watermark,mark
StreamSourceContexts -> WatermarkContext -> protected abstract boolean allowWatermark(Watermark mark)_;1487868265;Whether or not a watermark should be allowed;protected abstract boolean allowWatermark(Watermark mark)_;whether,or,not,a,watermark,should,be,allowed;protected,abstract,boolean,allow,watermark,watermark,mark
StreamSourceContexts -> WatermarkContext -> protected abstract boolean allowWatermark(Watermark mark)_;1493195810;Whether or not a watermark should be allowed;protected abstract boolean allowWatermark(Watermark mark)_;whether,or,not,a,watermark,should,be,allowed;protected,abstract,boolean,allow,watermark,watermark,mark
StreamSourceContexts -> WatermarkContext -> protected abstract boolean allowWatermark(Watermark mark)_;1493195810;Whether or not a watermark should be allowed.;protected abstract boolean allowWatermark(Watermark mark)_;whether,or,not,a,watermark,should,be,allowed;protected,abstract,boolean,allow,watermark,watermark,mark
StreamSourceContexts -> WatermarkContext -> protected abstract boolean allowWatermark(Watermark mark)_;1493195810;Whether or not a watermark should be allowed.;protected abstract boolean allowWatermark(Watermark mark)_;whether,or,not,a,watermark,should,be,allowed;protected,abstract,boolean,allow,watermark,watermark,mark
StreamSourceContexts -> WatermarkContext -> protected abstract boolean allowWatermark(Watermark mark)_;1495484544;Whether or not a watermark should be allowed.;protected abstract boolean allowWatermark(Watermark mark)_;whether,or,not,a,watermark,should,be,allowed;protected,abstract,boolean,allow,watermark,watermark,mark
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, TimeServiceProvider timeService, 			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval);1475688973;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li> {@link TimeCharacteristic#IngestionTime} = {@link AutomaticWatermarkContext}_<li> {@link TimeCharacteristic#ProcessingTime} = {@link NonTimestampContext}_<li> {@link TimeCharacteristic#EventTime} = {@link ManualWatermarkContext}_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic, TimeServiceProvider timeService,_			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(checkpointLock, output)__				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(timeService, checkpointLock, output, watermarkInterval)__				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,link,automatic,watermark,context,li,link,time,characteristic,processing,time,link,non,timestamp,context,li,link,time,characteristic,event,time,link,manual,watermark,context,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,time,service,provider,time,service,object,checkpoint,lock,output,stream,record,out,output,long,watermark,interval,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,checkpoint,lock,output,break,case,ingestion,time,ctx,new,automatic,watermark,context,time,service,checkpoint,lock,output,watermark,interval,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, TimeServiceProvider timeService, 			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval);1475688973;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@link AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@link NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@link ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic, TimeServiceProvider timeService,_			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(checkpointLock, output)__				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(timeService, checkpointLock, output, watermarkInterval)__				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,link,automatic,watermark,context,li,li,link,time,characteristic,processing,time,link,non,timestamp,context,li,li,link,time,characteristic,event,time,link,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,time,service,provider,time,service,object,checkpoint,lock,output,stream,record,out,output,long,watermark,interval,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,checkpoint,lock,output,break,case,ingestion,time,ctx,new,automatic,watermark,context,time,service,checkpoint,lock,output,watermark,interval,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext( 			TimeCharacteristic timeCharacteristic, TimeServiceProvider timeService, 			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval);1475688974;Depending on the {@link TimeCharacteristic}, this method will return the adequate_{@link org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext}. That is:_<ul>_<li>{@link TimeCharacteristic#IngestionTime} = {@link AutomaticWatermarkContext}</li>_<li>{@link TimeCharacteristic#ProcessingTime} = {@link NonTimestampContext}</li>_<li>{@link TimeCharacteristic#EventTime} = {@link ManualWatermarkContext}</li>_</ul>;public static <OUT> SourceFunction.SourceContext<OUT> getSourceContext(_			TimeCharacteristic timeCharacteristic, TimeServiceProvider timeService,_			Object checkpointLock, Output<StreamRecord<OUT>> output, long watermarkInterval) {__		final SourceFunction.SourceContext<OUT> ctx__		switch (timeCharacteristic) {_			case EventTime:_				ctx = new ManualWatermarkContext<>(checkpointLock, output)__				break__			case IngestionTime:_				ctx = new AutomaticWatermarkContext<>(timeService, checkpointLock, output, watermarkInterval)__				break__			case ProcessingTime:_				ctx = new NonTimestampContext<>(checkpointLock, output)__				break__			default:_				throw new IllegalArgumentException(String.valueOf(timeCharacteristic))__		}_		return ctx__	};depending,on,the,link,time,characteristic,this,method,will,return,the,adequate,link,org,apache,flink,streaming,api,functions,source,source,function,source,context,that,is,ul,li,link,time,characteristic,ingestion,time,link,automatic,watermark,context,li,li,link,time,characteristic,processing,time,link,non,timestamp,context,li,li,link,time,characteristic,event,time,link,manual,watermark,context,li,ul;public,static,out,source,function,source,context,out,get,source,context,time,characteristic,time,characteristic,time,service,provider,time,service,object,checkpoint,lock,output,stream,record,out,output,long,watermark,interval,final,source,function,source,context,out,ctx,switch,time,characteristic,case,event,time,ctx,new,manual,watermark,context,checkpoint,lock,output,break,case,ingestion,time,ctx,new,automatic,watermark,context,time,service,checkpoint,lock,output,watermark,interval,break,case,processing,time,ctx,new,non,timestamp,context,checkpoint,lock,output,break,default,throw,new,illegal,argument,exception,string,value,of,time,characteristic,return,ctx
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndEmitWatermark(Watermark mark)_;1487783998;Process and emit watermark. Only called if {@link WatermarkContext#allowWatermark(Watermark)} returns {@code true};protected abstract void processAndEmitWatermark(Watermark mark)_;process,and,emit,watermark,only,called,if,link,watermark,context,allow,watermark,watermark,returns,code,true;protected,abstract,void,process,and,emit,watermark,watermark,mark
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndEmitWatermark(Watermark mark)_;1487868265;Process and emit watermark. Only called if {@link WatermarkContext#allowWatermark(Watermark)} returns {@code true};protected abstract void processAndEmitWatermark(Watermark mark)_;process,and,emit,watermark,only,called,if,link,watermark,context,allow,watermark,watermark,returns,code,true;protected,abstract,void,process,and,emit,watermark,watermark,mark
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndEmitWatermark(Watermark mark)_;1493195810;Process and emit watermark. Only called if {@link WatermarkContext#allowWatermark(Watermark)} returns {@code true};protected abstract void processAndEmitWatermark(Watermark mark)_;process,and,emit,watermark,only,called,if,link,watermark,context,allow,watermark,watermark,returns,code,true;protected,abstract,void,process,and,emit,watermark,watermark,mark
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndEmitWatermark(Watermark mark)_;1493195810;Process and emit watermark. Only called if_{@link WatermarkContext#allowWatermark(Watermark)} returns {@code true}.;protected abstract void processAndEmitWatermark(Watermark mark)_;process,and,emit,watermark,only,called,if,link,watermark,context,allow,watermark,watermark,returns,code,true;protected,abstract,void,process,and,emit,watermark,watermark,mark
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndEmitWatermark(Watermark mark)_;1493195810;Process and emit watermark. Only called if_{@link WatermarkContext#allowWatermark(Watermark)} returns {@code true}.;protected abstract void processAndEmitWatermark(Watermark mark)_;process,and,emit,watermark,only,called,if,link,watermark,context,allow,watermark,watermark,returns,code,true;protected,abstract,void,process,and,emit,watermark,watermark,mark
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndEmitWatermark(Watermark mark)_;1495484544;Process and emit watermark. Only called if_{@link WatermarkContext#allowWatermark(Watermark)} returns {@code true}.;protected abstract void processAndEmitWatermark(Watermark mark)_;process,and,emit,watermark,only,called,if,link,watermark,context,allow,watermark,watermark,returns,code,true;protected,abstract,void,process,and,emit,watermark,watermark,mark
StreamSourceContexts -> AutomaticWatermarkContext -> @Override 		protected void processAndEmitWatermark(Watermark mark);1487783998;This will only be called if allowWatermark returned {@code true};@Override_		protected void processAndEmitWatermark(Watermark mark) {_			nextWatermarkTime = Long.MAX_VALUE__			output.emitWatermark(mark)___			_			_			_			final ScheduledFuture<?> nextWatermarkTimer = this.nextWatermarkTimer__			if (nextWatermarkTimer != null) {_				nextWatermarkTimer.cancel(true)__			}_		};this,will,only,be,called,if,allow,watermark,returned,code,true;override,protected,void,process,and,emit,watermark,watermark,mark,next,watermark,time,long,output,emit,watermark,mark,final,scheduled,future,next,watermark,timer,this,next,watermark,timer,if,next,watermark,timer,null,next,watermark,timer,cancel,true
StreamSourceContexts -> AutomaticWatermarkContext -> @Override 		protected void processAndEmitWatermark(Watermark mark);1487868265;This will only be called if allowWatermark returned {@code true};@Override_		protected void processAndEmitWatermark(Watermark mark) {_			nextWatermarkTime = Long.MAX_VALUE__			output.emitWatermark(mark)___			_			_			_			final ScheduledFuture<?> nextWatermarkTimer = this.nextWatermarkTimer__			if (nextWatermarkTimer != null) {_				nextWatermarkTimer.cancel(true)__			}_		};this,will,only,be,called,if,allow,watermark,returned,code,true;override,protected,void,process,and,emit,watermark,watermark,mark,next,watermark,time,long,output,emit,watermark,mark,final,scheduled,future,next,watermark,timer,this,next,watermark,timer,if,next,watermark,timer,null,next,watermark,timer,cancel,true
StreamSourceContexts -> AutomaticWatermarkContext -> @Override 		protected void processAndEmitWatermark(Watermark mark);1493195810;This will only be called if allowWatermark returned {@code true};@Override_		protected void processAndEmitWatermark(Watermark mark) {_			nextWatermarkTime = Long.MAX_VALUE__			output.emitWatermark(mark)___			_			_			_			final ScheduledFuture<?> nextWatermarkTimer = this.nextWatermarkTimer__			if (nextWatermarkTimer != null) {_				nextWatermarkTimer.cancel(true)__			}_		};this,will,only,be,called,if,allow,watermark,returned,code,true;override,protected,void,process,and,emit,watermark,watermark,mark,next,watermark,time,long,output,emit,watermark,mark,final,scheduled,future,next,watermark,timer,this,next,watermark,timer,if,next,watermark,timer,null,next,watermark,timer,cancel,true
StreamSourceContexts -> AutomaticWatermarkContext -> @Override 		protected void processAndEmitWatermark(Watermark mark);1493195810;This will only be called if allowWatermark returned {@code true}.;@Override_		protected void processAndEmitWatermark(Watermark mark) {_			nextWatermarkTime = Long.MAX_VALUE__			output.emitWatermark(mark)___			_			_			_			final ScheduledFuture<?> nextWatermarkTimer = this.nextWatermarkTimer__			if (nextWatermarkTimer != null) {_				nextWatermarkTimer.cancel(true)__			}_		};this,will,only,be,called,if,allow,watermark,returned,code,true;override,protected,void,process,and,emit,watermark,watermark,mark,next,watermark,time,long,output,emit,watermark,mark,final,scheduled,future,next,watermark,timer,this,next,watermark,timer,if,next,watermark,timer,null,next,watermark,timer,cancel,true
StreamSourceContexts -> AutomaticWatermarkContext -> @Override 		protected void processAndEmitWatermark(Watermark mark);1493195810;This will only be called if allowWatermark returned {@code true}.;@Override_		protected void processAndEmitWatermark(Watermark mark) {_			nextWatermarkTime = Long.MAX_VALUE__			output.emitWatermark(mark)___			_			_			_			final ScheduledFuture<?> nextWatermarkTimer = this.nextWatermarkTimer__			if (nextWatermarkTimer != null) {_				nextWatermarkTimer.cancel(true)__			}_		};this,will,only,be,called,if,allow,watermark,returned,code,true;override,protected,void,process,and,emit,watermark,watermark,mark,next,watermark,time,long,output,emit,watermark,mark,final,scheduled,future,next,watermark,timer,this,next,watermark,timer,if,next,watermark,timer,null,next,watermark,timer,cancel,true
StreamSourceContexts -> AutomaticWatermarkContext -> @Override 		protected void processAndEmitWatermark(Watermark mark);1495484544;This will only be called if allowWatermark returned {@code true}.;@Override_		protected void processAndEmitWatermark(Watermark mark) {_			nextWatermarkTime = Long.MAX_VALUE__			output.emitWatermark(mark)___			_			_			_			final ScheduledFuture<?> nextWatermarkTimer = this.nextWatermarkTimer__			if (nextWatermarkTimer != null) {_				nextWatermarkTimer.cancel(true)__			}_		};this,will,only,be,called,if,allow,watermark,returned,code,true;override,protected,void,process,and,emit,watermark,watermark,mark,next,watermark,time,long,output,emit,watermark,mark,final,scheduled,future,next,watermark,timer,this,next,watermark,timer,if,next,watermark,timer,null,next,watermark,timer,cancel,true
StreamSourceContexts -> WatermarkContext -> public WatermarkContext( 				final ProcessingTimeService timeService, 				final Object checkpointLock, 				final StreamStatusMaintainer streamStatusMaintainer, 				final long idleTimeout);1487783998;Create a watermark context.__@param timeService the time service to schedule idleness detection tasks_@param checkpointLock the checkpoint lock_@param streamStatusMaintainer the stream status maintainer to toggle and retrieve current status_@param idleTimeout (-1 if idleness checking is disabled);public WatermarkContext(_				final ProcessingTimeService timeService,_				final Object checkpointLock,_				final StreamStatusMaintainer streamStatusMaintainer,_				final long idleTimeout) {__			this.timeService = Preconditions.checkNotNull(timeService, "Time Service cannot be null.")__			this.checkpointLock = Preconditions.checkNotNull(checkpointLock, "Checkpoint Lock cannot be null.")__			this.streamStatusMaintainer = Preconditions.checkNotNull(streamStatusMaintainer, "Stream Status Maintainer cannot be null.")___			if (idleTimeout != -1) {_				Preconditions.checkArgument(idleTimeout >= 1, "The idle timeout cannot be smaller than 1 ms.")__			}_			this.idleTimeout = idleTimeout___			scheduleNextIdleDetectionTask()__		};create,a,watermark,context,param,time,service,the,time,service,to,schedule,idleness,detection,tasks,param,checkpoint,lock,the,checkpoint,lock,param,stream,status,maintainer,the,stream,status,maintainer,to,toggle,and,retrieve,current,status,param,idle,timeout,1,if,idleness,checking,is,disabled;public,watermark,context,final,processing,time,service,time,service,final,object,checkpoint,lock,final,stream,status,maintainer,stream,status,maintainer,final,long,idle,timeout,this,time,service,preconditions,check,not,null,time,service,time,service,cannot,be,null,this,checkpoint,lock,preconditions,check,not,null,checkpoint,lock,checkpoint,lock,cannot,be,null,this,stream,status,maintainer,preconditions,check,not,null,stream,status,maintainer,stream,status,maintainer,cannot,be,null,if,idle,timeout,1,preconditions,check,argument,idle,timeout,1,the,idle,timeout,cannot,be,smaller,than,1,ms,this,idle,timeout,idle,timeout,schedule,next,idle,detection,task
StreamSourceContexts -> WatermarkContext -> public WatermarkContext( 				final ProcessingTimeService timeService, 				final Object checkpointLock, 				final StreamStatusMaintainer streamStatusMaintainer, 				final long idleTimeout);1487868265;Create a watermark context.__@param timeService the time service to schedule idleness detection tasks_@param checkpointLock the checkpoint lock_@param streamStatusMaintainer the stream status maintainer to toggle and retrieve current status_@param idleTimeout (-1 if idleness checking is disabled);public WatermarkContext(_				final ProcessingTimeService timeService,_				final Object checkpointLock,_				final StreamStatusMaintainer streamStatusMaintainer,_				final long idleTimeout) {__			this.timeService = Preconditions.checkNotNull(timeService, "Time Service cannot be null.")__			this.checkpointLock = Preconditions.checkNotNull(checkpointLock, "Checkpoint Lock cannot be null.")__			this.streamStatusMaintainer = Preconditions.checkNotNull(streamStatusMaintainer, "Stream Status Maintainer cannot be null.")___			if (idleTimeout != -1) {_				Preconditions.checkArgument(idleTimeout >= 1, "The idle timeout cannot be smaller than 1 ms.")__			}_			this.idleTimeout = idleTimeout___			scheduleNextIdleDetectionTask()__		};create,a,watermark,context,param,time,service,the,time,service,to,schedule,idleness,detection,tasks,param,checkpoint,lock,the,checkpoint,lock,param,stream,status,maintainer,the,stream,status,maintainer,to,toggle,and,retrieve,current,status,param,idle,timeout,1,if,idleness,checking,is,disabled;public,watermark,context,final,processing,time,service,time,service,final,object,checkpoint,lock,final,stream,status,maintainer,stream,status,maintainer,final,long,idle,timeout,this,time,service,preconditions,check,not,null,time,service,time,service,cannot,be,null,this,checkpoint,lock,preconditions,check,not,null,checkpoint,lock,checkpoint,lock,cannot,be,null,this,stream,status,maintainer,preconditions,check,not,null,stream,status,maintainer,stream,status,maintainer,cannot,be,null,if,idle,timeout,1,preconditions,check,argument,idle,timeout,1,the,idle,timeout,cannot,be,smaller,than,1,ms,this,idle,timeout,idle,timeout,schedule,next,idle,detection,task
StreamSourceContexts -> WatermarkContext -> public WatermarkContext( 				final ProcessingTimeService timeService, 				final Object checkpointLock, 				final StreamStatusMaintainer streamStatusMaintainer, 				final long idleTimeout);1493195810;Create a watermark context.__@param timeService the time service to schedule idleness detection tasks_@param checkpointLock the checkpoint lock_@param streamStatusMaintainer the stream status maintainer to toggle and retrieve current status_@param idleTimeout (-1 if idleness checking is disabled);public WatermarkContext(_				final ProcessingTimeService timeService,_				final Object checkpointLock,_				final StreamStatusMaintainer streamStatusMaintainer,_				final long idleTimeout) {__			this.timeService = Preconditions.checkNotNull(timeService, "Time Service cannot be null.")__			this.checkpointLock = Preconditions.checkNotNull(checkpointLock, "Checkpoint Lock cannot be null.")__			this.streamStatusMaintainer = Preconditions.checkNotNull(streamStatusMaintainer, "Stream Status Maintainer cannot be null.")___			if (idleTimeout != -1) {_				Preconditions.checkArgument(idleTimeout >= 1, "The idle timeout cannot be smaller than 1 ms.")__			}_			this.idleTimeout = idleTimeout___			scheduleNextIdleDetectionTask()__		};create,a,watermark,context,param,time,service,the,time,service,to,schedule,idleness,detection,tasks,param,checkpoint,lock,the,checkpoint,lock,param,stream,status,maintainer,the,stream,status,maintainer,to,toggle,and,retrieve,current,status,param,idle,timeout,1,if,idleness,checking,is,disabled;public,watermark,context,final,processing,time,service,time,service,final,object,checkpoint,lock,final,stream,status,maintainer,stream,status,maintainer,final,long,idle,timeout,this,time,service,preconditions,check,not,null,time,service,time,service,cannot,be,null,this,checkpoint,lock,preconditions,check,not,null,checkpoint,lock,checkpoint,lock,cannot,be,null,this,stream,status,maintainer,preconditions,check,not,null,stream,status,maintainer,stream,status,maintainer,cannot,be,null,if,idle,timeout,1,preconditions,check,argument,idle,timeout,1,the,idle,timeout,cannot,be,smaller,than,1,ms,this,idle,timeout,idle,timeout,schedule,next,idle,detection,task
StreamSourceContexts -> WatermarkContext -> public WatermarkContext( 				final ProcessingTimeService timeService, 				final Object checkpointLock, 				final StreamStatusMaintainer streamStatusMaintainer, 				final long idleTimeout);1493195810;Create a watermark context.__@param timeService the time service to schedule idleness detection tasks_@param checkpointLock the checkpoint lock_@param streamStatusMaintainer the stream status maintainer to toggle and retrieve current status_@param idleTimeout (-1 if idleness checking is disabled);public WatermarkContext(_				final ProcessingTimeService timeService,_				final Object checkpointLock,_				final StreamStatusMaintainer streamStatusMaintainer,_				final long idleTimeout) {__			this.timeService = Preconditions.checkNotNull(timeService, "Time Service cannot be null.")__			this.checkpointLock = Preconditions.checkNotNull(checkpointLock, "Checkpoint Lock cannot be null.")__			this.streamStatusMaintainer = Preconditions.checkNotNull(streamStatusMaintainer, "Stream Status Maintainer cannot be null.")___			if (idleTimeout != -1) {_				Preconditions.checkArgument(idleTimeout >= 1, "The idle timeout cannot be smaller than 1 ms.")__			}_			this.idleTimeout = idleTimeout___			scheduleNextIdleDetectionTask()__		};create,a,watermark,context,param,time,service,the,time,service,to,schedule,idleness,detection,tasks,param,checkpoint,lock,the,checkpoint,lock,param,stream,status,maintainer,the,stream,status,maintainer,to,toggle,and,retrieve,current,status,param,idle,timeout,1,if,idleness,checking,is,disabled;public,watermark,context,final,processing,time,service,time,service,final,object,checkpoint,lock,final,stream,status,maintainer,stream,status,maintainer,final,long,idle,timeout,this,time,service,preconditions,check,not,null,time,service,time,service,cannot,be,null,this,checkpoint,lock,preconditions,check,not,null,checkpoint,lock,checkpoint,lock,cannot,be,null,this,stream,status,maintainer,preconditions,check,not,null,stream,status,maintainer,stream,status,maintainer,cannot,be,null,if,idle,timeout,1,preconditions,check,argument,idle,timeout,1,the,idle,timeout,cannot,be,smaller,than,1,ms,this,idle,timeout,idle,timeout,schedule,next,idle,detection,task
StreamSourceContexts -> WatermarkContext -> public WatermarkContext( 				final ProcessingTimeService timeService, 				final Object checkpointLock, 				final StreamStatusMaintainer streamStatusMaintainer, 				final long idleTimeout);1493195810;Create a watermark context.__@param timeService the time service to schedule idleness detection tasks_@param checkpointLock the checkpoint lock_@param streamStatusMaintainer the stream status maintainer to toggle and retrieve current status_@param idleTimeout (-1 if idleness checking is disabled);public WatermarkContext(_				final ProcessingTimeService timeService,_				final Object checkpointLock,_				final StreamStatusMaintainer streamStatusMaintainer,_				final long idleTimeout) {__			this.timeService = Preconditions.checkNotNull(timeService, "Time Service cannot be null.")__			this.checkpointLock = Preconditions.checkNotNull(checkpointLock, "Checkpoint Lock cannot be null.")__			this.streamStatusMaintainer = Preconditions.checkNotNull(streamStatusMaintainer, "Stream Status Maintainer cannot be null.")___			if (idleTimeout != -1) {_				Preconditions.checkArgument(idleTimeout >= 1, "The idle timeout cannot be smaller than 1 ms.")__			}_			this.idleTimeout = idleTimeout___			scheduleNextIdleDetectionTask()__		};create,a,watermark,context,param,time,service,the,time,service,to,schedule,idleness,detection,tasks,param,checkpoint,lock,the,checkpoint,lock,param,stream,status,maintainer,the,stream,status,maintainer,to,toggle,and,retrieve,current,status,param,idle,timeout,1,if,idleness,checking,is,disabled;public,watermark,context,final,processing,time,service,time,service,final,object,checkpoint,lock,final,stream,status,maintainer,stream,status,maintainer,final,long,idle,timeout,this,time,service,preconditions,check,not,null,time,service,time,service,cannot,be,null,this,checkpoint,lock,preconditions,check,not,null,checkpoint,lock,checkpoint,lock,cannot,be,null,this,stream,status,maintainer,preconditions,check,not,null,stream,status,maintainer,stream,status,maintainer,cannot,be,null,if,idle,timeout,1,preconditions,check,argument,idle,timeout,1,the,idle,timeout,cannot,be,smaller,than,1,ms,this,idle,timeout,idle,timeout,schedule,next,idle,detection,task
StreamSourceContexts -> WatermarkContext -> public WatermarkContext( 				final ProcessingTimeService timeService, 				final Object checkpointLock, 				final StreamStatusMaintainer streamStatusMaintainer, 				final long idleTimeout);1495484544;Create a watermark context.__@param timeService the time service to schedule idleness detection tasks_@param checkpointLock the checkpoint lock_@param streamStatusMaintainer the stream status maintainer to toggle and retrieve current status_@param idleTimeout (-1 if idleness checking is disabled);public WatermarkContext(_				final ProcessingTimeService timeService,_				final Object checkpointLock,_				final StreamStatusMaintainer streamStatusMaintainer,_				final long idleTimeout) {__			this.timeService = Preconditions.checkNotNull(timeService, "Time Service cannot be null.")__			this.checkpointLock = Preconditions.checkNotNull(checkpointLock, "Checkpoint Lock cannot be null.")__			this.streamStatusMaintainer = Preconditions.checkNotNull(streamStatusMaintainer, "Stream Status Maintainer cannot be null.")___			if (idleTimeout != -1) {_				Preconditions.checkArgument(idleTimeout >= 1, "The idle timeout cannot be smaller than 1 ms.")__			}_			this.idleTimeout = idleTimeout___			scheduleNextIdleDetectionTask()__		};create,a,watermark,context,param,time,service,the,time,service,to,schedule,idleness,detection,tasks,param,checkpoint,lock,the,checkpoint,lock,param,stream,status,maintainer,the,stream,status,maintainer,to,toggle,and,retrieve,current,status,param,idle,timeout,1,if,idleness,checking,is,disabled;public,watermark,context,final,processing,time,service,time,service,final,object,checkpoint,lock,final,stream,status,maintainer,stream,status,maintainer,final,long,idle,timeout,this,time,service,preconditions,check,not,null,time,service,time,service,cannot,be,null,this,checkpoint,lock,preconditions,check,not,null,checkpoint,lock,checkpoint,lock,cannot,be,null,this,stream,status,maintainer,preconditions,check,not,null,stream,status,maintainer,stream,status,maintainer,cannot,be,null,if,idle,timeout,1,preconditions,check,argument,idle,timeout,1,the,idle,timeout,cannot,be,smaller,than,1,ms,this,idle,timeout,idle,timeout,schedule,next,idle,detection,task
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollect(T element)_;1487783998;Process and collect record.;protected abstract void processAndCollect(T element)_;process,and,collect,record;protected,abstract,void,process,and,collect,t,element
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollect(T element)_;1487868265;Process and collect record.;protected abstract void processAndCollect(T element)_;process,and,collect,record;protected,abstract,void,process,and,collect,t,element
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollect(T element)_;1493195810;Process and collect record.;protected abstract void processAndCollect(T element)_;process,and,collect,record;protected,abstract,void,process,and,collect,t,element
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollect(T element)_;1493195810;Process and collect record.;protected abstract void processAndCollect(T element)_;process,and,collect,record;protected,abstract,void,process,and,collect,t,element
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollect(T element)_;1493195810;Process and collect record.;protected abstract void processAndCollect(T element)_;process,and,collect,record;protected,abstract,void,process,and,collect,t,element
StreamSourceContexts -> WatermarkContext -> protected abstract void processAndCollect(T element)_;1495484544;Process and collect record.;protected abstract void processAndCollect(T element)_;process,and,collect,record;protected,abstract,void,process,and,collect,t,element
