# id;timestamp;commentText;codeText;commentWords;codeWords
Buckets -> private void updateMaxPartCounter(long candidate);1532095949;Updates the state keeping track of the maximum used part_counter across all local active buckets._@param candidate the part counter that will potentially replace the current {@link #maxPartCounterUsed}.;private void updateMaxPartCounter(long candidate) {_		maxPartCounterUsed = Math.max(maxPartCounterUsed, candidate)__	};updates,the,state,keeping,track,of,the,maximum,used,part,counter,across,all,local,active,buckets,param,candidate,the,part,counter,that,will,potentially,replace,the,current,link,max,part,counter,used;private,void,update,max,part,counter,long,candidate,max,part,counter,used,math,max,max,part,counter,used,candidate
Buckets -> private void updateMaxPartCounter(long candidate);1532348102;Updates the state keeping track of the maximum used part_counter across all local active buckets._@param candidate the part counter that will potentially replace the current {@link #maxPartCounterUsed}.;private void updateMaxPartCounter(long candidate) {_		maxPartCounterUsed = Math.max(maxPartCounterUsed, candidate)__	};updates,the,state,keeping,track,of,the,maximum,used,part,counter,across,all,local,active,buckets,param,candidate,the,part,counter,that,will,potentially,replace,the,current,link,max,part,counter,used;private,void,update,max,part,counter,long,candidate,max,part,counter,used,math,max,max,part,counter,used,candidate
Buckets -> private void updateMaxPartCounter(long candidate);1533029605;Updates the state keeping track of the maximum used part_counter across all local active buckets._@param candidate the part counter that will potentially replace the current {@link #maxPartCounterUsed}.;private void updateMaxPartCounter(long candidate) {_		maxPartCounterUsed = Math.max(maxPartCounterUsed, candidate)__	};updates,the,state,keeping,track,of,the,maximum,used,part,counter,across,all,local,active,buckets,param,candidate,the,part,counter,that,will,potentially,replace,the,current,link,max,part,counter,used;private,void,update,max,part,counter,long,candidate,max,part,counter,used,math,max,max,part,counter,used,candidate
Buckets -> private void updateMaxPartCounter(long candidate);1533111305;Updates the state keeping track of the maximum used part_counter across all local active buckets._@param candidate the part counter that will potentially replace the current {@link #maxPartCounterUsed}.;private void updateMaxPartCounter(long candidate) {_		maxPartCounterUsed = Math.max(maxPartCounterUsed, candidate)__	};updates,the,state,keeping,track,of,the,maximum,used,part,counter,across,all,local,active,buckets,param,candidate,the,part,counter,that,will,potentially,replace,the,current,link,max,part,counter,used;private,void,update,max,part,counter,long,candidate,max,part,counter,used,math,max,max,part,counter,used,candidate
Buckets -> Buckets( 			final Path basePath, 			final BucketAssigner<IN, BucketID> bucketAssigner, 			final BucketFactory<IN, BucketID> bucketFactory, 			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory, 			final RollingPolicy<IN, BucketID> rollingPolicy, 			final int subtaskIndex) throws IOException;1533229113;A constructor creating a new empty bucket manager.__@param basePath The base path for our buckets._@param bucketAssigner The {@link BucketAssigner} provided by the user._@param bucketFactory The {@link BucketFactory} to be used to create buckets._@param partFileWriterFactory The {@link PartFileWriter.PartFileFactory} to be used when writing data._@param rollingPolicy The {@link RollingPolicy} as specified by the user.;Buckets(_			final Path basePath,_			final BucketAssigner<IN, BucketID> bucketAssigner,_			final BucketFactory<IN, BucketID> bucketFactory,_			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory,_			final RollingPolicy<IN, BucketID> rollingPolicy,_			final int subtaskIndex) throws IOException {__		this.basePath = Preconditions.checkNotNull(basePath)__		this.bucketAssigner = Preconditions.checkNotNull(bucketAssigner)__		this.bucketFactory = Preconditions.checkNotNull(bucketFactory)__		this.partFileWriterFactory = Preconditions.checkNotNull(partFileWriterFactory)__		this.rollingPolicy = Preconditions.checkNotNull(rollingPolicy)__		this.subtaskIndex = subtaskIndex___		this.activeBuckets = new HashMap<>()__		this.bucketerContext = new Buckets.BucketerContext()___		this.fsWriter = FileSystem.get(basePath.toUri()).createRecoverableWriter()__		this.bucketStateSerializer = new BucketStateSerializer<>(_				fsWriter.getResumeRecoverableSerializer(),_				fsWriter.getCommitRecoverableSerializer(),_				bucketAssigner.getSerializer()_		)___		this.maxPartCounter = 0L__	};a,constructor,creating,a,new,empty,bucket,manager,param,base,path,the,base,path,for,our,buckets,param,bucket,assigner,the,link,bucket,assigner,provided,by,the,user,param,bucket,factory,the,link,bucket,factory,to,be,used,to,create,buckets,param,part,file,writer,factory,the,link,part,file,writer,part,file,factory,to,be,used,when,writing,data,param,rolling,policy,the,link,rolling,policy,as,specified,by,the,user;buckets,final,path,base,path,final,bucket,assigner,in,bucket,id,bucket,assigner,final,bucket,factory,in,bucket,id,bucket,factory,final,part,file,writer,part,file,factory,in,bucket,id,part,file,writer,factory,final,rolling,policy,in,bucket,id,rolling,policy,final,int,subtask,index,throws,ioexception,this,base,path,preconditions,check,not,null,base,path,this,bucket,assigner,preconditions,check,not,null,bucket,assigner,this,bucket,factory,preconditions,check,not,null,bucket,factory,this,part,file,writer,factory,preconditions,check,not,null,part,file,writer,factory,this,rolling,policy,preconditions,check,not,null,rolling,policy,this,subtask,index,subtask,index,this,active,buckets,new,hash,map,this,bucketer,context,new,buckets,bucketer,context,this,fs,writer,file,system,get,base,path,to,uri,create,recoverable,writer,this,bucket,state,serializer,new,bucket,state,serializer,fs,writer,get,resume,recoverable,serializer,fs,writer,get,commit,recoverable,serializer,bucket,assigner,get,serializer,this,max,part,counter,0l
Buckets -> Buckets( 			final Path basePath, 			final BucketAssigner<IN, BucketID> bucketAssigner, 			final BucketFactory<IN, BucketID> bucketFactory, 			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory, 			final RollingPolicy<IN, BucketID> rollingPolicy, 			final int subtaskIndex) throws IOException;1533229145;A constructor creating a new empty bucket manager.__@param basePath The base path for our buckets._@param bucketAssigner The {@link BucketAssigner} provided by the user._@param bucketFactory The {@link BucketFactory} to be used to create buckets._@param partFileWriterFactory The {@link PartFileWriter.PartFileFactory} to be used when writing data._@param rollingPolicy The {@link RollingPolicy} as specified by the user.;Buckets(_			final Path basePath,_			final BucketAssigner<IN, BucketID> bucketAssigner,_			final BucketFactory<IN, BucketID> bucketFactory,_			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory,_			final RollingPolicy<IN, BucketID> rollingPolicy,_			final int subtaskIndex) throws IOException {__		this.basePath = Preconditions.checkNotNull(basePath)__		this.bucketAssigner = Preconditions.checkNotNull(bucketAssigner)__		this.bucketFactory = Preconditions.checkNotNull(bucketFactory)__		this.partFileWriterFactory = Preconditions.checkNotNull(partFileWriterFactory)__		this.rollingPolicy = Preconditions.checkNotNull(rollingPolicy)__		this.subtaskIndex = subtaskIndex___		this.activeBuckets = new HashMap<>()__		this.bucketerContext = new Buckets.BucketerContext()___		try {_			this.fsWriter = FileSystem.get(basePath.toUri()).createRecoverableWriter()__		} catch (IOException e) {_			LOG.error("Unable to create filesystem for path: {}", basePath)__			throw e__		}__		this.bucketStateSerializer = new BucketStateSerializer<>(_				fsWriter.getResumeRecoverableSerializer(),_				fsWriter.getCommitRecoverableSerializer(),_				bucketAssigner.getSerializer()_		)___		this.maxPartCounter = 0L__	};a,constructor,creating,a,new,empty,bucket,manager,param,base,path,the,base,path,for,our,buckets,param,bucket,assigner,the,link,bucket,assigner,provided,by,the,user,param,bucket,factory,the,link,bucket,factory,to,be,used,to,create,buckets,param,part,file,writer,factory,the,link,part,file,writer,part,file,factory,to,be,used,when,writing,data,param,rolling,policy,the,link,rolling,policy,as,specified,by,the,user;buckets,final,path,base,path,final,bucket,assigner,in,bucket,id,bucket,assigner,final,bucket,factory,in,bucket,id,bucket,factory,final,part,file,writer,part,file,factory,in,bucket,id,part,file,writer,factory,final,rolling,policy,in,bucket,id,rolling,policy,final,int,subtask,index,throws,ioexception,this,base,path,preconditions,check,not,null,base,path,this,bucket,assigner,preconditions,check,not,null,bucket,assigner,this,bucket,factory,preconditions,check,not,null,bucket,factory,this,part,file,writer,factory,preconditions,check,not,null,part,file,writer,factory,this,rolling,policy,preconditions,check,not,null,rolling,policy,this,subtask,index,subtask,index,this,active,buckets,new,hash,map,this,bucketer,context,new,buckets,bucketer,context,try,this,fs,writer,file,system,get,base,path,to,uri,create,recoverable,writer,catch,ioexception,e,log,error,unable,to,create,filesystem,for,path,base,path,throw,e,this,bucket,state,serializer,new,bucket,state,serializer,fs,writer,get,resume,recoverable,serializer,fs,writer,get,commit,recoverable,serializer,bucket,assigner,get,serializer,this,max,part,counter,0l
Buckets -> Buckets( 			final Path basePath, 			final BucketAssigner<IN, BucketID> bucketAssigner, 			final BucketFactory<IN, BucketID> bucketFactory, 			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory, 			final RollingPolicy<IN, BucketID> rollingPolicy, 			final int subtaskIndex) throws IOException;1541059170;A constructor creating a new empty bucket manager.__@param basePath The base path for our buckets._@param bucketAssigner The {@link BucketAssigner} provided by the user._@param bucketFactory The {@link BucketFactory} to be used to create buckets._@param partFileWriterFactory The {@link PartFileWriter.PartFileFactory} to be used when writing data._@param rollingPolicy The {@link RollingPolicy} as specified by the user.;Buckets(_			final Path basePath,_			final BucketAssigner<IN, BucketID> bucketAssigner,_			final BucketFactory<IN, BucketID> bucketFactory,_			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory,_			final RollingPolicy<IN, BucketID> rollingPolicy,_			final int subtaskIndex) throws IOException {__		this.basePath = Preconditions.checkNotNull(basePath)__		this.bucketAssigner = Preconditions.checkNotNull(bucketAssigner)__		this.bucketFactory = Preconditions.checkNotNull(bucketFactory)__		this.partFileWriterFactory = Preconditions.checkNotNull(partFileWriterFactory)__		this.rollingPolicy = Preconditions.checkNotNull(rollingPolicy)__		this.subtaskIndex = subtaskIndex___		this.activeBuckets = new HashMap<>()__		this.bucketerContext = new Buckets.BucketerContext()___		try {_			this.fsWriter = FileSystem.get(basePath.toUri()).createRecoverableWriter()__		} catch (IOException e) {_			LOG.error("Unable to create filesystem for path: {}", basePath)__			throw e__		}__		this.bucketStateSerializer = new BucketStateSerializer<>(_				fsWriter.getResumeRecoverableSerializer(),_				fsWriter.getCommitRecoverableSerializer(),_				bucketAssigner.getSerializer()_		)___		this.maxPartCounter = 0L__	};a,constructor,creating,a,new,empty,bucket,manager,param,base,path,the,base,path,for,our,buckets,param,bucket,assigner,the,link,bucket,assigner,provided,by,the,user,param,bucket,factory,the,link,bucket,factory,to,be,used,to,create,buckets,param,part,file,writer,factory,the,link,part,file,writer,part,file,factory,to,be,used,when,writing,data,param,rolling,policy,the,link,rolling,policy,as,specified,by,the,user;buckets,final,path,base,path,final,bucket,assigner,in,bucket,id,bucket,assigner,final,bucket,factory,in,bucket,id,bucket,factory,final,part,file,writer,part,file,factory,in,bucket,id,part,file,writer,factory,final,rolling,policy,in,bucket,id,rolling,policy,final,int,subtask,index,throws,ioexception,this,base,path,preconditions,check,not,null,base,path,this,bucket,assigner,preconditions,check,not,null,bucket,assigner,this,bucket,factory,preconditions,check,not,null,bucket,factory,this,part,file,writer,factory,preconditions,check,not,null,part,file,writer,factory,this,rolling,policy,preconditions,check,not,null,rolling,policy,this,subtask,index,subtask,index,this,active,buckets,new,hash,map,this,bucketer,context,new,buckets,bucketer,context,try,this,fs,writer,file,system,get,base,path,to,uri,create,recoverable,writer,catch,ioexception,e,log,error,unable,to,create,filesystem,for,path,base,path,throw,e,this,bucket,state,serializer,new,bucket,state,serializer,fs,writer,get,resume,recoverable,serializer,fs,writer,get,commit,recoverable,serializer,bucket,assigner,get,serializer,this,max,part,counter,0l
Buckets -> Buckets( 			final Path basePath, 			final BucketAssigner<IN, BucketID> bucketAssigner, 			final BucketFactory<IN, BucketID> bucketFactory, 			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory, 			final RollingPolicy<IN, BucketID> rollingPolicy, 			final int subtaskIndex) throws IOException;1547025573;A constructor creating a new empty bucket manager.__@param basePath The base path for our buckets._@param bucketAssigner The {@link BucketAssigner} provided by the user._@param bucketFactory The {@link BucketFactory} to be used to create buckets._@param partFileWriterFactory The {@link PartFileWriter.PartFileFactory} to be used when writing data._@param rollingPolicy The {@link RollingPolicy} as specified by the user.;Buckets(_			final Path basePath,_			final BucketAssigner<IN, BucketID> bucketAssigner,_			final BucketFactory<IN, BucketID> bucketFactory,_			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory,_			final RollingPolicy<IN, BucketID> rollingPolicy,_			final int subtaskIndex) throws IOException {__		this.basePath = Preconditions.checkNotNull(basePath)__		this.bucketAssigner = Preconditions.checkNotNull(bucketAssigner)__		this.bucketFactory = Preconditions.checkNotNull(bucketFactory)__		this.partFileWriterFactory = Preconditions.checkNotNull(partFileWriterFactory)__		this.rollingPolicy = Preconditions.checkNotNull(rollingPolicy)__		this.subtaskIndex = subtaskIndex___		this.activeBuckets = new HashMap<>()__		this.bucketerContext = new Buckets.BucketerContext()___		try {_			this.fsWriter = FileSystem.get(basePath.toUri()).createRecoverableWriter()__		} catch (IOException e) {_			LOG.error("Unable to create filesystem for path: {}", basePath)__			throw e__		}__		this.bucketStateSerializer = new BucketStateSerializer<>(_				fsWriter.getResumeRecoverableSerializer(),_				fsWriter.getCommitRecoverableSerializer(),_				bucketAssigner.getSerializer()_		)___		this.maxPartCounter = 0L__	};a,constructor,creating,a,new,empty,bucket,manager,param,base,path,the,base,path,for,our,buckets,param,bucket,assigner,the,link,bucket,assigner,provided,by,the,user,param,bucket,factory,the,link,bucket,factory,to,be,used,to,create,buckets,param,part,file,writer,factory,the,link,part,file,writer,part,file,factory,to,be,used,when,writing,data,param,rolling,policy,the,link,rolling,policy,as,specified,by,the,user;buckets,final,path,base,path,final,bucket,assigner,in,bucket,id,bucket,assigner,final,bucket,factory,in,bucket,id,bucket,factory,final,part,file,writer,part,file,factory,in,bucket,id,part,file,writer,factory,final,rolling,policy,in,bucket,id,rolling,policy,final,int,subtask,index,throws,ioexception,this,base,path,preconditions,check,not,null,base,path,this,bucket,assigner,preconditions,check,not,null,bucket,assigner,this,bucket,factory,preconditions,check,not,null,bucket,factory,this,part,file,writer,factory,preconditions,check,not,null,part,file,writer,factory,this,rolling,policy,preconditions,check,not,null,rolling,policy,this,subtask,index,subtask,index,this,active,buckets,new,hash,map,this,bucketer,context,new,buckets,bucketer,context,try,this,fs,writer,file,system,get,base,path,to,uri,create,recoverable,writer,catch,ioexception,e,log,error,unable,to,create,filesystem,for,path,base,path,throw,e,this,bucket,state,serializer,new,bucket,state,serializer,fs,writer,get,resume,recoverable,serializer,fs,writer,get,commit,recoverable,serializer,bucket,assigner,get,serializer,this,max,part,counter,0l
Buckets -> void onElement(IN value, SinkFunction.Context context) throws Exception;1532095949;Called on every incoming element to write it to its final location._@param value the element itself._@param context the {@link SinkFunction.Context context} available to the sink function._@throws Exception;void onElement(IN value, SinkFunction.Context context) throws Exception {_		final long currentProcessingTime = context.currentProcessingTime()___		_		bucketerContext.update(_				context.timestamp(),_				context.currentWatermark(),_				currentProcessingTime)___		final BucketID bucketId = bucketer.getBucketId(value, bucketerContext)___		Bucket<IN, BucketID> bucket = activeBuckets.get(bucketId)__		if (bucket == null) {_			final Path bucketPath = assembleBucketPath(bucketId)__			bucket = bucketFactory.getNewBucket(_					fileSystemWriter,_					subtaskIndex,_					bucketId,_					bucketPath,_					initMaxPartCounter,_					partFileWriterFactory)__			activeBuckets.put(bucketId, bucket)__		}__		final PartFileInfo<BucketID> info = bucket.getInProgressPartInfo()__		if (info == null || rollingPolicy.shouldRollOnEvent(info)) {_			bucket.rollPartFile(currentProcessingTime)__		}_		bucket.write(value, currentProcessingTime)___		_		_		_		updateMaxPartCounter(bucket.getPartCounter())__	};called,on,every,incoming,element,to,write,it,to,its,final,location,param,value,the,element,itself,param,context,the,link,sink,function,context,context,available,to,the,sink,function,throws,exception;void,on,element,in,value,sink,function,context,context,throws,exception,final,long,current,processing,time,context,current,processing,time,bucketer,context,update,context,timestamp,context,current,watermark,current,processing,time,final,bucket,id,bucket,id,bucketer,get,bucket,id,value,bucketer,context,bucket,in,bucket,id,bucket,active,buckets,get,bucket,id,if,bucket,null,final,path,bucket,path,assemble,bucket,path,bucket,id,bucket,bucket,factory,get,new,bucket,file,system,writer,subtask,index,bucket,id,bucket,path,init,max,part,counter,part,file,writer,factory,active,buckets,put,bucket,id,bucket,final,part,file,info,bucket,id,info,bucket,get,in,progress,part,info,if,info,null,rolling,policy,should,roll,on,event,info,bucket,roll,part,file,current,processing,time,bucket,write,value,current,processing,time,update,max,part,counter,bucket,get,part,counter
Buckets -> void onElement(IN value, SinkFunction.Context context) throws Exception;1532348102;Called on every incoming element to write it to its final location._@param value the element itself._@param context the {@link SinkFunction.Context context} available to the sink function._@throws Exception;void onElement(IN value, SinkFunction.Context context) throws Exception {_		final long currentProcessingTime = context.currentProcessingTime()___		_		bucketerContext.update(_				context.timestamp(),_				context.currentWatermark(),_				currentProcessingTime)___		final BucketID bucketId = bucketer.getBucketId(value, bucketerContext)___		Bucket<IN, BucketID> bucket = activeBuckets.get(bucketId)__		if (bucket == null) {_			final Path bucketPath = assembleBucketPath(bucketId)__			bucket = bucketFactory.getNewBucket(_					fileSystemWriter,_					subtaskIndex,_					bucketId,_					bucketPath,_					initMaxPartCounter,_					partFileWriterFactory)__			activeBuckets.put(bucketId, bucket)__		}__		final PartFileInfo<BucketID> info = bucket.getInProgressPartInfo()__		if (info == null || rollingPolicy.shouldRollOnEvent(info, value)) {_			bucket.rollPartFile(currentProcessingTime)__		}_		bucket.write(value, currentProcessingTime)___		_		_		_		updateMaxPartCounter(bucket.getPartCounter())__	};called,on,every,incoming,element,to,write,it,to,its,final,location,param,value,the,element,itself,param,context,the,link,sink,function,context,context,available,to,the,sink,function,throws,exception;void,on,element,in,value,sink,function,context,context,throws,exception,final,long,current,processing,time,context,current,processing,time,bucketer,context,update,context,timestamp,context,current,watermark,current,processing,time,final,bucket,id,bucket,id,bucketer,get,bucket,id,value,bucketer,context,bucket,in,bucket,id,bucket,active,buckets,get,bucket,id,if,bucket,null,final,path,bucket,path,assemble,bucket,path,bucket,id,bucket,bucket,factory,get,new,bucket,file,system,writer,subtask,index,bucket,id,bucket,path,init,max,part,counter,part,file,writer,factory,active,buckets,put,bucket,id,bucket,final,part,file,info,bucket,id,info,bucket,get,in,progress,part,info,if,info,null,rolling,policy,should,roll,on,event,info,value,bucket,roll,part,file,current,processing,time,bucket,write,value,current,processing,time,update,max,part,counter,bucket,get,part,counter
Buckets -> void onElement(IN value, SinkFunction.Context context) throws Exception;1533029605;Called on every incoming element to write it to its final location._@param value the element itself._@param context the {@link SinkFunction.Context context} available to the sink function._@throws Exception;void onElement(IN value, SinkFunction.Context context) throws Exception {_		final long currentProcessingTime = context.currentProcessingTime()___		_		bucketerContext.update(_				context.timestamp(),_				context.currentWatermark(),_				currentProcessingTime)___		final BucketID bucketId = bucketer.getBucketId(value, bucketerContext)___		Bucket<IN, BucketID> bucket = activeBuckets.get(bucketId)__		if (bucket == null) {_			final Path bucketPath = assembleBucketPath(bucketId)__			bucket = bucketFactory.getNewBucket(_					fileSystemWriter,_					subtaskIndex,_					bucketId,_					bucketPath,_					initMaxPartCounter,_					partFileWriterFactory)__			activeBuckets.put(bucketId, bucket)__		}__		final PartFileInfo<BucketID> info = bucket.getInProgressPartInfo()__		if (info == null || rollingPolicy.shouldRollOnEvent(info, value)) {_			bucket.rollPartFile(currentProcessingTime)__		}_		bucket.write(value, currentProcessingTime)___		_		_		_		updateMaxPartCounter(bucket.getPartCounter())__	};called,on,every,incoming,element,to,write,it,to,its,final,location,param,value,the,element,itself,param,context,the,link,sink,function,context,context,available,to,the,sink,function,throws,exception;void,on,element,in,value,sink,function,context,context,throws,exception,final,long,current,processing,time,context,current,processing,time,bucketer,context,update,context,timestamp,context,current,watermark,current,processing,time,final,bucket,id,bucket,id,bucketer,get,bucket,id,value,bucketer,context,bucket,in,bucket,id,bucket,active,buckets,get,bucket,id,if,bucket,null,final,path,bucket,path,assemble,bucket,path,bucket,id,bucket,bucket,factory,get,new,bucket,file,system,writer,subtask,index,bucket,id,bucket,path,init,max,part,counter,part,file,writer,factory,active,buckets,put,bucket,id,bucket,final,part,file,info,bucket,id,info,bucket,get,in,progress,part,info,if,info,null,rolling,policy,should,roll,on,event,info,value,bucket,roll,part,file,current,processing,time,bucket,write,value,current,processing,time,update,max,part,counter,bucket,get,part,counter
Buckets -> void onElement(IN value, SinkFunction.Context context) throws Exception;1533111305;Called on every incoming element to write it to its final location._@param value the element itself._@param context the {@link SinkFunction.Context context} available to the sink function._@throws Exception;void onElement(IN value, SinkFunction.Context context) throws Exception {_		final long currentProcessingTime = context.currentProcessingTime()___		_		bucketerContext.update(_				context.timestamp(),_				context.currentWatermark(),_				currentProcessingTime)___		final BucketID bucketId = bucketer.getBucketId(value, bucketerContext)___		Bucket<IN, BucketID> bucket = activeBuckets.get(bucketId)__		if (bucket == null) {_			final Path bucketPath = assembleBucketPath(bucketId)__			bucket = bucketFactory.getNewBucket(_					fileSystemWriter,_					subtaskIndex,_					bucketId,_					bucketPath,_					maxPartCounterUsed,_					partFileWriterFactory)__			activeBuckets.put(bucketId, bucket)__		}__		final PartFileInfo<BucketID> info = bucket.getInProgressPartInfo()__		if (info == null || rollingPolicy.shouldRollOnEvent(info, value)) {__			_			_			_			__			bucket.rollPartFile(currentProcessingTime)__		}_		bucket.write(value, currentProcessingTime)___		_		_		_		updateMaxPartCounter(bucket.getPartCounter())__	};called,on,every,incoming,element,to,write,it,to,its,final,location,param,value,the,element,itself,param,context,the,link,sink,function,context,context,available,to,the,sink,function,throws,exception;void,on,element,in,value,sink,function,context,context,throws,exception,final,long,current,processing,time,context,current,processing,time,bucketer,context,update,context,timestamp,context,current,watermark,current,processing,time,final,bucket,id,bucket,id,bucketer,get,bucket,id,value,bucketer,context,bucket,in,bucket,id,bucket,active,buckets,get,bucket,id,if,bucket,null,final,path,bucket,path,assemble,bucket,path,bucket,id,bucket,bucket,factory,get,new,bucket,file,system,writer,subtask,index,bucket,id,bucket,path,max,part,counter,used,part,file,writer,factory,active,buckets,put,bucket,id,bucket,final,part,file,info,bucket,id,info,bucket,get,in,progress,part,info,if,info,null,rolling,policy,should,roll,on,event,info,value,bucket,roll,part,file,current,processing,time,bucket,write,value,current,processing,time,update,max,part,counter,bucket,get,part,counter
Buckets -> private Path assembleBucketPath(BucketID bucketId);1532095949;Assembles the final bucket {@link Path} that will be used for the provided bucket in the_underlying filesystem._@param bucketId the id of the bucket as returned by the {@link Bucketer}._@return The resulting path.;private Path assembleBucketPath(BucketID bucketId) {_		return new Path(basePath, bucketId.toString())__	};assembles,the,final,bucket,link,path,that,will,be,used,for,the,provided,bucket,in,the,underlying,filesystem,param,bucket,id,the,id,of,the,bucket,as,returned,by,the,link,bucketer,return,the,resulting,path;private,path,assemble,bucket,path,bucket,id,bucket,id,return,new,path,base,path,bucket,id,to,string
Buckets -> private Path assembleBucketPath(BucketID bucketId);1532348102;Assembles the final bucket {@link Path} that will be used for the provided bucket in the_underlying filesystem._@param bucketId the id of the bucket as returned by the {@link Bucketer}._@return The resulting path.;private Path assembleBucketPath(BucketID bucketId) {_		return new Path(basePath, bucketId.toString())__	};assembles,the,final,bucket,link,path,that,will,be,used,for,the,provided,bucket,in,the,underlying,filesystem,param,bucket,id,the,id,of,the,bucket,as,returned,by,the,link,bucketer,return,the,resulting,path;private,path,assemble,bucket,path,bucket,id,bucket,id,return,new,path,base,path,bucket,id,to,string
Buckets -> private Path assembleBucketPath(BucketID bucketId);1533029605;Assembles the final bucket {@link Path} that will be used for the provided bucket in the_underlying filesystem._@param bucketId the id of the bucket as returned by the {@link Bucketer}._@return The resulting path.;private Path assembleBucketPath(BucketID bucketId) {_		return new Path(basePath, bucketId.toString())__	};assembles,the,final,bucket,link,path,that,will,be,used,for,the,provided,bucket,in,the,underlying,filesystem,param,bucket,id,the,id,of,the,bucket,as,returned,by,the,link,bucketer,return,the,resulting,path;private,path,assemble,bucket,path,bucket,id,bucket,id,return,new,path,base,path,bucket,id,to,string
Buckets -> private Path assembleBucketPath(BucketID bucketId);1533111305;Assembles the final bucket {@link Path} that will be used for the provided bucket in the_underlying filesystem._@param bucketId the id of the bucket as returned by the {@link Bucketer}._@return The resulting path.;private Path assembleBucketPath(BucketID bucketId) {_		return new Path(basePath, bucketId.toString())__	};assembles,the,final,bucket,link,path,that,will,be,used,for,the,provided,bucket,in,the,underlying,filesystem,param,bucket,id,the,id,of,the,bucket,as,returned,by,the,link,bucketer,return,the,resulting,path;private,path,assemble,bucket,path,bucket,id,bucket,id,return,new,path,base,path,bucket,id,to,string
Buckets -> Buckets( 			final Path basePath, 			final Bucketer<IN, BucketID> bucketer, 			final BucketFactory<IN, BucketID> bucketFactory, 			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory, 			final RollingPolicy<IN, BucketID> rollingPolicy, 			final int subtaskIndex) throws IOException;1532348102;A private constructor creating a new empty bucket manager.__@param basePath The base path for our buckets._@param bucketer The {@link Bucketer} provided by the user._@param bucketFactory The {@link BucketFactory} to be used to create buckets._@param partFileWriterFactory The {@link PartFileWriter.PartFileFactory} to be used when writing data._@param rollingPolicy The {@link RollingPolicy} as specified by the user.;Buckets(_			final Path basePath,_			final Bucketer<IN, BucketID> bucketer,_			final BucketFactory<IN, BucketID> bucketFactory,_			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory,_			final RollingPolicy<IN, BucketID> rollingPolicy,_			final int subtaskIndex) throws IOException {__		this.basePath = Preconditions.checkNotNull(basePath)__		this.bucketer = Preconditions.checkNotNull(bucketer)__		this.bucketFactory = Preconditions.checkNotNull(bucketFactory)__		this.partFileWriterFactory = Preconditions.checkNotNull(partFileWriterFactory)__		this.rollingPolicy = Preconditions.checkNotNull(rollingPolicy)__		this.subtaskIndex = subtaskIndex___		this.activeBuckets = new HashMap<>()__		this.bucketerContext = new Buckets.BucketerContext()___		this.fileSystemWriter = FileSystem.get(basePath.toUri()).createRecoverableWriter()__		this.bucketStateSerializer = new BucketStateSerializer<>(_				fileSystemWriter.getResumeRecoverableSerializer(),_				fileSystemWriter.getCommitRecoverableSerializer(),_				bucketer.getSerializer()_		)___		this.initMaxPartCounter = 0L__		this.maxPartCounterUsed = 0L__	};a,private,constructor,creating,a,new,empty,bucket,manager,param,base,path,the,base,path,for,our,buckets,param,bucketer,the,link,bucketer,provided,by,the,user,param,bucket,factory,the,link,bucket,factory,to,be,used,to,create,buckets,param,part,file,writer,factory,the,link,part,file,writer,part,file,factory,to,be,used,when,writing,data,param,rolling,policy,the,link,rolling,policy,as,specified,by,the,user;buckets,final,path,base,path,final,bucketer,in,bucket,id,bucketer,final,bucket,factory,in,bucket,id,bucket,factory,final,part,file,writer,part,file,factory,in,bucket,id,part,file,writer,factory,final,rolling,policy,in,bucket,id,rolling,policy,final,int,subtask,index,throws,ioexception,this,base,path,preconditions,check,not,null,base,path,this,bucketer,preconditions,check,not,null,bucketer,this,bucket,factory,preconditions,check,not,null,bucket,factory,this,part,file,writer,factory,preconditions,check,not,null,part,file,writer,factory,this,rolling,policy,preconditions,check,not,null,rolling,policy,this,subtask,index,subtask,index,this,active,buckets,new,hash,map,this,bucketer,context,new,buckets,bucketer,context,this,file,system,writer,file,system,get,base,path,to,uri,create,recoverable,writer,this,bucket,state,serializer,new,bucket,state,serializer,file,system,writer,get,resume,recoverable,serializer,file,system,writer,get,commit,recoverable,serializer,bucketer,get,serializer,this,init,max,part,counter,0l,this,max,part,counter,used,0l
Buckets -> Buckets( 			final Path basePath, 			final Bucketer<IN, BucketID> bucketer, 			final BucketFactory<IN, BucketID> bucketFactory, 			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory, 			final RollingPolicy<IN, BucketID> rollingPolicy, 			final int subtaskIndex) throws IOException;1533029605;A private constructor creating a new empty bucket manager.__@param basePath The base path for our buckets._@param bucketer The {@link Bucketer} provided by the user._@param bucketFactory The {@link BucketFactory} to be used to create buckets._@param partFileWriterFactory The {@link PartFileWriter.PartFileFactory} to be used when writing data._@param rollingPolicy The {@link RollingPolicy} as specified by the user.;Buckets(_			final Path basePath,_			final Bucketer<IN, BucketID> bucketer,_			final BucketFactory<IN, BucketID> bucketFactory,_			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory,_			final RollingPolicy<IN, BucketID> rollingPolicy,_			final int subtaskIndex) throws IOException {__		this.basePath = Preconditions.checkNotNull(basePath)__		this.bucketer = Preconditions.checkNotNull(bucketer)__		this.bucketFactory = Preconditions.checkNotNull(bucketFactory)__		this.partFileWriterFactory = Preconditions.checkNotNull(partFileWriterFactory)__		this.rollingPolicy = Preconditions.checkNotNull(rollingPolicy)__		this.subtaskIndex = subtaskIndex___		this.activeBuckets = new HashMap<>()__		this.bucketerContext = new Buckets.BucketerContext()___		this.fileSystemWriter = FileSystem.get(basePath.toUri()).createRecoverableWriter()__		this.bucketStateSerializer = new BucketStateSerializer<>(_				fileSystemWriter.getResumeRecoverableSerializer(),_				fileSystemWriter.getCommitRecoverableSerializer(),_				bucketer.getSerializer()_		)___		this.initMaxPartCounter = 0L__		this.maxPartCounterUsed = 0L__	};a,private,constructor,creating,a,new,empty,bucket,manager,param,base,path,the,base,path,for,our,buckets,param,bucketer,the,link,bucketer,provided,by,the,user,param,bucket,factory,the,link,bucket,factory,to,be,used,to,create,buckets,param,part,file,writer,factory,the,link,part,file,writer,part,file,factory,to,be,used,when,writing,data,param,rolling,policy,the,link,rolling,policy,as,specified,by,the,user;buckets,final,path,base,path,final,bucketer,in,bucket,id,bucketer,final,bucket,factory,in,bucket,id,bucket,factory,final,part,file,writer,part,file,factory,in,bucket,id,part,file,writer,factory,final,rolling,policy,in,bucket,id,rolling,policy,final,int,subtask,index,throws,ioexception,this,base,path,preconditions,check,not,null,base,path,this,bucketer,preconditions,check,not,null,bucketer,this,bucket,factory,preconditions,check,not,null,bucket,factory,this,part,file,writer,factory,preconditions,check,not,null,part,file,writer,factory,this,rolling,policy,preconditions,check,not,null,rolling,policy,this,subtask,index,subtask,index,this,active,buckets,new,hash,map,this,bucketer,context,new,buckets,bucketer,context,this,file,system,writer,file,system,get,base,path,to,uri,create,recoverable,writer,this,bucket,state,serializer,new,bucket,state,serializer,file,system,writer,get,resume,recoverable,serializer,file,system,writer,get,commit,recoverable,serializer,bucketer,get,serializer,this,init,max,part,counter,0l,this,max,part,counter,used,0l
Buckets -> Buckets( 			final Path basePath, 			final Bucketer<IN, BucketID> bucketer, 			final BucketFactory<IN, BucketID> bucketFactory, 			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory, 			final RollingPolicy<IN, BucketID> rollingPolicy, 			final int subtaskIndex) throws IOException;1533111305;A private constructor creating a new empty bucket manager.__@param basePath The base path for our buckets._@param bucketer The {@link Bucketer} provided by the user._@param bucketFactory The {@link BucketFactory} to be used to create buckets._@param partFileWriterFactory The {@link PartFileWriter.PartFileFactory} to be used when writing data._@param rollingPolicy The {@link RollingPolicy} as specified by the user.;Buckets(_			final Path basePath,_			final Bucketer<IN, BucketID> bucketer,_			final BucketFactory<IN, BucketID> bucketFactory,_			final PartFileWriter.PartFileFactory<IN, BucketID> partFileWriterFactory,_			final RollingPolicy<IN, BucketID> rollingPolicy,_			final int subtaskIndex) throws IOException {__		this.basePath = Preconditions.checkNotNull(basePath)__		this.bucketer = Preconditions.checkNotNull(bucketer)__		this.bucketFactory = Preconditions.checkNotNull(bucketFactory)__		this.partFileWriterFactory = Preconditions.checkNotNull(partFileWriterFactory)__		this.rollingPolicy = Preconditions.checkNotNull(rollingPolicy)__		this.subtaskIndex = subtaskIndex___		this.activeBuckets = new HashMap<>()__		this.bucketerContext = new Buckets.BucketerContext()___		this.fileSystemWriter = FileSystem.get(basePath.toUri()).createRecoverableWriter()__		this.bucketStateSerializer = new BucketStateSerializer<>(_				fileSystemWriter.getResumeRecoverableSerializer(),_				fileSystemWriter.getCommitRecoverableSerializer(),_				bucketer.getSerializer()_		)___		this.maxPartCounterUsed = 0L__	};a,private,constructor,creating,a,new,empty,bucket,manager,param,base,path,the,base,path,for,our,buckets,param,bucketer,the,link,bucketer,provided,by,the,user,param,bucket,factory,the,link,bucket,factory,to,be,used,to,create,buckets,param,part,file,writer,factory,the,link,part,file,writer,part,file,factory,to,be,used,when,writing,data,param,rolling,policy,the,link,rolling,policy,as,specified,by,the,user;buckets,final,path,base,path,final,bucketer,in,bucket,id,bucketer,final,bucket,factory,in,bucket,id,bucket,factory,final,part,file,writer,part,file,factory,in,bucket,id,part,file,writer,factory,final,rolling,policy,in,bucket,id,rolling,policy,final,int,subtask,index,throws,ioexception,this,base,path,preconditions,check,not,null,base,path,this,bucketer,preconditions,check,not,null,bucketer,this,bucket,factory,preconditions,check,not,null,bucket,factory,this,part,file,writer,factory,preconditions,check,not,null,part,file,writer,factory,this,rolling,policy,preconditions,check,not,null,rolling,policy,this,subtask,index,subtask,index,this,active,buckets,new,hash,map,this,bucketer,context,new,buckets,bucketer,context,this,file,system,writer,file,system,get,base,path,to,uri,create,recoverable,writer,this,bucket,state,serializer,new,bucket,state,serializer,file,system,writer,get,resume,recoverable,serializer,file,system,writer,get,commit,recoverable,serializer,bucketer,get,serializer,this,max,part,counter,used,0l
Buckets -> void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception;1532095949;Initializes the state after recovery from a failure._@param bucketStates the state holding recovered state about active buckets._@param partCounterState the state holding the max previously used part counters._@throws Exception;void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception {__		_		_		_		_		__		_		long maxCounter = 0L__		for (long partCounter: partCounterState.get()) {_			maxCounter = Math.max(partCounter, maxCounter)__		}_		initMaxPartCounter = maxCounter___		_		for (byte[] recoveredState : bucketStates.get()) {_			final BucketState<BucketID> bucketState = SimpleVersionedSerialization.readVersionAndDeSerialize(_					bucketStateSerializer, recoveredState)___			final BucketID bucketId = bucketState.getBucketId()___			LOG.info("Recovered bucket for {}", bucketId)___			final Bucket<IN, BucketID> restoredBucket = bucketFactory.restoreBucket(_					fileSystemWriter,_					subtaskIndex,_					initMaxPartCounter,_					partFileWriterFactory,_					bucketState_			)___			final Bucket<IN, BucketID> existingBucket = activeBuckets.get(bucketId)__			if (existingBucket == null) {_				activeBuckets.put(bucketId, restoredBucket)__			} else {_				existingBucket.merge(restoredBucket)__			}__			if (LOG.isDebugEnabled()) {_				LOG.debug("{} idx {} restored state for bucket {}", getClass().getSimpleName(),_						subtaskIndex, assembleBucketPath(bucketId))__			}_		}_	};initializes,the,state,after,recovery,from,a,failure,param,bucket,states,the,state,holding,recovered,state,about,active,buckets,param,part,counter,state,the,state,holding,the,max,previously,used,part,counters,throws,exception;void,initialize,state,final,list,state,byte,bucket,states,final,list,state,long,part,counter,state,throws,exception,long,max,counter,0l,for,long,part,counter,part,counter,state,get,max,counter,math,max,part,counter,max,counter,init,max,part,counter,max,counter,for,byte,recovered,state,bucket,states,get,final,bucket,state,bucket,id,bucket,state,simple,versioned,serialization,read,version,and,de,serialize,bucket,state,serializer,recovered,state,final,bucket,id,bucket,id,bucket,state,get,bucket,id,log,info,recovered,bucket,for,bucket,id,final,bucket,in,bucket,id,restored,bucket,bucket,factory,restore,bucket,file,system,writer,subtask,index,init,max,part,counter,part,file,writer,factory,bucket,state,final,bucket,in,bucket,id,existing,bucket,active,buckets,get,bucket,id,if,existing,bucket,null,active,buckets,put,bucket,id,restored,bucket,else,existing,bucket,merge,restored,bucket,if,log,is,debug,enabled,log,debug,idx,restored,state,for,bucket,get,class,get,simple,name,subtask,index,assemble,bucket,path,bucket,id
Buckets -> void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception;1532348102;Initializes the state after recovery from a failure._@param bucketStates the state holding recovered state about active buckets._@param partCounterState the state holding the max previously used part counters._@throws Exception;void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception {__		_		_		_		_		__		_		long maxCounter = 0L__		for (long partCounter: partCounterState.get()) {_			maxCounter = Math.max(partCounter, maxCounter)__		}_		initMaxPartCounter = maxCounter___		_		for (byte[] recoveredState : bucketStates.get()) {_			final BucketState<BucketID> bucketState = SimpleVersionedSerialization.readVersionAndDeSerialize(_					bucketStateSerializer, recoveredState)___			final BucketID bucketId = bucketState.getBucketId()___			LOG.info("Recovered bucket for {}", bucketId)___			final Bucket<IN, BucketID> restoredBucket = bucketFactory.restoreBucket(_					fileSystemWriter,_					subtaskIndex,_					initMaxPartCounter,_					partFileWriterFactory,_					bucketState_			)___			final Bucket<IN, BucketID> existingBucket = activeBuckets.get(bucketId)__			if (existingBucket == null) {_				activeBuckets.put(bucketId, restoredBucket)__			} else {_				existingBucket.merge(restoredBucket)__			}__			if (LOG.isDebugEnabled()) {_				LOG.debug("{} idx {} restored state for bucket {}", getClass().getSimpleName(),_						subtaskIndex, assembleBucketPath(bucketId))__			}_		}_	};initializes,the,state,after,recovery,from,a,failure,param,bucket,states,the,state,holding,recovered,state,about,active,buckets,param,part,counter,state,the,state,holding,the,max,previously,used,part,counters,throws,exception;void,initialize,state,final,list,state,byte,bucket,states,final,list,state,long,part,counter,state,throws,exception,long,max,counter,0l,for,long,part,counter,part,counter,state,get,max,counter,math,max,part,counter,max,counter,init,max,part,counter,max,counter,for,byte,recovered,state,bucket,states,get,final,bucket,state,bucket,id,bucket,state,simple,versioned,serialization,read,version,and,de,serialize,bucket,state,serializer,recovered,state,final,bucket,id,bucket,id,bucket,state,get,bucket,id,log,info,recovered,bucket,for,bucket,id,final,bucket,in,bucket,id,restored,bucket,bucket,factory,restore,bucket,file,system,writer,subtask,index,init,max,part,counter,part,file,writer,factory,bucket,state,final,bucket,in,bucket,id,existing,bucket,active,buckets,get,bucket,id,if,existing,bucket,null,active,buckets,put,bucket,id,restored,bucket,else,existing,bucket,merge,restored,bucket,if,log,is,debug,enabled,log,debug,idx,restored,state,for,bucket,get,class,get,simple,name,subtask,index,assemble,bucket,path,bucket,id
Buckets -> void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception;1533029605;Initializes the state after recovery from a failure._@param bucketStates the state holding recovered state about active buckets._@param partCounterState the state holding the max previously used part counters._@throws Exception;void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception {__		_		_		_		_		__		_		long maxCounter = 0L__		for (long partCounter: partCounterState.get()) {_			maxCounter = Math.max(partCounter, maxCounter)__		}_		initMaxPartCounter = maxCounter___		_		for (byte[] recoveredState : bucketStates.get()) {_			final BucketState<BucketID> bucketState = SimpleVersionedSerialization.readVersionAndDeSerialize(_					bucketStateSerializer, recoveredState)___			final BucketID bucketId = bucketState.getBucketId()___			LOG.info("Recovered bucket for {}", bucketId)___			final Bucket<IN, BucketID> restoredBucket = bucketFactory.restoreBucket(_					fileSystemWriter,_					subtaskIndex,_					initMaxPartCounter,_					partFileWriterFactory,_					bucketState_			)___			final Bucket<IN, BucketID> existingBucket = activeBuckets.get(bucketId)__			if (existingBucket == null) {_				activeBuckets.put(bucketId, restoredBucket)__			} else {_				existingBucket.merge(restoredBucket)__			}__			if (LOG.isDebugEnabled()) {_				LOG.debug("{} idx {} restored state for bucket {}", getClass().getSimpleName(),_						subtaskIndex, assembleBucketPath(bucketId))__			}_		}_	};initializes,the,state,after,recovery,from,a,failure,param,bucket,states,the,state,holding,recovered,state,about,active,buckets,param,part,counter,state,the,state,holding,the,max,previously,used,part,counters,throws,exception;void,initialize,state,final,list,state,byte,bucket,states,final,list,state,long,part,counter,state,throws,exception,long,max,counter,0l,for,long,part,counter,part,counter,state,get,max,counter,math,max,part,counter,max,counter,init,max,part,counter,max,counter,for,byte,recovered,state,bucket,states,get,final,bucket,state,bucket,id,bucket,state,simple,versioned,serialization,read,version,and,de,serialize,bucket,state,serializer,recovered,state,final,bucket,id,bucket,id,bucket,state,get,bucket,id,log,info,recovered,bucket,for,bucket,id,final,bucket,in,bucket,id,restored,bucket,bucket,factory,restore,bucket,file,system,writer,subtask,index,init,max,part,counter,part,file,writer,factory,bucket,state,final,bucket,in,bucket,id,existing,bucket,active,buckets,get,bucket,id,if,existing,bucket,null,active,buckets,put,bucket,id,restored,bucket,else,existing,bucket,merge,restored,bucket,if,log,is,debug,enabled,log,debug,idx,restored,state,for,bucket,get,class,get,simple,name,subtask,index,assemble,bucket,path,bucket,id
Buckets -> void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception;1533111305;Initializes the state after recovery from a failure._@param bucketStates the state holding recovered state about active buckets._@param partCounterState the state holding the max previously used part counters._@throws Exception;void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception {__		_		_		_		_		__		_		long maxCounter = 0L__		for (long partCounter: partCounterState.get()) {_			maxCounter = Math.max(partCounter, maxCounter)__		}_		maxPartCounterUsed = maxCounter___		_		for (byte[] recoveredState : bucketStates.get()) {_			final BucketState<BucketID> bucketState = SimpleVersionedSerialization.readVersionAndDeSerialize(_					bucketStateSerializer, recoveredState)___			final BucketID bucketId = bucketState.getBucketId()___			LOG.info("Recovered bucket for {}", bucketId)___			final Bucket<IN, BucketID> restoredBucket = bucketFactory.restoreBucket(_					fileSystemWriter,_					subtaskIndex,_					maxPartCounterUsed,_					partFileWriterFactory,_					bucketState_			)___			final Bucket<IN, BucketID> existingBucket = activeBuckets.get(bucketId)__			if (existingBucket == null) {_				activeBuckets.put(bucketId, restoredBucket)__			} else {_				existingBucket.merge(restoredBucket)__			}__			if (LOG.isDebugEnabled()) {_				LOG.debug("{} idx {} restored state for bucket {}", getClass().getSimpleName(),_						subtaskIndex, assembleBucketPath(bucketId))__			}_		}_	};initializes,the,state,after,recovery,from,a,failure,param,bucket,states,the,state,holding,recovered,state,about,active,buckets,param,part,counter,state,the,state,holding,the,max,previously,used,part,counters,throws,exception;void,initialize,state,final,list,state,byte,bucket,states,final,list,state,long,part,counter,state,throws,exception,long,max,counter,0l,for,long,part,counter,part,counter,state,get,max,counter,math,max,part,counter,max,counter,max,part,counter,used,max,counter,for,byte,recovered,state,bucket,states,get,final,bucket,state,bucket,id,bucket,state,simple,versioned,serialization,read,version,and,de,serialize,bucket,state,serializer,recovered,state,final,bucket,id,bucket,id,bucket,state,get,bucket,id,log,info,recovered,bucket,for,bucket,id,final,bucket,in,bucket,id,restored,bucket,bucket,factory,restore,bucket,file,system,writer,subtask,index,max,part,counter,used,part,file,writer,factory,bucket,state,final,bucket,in,bucket,id,existing,bucket,active,buckets,get,bucket,id,if,existing,bucket,null,active,buckets,put,bucket,id,restored,bucket,else,existing,bucket,merge,restored,bucket,if,log,is,debug,enabled,log,debug,idx,restored,state,for,bucket,get,class,get,simple,name,subtask,index,assemble,bucket,path,bucket,id
Buckets -> void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception;1533229113;Initializes the state after recovery from a failure.__<p>During this process:_<ol>_<li>we set the initial value for part counter to the maximum value used before across all tasks and buckets._This guarantees that we do not overwrite valid data,</li>_<li>we commit any pending files for previous checkpoints (previous to the last successful one from which we restore),</li>_<li>we resume writing to the previous in-progress file of each bucket, and</li>_<li>if we receive multiple states for the same bucket, we merge them.</li>_</ol>_@param bucketStates the state holding recovered state about active buckets._@param partCounterState the state holding the max previously used part counters._@throws Exception if anything goes wrong during retrieving the state or restoring/committing of any_in-progress/pending part files;void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception {_		initializePartCounter(partCounterState)__		initializeActiveBuckets(bucketStates)__	};initializes,the,state,after,recovery,from,a,failure,p,during,this,process,ol,li,we,set,the,initial,value,for,part,counter,to,the,maximum,value,used,before,across,all,tasks,and,buckets,this,guarantees,that,we,do,not,overwrite,valid,data,li,li,we,commit,any,pending,files,for,previous,checkpoints,previous,to,the,last,successful,one,from,which,we,restore,li,li,we,resume,writing,to,the,previous,in,progress,file,of,each,bucket,and,li,li,if,we,receive,multiple,states,for,the,same,bucket,we,merge,them,li,ol,param,bucket,states,the,state,holding,recovered,state,about,active,buckets,param,part,counter,state,the,state,holding,the,max,previously,used,part,counters,throws,exception,if,anything,goes,wrong,during,retrieving,the,state,or,restoring,committing,of,any,in,progress,pending,part,files;void,initialize,state,final,list,state,byte,bucket,states,final,list,state,long,part,counter,state,throws,exception,initialize,part,counter,part,counter,state,initialize,active,buckets,bucket,states
Buckets -> void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception;1533229145;Initializes the state after recovery from a failure.__<p>During this process:_<ol>_<li>we set the initial value for part counter to the maximum value used before across all tasks and buckets._This guarantees that we do not overwrite valid data,</li>_<li>we commit any pending files for previous checkpoints (previous to the last successful one from which we restore),</li>_<li>we resume writing to the previous in-progress file of each bucket, and</li>_<li>if we receive multiple states for the same bucket, we merge them.</li>_</ol>_@param bucketStates the state holding recovered state about active buckets._@param partCounterState the state holding the max previously used part counters._@throws Exception if anything goes wrong during retrieving the state or restoring/committing of any_in-progress/pending part files;void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception {__		initializePartCounter(partCounterState)___		LOG.info("Subtask {} initializing its state (max part counter={}).", subtaskIndex, maxPartCounter)___		initializeActiveBuckets(bucketStates)__	};initializes,the,state,after,recovery,from,a,failure,p,during,this,process,ol,li,we,set,the,initial,value,for,part,counter,to,the,maximum,value,used,before,across,all,tasks,and,buckets,this,guarantees,that,we,do,not,overwrite,valid,data,li,li,we,commit,any,pending,files,for,previous,checkpoints,previous,to,the,last,successful,one,from,which,we,restore,li,li,we,resume,writing,to,the,previous,in,progress,file,of,each,bucket,and,li,li,if,we,receive,multiple,states,for,the,same,bucket,we,merge,them,li,ol,param,bucket,states,the,state,holding,recovered,state,about,active,buckets,param,part,counter,state,the,state,holding,the,max,previously,used,part,counters,throws,exception,if,anything,goes,wrong,during,retrieving,the,state,or,restoring,committing,of,any,in,progress,pending,part,files;void,initialize,state,final,list,state,byte,bucket,states,final,list,state,long,part,counter,state,throws,exception,initialize,part,counter,part,counter,state,log,info,subtask,initializing,its,state,max,part,counter,subtask,index,max,part,counter,initialize,active,buckets,bucket,states
Buckets -> void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception;1541059170;Initializes the state after recovery from a failure.__<p>During this process:_<ol>_<li>we set the initial value for part counter to the maximum value used before across all tasks and buckets._This guarantees that we do not overwrite valid data,</li>_<li>we commit any pending files for previous checkpoints (previous to the last successful one from which we restore),</li>_<li>we resume writing to the previous in-progress file of each bucket, and</li>_<li>if we receive multiple states for the same bucket, we merge them.</li>_</ol>_@param bucketStates the state holding recovered state about active buckets._@param partCounterState the state holding the max previously used part counters._@throws Exception if anything goes wrong during retrieving the state or restoring/committing of any_in-progress/pending part files;void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception {__		initializePartCounter(partCounterState)___		LOG.info("Subtask {} initializing its state (max part counter={}).", subtaskIndex, maxPartCounter)___		initializeActiveBuckets(bucketStates)__	};initializes,the,state,after,recovery,from,a,failure,p,during,this,process,ol,li,we,set,the,initial,value,for,part,counter,to,the,maximum,value,used,before,across,all,tasks,and,buckets,this,guarantees,that,we,do,not,overwrite,valid,data,li,li,we,commit,any,pending,files,for,previous,checkpoints,previous,to,the,last,successful,one,from,which,we,restore,li,li,we,resume,writing,to,the,previous,in,progress,file,of,each,bucket,and,li,li,if,we,receive,multiple,states,for,the,same,bucket,we,merge,them,li,ol,param,bucket,states,the,state,holding,recovered,state,about,active,buckets,param,part,counter,state,the,state,holding,the,max,previously,used,part,counters,throws,exception,if,anything,goes,wrong,during,retrieving,the,state,or,restoring,committing,of,any,in,progress,pending,part,files;void,initialize,state,final,list,state,byte,bucket,states,final,list,state,long,part,counter,state,throws,exception,initialize,part,counter,part,counter,state,log,info,subtask,initializing,its,state,max,part,counter,subtask,index,max,part,counter,initialize,active,buckets,bucket,states
Buckets -> void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception;1547025573;Initializes the state after recovery from a failure.__<p>During this process:_<ol>_<li>we set the initial value for part counter to the maximum value used before across all tasks and buckets._This guarantees that we do not overwrite valid data,</li>_<li>we commit any pending files for previous checkpoints (previous to the last successful one from which we restore),</li>_<li>we resume writing to the previous in-progress file of each bucket, and</li>_<li>if we receive multiple states for the same bucket, we merge them.</li>_</ol>_@param bucketStates the state holding recovered state about active buckets._@param partCounterState the state holding the max previously used part counters._@throws Exception if anything goes wrong during retrieving the state or restoring/committing of any_in-progress/pending part files;void initializeState(final ListState<byte[]> bucketStates, final ListState<Long> partCounterState) throws Exception {__		initializePartCounter(partCounterState)___		LOG.info("Subtask {} initializing its state (max part counter={}).", subtaskIndex, maxPartCounter)___		initializeActiveBuckets(bucketStates)__	};initializes,the,state,after,recovery,from,a,failure,p,during,this,process,ol,li,we,set,the,initial,value,for,part,counter,to,the,maximum,value,used,before,across,all,tasks,and,buckets,this,guarantees,that,we,do,not,overwrite,valid,data,li,li,we,commit,any,pending,files,for,previous,checkpoints,previous,to,the,last,successful,one,from,which,we,restore,li,li,we,resume,writing,to,the,previous,in,progress,file,of,each,bucket,and,li,li,if,we,receive,multiple,states,for,the,same,bucket,we,merge,them,li,ol,param,bucket,states,the,state,holding,recovered,state,about,active,buckets,param,part,counter,state,the,state,holding,the,max,previously,used,part,counters,throws,exception,if,anything,goes,wrong,during,retrieving,the,state,or,restoring,committing,of,any,in,progress,pending,part,files;void,initialize,state,final,list,state,byte,bucket,states,final,list,state,long,part,counter,state,throws,exception,initialize,part,counter,part,counter,state,log,info,subtask,initializing,its,state,max,part,counter,subtask,index,max,part,counter,initialize,active,buckets,bucket,states
