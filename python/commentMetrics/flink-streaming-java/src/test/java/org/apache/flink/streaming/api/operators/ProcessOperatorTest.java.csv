# id;timestamp;commentText;codeText;commentWords;codeWords
ProcessOperatorTest -> @Test 	public void testProcessingTimeTimerWithState() throws Exception;1480354709;Verifies that we don't have leakage between different keys.;@Test_	public void testProcessingTimeTimerWithState() throws Exception {__		ProcessOperator<Integer, Integer, String> operator =_				new ProcessOperator<>(new TriggeringStatefulFlatMapFunction(TimeDomain.PROCESSING_TIME))___		OneInputStreamOperatorTestHarness<Integer, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.setup()__		testHarness.open()___		testHarness.setProcessingTime(1)__		testHarness.processElement(new StreamRecord<>(17))_ __		testHarness.setProcessingTime(2)__		testHarness.processElement(new StreamRecord<>(42))_ __		testHarness.setProcessingTime(6)__		testHarness.setProcessingTime(7)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()___		expectedOutput.add(new StreamRecord<>("INPUT:17"))__		expectedOutput.add(new StreamRecord<>("INPUT:42"))__		expectedOutput.add(new StreamRecord<>("STATE:17", 6L))__		expectedOutput.add(new StreamRecord<>("STATE:42", 7L))___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.close()__	};verifies,that,we,don,t,have,leakage,between,different,keys;test,public,void,test,processing,time,timer,with,state,throws,exception,process,operator,integer,integer,string,operator,new,process,operator,new,triggering,stateful,flat,map,function,time,domain,one,input,stream,operator,test,harness,integer,string,test,harness,new,keyed,one,input,stream,operator,test,harness,operator,new,identity,key,selector,integer,basic,type,info,test,harness,setup,test,harness,open,test,harness,set,processing,time,1,test,harness,process,element,new,stream,record,17,test,harness,set,processing,time,2,test,harness,process,element,new,stream,record,42,test,harness,set,processing,time,6,test,harness,set,processing,time,7,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,input,17,expected,output,add,new,stream,record,input,42,expected,output,add,new,stream,record,state,17,6l,expected,output,add,new,stream,record,state,42,7l,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,close
ProcessOperatorTest -> @Test 	public void testProcessingTimeTimerWithState() throws Exception;1484303457;Verifies that we don't have leakage between different keys.;@Test_	public void testProcessingTimeTimerWithState() throws Exception {__		ProcessOperator<Integer, Integer, String> operator =_				new ProcessOperator<>(new TriggeringStatefulFlatMapFunction(TimeDomain.PROCESSING_TIME))___		OneInputStreamOperatorTestHarness<Integer, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.setup()__		testHarness.open()___		testHarness.setProcessingTime(1)__		testHarness.processElement(new StreamRecord<>(17))_ __		testHarness.setProcessingTime(2)__		testHarness.processElement(new StreamRecord<>(42))_ __		testHarness.setProcessingTime(6)__		testHarness.setProcessingTime(7)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()___		expectedOutput.add(new StreamRecord<>("INPUT:17"))__		expectedOutput.add(new StreamRecord<>("INPUT:42"))__		expectedOutput.add(new StreamRecord<>("STATE:17", 6L))__		expectedOutput.add(new StreamRecord<>("STATE:42", 7L))___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.close()__	};verifies,that,we,don,t,have,leakage,between,different,keys;test,public,void,test,processing,time,timer,with,state,throws,exception,process,operator,integer,integer,string,operator,new,process,operator,new,triggering,stateful,flat,map,function,time,domain,one,input,stream,operator,test,harness,integer,string,test,harness,new,keyed,one,input,stream,operator,test,harness,operator,new,identity,key,selector,integer,basic,type,info,test,harness,setup,test,harness,open,test,harness,set,processing,time,1,test,harness,process,element,new,stream,record,17,test,harness,set,processing,time,2,test,harness,process,element,new,stream,record,42,test,harness,set,processing,time,6,test,harness,set,processing,time,7,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,input,17,expected,output,add,new,stream,record,input,42,expected,output,add,new,stream,record,state,17,6l,expected,output,add,new,stream,record,state,42,7l,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,close
ProcessOperatorTest -> @Test 	public void testProcessingTimeTimerWithState() throws Exception;1488799576;Verifies that we don't have leakage between different keys.;@Test_	public void testProcessingTimeTimerWithState() throws Exception {__		ProcessOperator<Integer, Integer, String> operator =_				new ProcessOperator<>(new TriggeringStatefulFlatMapFunction(TimeDomain.PROCESSING_TIME))___		OneInputStreamOperatorTestHarness<Integer, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.setup()__		testHarness.open()___		testHarness.setProcessingTime(1)__		testHarness.processElement(new StreamRecord<>(17))_ __		testHarness.setProcessingTime(2)__		testHarness.processElement(new StreamRecord<>(42))_ __		testHarness.setProcessingTime(6)__		testHarness.setProcessingTime(7)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()___		expectedOutput.add(new StreamRecord<>("INPUT:17"))__		expectedOutput.add(new StreamRecord<>("INPUT:42"))__		expectedOutput.add(new StreamRecord<>("STATE:17", 6L))__		expectedOutput.add(new StreamRecord<>("STATE:42", 7L))___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.close()__	};verifies,that,we,don,t,have,leakage,between,different,keys;test,public,void,test,processing,time,timer,with,state,throws,exception,process,operator,integer,integer,string,operator,new,process,operator,new,triggering,stateful,flat,map,function,time,domain,one,input,stream,operator,test,harness,integer,string,test,harness,new,keyed,one,input,stream,operator,test,harness,operator,new,identity,key,selector,integer,basic,type,info,test,harness,setup,test,harness,open,test,harness,set,processing,time,1,test,harness,process,element,new,stream,record,17,test,harness,set,processing,time,2,test,harness,process,element,new,stream,record,42,test,harness,set,processing,time,6,test,harness,set,processing,time,7,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,stream,record,input,17,expected,output,add,new,stream,record,input,42,expected,output,add,new,stream,record,state,17,6l,expected,output,add,new,stream,record,state,42,7l,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,close
ProcessOperatorTest -> @Test 	public void testEventTimeTimerWithState() throws Exception;1480354709;Verifies that we don't have leakage between different keys.;@Test_	public void testEventTimeTimerWithState() throws Exception {__		ProcessOperator<Integer, Integer, String> operator =_				new ProcessOperator<>(new TriggeringStatefulFlatMapFunction(TimeDomain.EVENT_TIME))___		OneInputStreamOperatorTestHarness<Integer, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.setup()__		testHarness.open()___		testHarness.processWatermark(new Watermark(1))__		testHarness.processElement(new StreamRecord<>(17, 0L))_ __		testHarness.processWatermark(new Watermark(2))__		testHarness.processElement(new StreamRecord<>(42, 1L))_ __		testHarness.processWatermark(new Watermark(6))__		testHarness.processWatermark(new Watermark(7))___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()___		expectedOutput.add(new Watermark(1L))__		expectedOutput.add(new StreamRecord<>("INPUT:17", 0L))__		expectedOutput.add(new Watermark(2L))__		expectedOutput.add(new StreamRecord<>("INPUT:42", 1L))__		expectedOutput.add(new StreamRecord<>("STATE:17", 6L))__		expectedOutput.add(new Watermark(6L))__		expectedOutput.add(new StreamRecord<>("STATE:42", 7L))__		expectedOutput.add(new Watermark(7L))___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.close()__	};verifies,that,we,don,t,have,leakage,between,different,keys;test,public,void,test,event,time,timer,with,state,throws,exception,process,operator,integer,integer,string,operator,new,process,operator,new,triggering,stateful,flat,map,function,time,domain,one,input,stream,operator,test,harness,integer,string,test,harness,new,keyed,one,input,stream,operator,test,harness,operator,new,identity,key,selector,integer,basic,type,info,test,harness,setup,test,harness,open,test,harness,process,watermark,new,watermark,1,test,harness,process,element,new,stream,record,17,0l,test,harness,process,watermark,new,watermark,2,test,harness,process,element,new,stream,record,42,1l,test,harness,process,watermark,new,watermark,6,test,harness,process,watermark,new,watermark,7,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,watermark,1l,expected,output,add,new,stream,record,input,17,0l,expected,output,add,new,watermark,2l,expected,output,add,new,stream,record,input,42,1l,expected,output,add,new,stream,record,state,17,6l,expected,output,add,new,watermark,6l,expected,output,add,new,stream,record,state,42,7l,expected,output,add,new,watermark,7l,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,close
ProcessOperatorTest -> @Test 	public void testEventTimeTimerWithState() throws Exception;1484303457;Verifies that we don't have leakage between different keys.;@Test_	public void testEventTimeTimerWithState() throws Exception {__		ProcessOperator<Integer, Integer, String> operator =_				new ProcessOperator<>(new TriggeringStatefulFlatMapFunction(TimeDomain.EVENT_TIME))___		OneInputStreamOperatorTestHarness<Integer, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.setup()__		testHarness.open()___		testHarness.processWatermark(new Watermark(1))__		testHarness.processElement(new StreamRecord<>(17, 0L))_ __		testHarness.processWatermark(new Watermark(2))__		testHarness.processElement(new StreamRecord<>(42, 1L))_ __		testHarness.processWatermark(new Watermark(6))__		testHarness.processWatermark(new Watermark(7))___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()___		expectedOutput.add(new Watermark(1L))__		expectedOutput.add(new StreamRecord<>("INPUT:17", 0L))__		expectedOutput.add(new Watermark(2L))__		expectedOutput.add(new StreamRecord<>("INPUT:42", 1L))__		expectedOutput.add(new StreamRecord<>("STATE:17", 6L))__		expectedOutput.add(new Watermark(6L))__		expectedOutput.add(new StreamRecord<>("STATE:42", 7L))__		expectedOutput.add(new Watermark(7L))___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.close()__	};verifies,that,we,don,t,have,leakage,between,different,keys;test,public,void,test,event,time,timer,with,state,throws,exception,process,operator,integer,integer,string,operator,new,process,operator,new,triggering,stateful,flat,map,function,time,domain,one,input,stream,operator,test,harness,integer,string,test,harness,new,keyed,one,input,stream,operator,test,harness,operator,new,identity,key,selector,integer,basic,type,info,test,harness,setup,test,harness,open,test,harness,process,watermark,new,watermark,1,test,harness,process,element,new,stream,record,17,0l,test,harness,process,watermark,new,watermark,2,test,harness,process,element,new,stream,record,42,1l,test,harness,process,watermark,new,watermark,6,test,harness,process,watermark,new,watermark,7,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,watermark,1l,expected,output,add,new,stream,record,input,17,0l,expected,output,add,new,watermark,2l,expected,output,add,new,stream,record,input,42,1l,expected,output,add,new,stream,record,state,17,6l,expected,output,add,new,watermark,6l,expected,output,add,new,stream,record,state,42,7l,expected,output,add,new,watermark,7l,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,close
ProcessOperatorTest -> @Test 	public void testEventTimeTimerWithState() throws Exception;1488799576;Verifies that we don't have leakage between different keys.;@Test_	public void testEventTimeTimerWithState() throws Exception {__		ProcessOperator<Integer, Integer, String> operator =_				new ProcessOperator<>(new TriggeringStatefulFlatMapFunction(TimeDomain.EVENT_TIME))___		OneInputStreamOperatorTestHarness<Integer, String> testHarness =_				new KeyedOneInputStreamOperatorTestHarness<>(operator, new IdentityKeySelector<Integer>(), BasicTypeInfo.INT_TYPE_INFO)___		testHarness.setup()__		testHarness.open()___		testHarness.processWatermark(new Watermark(1))__		testHarness.processElement(new StreamRecord<>(17, 0L))_ __		testHarness.processWatermark(new Watermark(2))__		testHarness.processElement(new StreamRecord<>(42, 1L))_ __		testHarness.processWatermark(new Watermark(6))__		testHarness.processWatermark(new Watermark(7))___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<>()___		expectedOutput.add(new Watermark(1L))__		expectedOutput.add(new StreamRecord<>("INPUT:17", 0L))__		expectedOutput.add(new Watermark(2L))__		expectedOutput.add(new StreamRecord<>("INPUT:42", 1L))__		expectedOutput.add(new StreamRecord<>("STATE:17", 6L))__		expectedOutput.add(new Watermark(6L))__		expectedOutput.add(new StreamRecord<>("STATE:42", 7L))__		expectedOutput.add(new Watermark(7L))___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.close()__	};verifies,that,we,don,t,have,leakage,between,different,keys;test,public,void,test,event,time,timer,with,state,throws,exception,process,operator,integer,integer,string,operator,new,process,operator,new,triggering,stateful,flat,map,function,time,domain,one,input,stream,operator,test,harness,integer,string,test,harness,new,keyed,one,input,stream,operator,test,harness,operator,new,identity,key,selector,integer,basic,type,info,test,harness,setup,test,harness,open,test,harness,process,watermark,new,watermark,1,test,harness,process,element,new,stream,record,17,0l,test,harness,process,watermark,new,watermark,2,test,harness,process,element,new,stream,record,42,1l,test,harness,process,watermark,new,watermark,6,test,harness,process,watermark,new,watermark,7,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,expected,output,add,new,watermark,1l,expected,output,add,new,stream,record,input,17,0l,expected,output,add,new,watermark,2l,expected,output,add,new,stream,record,input,42,1l,expected,output,add,new,stream,record,state,17,6l,expected,output,add,new,watermark,6l,expected,output,add,new,stream,record,state,42,7l,expected,output,add,new,watermark,7l,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,close
