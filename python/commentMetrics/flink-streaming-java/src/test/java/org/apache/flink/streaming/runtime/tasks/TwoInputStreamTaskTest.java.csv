# id;timestamp;commentText;codeText;commentWords;codeWords
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1486732842;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				coMapTask, 2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)____		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1487871589;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				coMapTask, 2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)____		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1495484544;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				coMapTask, 2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1502801814;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				coMapTask, 2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1509118643;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				coMapTask, 2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1515519059;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				TwoInputStreamTask::new,_				2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1517489695;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				TwoInputStreamTask::new,_				2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1517584327;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				TwoInputStreamTask::new,_				2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1528997616;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				TwoInputStreamTask::new,_				2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1531303507;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				TwoInputStreamTask::new,_				2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1535979810;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				TwoInputStreamTask::new,_				2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkAndStreamStatusForwarding() throws Exception;1550833397;This test verifies that watermarks and stream statuses are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all active inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkAndStreamStatusForwarding() throws Exception {__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_			new TwoInputStreamTaskTestHarness<String, Integer, String>(_				TwoInputStreamTask::new,_				2, 2, new int[] {1, 2},_				BasicTypeInfo.STRING_TYPE_INFO,_				BasicTypeInfo.INT_TYPE_INFO,_				BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)___		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 1)__		testHarness.processElement(StreamStatus.IDLE, 1, 0)__		testHarness.processElement(new Watermark(initialTime + 6), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 5), 1, 1)_ _		testHarness.processElement(StreamStatus.IDLE, 1, 1)_ _		                                                     _		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 5))__		_		_		_		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.IDLE, 0, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.IDLE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(StreamStatus.ACTIVE, 1, 0)__		testHarness.processElement(StreamStatus.ACTIVE, 0, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(StreamStatus.ACTIVE)__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,and,stream,statuses,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,active,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,and,stream,status,forwarding,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,1,test,harness,process,element,stream,status,idle,1,0,test,harness,process,element,new,watermark,initial,time,6,0,0,test,harness,process,element,new,watermark,initial,time,5,1,1,test,harness,process,element,stream,status,idle,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,5,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,idle,0,0,test,harness,wait,for,input,processing,expected,output,add,stream,status,idle,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,stream,status,active,1,0,test,harness,process,element,stream,status,active,0,1,test,harness,wait,for,input,processing,expected,output,add,stream,status,active,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1445418103;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1453902315;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1467026067;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1476972861;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1478257462;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1478636134;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1480624969;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1486732842;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1487871589;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1495484544;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1502801814;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1509118643;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1515519059;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1517489695;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1517584327;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1528997616;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1531303507;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1535979810;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods where not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,where,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOpenCloseAndTimestamps() throws Exception;1550833397;This test verifies that open() and close() are correctly called. This test also verifies_that timestamps of emitted elements are correct. {@link CoStreamMap} assigns the input_timestamp to emitted elements.;@Test_	@SuppressWarnings("unchecked")_	public void testOpenCloseAndTimestamps() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new TestOpenCloseMapFunction())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		long initialTime = 0L__		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new StreamRecord<String>("Hello", initialTime + 1), 0, 0)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime + 1))___		_		testHarness.waitForInputProcessing()___		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime + 2), 1, 0)___		expectedOutput.add(new StreamRecord<String>("1337", initialTime + 2))___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		Assert.assertTrue("RichFunction methods were not called.", TestOpenCloseMapFunction.closeCalled)___		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())__	};this,test,verifies,that,open,and,close,are,correctly,called,this,test,also,verifies,that,timestamps,of,emitted,elements,are,correct,link,co,stream,map,assigns,the,input,timestamp,to,emitted,elements;test,suppress,warnings,unchecked,public,void,test,open,close,and,timestamps,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,test,open,close,map,function,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,long,initial,time,0l,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,stream,record,string,hello,initial,time,1,0,0,expected,output,add,new,stream,record,string,hello,initial,time,1,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,1337,initial,time,2,1,0,expected,output,add,new,stream,record,string,1337,initial,time,2,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,assert,assert,true,rich,function,methods,were,not,called,test,open,close,map,function,close,called,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1445418103;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()____		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1453902315;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()____		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1467026067;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()____		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1476972861;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()____		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1478257462;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()____		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1478636134;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()____		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1480624969;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()____		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1486732842;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()____		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1487871589;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()____		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1495484544;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1502801814;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forFullCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,full,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1509118643;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1515519059;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpoint()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1517489695;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1517584327;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1528997616;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1531303507;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1535979810;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testOvertakingCheckpointBarriers() throws Exception;1550833397;This test verifies that checkpoint barriers and barrier buffers work correctly with_concurrent checkpoint barriers where one checkpoint is "overtaking" another checkpoint, i.e._some inputs receive barriers from an earlier checkpoint, thereby blocking,_then all inputs receive barriers from a later checkpoint.;@Test_	@SuppressWarnings("unchecked")_	public void testOvertakingCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 0)___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(1337, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("42", initialTime))__		expectedOutput.add(new StreamRecord<String>("1337", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		_		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		expectedOutput.add(new CancelCheckpointMarker(0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))__		expectedOutput.add(new CheckpointBarrier(1, 1, CheckpointOptions.forCheckpointWithDefaultLocation()))___		testHarness.waitForInputProcessing()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		_		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())__	};this,test,verifies,that,checkpoint,barriers,and,barrier,buffers,work,correctly,with,concurrent,checkpoint,barriers,where,one,checkpoint,is,overtaking,another,checkpoint,i,e,some,inputs,receive,barriers,from,an,earlier,checkpoint,thereby,blocking,then,all,inputs,receive,barriers,from,a,later,checkpoint;test,suppress,warnings,unchecked,public,void,test,overtaking,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,test,harness,process,element,new,stream,record,integer,1337,initial,time,1,1,expected,output,add,new,stream,record,string,42,initial,time,expected,output,add,new,stream,record,string,1337,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,1,1,expected,output,add,new,cancel,checkpoint,marker,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,expected,output,add,new,checkpoint,barrier,1,1,checkpoint,options,for,checkpoint,with,default,location,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1445418103;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)____		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1453902315;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)____		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1467026067;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)____		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1476972861;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)____		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1478257462;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)____		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1478636134;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)____		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testWatermarkForwarding() throws Exception;1480624969;This test verifies that watermarks are correctly forwarded. This also checks whether_watermarks are forwarded only when we have received watermarks from all inputs. The_forwarded watermark must be the minimum of the watermarks of all inputs.;@Test_	@SuppressWarnings("unchecked")_	public void testWatermarkForwarding() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processElement(new Watermark(initialTime), 0, 0)__		testHarness.processElement(new Watermark(initialTime), 0, 1)___		testHarness.processElement(new Watermark(initialTime), 1, 0)____		_		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime), 1, 1)___		_		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		testHarness.processElement(new StreamRecord<String>("Hello", initialTime), 0, 0)__		testHarness.processElement(new StreamRecord<Integer>(42, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("Hello", initialTime))__		expectedOutput.add(new StreamRecord<String>("42", initialTime))___		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.processElement(new Watermark(initialTime + 4), 0, 0)__		testHarness.processElement(new Watermark(initialTime + 3), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 3), 1, 0)__		testHarness.processElement(new Watermark(initialTime + 2), 1, 1)___		_		_		expectedOutput.add(new Watermark(initialTime + 2))__		testHarness.waitForInputProcessing()__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())____		_		_		testHarness.processElement(new Watermark(initialTime + 4), 1, 1)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 3))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		_		_		testHarness.processElement(new Watermark(initialTime + 4), 0, 1)__		testHarness.processElement(new Watermark(initialTime + 4), 1, 0)__		testHarness.waitForInputProcessing()__		expectedOutput.add(new Watermark(initialTime + 4))__		TestHarnessUtil.assertOutputEquals("Output was not correct.", expectedOutput, testHarness.getOutput())___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(2, resultElements.size())__	};this,test,verifies,that,watermarks,are,correctly,forwarded,this,also,checks,whether,watermarks,are,forwarded,only,when,we,have,received,watermarks,from,all,inputs,the,forwarded,watermark,must,be,the,minimum,of,the,watermarks,of,all,inputs;test,suppress,warnings,unchecked,public,void,test,watermark,forwarding,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,element,new,watermark,initial,time,0,0,test,harness,process,element,new,watermark,initial,time,0,1,test,harness,process,element,new,watermark,initial,time,1,0,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,stream,record,string,hello,initial,time,0,0,test,harness,process,element,new,stream,record,integer,42,initial,time,1,1,expected,output,add,new,stream,record,string,hello,initial,time,expected,output,add,new,stream,record,string,42,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,0,test,harness,process,element,new,watermark,initial,time,3,0,1,test,harness,process,element,new,watermark,initial,time,3,1,0,test,harness,process,element,new,watermark,initial,time,2,1,1,expected,output,add,new,watermark,initial,time,2,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,1,1,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,3,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,element,new,watermark,initial,time,4,0,1,test,harness,process,element,new,watermark,initial,time,4,1,0,test,harness,wait,for,input,processing,expected,output,add,new,watermark,initial,time,4,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,2,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1445418103;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				testHarness.getOutput(),_				expectedOutput)___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				testHarness.getOutput(),_				expectedOutput)___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,test,harness,get,output,expected,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,test,harness,get,output,expected,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1453902315;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				testHarness.getOutput(),_				expectedOutput)___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				testHarness.getOutput(),_				expectedOutput)___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,test,harness,get,output,expected,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,test,harness,get,output,expected,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1467026067;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				testHarness.getOutput(),_				expectedOutput)___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))__		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				testHarness.getOutput(),_				expectedOutput)___		testHarness.endInput()___		testHarness.waitForTaskCompletion()___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,test,harness,util,assert,output,equals,output,was,not,correct,test,harness,get,output,expected,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,test,harness,get,output,expected,output,test,harness,end,input,test,harness,wait,for,task,completion,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1476972861;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				testHarness.getOutput(),_				expectedOutput)___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,test,harness,get,output,expected,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1478257462;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				testHarness.getOutput(),_				expectedOutput)___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,test,harness,get,output,expected,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1478636134;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				testHarness.getOutput(),_				expectedOutput)___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,test,harness,get,output,expected,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1480624969;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1486732842;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1487871589;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())____		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1495484544;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1502801814;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forFullCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,full,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1509118643;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTask<String, Integer, String> coMapTask = new TwoInputStreamTask<String, Integer, String>()__		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness = new TwoInputStreamTaskTestHarness<String, Integer, String>(coMapTask, 2, 2, new int[] {1, 2}, BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,string,integer,string,co,map,task,new,two,input,stream,task,string,integer,string,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,co,map,task,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1515519059;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<String, Integer, String>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpoint()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1517489695;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<String, Integer, String>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1517584327;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<String, Integer, String>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1528997616;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<String, Integer, String>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1531303507;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<String, Integer, String>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1535979810;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<String, Integer, String>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
TwoInputStreamTaskTest -> @Test 	@SuppressWarnings("unchecked") 	public void testCheckpointBarriers() throws Exception;1550833397;This test verifies that checkpoint barriers are correctly forwarded.;@Test_	@SuppressWarnings("unchecked")_	public void testCheckpointBarriers() throws Exception {_		final TwoInputStreamTaskTestHarness<String, Integer, String> testHarness =_				new TwoInputStreamTaskTestHarness<String, Integer, String>(_						TwoInputStreamTask::new,_						2, 2, new int[] {1, 2},_						BasicTypeInfo.STRING_TYPE_INFO, BasicTypeInfo.INT_TYPE_INFO, BasicTypeInfo.STRING_TYPE_INFO)__		testHarness.setupOutputForSingletonOperatorChain()___		StreamConfig streamConfig = testHarness.getStreamConfig()__		CoStreamMap<String, Integer, String> coMapOperator = new CoStreamMap<String, Integer, String>(new IdentityMap())__		streamConfig.setStreamOperator(coMapOperator)__		streamConfig.setOperatorID(new OperatorID())___		ConcurrentLinkedQueue<Object> expectedOutput = new ConcurrentLinkedQueue<Object>()__		long initialTime = 0L___		testHarness.invoke()__		testHarness.waitForTaskRunning()___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 0)___		_		_		testHarness.processElement(new StreamRecord<String>("Hello-0-0", initialTime), 0, 0)___		_		testHarness.processElement(new StreamRecord<String>("Ciao-0-0", initialTime), 0, 1)__		expectedOutput.add(new StreamRecord<String>("Ciao-0-0", initialTime))___		testHarness.waitForInputProcessing()___		_		_		_		testHarness.processElement(new StreamRecord<Integer>(11, initialTime), 1, 1)__		testHarness.processElement(new StreamRecord<Integer>(111, initialTime), 1, 1)__		expectedOutput.add(new StreamRecord<String>("11", initialTime))__		expectedOutput.add(new StreamRecord<String>("111", initialTime))___		testHarness.waitForInputProcessing()___		_		_		for (int i = 0_ i < 20_ ++i) {_			if (testHarness.getOutput().size() >= expectedOutput.size()) {_				break__			} else {_				Thread.sleep(100)__			}_		}__		_		TestHarnessUtil.assertOutputEquals("Output was not correct.",_			expectedOutput,_			testHarness.getOutput())___		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 0, 1)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 0)__		testHarness.processEvent(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()), 1, 1)___		testHarness.waitForInputProcessing()__		testHarness.endInput()__		testHarness.waitForTaskCompletion()___		_		expectedOutput.add(new CheckpointBarrier(0, 0, CheckpointOptions.forCheckpointWithDefaultLocation()))__		expectedOutput.add(new StreamRecord<String>("Hello-0-0", initialTime))___		TestHarnessUtil.assertOutputEquals("Output was not correct.",_				expectedOutput,_				testHarness.getOutput())___		List<String> resultElements = TestHarnessUtil.getRawElementsFromOutput(testHarness.getOutput())__		Assert.assertEquals(4, resultElements.size())__	};this,test,verifies,that,checkpoint,barriers,are,correctly,forwarded;test,suppress,warnings,unchecked,public,void,test,checkpoint,barriers,throws,exception,final,two,input,stream,task,test,harness,string,integer,string,test,harness,new,two,input,stream,task,test,harness,string,integer,string,two,input,stream,task,new,2,2,new,int,1,2,basic,type,info,basic,type,info,basic,type,info,test,harness,setup,output,for,singleton,operator,chain,stream,config,stream,config,test,harness,get,stream,config,co,stream,map,string,integer,string,co,map,operator,new,co,stream,map,string,integer,string,new,identity,map,stream,config,set,stream,operator,co,map,operator,stream,config,set,operator,id,new,operator,id,concurrent,linked,queue,object,expected,output,new,concurrent,linked,queue,object,long,initial,time,0l,test,harness,invoke,test,harness,wait,for,task,running,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,0,test,harness,process,element,new,stream,record,string,hello,0,0,initial,time,0,0,test,harness,process,element,new,stream,record,string,ciao,0,0,initial,time,0,1,expected,output,add,new,stream,record,string,ciao,0,0,initial,time,test,harness,wait,for,input,processing,test,harness,process,element,new,stream,record,integer,11,initial,time,1,1,test,harness,process,element,new,stream,record,integer,111,initial,time,1,1,expected,output,add,new,stream,record,string,11,initial,time,expected,output,add,new,stream,record,string,111,initial,time,test,harness,wait,for,input,processing,for,int,i,0,i,20,i,if,test,harness,get,output,size,expected,output,size,break,else,thread,sleep,100,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,0,1,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,0,test,harness,process,event,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,1,1,test,harness,wait,for,input,processing,test,harness,end,input,test,harness,wait,for,task,completion,expected,output,add,new,checkpoint,barrier,0,0,checkpoint,options,for,checkpoint,with,default,location,expected,output,add,new,stream,record,string,hello,0,0,initial,time,test,harness,util,assert,output,equals,output,was,not,correct,expected,output,test,harness,get,output,list,string,result,elements,test,harness,util,get,raw,elements,from,output,test,harness,get,output,assert,assert,equals,4,result,elements,size
