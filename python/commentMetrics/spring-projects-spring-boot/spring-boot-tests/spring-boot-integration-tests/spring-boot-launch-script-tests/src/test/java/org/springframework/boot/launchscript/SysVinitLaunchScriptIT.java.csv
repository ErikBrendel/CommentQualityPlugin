commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;10;;@Parameters(name = "{0} {1}") public static List<Object[]> parameters() {     List<Object[]> parameters = new ArrayList<>().     for (File os : new File("src/test/resources/conf").listFiles()) {         for (File version : os.listFiles()) {             parameters.add(new Object[] { os.getName(), version.getName() }).         }     }     return parameters. }
false;public;0;6;;@Test public void statusWhenStopped() throws Exception {     String output = doTest("status-when-stopped.sh").     assertThat(output).contains("Status: 3").     assertThat(output).has(coloredString(AnsiColor.RED, "Not running")). }
false;public;0;7;;@Test public void statusWhenStarted() throws Exception {     String output = doTest("status-when-started.sh").     assertThat(output).contains("Status: 0").     assertThat(output).has(coloredString(AnsiColor.GREEN, "Started [" + extractPid(output) + "]")). }
false;public;0;7;;@Test public void statusWhenKilled() throws Exception {     String output = doTest("status-when-killed.sh").     assertThat(output).contains("Status: 1").     assertThat(output).has(coloredString(AnsiColor.RED, "Not running (process " + extractPid(output) + " not found)")). }
false;public;0;7;;@Test public void stopWhenStopped() throws Exception {     String output = doTest("stop-when-stopped.sh").     assertThat(output).contains("Status: 0").     assertThat(output).has(coloredString(AnsiColor.YELLOW, "Not running (pidfile not found)")). }
false;public;0;7;;@Test public void forceStopWhenStopped() throws Exception {     String output = doTest("force-stop-when-stopped.sh").     assertThat(output).contains("Status: 0").     assertThat(output).has(coloredString(AnsiColor.YELLOW, "Not running (pidfile not found)")). }
false;public;0;7;;@Test public void startWhenStarted() throws Exception {     String output = doTest("start-when-started.sh").     assertThat(output).contains("Status: 0").     assertThat(output).has(coloredString(AnsiColor.YELLOW, "Already running [" + extractPid(output) + "]")). }
false;public;0;9;;@Test public void restartWhenStopped() throws Exception {     String output = doTest("restart-when-stopped.sh").     assertThat(output).contains("Status: 0").     assertThat(output).has(coloredString(AnsiColor.YELLOW, "Not running (pidfile not found)")).     assertThat(output).has(coloredString(AnsiColor.GREEN, "Started [" + extractPid(output) + "]")). }
false;public;0;11;;@Test public void restartWhenStarted() throws Exception {     String output = doTest("restart-when-started.sh").     assertThat(output).contains("Status: 0").     assertThat(output).has(coloredString(AnsiColor.GREEN, "Started [" + extract("PID1", output) + "]")).     assertThat(output).has(coloredString(AnsiColor.GREEN, "Stopped [" + extract("PID1", output) + "]")).     assertThat(output).has(coloredString(AnsiColor.GREEN, "Started [" + extract("PID2", output) + "]")). }
false;public;0;7;;@Test public void startWhenStopped() throws Exception {     String output = doTest("start-when-stopped.sh").     assertThat(output).contains("Status: 0").     assertThat(output).has(coloredString(AnsiColor.GREEN, "Started [" + extractPid(output) + "]")). }
false;public;0;5;;@Test public void basicLaunch() throws Exception {     String output = doTest("basic-launch.sh").     assertThat(output).doesNotContain("PID_FOLDER"). }
false;public;0;6;;@Test public void launchWithMissingLogFolderGeneratesAWarning() throws Exception {     String output = doTest("launch-with-missing-log-folder.sh").     assertThat(output).has(coloredString(AnsiColor.YELLOW, "LOG_FOLDER /does/not/exist does not exist. Falling back to /tmp")). }
false;public;0;6;;@Test public void launchWithMissingPidFolderGeneratesAWarning() throws Exception {     String output = doTest("launch-with-missing-pid-folder.sh").     assertThat(output).has(coloredString(AnsiColor.YELLOW, "PID_FOLDER /does/not/exist does not exist. Falling back to /tmp")). }
false;public;0;4;;@Test public void launchWithSingleCommandLineArgument() throws Exception {     doLaunch("launch-with-single-command-line-argument.sh"). }
false;public;0;4;;@Test public void launchWithMultipleCommandLineArguments() throws Exception {     doLaunch("launch-with-multiple-command-line-arguments.sh"). }
false;public;0;4;;@Test public void launchWithSingleRunArg() throws Exception {     doLaunch("launch-with-single-run-arg.sh"). }
false;public;0;4;;@Test public void launchWithMultipleRunArgs() throws Exception {     doLaunch("launch-with-multiple-run-args.sh"). }
false;public;0;4;;@Test public void launchWithSingleJavaOpt() throws Exception {     doLaunch("launch-with-single-java-opt.sh"). }
false;public;0;4;;@Test public void launchWithDoubleLinkSingleJavaOpt() throws Exception {     doLaunch("launch-with-double-link-single-java-opt.sh"). }
false;public;0;4;;@Test public void launchWithMultipleJavaOpts() throws Exception {     doLaunch("launch-with-multiple-java-opts.sh"). }
false;public;0;6;;@Test public void launchWithUseOfStartStopDaemonDisabled() throws Exception {     // CentOS doesn't have start-stop-daemon     assumeThat(this.os, is(not("CentOS"))).     doLaunch("launch-with-use-of-start-stop-daemon-disabled.sh"). }
false;public;0;10;;@Test public void launchWithRelativePidFolder() throws Exception {     String output = doTest("launch-with-relative-pid-folder.sh").     assertThat(output).has(coloredString(AnsiColor.GREEN, "Started [" + extractPid(output) + "]")).     assertThat(output).has(coloredString(AnsiColor.GREEN, "Running [" + extractPid(output) + "]")).     assertThat(output).has(coloredString(AnsiColor.GREEN, "Stopped [" + extractPid(output) + "]")). }
false;public;0;5;;@Test public void pidFolderOwnership() throws Exception {     String output = doTest("pid-folder-ownership.sh").     assertThat(output).contains("phil root"). }
false;public;0;5;;@Test public void pidFileOwnership() throws Exception {     String output = doTest("pid-file-ownership.sh").     assertThat(output).contains("phil root"). }
false;public;0;5;;@Test public void logFileOwnership() throws Exception {     String output = doTest("log-file-ownership.sh").     assertThat(output).contains("phil root"). }
false;public;0;5;;@Test public void logFileOwnershipIsChangedWhenCreated() throws Exception {     String output = doTest("log-file-ownership-is-changed-when-created.sh").     assertThat(output).contains("andy root"). }
false;public;0;5;;@Test public void logFileOwnershipIsUnchangedWhenExists() throws Exception {     String output = doTest("log-file-ownership-is-unchanged-when-exists.sh").     assertThat(output).contains("root root"). }
false;public;0;5;;@Test public void launchWithRelativeLogFolder() throws Exception {     String output = doTest("launch-with-relative-log-folder.sh").     assertThat(output).contains("Log written"). }
false;private;1;3;;private void doLaunch(String script) throws Exception {     assertThat(doTest(script)).contains("Launched"). }
false;public;1;5;;@Override public void onNext(Frame item) {     output.append(new String(item.getPayload())).     super.onNext(item). }
false;private;1;35;;private String doTest(String script) throws Exception {     DockerClient docker = createClient().     String imageId = buildImage(docker).     String container = createContainer(docker, imageId, script).     try {         copyFilesToContainer(docker, container, script).         docker.startContainerCmd(container).exec().         StringBuilder output = new StringBuilder().         AttachContainerResultCallback resultCallback = docker.attachContainerCmd(container).withStdOut(true).withStdErr(true).withFollowStream(true).withLogs(true).exec(new AttachContainerResultCallback() {              @Override             public void onNext(Frame item) {                 output.append(new String(item.getPayload())).                 super.onNext(item).             }         }).         resultCallback.awaitCompletion(60, TimeUnit.SECONDS).         WaitContainerResultCallback waitContainerCallback = new WaitContainerResultCallback().         docker.waitContainerCmd(container).exec(waitContainerCallback).         waitContainerCallback.awaitCompletion(60, TimeUnit.SECONDS).         return output.toString().     } finally {         try {             docker.removeContainerCmd(container).exec().         } catch (Exception ex) {         // Continue         }     } }
false;private;0;6;;private DockerClient createClient() {     DockerClientConfig config = DefaultDockerClientConfig.createDefaultConfigBuilder().withApiVersion("1.19").build().     return DockerClientBuilder.getInstance(config).withDockerCmdExecFactory(this.commandExecFactory).build(). }
false;public;1;5;;@Override public void onNext(BuildResponseItem item) {     super.onNext(item).     this.items.add(item). }
false;public;0;11;;@Override public String awaitImageId() {     try {         awaitCompletion().     } catch (InterruptedException ex) {         throw new DockerClientException("Interrupted while waiting for image id", ex).     }     return getImageId(). }
false;private;0;12;;@SuppressWarnings("deprecation") private String getImageId() {     if (this.items.isEmpty()) {         throw new DockerClientException("Could not build image").     }     String imageId = extractImageId().     if (imageId == null) {         throw new DockerClientException("Could not build image: " + this.items.get(this.items.size() - 1).getError()).     }     return imageId. }
false;private;0;12;;private String extractImageId() {     Collections.reverse(this.items).     for (BuildResponseItem item : this.items) {         if (item.isErrorIndicated() || item.getStream() == null) {             return null.         }         if (item.getStream().contains("Successfully built")) {             return item.getStream().replace("Successfully built", "").trim().         }     }     return null. }
false;private;1;59;;private String buildImage(DockerClient docker) {     String dockerfile = "src/test/resources/conf/" + this.os + "/" + this.version + "/Dockerfile".     String tag = "spring-boot-it/" + this.os.toLowerCase(Locale.ENGLISH) + ":" + this.version.     BuildImageResultCallback resultCallback = new BuildImageResultCallback() {          private List<BuildResponseItem> items = new ArrayList<>().          @Override         public void onNext(BuildResponseItem item) {             super.onNext(item).             this.items.add(item).         }          @Override         public String awaitImageId() {             try {                 awaitCompletion().             } catch (InterruptedException ex) {                 throw new DockerClientException("Interrupted while waiting for image id", ex).             }             return getImageId().         }          @SuppressWarnings("deprecation")         private String getImageId() {             if (this.items.isEmpty()) {                 throw new DockerClientException("Could not build image").             }             String imageId = extractImageId().             if (imageId == null) {                 throw new DockerClientException("Could not build image: " + this.items.get(this.items.size() - 1).getError()).             }             return imageId.         }          private String extractImageId() {             Collections.reverse(this.items).             for (BuildResponseItem item : this.items) {                 if (item.isErrorIndicated() || item.getStream() == null) {                     return null.                 }                 if (item.getStream().contains("Successfully built")) {                     return item.getStream().replace("Successfully built", "").trim().                 }             }             return null.         }     }.     docker.buildImageCmd(new File(dockerfile)).withTags(new HashSet<>(Arrays.asList(tag))).exec(resultCallback).     String imageId = resultCallback.awaitImageId().     return imageId. }
false;private;3;5;;private String createContainer(DockerClient docker, String imageId, String testScript) {     return docker.createContainerCmd(imageId).withTty(false).withCmd("/bin/bash", "-c", "chmod +x " + testScript + " && ./" + testScript).exec().getId(). }
false;private;3;8;;private void copyFilesToContainer(DockerClient docker, final String container, String script) {     copyToContainer(docker, container, findApplication()).     copyToContainer(docker, container, new File("src/test/resources/scripts/test-functions.sh")).     copyToContainer(docker, container, new File("src/test/resources/scripts/" + script)). }
false;private;3;5;;private void copyToContainer(DockerClient docker, final String container, final File file) {     this.commandExecFactory.createCopyToContainerCmdExec().exec(new CopyToContainerCmd(container, file)). }
false;private;0;12;;private File findApplication() {     File targetDir = new File("target").     for (File file : targetDir.listFiles()) {         if (file.getName().startsWith("spring-boot-launch-script-tests") && file.getName().endsWith(".jar") && !file.getName().endsWith("-sources.jar")) {             return file.         }     }     throw new IllegalStateException("Could not find test application in target directory. Have you built it (mvn package)?"). }
false;public;1;4;;@Override public boolean matches(String value) {     return containsString(colorString).matches(value). }
false;private;2;11;;private Condition<String> coloredString(AnsiColor color, String string) {     String colorString = ESC + "[0." + color + "m" + string + ESC + "[0m".     return new Condition<String>() {          @Override         public boolean matches(String value) {             return containsString(colorString).matches(value).         }     }. }
false;private;1;3;;private String extractPid(String output) {     return extract("PID", output). }
false;private;2;9;;private String extract(String label, String output) {     Pattern pattern = Pattern.compile(".*" + label + ": ([0-9]+).*", Pattern.DOTALL).     java.util.regex.Matcher matcher = pattern.matcher(output).     if (matcher.matches()) {         return matcher.group(1).     }     throw new IllegalArgumentException("Failed to extract " + label + " from output: " + output). }
false;protected;1;17;;@Override protected Void execute(CopyToContainerCmd command) {     try (InputStream streamToUpload = new FileInputStream(CompressArchiveUtil.archiveTARFiles(command.getFile().getParentFile(), Arrays.asList(command.getFile()), command.getFile().getName()))) {         WebTarget webResource = getBaseResource().path("/containers/{id}/archive").resolveTemplate("id", command.getContainer()).         webResource.queryParam("path", ".").queryParam("noOverwriteDirNonDir", false).request().put(Entity.entity(streamToUpload, "application/x-tar")).close().         return null.     } catch (Exception ex) {         throw new RuntimeException(ex).     } }
false;public;0;3;;public String getContainer() {     return this.container. }
false;public;0;3;;public File getFile() {     return this.file. }
false;public;0;4;;@Override public void close() { }
false;private;0;3;;private CopyToContainerCmdExec createCopyToContainerCmdExec() {     return new CopyToContainerCmdExec(getBaseResource(), getDockerClientConfig()). }
