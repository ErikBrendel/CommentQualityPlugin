commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Test public void allBeanMethodsArePublic() throws IOException {     Set<String> nonPublicBeanMethods = new HashSet<>().     for (AnnotationMetadata configurationClass : findConfigurationClasses()) {         Set<MethodMetadata> beanMethods = configurationClass.getAnnotatedMethods(Bean.class.getName()).         for (MethodMetadata methodMetadata : beanMethods) {             if (!isPublic(methodMetadata)) {                 nonPublicBeanMethods.add(methodMetadata.getDeclaringClassName() + "." + methodMetadata.getMethodName()).             }         }     }     assertThat(nonPublicBeanMethods).as("Found non-public @Bean methods").isEmpty(). }
false;private;0;18;;private Set<AnnotationMetadata> findConfigurationClasses() throws IOException {     Set<AnnotationMetadata> configurationClasses = new HashSet<>().     Resource[] resources = this.resolver.getResources("classpath*:" + getClass().getPackage().getName().replace('.', '/') + "/**/*.class").     for (Resource resource : resources) {         if (!isTestClass(resource)) {             MetadataReader metadataReader = new SimpleMetadataReaderFactory().getMetadataReader(resource).             AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata().             if (annotationMetadata.getAnnotationTypes().contains(Configuration.class.getName())) {                 configurationClasses.add(annotationMetadata).             }         }     }     return configurationClasses. }
false;private;1;4;;private boolean isTestClass(Resource resource) throws IOException {     return resource.getFile().getAbsolutePath().startsWith(this.buildOutput.getTestClassesLocation().getAbsolutePath()). }
false;private;1;5;;private boolean isPublic(MethodMetadata methodMetadata) {     int access = (Integer) new DirectFieldAccessor(methodMetadata).getPropertyValue("access").     return (access & Opcodes.ACC_PUBLIC) != 0. }
