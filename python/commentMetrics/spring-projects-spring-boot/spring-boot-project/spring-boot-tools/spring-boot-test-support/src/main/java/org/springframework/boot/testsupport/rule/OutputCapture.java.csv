commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Override public void evaluate() throws Throwable {     captureOutput().     try {         base.evaluate().     } finally {         try {             if (!OutputCapture.this.matchers.isEmpty()) {                 String output = OutputCapture.this.toString().                 Assert.assertThat(output, allOf(OutputCapture.this.matchers)).             }         } finally {             releaseOutput().         }     } }
false;public;2;23;;@Override public Statement apply(Statement base, Description description) {     return new Statement() {          @Override         public void evaluate() throws Throwable {             captureOutput().             try {                 base.evaluate().             } finally {                 try {                     if (!OutputCapture.this.matchers.isEmpty()) {                         String output = OutputCapture.this.toString().                         Assert.assertThat(output, allOf(OutputCapture.this.matchers)).                     }                 } finally {                     releaseOutput().                 }             }         }     }. }
false;protected;0;8;;protected void captureOutput() {     // FIXME AnsiOutput.setEnabled(Enabled.NEVER).     this.copy = new ByteArrayOutputStream().     this.captureOut = new CaptureOutputStream(System.out, this.copy).     this.captureErr = new CaptureOutputStream(System.err, this.copy).     System.setOut(new PrintStream(this.captureOut)).     System.setErr(new PrintStream(this.captureErr)). }
false;protected;0;6;;protected void releaseOutput() {     // FIXME AnsiOutput.setEnabled(Enabled.DETECT).     System.setOut(this.captureOut.getOriginal()).     System.setErr(this.captureErr.getOriginal()).     this.copy = null. }
false;public;0;9;;public void flush() {     try {         this.captureOut.flush().         this.captureErr.flush().     } catch (IOException ex) {     // ignore     } }
false;public;0;5;;@Override public String toString() {     flush().     return this.copy.toString(). }
true;public;1;3;/**  * Verify that the output is matched by the supplied {@code matcher}. Verification is  * performed after the test method has executed.  * @param matcher the matcher  */ ;/**  * Verify that the output is matched by the supplied {@code matcher}. Verification is  * performed after the test method has executed.  * @param matcher the matcher  */ public void expect(Matcher<? super String> matcher) {     this.matchers.add(matcher). }
false;public;1;6;;@Override public void write(int b) throws IOException {     this.copy.write(b).     this.original.write(b).     this.original.flush(). }
false;public;1;4;;@Override public void write(byte[] b) throws IOException {     write(b, 0, b.length). }
false;public;3;5;;@Override public void write(byte[] b, int off, int len) throws IOException {     this.copy.write(b, off, len).     this.original.write(b, off, len). }
false;public;0;3;;public PrintStream getOriginal() {     return this.original. }
false;public;0;5;;@Override public void flush() throws IOException {     this.copy.flush().     this.original.flush(). }
