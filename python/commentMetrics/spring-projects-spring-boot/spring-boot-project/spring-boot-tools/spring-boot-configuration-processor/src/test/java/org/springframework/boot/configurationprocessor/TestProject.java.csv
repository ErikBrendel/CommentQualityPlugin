commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected File getSourceFolder() {     return TestProject.this.sourceFolder. }
false;private;1;5;;private void copySources(Set<Class<?>> contents) throws IOException {     for (Class<?> type : contents) {         copySources(type).     } }
false;private;1;7;;private void copySources(Class<?> type) throws IOException {     File original = getOriginalSourceFile(type).     File target = getSourceFile(type).     target.getParentFile().mkdirs().     FileCopyUtils.copy(original, target).     this.sourceFiles.add(target). }
false;public;1;3;;public File getSourceFile(Class<?> type) {     return new File(this.sourceFolder, TestCompiler.sourcePathFor(type)). }
false;public;0;8;;public ConfigurationMetadata fullBuild() {     TestConfigurationMetadataAnnotationProcessor processor = new TestConfigurationMetadataAnnotationProcessor(this.compiler.getOutputLocation()).     TestCompilationTask task = this.compiler.getTask(this.sourceFiles).     deleteFolderContents(this.compiler.getOutputLocation()).     task.call(processor).     return processor.getMetadata(). }
false;public;1;7;;public ConfigurationMetadata incrementalBuild(Class<?>... toRecompile) {     TestConfigurationMetadataAnnotationProcessor processor = new TestConfigurationMetadataAnnotationProcessor(this.compiler.getOutputLocation()).     TestCompilationTask task = this.compiler.getTask(toRecompile).     task.call(processor).     return processor.getMetadata(). }
false;private;1;4;;private void deleteFolderContents(File outputFolder) {     FileSystemUtils.deleteRecursively(outputFolder).     outputFolder.mkdirs(). }
true;public;1;4;/**  * Retrieve File relative to project's output folder.  * @param relativePath the relative path  * @return the output file  */ ;/**  * Retrieve File relative to project's output folder.  * @param relativePath the relative path  * @return the output file  */ public File getOutputFile(String relativePath) {     Assert.assertFalse(new File(relativePath).isAbsolute()).     return new File(this.compiler.getOutputLocation(), relativePath). }
true;public;2;11;/**  * Add source code at the end of file, just before last '}'  * @param target the target  * @param snippetStream the snippet stream  * @throws Exception if the source cannot be added  */ ;/**  * Add source code at the end of file, just before last '}'  * @param target the target  * @param snippetStream the snippet stream  * @throws Exception if the source cannot be added  */ public void addSourceCode(Class<?> target, InputStream snippetStream) throws Exception {     File targetFile = getSourceFile(target).     String contents = getContents(targetFile).     int insertAt = contents.lastIndexOf('}').     String additionalSource = FileCopyUtils.copyToString(new InputStreamReader(snippetStream)).     contents = contents.substring(0, insertAt) + additionalSource + contents.substring(insertAt).     putContents(targetFile, contents). }
true;public;1;5;/**  * Delete source file for given class from project.  * @param type the class to delete  */ ;/**  * Delete source file for given class from project.  * @param type the class to delete  */ public void delete(Class<?> type) {     File target = getSourceFile(type).     target.delete().     this.sourceFiles.remove(target). }
true;public;1;4;/**  * Restore source code of given class to its original contents.  * @param type the class to revert  * @throws IOException on IO error  */ ;/**  * Restore source code of given class to its original contents.  * @param type the class to revert  * @throws IOException on IO error  */ public void revert(Class<?> type) throws IOException {     Assert.assertTrue(getSourceFile(type).exists()).     copySources(type). }
true;public;1;4;/**  * Add source code of given class to this project.  * @param type the class to add  * @throws IOException on IO error  */ ;/**  * Add source code of given class to this project.  * @param type the class to add  * @throws IOException on IO error  */ public void add(Class<?> type) throws IOException {     Assert.assertFalse(getSourceFile(type).exists()).     copySources(type). }
false;public;3;6;;public void replaceText(Class<?> type, String find, String replace) throws Exception {     File target = getSourceFile(type).     String contents = getContents(target).     contents = contents.replace(find, replace).     putContents(target, contents). }
true;private;1;3;/**  * Find the 'original' source code for given test class. Clients or subclasses should  * have no need to know about these. They should work only with the copied source  * code.  */ ;/**  * Find the 'original' source code for given test class. Clients or subclasses should  * have no need to know about these. They should work only with the copied source  * code.  */ private File getOriginalSourceFile(Class<?> type) {     return new File(TestCompiler.SOURCE_FOLDER, TestCompiler.sourcePathFor(type)). }
false;private,static;2;3;;private static void putContents(File targetFile, String contents) throws IOException {     FileCopyUtils.copy(new StringReader(contents), new FileWriter(targetFile)). }
false;private,static;1;3;;private static String getContents(File file) throws Exception {     return FileCopyUtils.copyToString(new FileReader(file)). }
