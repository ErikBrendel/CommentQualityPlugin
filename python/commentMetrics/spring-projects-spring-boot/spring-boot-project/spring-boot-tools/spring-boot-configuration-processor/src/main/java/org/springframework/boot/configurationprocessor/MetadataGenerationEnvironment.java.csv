commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;17;;private static Set<String> determineTypeExcludes() {     Set<String> excludes = new HashSet<>().     excludes.add("com.zaxxer.hikari.IConnectionCustomizer").     excludes.add("groovy.text.markup.MarkupTemplateEngine").     excludes.add("java.io.Writer").     excludes.add("java.io.PrintWriter").     excludes.add("java.lang.ClassLoader").     excludes.add("java.util.concurrent.ThreadFactory").     excludes.add("javax.jms.XAConnectionFactory").     excludes.add("javax.sql.DataSource").     excludes.add("javax.sql.XADataSource").     excludes.add("org.apache.tomcat.jdbc.pool.PoolConfiguration").     excludes.add("org.apache.tomcat.jdbc.pool.Validator").     excludes.add("org.flywaydb.core.api.callback.FlywayCallback").     excludes.add("org.flywaydb.core.api.resolver.MigrationResolver").     return excludes. }
false;private,static;1;8;;private static FieldValuesParser resolveFieldValuesParser(ProcessingEnvironment env) {     try {         return new JavaCompilerFieldValuesParser(env).     } catch (Throwable ex) {         return FieldValuesParser.NONE.     } }
false;public;0;3;;public TypeUtils getTypeUtils() {     return this.typeUtils. }
false;public;2;4;;public Object getDefaultValue(TypeElement type, String name) {     return this.defaultValues.computeIfAbsent(type, this::resolveFieldValues).get(name). }
false;public;1;10;;public boolean isExcluded(TypeMirror type) {     if (type == null) {         return false.     }     String typeName = type.toString().     if (typeName.endsWith("[]")) {         typeName = typeName.substring(0, typeName.length() - 2).     }     return this.typeExcludes.contains(typeName). }
false;public;1;9;;public boolean isDeprecated(Element element) {     if (isElementDeprecated(element)) {         return true.     }     if (element instanceof VariableElement || element instanceof ExecutableElement) {         return isElementDeprecated(element.getEnclosingElement()).     }     return false. }
false;public;1;14;;public ItemDeprecation resolveItemDeprecation(Element element) {     AnnotationMirror annotation = getAnnotation(element, this.deprecatedConfigurationPropertyAnnotation).     String reason = null.     String replacement = null.     if (annotation != null) {         Map<String, Object> elementValues = getAnnotationElementValues(annotation).         reason = (String) elementValues.get("reason").         replacement = (String) elementValues.get("replacement").     }     reason = "".equals(reason) ? null : reason.     replacement = "".equals(replacement) ? null : replacement.     return new ItemDeprecation(reason, replacement). }
false;public;2;3;;public boolean hasAnnotation(Element element, String type) {     return getAnnotation(element, type) != null. }
false;public;2;10;;public AnnotationMirror getAnnotation(Element element, String type) {     if (element != null) {         for (AnnotationMirror annotation : element.getAnnotationMirrors()) {             if (type.equals(annotation.getAnnotationType().toString())) {                 return annotation.             }         }     }     return null. }
false;public;1;6;;public Map<String, Object> getAnnotationElementValues(AnnotationMirror annotation) {     Map<String, Object> values = new LinkedHashMap<>().     annotation.getElementValues().forEach((name, value) -> values.put(name.getSimpleName().toString(), value.getValue())).     return values. }
false;public;0;3;;public TypeElement getConfigurationPropertiesAnnotationElement() {     return this.elements.getTypeElement(this.configurationPropertiesAnnotation). }
false;public;1;3;;public AnnotationMirror getConfigurationPropertiesAnnotation(Element element) {     return getAnnotation(element, this.configurationPropertiesAnnotation). }
false;public;1;3;;public AnnotationMirror getNestedConfigurationPropertyAnnotation(Element element) {     return getAnnotation(element, this.nestedConfigurationPropertyAnnotation). }
false;public;0;3;;public TypeElement getEndpointAnnotationElement() {     return this.elements.getTypeElement(this.endpointAnnotation). }
false;public;1;3;;public AnnotationMirror getReadOperationAnnotation(Element element) {     return getAnnotation(element, this.readOperationAnnotation). }
false;public;1;3;;public boolean hasNullableAnnotation(Element element) {     return getAnnotation(element, NULLABLE_ANNOTATION) != null. }
false;private;1;4;;private boolean isElementDeprecated(Element element) {     return hasAnnotation(element, "java.lang.Deprecated") || hasAnnotation(element, this.deprecatedConfigurationPropertyAnnotation). }
false;private;1;5;;private Map<String, Object> resolveFieldValues(TypeElement element) {     Map<String, Object> values = new LinkedHashMap<>().     resolveFieldValuesFor(values, element).     return values. }
false;private;2;17;;private void resolveFieldValuesFor(Map<String, Object> values, TypeElement element) {     try {         this.fieldValuesParser.getFieldValues(element).forEach((name, value) -> {             if (!values.containsKey(name)) {                 values.put(name, value).             }         }).     } catch (Exception ex) {     // continue     }     Element superType = this.typeUtils.asElement(element.getSuperclass()).     if (superType instanceof TypeElement && superType.asType().getKind() != TypeKind.NONE) {         resolveFieldValuesFor(values, (TypeElement) superType).     } }
