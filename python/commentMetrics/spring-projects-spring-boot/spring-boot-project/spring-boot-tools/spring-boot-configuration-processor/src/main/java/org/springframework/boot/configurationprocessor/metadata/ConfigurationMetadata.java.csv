commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Add item meta-data.  * @param itemMetadata the meta-data to add  */ ;/**  * Add item meta-data.  * @param itemMetadata the meta-data to add  */ public void add(ItemMetadata itemMetadata) {     add(this.items, itemMetadata.getName(), itemMetadata). }
true;public;1;3;/**  * Add item hint.  * @param itemHint the item hint to add  */ ;/**  * Add item hint.  * @param itemHint the item hint to add  */ public void add(ItemHint itemHint) {     add(this.hints, itemHint.getName(), itemHint). }
true;public;1;8;/**  * Merge the content from another {@link ConfigurationMetadata}.  * @param metadata the {@link ConfigurationMetadata} instance to merge  */ ;/**  * Merge the content from another {@link ConfigurationMetadata}.  * @param metadata the {@link ConfigurationMetadata} instance to merge  */ public void merge(ConfigurationMetadata metadata) {     for (ItemMetadata additionalItem : metadata.getItems()) {         mergeItemMetadata(additionalItem).     }     for (ItemHint itemHint : metadata.getHints()) {         add(itemHint).     } }
true;public;0;3;/**  * Return item meta-data.  * @return the items  */ ;/**  * Return item meta-data.  * @return the items  */ public List<ItemMetadata> getItems() {     return flattenValues(this.items). }
true;public;0;3;/**  * Return hint meta-data.  * @return the hints  */ ;/**  * Return hint meta-data.  * @return the hints  */ public List<ItemHint> getHints() {     return flattenValues(this.hints). }
false;protected;1;32;;protected void mergeItemMetadata(ItemMetadata metadata) {     ItemMetadata matching = findMatchingItemMetadata(metadata).     if (matching != null) {         if (metadata.getDescription() != null) {             matching.setDescription(metadata.getDescription()).         }         if (metadata.getDefaultValue() != null) {             matching.setDefaultValue(metadata.getDefaultValue()).         }         ItemDeprecation deprecation = metadata.getDeprecation().         ItemDeprecation matchingDeprecation = matching.getDeprecation().         if (deprecation != null) {             if (matchingDeprecation == null) {                 matching.setDeprecation(deprecation).             } else {                 if (deprecation.getReason() != null) {                     matchingDeprecation.setReason(deprecation.getReason()).                 }                 if (deprecation.getReplacement() != null) {                     matchingDeprecation.setReplacement(deprecation.getReplacement()).                 }                 if (deprecation.getLevel() != null) {                     matchingDeprecation.setLevel(deprecation.getLevel()).                 }             }         }     } else {         add(this.items, metadata.getName(), metadata).     } }
false;private;3;4;;private <K, V> void add(Map<K, List<V>> map, K key, V value) {     List<V> values = map.computeIfAbsent(key, (k) -> new ArrayList<>()).     values.add(value). }
false;private;1;21;;private ItemMetadata findMatchingItemMetadata(ItemMetadata metadata) {     List<ItemMetadata> candidates = this.items.get(metadata.getName()).     if (candidates == null || candidates.isEmpty()) {         return null.     }     candidates = new ArrayList<>(candidates).     candidates.removeIf((itemMetadata) -> !itemMetadata.hasSameType(metadata)).     if (candidates.size() > 1 && metadata.getType() != null) {         candidates.removeIf((itemMetadata) -> !metadata.getType().equals(itemMetadata.getType())).     }     if (candidates.size() == 1) {         return candidates.get(0).     }     for (ItemMetadata candidate : candidates) {         if (nullSafeEquals(candidate.getSourceType(), metadata.getSourceType())) {             return candidate.         }     }     return null. }
false;private;2;6;;private boolean nullSafeEquals(Object o1, Object o2) {     if (o1 == o2) {         return true.     }     return o1 != null && o2 != null && o1.equals(o2). }
false;public,static;2;6;;public static String nestedPrefix(String prefix, String name) {     String nestedPrefix = (prefix != null) ? prefix : "".     String dashedName = toDashedCase(name).     nestedPrefix += "".equals(nestedPrefix) ? dashedName : "." + dashedName.     return nestedPrefix. }
false;static;1;19;;static String toDashedCase(String name) {     StringBuilder dashed = new StringBuilder().     Character previous = null.     for (char current : name.toCharArray()) {         if (SEPARATORS.contains(current)) {             dashed.append("-").         } else if (Character.isUpperCase(current) && previous != null && !SEPARATORS.contains(previous)) {             dashed.append("-").append(current).         } else {             dashed.append(current).         }         previous = current.     }     return dashed.toString().toLowerCase(Locale.ENGLISH). }
false;private,static;1;8;;private static <T extends Comparable<T>> List<T> flattenValues(Map<?, List<T>> map) {     List<T> content = new ArrayList<>().     for (List<T> values : map.values()) {         content.addAll(values).     }     Collections.sort(content).     return content. }
false;public;0;8;;@Override public String toString() {     StringBuilder result = new StringBuilder().     result.append(String.format("items: %n")).     this.items.values().forEach((itemMetadata) -> result.append("\t").append(String.format("%s%n", itemMetadata))).     return result.toString(). }
