commented;modifiers;parameterAmount;loc;comment;code
true;public;2;20;/**  * Return the {@link PropertyDescriptor} instances that are valid candidates for the  * specified {@link TypeElement type} based on the specified {@link ExecutableElement  * factory method}, if any.  * @param type the target type  * @param factoryMethod the method that triggered the metadata for that {@code type}  * or {@code null}  * @return the candidate properties for metadata generation  */ ;/**  * Return the {@link PropertyDescriptor} instances that are valid candidates for the  * specified {@link TypeElement type} based on the specified {@link ExecutableElement  * factory method}, if any.  * @param type the target type  * @param factoryMethod the method that triggered the metadata for that {@code type}  * or {@code null}  * @return the candidate properties for metadata generation  */ public Stream<PropertyDescriptor<?>> resolve(TypeElement type, ExecutableElement factoryMethod) {     TypeElementMembers members = new TypeElementMembers(this.environment, type).     List<PropertyDescriptor<?>> candidates = new ArrayList<>().     // First check if we have regular java bean properties there     members.getPublicGetters().forEach((name, getter) -> {         TypeMirror returnType = getter.getReturnType().         candidates.add(new JavaBeanPropertyDescriptor(type, factoryMethod, getter, name, returnType, members.getFields().get(name), members.getPublicSetter(name, returnType))).     }).     // Then check for Lombok ones     members.getFields().forEach((name, field) -> {         TypeMirror returnType = field.asType().         ExecutableElement getter = members.getPublicGetter(name, returnType).         candidates.add(new LombokPropertyDescriptor(type, factoryMethod, field, name, returnType, getter)).     }).     return candidates.stream().filter(this::isCandidate). }
false;private;1;4;;private boolean isCandidate(PropertyDescriptor<?> descriptor) {     return descriptor.isProperty(this.environment) || descriptor.isNested(this.environment). }
