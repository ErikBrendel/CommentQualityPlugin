commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected String configurationPropertiesAnnotation() {     return CONFIGURATION_PROPERTIES_ANNOTATION. }
false;protected;0;3;;protected String nestedConfigurationPropertyAnnotation() {     return NESTED_CONFIGURATION_PROPERTY_ANNOTATION. }
false;protected;0;3;;protected String deprecatedConfigurationPropertyAnnotation() {     return DEPRECATED_CONFIGURATION_PROPERTY_ANNOTATION. }
false;protected;0;3;;protected String endpointAnnotation() {     return ENDPOINT_ANNOTATION. }
false;protected;0;3;;protected String readOperationAnnotation() {     return READ_OPERATION_ANNOTATION. }
false;public;0;4;;@Override public SourceVersion getSupportedSourceVersion() {     return SourceVersion.latestSupported(). }
false;public;0;4;;@Override public Set<String> getSupportedOptions() {     return SUPPORTED_OPTIONS. }
false;public,synchronized;1;12;;@Override public synchronized void init(ProcessingEnvironment env) {     super.init(env).     this.metadataStore = new MetadataStore(env).     this.metadataCollector = new MetadataCollector(env, this.metadataStore.readMetadata()).     this.metadataEnv = new MetadataGenerationEnvironment(env, configurationPropertiesAnnotation(), nestedConfigurationPropertyAnnotation(), deprecatedConfigurationPropertyAnnotation(), endpointAnnotation(), readOperationAnnotation()). }
false;public;2;26;;@Override public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {     this.metadataCollector.processing(roundEnv).     TypeElement annotationType = this.metadataEnv.getConfigurationPropertiesAnnotationElement().     if (annotationType != null) {         // Is @ConfigurationProperties available         for (Element element : roundEnv.getElementsAnnotatedWith(annotationType)) {             processElement(element).         }     }     TypeElement endpointType = this.metadataEnv.getEndpointAnnotationElement().     if (endpointType != null) {         // Is @Endpoint available         getElementsAnnotatedOrMetaAnnotatedWith(roundEnv, endpointType).forEach(this::processEndpoint).     }     if (roundEnv.processingOver()) {         try {             writeMetaData().         } catch (Exception ex) {             throw new IllegalStateException("Failed to write metadata", ex).         }     }     return false. }
false;private;2;15;;private Map<Element, List<Element>> getElementsAnnotatedOrMetaAnnotatedWith(RoundEnvironment roundEnv, TypeElement annotation) {     DeclaredType annotationType = (DeclaredType) annotation.asType().     Map<Element, List<Element>> result = new LinkedHashMap<>().     for (Element element : roundEnv.getRootElements()) {         LinkedList<Element> stack = new LinkedList<>().         stack.push(element).         collectElementsAnnotatedOrMetaAnnotatedWith(annotationType, stack).         stack.removeFirst().         if (!stack.isEmpty()) {             result.put(element, Collections.unmodifiableList(stack)).         }     }     return result. }
false;private;2;18;;private boolean collectElementsAnnotatedOrMetaAnnotatedWith(DeclaredType annotationType, LinkedList<Element> stack) {     Element element = stack.peekLast().     for (AnnotationMirror annotation : this.processingEnv.getElementUtils().getAllAnnotationMirrors(element)) {         Element annotationElement = annotation.getAnnotationType().asElement().         if (!stack.contains(annotationElement)) {             stack.addLast(annotationElement).             if (annotationElement.equals(annotationType.asElement())) {                 return true.             }             if (!collectElementsAnnotatedOrMetaAnnotatedWith(annotationType, stack)) {                 stack.removeLast().             }         }     }     return false. }
false;private;1;19;;private void processElement(Element element) {     try {         AnnotationMirror annotation = this.metadataEnv.getConfigurationPropertiesAnnotation(element).         if (annotation != null) {             String prefix = getPrefix(annotation).             if (element instanceof TypeElement) {                 processAnnotatedTypeElement(prefix, (TypeElement) element).             } else if (element instanceof ExecutableElement) {                 processExecutableElement(prefix, (ExecutableElement) element).             }         }     } catch (Exception ex) {         throw new IllegalStateException("Error processing configuration meta-data on " + element, ex).     } }
false;private;2;5;;private void processAnnotatedTypeElement(String prefix, TypeElement element) {     String type = this.metadataEnv.getTypeUtils().getQualifiedName(element).     this.metadataCollector.add(ItemMetadata.newGroup(prefix, type, type, null)).     processTypeElement(prefix, element, null). }
false;private;2;25;;private void processExecutableElement(String prefix, ExecutableElement element) {     if (element.getModifiers().contains(Modifier.PUBLIC) && (TypeKind.VOID != element.getReturnType().getKind())) {         Element returns = this.processingEnv.getTypeUtils().asElement(element.getReturnType()).         if (returns instanceof TypeElement) {             ItemMetadata group = ItemMetadata.newGroup(prefix, this.metadataEnv.getTypeUtils().getQualifiedName(returns), this.metadataEnv.getTypeUtils().getQualifiedName(element.getEnclosingElement()), element.toString()).             if (this.metadataCollector.hasSimilarGroup(group)) {                 this.processingEnv.getMessager().printMessage(Kind.ERROR, "Duplicate `@ConfigurationProperties` definition for prefix '" + prefix + "'", element).             } else {                 this.metadataCollector.add(group).                 processTypeElement(prefix, (TypeElement) returns, element).             }         }     } }
false;private;3;15;;private void processTypeElement(String prefix, TypeElement element, ExecutableElement source) {     new PropertyDescriptorResolver(this.metadataEnv).resolve(element, source).forEach((descriptor) -> {         this.metadataCollector.add(descriptor.resolveItemMetadata(prefix, this.metadataEnv)).         if (descriptor.isNested(this.metadataEnv)) {             TypeElement nestedTypeElement = (TypeElement) this.metadataEnv.getTypeUtils().asElement(descriptor.getType()).             String nestedPrefix = ConfigurationMetadata.nestedPrefix(prefix, descriptor.getName()).             processTypeElement(nestedPrefix, nestedTypeElement, source).         }     }). }
false;private;2;15;;private void processEndpoint(Element element, List<Element> annotations) {     try {         String annotationName = this.metadataEnv.getTypeUtils().getQualifiedName(annotations.get(0)).         AnnotationMirror annotation = this.metadataEnv.getAnnotation(element, annotationName).         if (element instanceof TypeElement) {             processEndpoint(annotation, (TypeElement) element).         }     } catch (Exception ex) {         throw new IllegalStateException("Error processing configuration meta-data on " + element, ex).     } }
false;private;2;22;;private void processEndpoint(AnnotationMirror annotation, TypeElement element) {     Map<String, Object> elementValues = this.metadataEnv.getAnnotationElementValues(annotation).     String endpointId = (String) elementValues.get("id").     if (endpointId == null || "".equals(endpointId)) {         // Can't process that endpoint         return.     }     String endpointKey = ItemMetadata.newItemMetadataPrefix("management.endpoint.", endpointId).     Boolean enabledByDefault = (Boolean) elementValues.get("enableByDefault").     String type = this.metadataEnv.getTypeUtils().getQualifiedName(element).     this.metadataCollector.add(ItemMetadata.newGroup(endpointKey, type, type, null)).     this.metadataCollector.add(ItemMetadata.newProperty(endpointKey, "enabled", Boolean.class.getName(), type, null, String.format("Whether to enable the %s endpoint.", endpointId), (enabledByDefault != null) ? enabledByDefault : true, null)).     if (hasMainReadOperation(element)) {         this.metadataCollector.add(ItemMetadata.newProperty(endpointKey, "cache.time-to-live", Duration.class.getName(), type, null, "Maximum time that a response can be cached.", "0ms", null)).     } }
false;private;1;11;;private boolean hasMainReadOperation(TypeElement element) {     for (ExecutableElement method : ElementFilter.methodsIn(element.getEnclosedElements())) {         if (this.metadataEnv.getReadOperationAnnotation(method) != null && (TypeKind.VOID != method.getReturnType().getKind()) && hasNoOrOptionalParameters(method)) {             return true.         }     }     return false. }
false;private;1;8;;private boolean hasNoOrOptionalParameters(ExecutableElement method) {     for (VariableElement parameter : method.getParameters()) {         if (!this.metadataEnv.hasNullableAnnotation(parameter)) {             return false.         }     }     return true. }
false;private;1;13;;private String getPrefix(AnnotationMirror annotation) {     Map<String, Object> elementValues = this.metadataEnv.getAnnotationElementValues(annotation).     Object prefix = elementValues.get("prefix").     if (prefix != null && !"".equals(prefix)) {         return (String) prefix.     }     Object value = elementValues.get("value").     if (value != null && !"".equals(value)) {         return (String) value.     }     return null. }
false;protected;0;9;;protected ConfigurationMetadata writeMetaData() throws Exception {     ConfigurationMetadata metadata = this.metadataCollector.getMetadata().     metadata = mergeAdditionalMetadata(metadata).     if (!metadata.getItems().isEmpty()) {         this.metadataStore.writeMetadata(metadata).         return metadata.     }     return null. }
false;private;1;19;;private ConfigurationMetadata mergeAdditionalMetadata(ConfigurationMetadata metadata) {     try {         ConfigurationMetadata merged = new ConfigurationMetadata(metadata).         merged.merge(this.metadataStore.readAdditionalMetadata()).         return merged.     } catch (FileNotFoundException ex) {     // No additional metadata     } catch (InvalidConfigurationMetadataException ex) {         log(ex.getKind(), ex.getMessage()).     } catch (Exception ex) {         logWarning("Unable to merge additional metadata").         logWarning(getStackTrace(ex)).     }     return metadata. }
false;private;1;5;;private String getStackTrace(Exception ex) {     StringWriter writer = new StringWriter().     ex.printStackTrace(new PrintWriter(writer, true)).     return writer.toString(). }
false;private;1;3;;private void logWarning(String msg) {     log(Kind.WARNING, msg). }
false;private;2;3;;private void log(Kind kind, String msg) {     this.processingEnv.getMessager().printMessage(kind, msg). }
