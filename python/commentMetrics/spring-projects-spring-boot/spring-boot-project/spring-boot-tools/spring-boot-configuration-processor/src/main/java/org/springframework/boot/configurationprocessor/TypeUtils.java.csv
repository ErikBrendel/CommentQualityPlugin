commented;modifiers;parameterAmount;loc;comment;code
false;private;3;14;;private TypeMirror getDeclaredType(Types types, Class<?> typeClass, int numberOfTypeArgs) {     TypeMirror[] typeArgs = new TypeMirror[numberOfTypeArgs].     Arrays.setAll(typeArgs, (i) -> types.getWildcardType(null, null)).     TypeElement typeElement = this.env.getElementUtils().getTypeElement(typeClass.getName()).     try {         return types.getDeclaredType(typeElement, typeArgs).     } catch (IllegalArgumentException ex) {         // Try again without generics for older Java versions         return types.getDeclaredType(typeElement).     } }
false;public;2;3;;public boolean isSameType(TypeMirror t1, TypeMirror t2) {     return this.types.isSameType(t1, t2). }
false;public;1;3;;public Element asElement(TypeMirror type) {     return this.types.asElement(type). }
true;public;1;3;/**  * Return the qualified name of the specified element.  * @param element the element to handle  * @return the fully qualified name of the element, suitable for a call to  * {@link Class#forName(String)}  */ ;/**  * Return the qualified name of the specified element.  * @param element the element to handle  * @return the fully qualified name of the element, suitable for a call to  * {@link Class#forName(String)}  */ public String getQualifiedName(Element element) {     return this.typeExtractor.getQualifiedName(element). }
true;public;2;6;/**  * Return the type of the specified {@link TypeMirror} including all its generic  * information.  * @param element the {@link TypeElement} in which this {@code type} is declared  * @param type the type to handle  * @return a representation of the type including all its generic information  */ ;/**  * Return the type of the specified {@link TypeMirror} including all its generic  * information.  * @param element the {@link TypeElement} in which this {@code type} is declared  * @param type the type to handle  * @return a representation of the type including all its generic information  */ public String getType(TypeElement element, TypeMirror type) {     if (type == null) {         return null.     }     return type.accept(this.typeExtractor, createTypeDescriptor(element)). }
false;public;1;4;;public boolean isCollectionOrMap(TypeMirror type) {     return this.env.getTypeUtils().isAssignable(type, this.collectionType) || this.env.getTypeUtils().isAssignable(type, this.mapType). }
false;public;1;8;;public String getJavaDoc(Element element) {     String javadoc = (element != null) ? this.env.getElementUtils().getDocComment(element) : null.     if (javadoc != null) {         javadoc = NEW_LINE_PATTERN.matcher(javadoc).replaceAll("").trim().     }     return "".equals(javadoc) ? null : javadoc. }
false;public;1;12;;public TypeMirror getWrapperOrPrimitiveFor(TypeMirror typeMirror) {     Class<?> candidate = getWrapperFor(typeMirror).     if (candidate != null) {         return this.env.getElementUtils().getTypeElement(candidate.getName()).asType().     }     TypeKind primitiveKind = getPrimitiveFor(typeMirror).     if (primitiveKind != null) {         return this.env.getTypeUtils().getPrimitiveType(primitiveKind).     }     return null. }
false;private;1;3;;private Class<?> getWrapperFor(TypeMirror type) {     return PRIMITIVE_WRAPPERS.get(type.getKind()). }
false;private;1;3;;private TypeKind getPrimitiveFor(TypeMirror type) {     return WRAPPER_TO_PRIMITIVE.get(type.toString()). }
false;;1;6;;TypeDescriptor resolveTypeDescriptor(TypeElement element) {     if (this.typeDescriptors.containsKey(element)) {         return this.typeDescriptors.get(element).     }     return createTypeDescriptor(element). }
false;private;1;6;;private TypeDescriptor createTypeDescriptor(TypeElement element) {     TypeDescriptor descriptor = new TypeDescriptor().     process(descriptor, element.asType()).     this.typeDescriptors.put(element, descriptor).     return descriptor. }
false;private;2;22;;private void process(TypeDescriptor descriptor, TypeMirror type) {     try {         if (type.getKind() == TypeKind.DECLARED) {             DeclaredType declaredType = (DeclaredType) type.             DeclaredType freshType = (DeclaredType) this.env.getElementUtils().getTypeElement(this.types.asElement(type).toString()).asType().             List<? extends TypeMirror> arguments = declaredType.getTypeArguments().             for (int i = 0. i < arguments.size(). i++) {                 TypeMirror specificType = arguments.get(i).                 TypeMirror signatureType = freshType.getTypeArguments().get(i).                 descriptor.registerIfNecessary(signatureType, specificType).             }             TypeElement element = (TypeElement) this.types.asElement(type).             process(descriptor, element.getSuperclass()).         }     } catch (Exception ex) {         this.env.getMessager().printMessage(Kind.WARNING, "Failed to generated type descriptor for " + type, this.types.asElement(type)).     } }
false;public;2;14;;@Override public String visitDeclared(DeclaredType type, TypeDescriptor descriptor) {     TypeElement enclosingElement = getEnclosingTypeElement(type).     String qualifiedName = determineQualifiedName(type, enclosingElement).     if (type.getTypeArguments().isEmpty()) {         return qualifiedName.     }     StringBuilder name = new StringBuilder().     name.append(qualifiedName).     name.append("<").append(type.getTypeArguments().stream().map((t) -> visit(t, descriptor)).collect(Collectors.joining(","))).append(">").     return name.toString(). }
false;private;2;8;;private String determineQualifiedName(DeclaredType type, TypeElement enclosingElement) {     if (enclosingElement != null) {         return getQualifiedName(enclosingElement) + "$" + type.asElement().getSimpleName().     }     return getQualifiedName(type.asElement()). }
false;public;2;15;;@Override public String visitTypeVariable(TypeVariable t, TypeDescriptor descriptor) {     TypeMirror typeMirror = descriptor.resolveGeneric(t).     if (typeMirror != null) {         if (typeMirror instanceof TypeVariable) {             // Still unresolved, let's use upper bound             return visit(((TypeVariable) typeMirror).getUpperBound(), descriptor).         } else {             return visit(typeMirror, descriptor).         }     }     // Unresolved generics, use upper bound     return visit(t.getUpperBound(), descriptor). }
false;public;2;4;;@Override public String visitArray(ArrayType t, TypeDescriptor descriptor) {     return t.getComponentType().accept(this, descriptor) + "[]". }
false;public;2;4;;@Override public String visitPrimitive(PrimitiveType t, TypeDescriptor descriptor) {     return this.types.boxedClass(t).getQualifiedName().toString(). }
false;protected;2;4;;@Override protected String defaultAction(TypeMirror t, TypeDescriptor descriptor) {     return t.toString(). }
false;public;1;15;;public String getQualifiedName(Element element) {     if (element == null) {         return null.     }     TypeElement enclosingElement = getEnclosingTypeElement(element.asType()).     if (enclosingElement != null) {         return getQualifiedName(enclosingElement) + "$" + ((DeclaredType) element.asType()).asElement().getSimpleName().     }     if (element instanceof TypeElement) {         return ((TypeElement) element).getQualifiedName().toString().     }     throw new IllegalStateException("Could not extract qualified name from " + element). }
false;private;1;10;;private TypeElement getEnclosingTypeElement(TypeMirror type) {     if (type instanceof DeclaredType) {         DeclaredType declaredType = (DeclaredType) type.         Element enclosingElement = declaredType.asElement().getEnclosingElement().         if (enclosingElement instanceof TypeElement) {             return (TypeElement) enclosingElement.         }     }     return null. }
false;public;0;3;;public Map<TypeVariable, TypeMirror> getGenerics() {     return Collections.unmodifiableMap(this.generics). }
false;public;1;3;;public TypeMirror resolveGeneric(TypeVariable typeVariable) {     return resolveGeneric(getParameterName(typeVariable)). }
false;public;1;5;;public TypeMirror resolveGeneric(String parameterName) {     return this.generics.entrySet().stream().filter((e) -> getParameterName(e.getKey()).equals(parameterName)).findFirst().map(Entry::getValue).orElse(null). }
false;private;2;10;;private void registerIfNecessary(TypeMirror variable, TypeMirror resolution) {     if (variable instanceof TypeVariable) {         TypeVariable typeVariable = (TypeVariable) variable.         if (this.generics.keySet().stream().noneMatch((candidate) -> getParameterName(candidate).equals(getParameterName(typeVariable)))) {             this.generics.put(typeVariable, resolution).         }     } }
false;private;1;3;;private String getParameterName(TypeVariable typeVariable) {     return typeVariable.asElement().getSimpleName().toString(). }
