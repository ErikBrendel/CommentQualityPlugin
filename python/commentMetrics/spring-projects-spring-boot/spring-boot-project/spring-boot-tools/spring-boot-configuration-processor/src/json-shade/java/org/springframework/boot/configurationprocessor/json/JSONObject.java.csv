commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public boolean equals(Object o) {     // API specifies this broken equals     return o == this || o == null. // implementation }
false;public;0;4;;@Override public String toString() {     return "null". }
true;public;0;3;/**  * Returns the number of name/value mappings in this object.  * @return the number of name/value mappings in this object  */ ;/**  * Returns the number of name/value mappings in this object.  * @return the number of name/value mappings in this object  */ public int length() {     return this.nameValuePairs.size(). }
true;public;2;4;/**  * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with  * the same name.  * @param name the name of the property  * @param value the value of the property  * @return this object.  * @throws JSONException if an error occurs  */ ;/**  * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with  * the same name.  * @param name the name of the property  * @param value the value of the property  * @return this object.  * @throws JSONException if an error occurs  */ public JSONObject put(String name, boolean value) throws JSONException {     this.nameValuePairs.put(checkName(name), value).     return this. }
true;public;2;4;/**  * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with  * the same name.  * @param name the name of the property  * @param value a finite value. May not be {@link Double#isNaN() NaNs} or  * {@link Double#isInfinite() infinities}.  * @return this object.  * @throws JSONException if an error occurs  */ ;/**  * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with  * the same name.  * @param name the name of the property  * @param value a finite value. May not be {@link Double#isNaN() NaNs} or  * {@link Double#isInfinite() infinities}.  * @return this object.  * @throws JSONException if an error occurs  */ public JSONObject put(String name, double value) throws JSONException {     this.nameValuePairs.put(checkName(name), JSON.checkDouble(value)).     return this. }
true;public;2;4;/**  * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with  * the same name.  * @param name the name of the property  * @param value the value of the property  * @return this object.  * @throws JSONException if an error occurs  */ ;/**  * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with  * the same name.  * @param name the name of the property  * @param value the value of the property  * @return this object.  * @throws JSONException if an error occurs  */ public JSONObject put(String name, int value) throws JSONException {     this.nameValuePairs.put(checkName(name), value).     return this. }
true;public;2;4;/**  * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with  * the same name.  * @param name the name of the property  * @param value the value of the property  * @return this object.  * @throws JSONException if an error occurs  */ ;/**  * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with  * the same name.  * @param name the name of the property  * @param value the value of the property  * @return this object.  * @throws JSONException if an error occurs  */ public JSONObject put(String name, long value) throws JSONException {     this.nameValuePairs.put(checkName(name), value).     return this. }
true;public;2;13;/**  * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with  * the same name. If the value is {@code null}, any existing mapping for {@code name}  * is removed.  * @param name the name of the property  * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,  * Long, Double, {@link #NULL}, or {@code null}. May not be {@link Double#isNaN()  * NaNs} or {@link Double#isInfinite() infinities}.  * @return this object.  * @throws JSONException if an error occurs  */ ;/**  * Maps {@code name} to {@code value}, clobbering any existing name/value mapping with  * the same name. If the value is {@code null}, any existing mapping for {@code name}  * is removed.  * @param name the name of the property  * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,  * Long, Double, {@link #NULL}, or {@code null}. May not be {@link Double#isNaN()  * NaNs} or {@link Double#isInfinite() infinities}.  * @return this object.  * @throws JSONException if an error occurs  */ public JSONObject put(String name, Object value) throws JSONException {     if (value == null) {         this.nameValuePairs.remove(name).         return this.     }     if (value instanceof Number) {         // deviate from the original by checking all Numbers, not just floats &         // doubles         JSON.checkDouble(((Number) value).doubleValue()).     }     this.nameValuePairs.put(checkName(name), value).     return this. }
true;public;2;6;/**  * Equivalent to {@code put(name, value)} when both parameters are non-null. does  * nothing otherwise.  * @param name the name of the property  * @param value the value of the property  * @return this object.  * @throws JSONException if an error occurs  */ ;/**  * Equivalent to {@code put(name, value)} when both parameters are non-null. does  * nothing otherwise.  * @param name the name of the property  * @param value the value of the property  * @return this object.  * @throws JSONException if an error occurs  */ public JSONObject putOpt(String name, Object value) throws JSONException {     if (name == null || value == null) {         return this.     }     return put(name, value). }
true;public;2;23;/**  * Appends {@code value} to the array already mapped to {@code name}. If this object  * has no mapping for {@code name}, this inserts a new mapping. If the mapping exists  * but its value is not an array, the existing and new values are inserted in order  * into a new array which is itself mapped to {@code name}. In aggregate, this allows  * values to be added to a mapping one at a time.  * @param name the name of the property  * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,  * Long, Double, {@link #NULL} or null. May not be {@link Double#isNaN() NaNs} or  * {@link Double#isInfinite() infinities}.  * @return this object.  * @throws JSONException if an error occurs  */ ;/**  * Appends {@code value} to the array already mapped to {@code name}. If this object  * has no mapping for {@code name}, this inserts a new mapping. If the mapping exists  * but its value is not an array, the existing and new values are inserted in order  * into a new array which is itself mapped to {@code name}. In aggregate, this allows  * values to be added to a mapping one at a time.  * @param name the name of the property  * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,  * Long, Double, {@link #NULL} or null. May not be {@link Double#isNaN() NaNs} or  * {@link Double#isInfinite() infinities}.  * @return this object.  * @throws JSONException if an error occurs  */ public JSONObject accumulate(String name, Object value) throws JSONException {     Object current = this.nameValuePairs.get(checkName(name)).     if (current == null) {         return put(name, value).     }     // check in accumulate, since array.put(Object) doesn't do any checking     if (value instanceof Number) {         JSON.checkDouble(((Number) value).doubleValue()).     }     if (current instanceof JSONArray) {         JSONArray array = (JSONArray) current.         array.put(value).     } else {         JSONArray array = new JSONArray().         array.put(current).         array.put(value).         this.nameValuePairs.put(name, array).     }     return this. }
false;;1;6;;String checkName(String name) throws JSONException {     if (name == null) {         throw new JSONException("Names must be non-null").     }     return name. }
true;public;1;3;/**  * Removes the named mapping if it exists. does nothing otherwise.  *  * @param name the name of the property  * @return the value previously mapped by {@code name}, or null if there was no such  * mapping.  */ ;/**  * Removes the named mapping if it exists. does nothing otherwise.  *  * @param name the name of the property  * @return the value previously mapped by {@code name}, or null if there was no such  * mapping.  */ public Object remove(String name) {     return this.nameValuePairs.remove(name). }
true;public;1;4;/**  * Returns true if this object has no mapping for {@code name} or if it has a mapping  * whose value is {@link #NULL}.  * @param name the name of the property  * @return true if this object has no mapping for {@code name}  */ ;/**  * Returns true if this object has no mapping for {@code name} or if it has a mapping  * whose value is {@link #NULL}.  * @param name the name of the property  * @return true if this object has no mapping for {@code name}  */ public boolean isNull(String name) {     Object value = this.nameValuePairs.get(name).     return value == null || value == NULL. }
true;public;1;3;/**  * Returns true if this object has a mapping for {@code name}. The mapping may be  * {@link #NULL}.  * @param name the name of the property  * @return true if this object has a mapping for {@code name}  */ ;/**  * Returns true if this object has a mapping for {@code name}. The mapping may be  * {@link #NULL}.  * @param name the name of the property  * @return true if this object has a mapping for {@code name}  */ public boolean has(String name) {     return this.nameValuePairs.containsKey(name). }
true;public;1;7;/**  * Returns the value mapped by {@code name}.  * @param name the name of the property  * @return the value  * @throws JSONException if no such mapping exists.  */ ;/**  * Returns the value mapped by {@code name}.  * @param name the name of the property  * @return the value  * @throws JSONException if no such mapping exists.  */ public Object get(String name) throws JSONException {     Object result = this.nameValuePairs.get(name).     if (result == null) {         throw new JSONException("No value for " + name).     }     return result. }
true;public;1;3;/**  * Returns the value mapped by {@code name}, or null if no such mapping exists.  * @param name the name of the property  * @return the value or {@code null}  */ ;/**  * Returns the value mapped by {@code name}, or null if no such mapping exists.  * @param name the name of the property  * @return the value or {@code null}  */ public Object opt(String name) {     return this.nameValuePairs.get(name). }
true;public;1;8;/**  * Returns the value mapped by {@code name} if it exists and is a boolean or can be  * coerced to a boolean.  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or cannot be coerced to a  * boolean.  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a boolean or can be  * coerced to a boolean.  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or cannot be coerced to a  * boolean.  */ public boolean getBoolean(String name) throws JSONException {     Object object = get(name).     Boolean result = JSON.toBoolean(object).     if (result == null) {         throw JSON.typeMismatch(name, object, "boolean").     }     return result. }
true;public;1;3;/**  * Returns the value mapped by {@code name} if it exists and is a boolean or can be  * coerced to a boolean. Returns false otherwise.  * @param name the name of the property  * @return the value or {@code null}  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a boolean or can be  * coerced to a boolean. Returns false otherwise.  * @param name the name of the property  * @return the value or {@code null}  */ public boolean optBoolean(String name) {     return optBoolean(name, false). }
true;public;2;5;/**  * Returns the value mapped by {@code name} if it exists and is a boolean or can be  * coerced to a boolean. Returns {@code fallback} otherwise.  * @param name the name of the property  * @param fallback a fallback value  * @return the value or {@code fallback}  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a boolean or can be  * coerced to a boolean. Returns {@code fallback} otherwise.  * @param name the name of the property  * @param fallback a fallback value  * @return the value or {@code fallback}  */ public boolean optBoolean(String name, boolean fallback) {     Object object = opt(name).     Boolean result = JSON.toBoolean(object).     return result != null ? result : fallback. }
true;public;1;8;/**  * Returns the value mapped by {@code name} if it exists and is a double or can be  * coerced to a double.  *  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or cannot be coerced to a  * double.  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a double or can be  * coerced to a double.  *  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or cannot be coerced to a  * double.  */ public double getDouble(String name) throws JSONException {     Object object = get(name).     Double result = JSON.toDouble(object).     if (result == null) {         throw JSON.typeMismatch(name, object, "double").     }     return result. }
true;public;1;3;/**  * Returns the value mapped by {@code name} if it exists and is a double or can be  * coerced to a double. Returns {@code NaN} otherwise.  * @param name the name of the property  * @return the value or {@code NaN}  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a double or can be  * coerced to a double. Returns {@code NaN} otherwise.  * @param name the name of the property  * @return the value or {@code NaN}  */ public double optDouble(String name) {     return optDouble(name, Double.NaN). }
true;public;2;5;/**  * Returns the value mapped by {@code name} if it exists and is a double or can be  * coerced to a double. Returns {@code fallback} otherwise.  * @param name the name of the property  * @param fallback a fallback value  * @return the value or {@code fallback}  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a double or can be  * coerced to a double. Returns {@code fallback} otherwise.  * @param name the name of the property  * @param fallback a fallback value  * @return the value or {@code fallback}  */ public double optDouble(String name, double fallback) {     Object object = opt(name).     Double result = JSON.toDouble(object).     return result != null ? result : fallback. }
true;public;1;8;/**  * Returns the value mapped by {@code name} if it exists and is an int or can be  * coerced to an int.  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or cannot be coerced to an int.  */ ;/**  * Returns the value mapped by {@code name} if it exists and is an int or can be  * coerced to an int.  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or cannot be coerced to an int.  */ public int getInt(String name) throws JSONException {     Object object = get(name).     Integer result = JSON.toInteger(object).     if (result == null) {         throw JSON.typeMismatch(name, object, "int").     }     return result. }
true;public;1;3;/**  * Returns the value mapped by {@code name} if it exists and is an int or can be  * coerced to an int. Returns 0 otherwise.  * @param name the name of the property  * @return the value of {@code 0}  */ ;/**  * Returns the value mapped by {@code name} if it exists and is an int or can be  * coerced to an int. Returns 0 otherwise.  * @param name the name of the property  * @return the value of {@code 0}  */ public int optInt(String name) {     return optInt(name, 0). }
true;public;2;5;/**  * Returns the value mapped by {@code name} if it exists and is an int or can be  * coerced to an int. Returns {@code fallback} otherwise.  * @param name the name of the property  * @param fallback a fallback value  * @return the value or {@code fallback}  */ ;/**  * Returns the value mapped by {@code name} if it exists and is an int or can be  * coerced to an int. Returns {@code fallback} otherwise.  * @param name the name of the property  * @param fallback a fallback value  * @return the value or {@code fallback}  */ public int optInt(String name, int fallback) {     Object object = opt(name).     Integer result = JSON.toInteger(object).     return result != null ? result : fallback. }
true;public;1;8;/**  * Returns the value mapped by {@code name} if it exists and is a long or can be  * coerced to a long. Note that JSON represents numbers as doubles, so this is  * <a href="#lossy">lossy</a>. use strings to transfer numbers via JSON.  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or cannot be coerced to a long.  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a long or can be  * coerced to a long. Note that JSON represents numbers as doubles, so this is  * <a href="#lossy">lossy</a>. use strings to transfer numbers via JSON.  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or cannot be coerced to a long.  */ public long getLong(String name) throws JSONException {     Object object = get(name).     Long result = JSON.toLong(object).     if (result == null) {         throw JSON.typeMismatch(name, object, "long").     }     return result. }
true;public;1;3;/**  * Returns the value mapped by {@code name} if it exists and is a long or can be  * coerced to a long. Returns 0 otherwise. Note that JSON represents numbers as  * doubles, so this is <a href="#lossy">lossy</a>. use strings to transfer numbers via  * JSON.  * @param name the name of the property  * @return the value or {@code 0L}  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a long or can be  * coerced to a long. Returns 0 otherwise. Note that JSON represents numbers as  * doubles, so this is <a href="#lossy">lossy</a>. use strings to transfer numbers via  * JSON.  * @param name the name of the property  * @return the value or {@code 0L}  */ public long optLong(String name) {     return optLong(name, 0L). }
true;public;2;5;/**  * Returns the value mapped by {@code name} if it exists and is a long or can be  * coerced to a long. Returns {@code fallback} otherwise. Note that JSON represents  * numbers as doubles, so this is <a href="#lossy">lossy</a>. use strings to transfer  * numbers via JSON.  * @param name the name of the property  * @param fallback a fallback value  * @return the value or {@code fallback}  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a long or can be  * coerced to a long. Returns {@code fallback} otherwise. Note that JSON represents  * numbers as doubles, so this is <a href="#lossy">lossy</a>. use strings to transfer  * numbers via JSON.  * @param name the name of the property  * @param fallback a fallback value  * @return the value or {@code fallback}  */ public long optLong(String name, long fallback) {     Object object = opt(name).     Long result = JSON.toLong(object).     return result != null ? result : fallback. }
true;public;1;8;/**  * Returns the value mapped by {@code name} if it exists, coercing it if necessary.  * @param name the name of the property  * @return the value  * @throws JSONException if no such mapping exists.  */ ;/**  * Returns the value mapped by {@code name} if it exists, coercing it if necessary.  * @param name the name of the property  * @return the value  * @throws JSONException if no such mapping exists.  */ public String getString(String name) throws JSONException {     Object object = get(name).     String result = JSON.toString(object).     if (result == null) {         throw JSON.typeMismatch(name, object, "String").     }     return result. }
true;public;1;3;/**  * Returns the value mapped by {@code name} if it exists, coercing it if necessary.  * Returns the empty string if no such mapping exists.  * @param name the name of the property  * @return the value or an empty string  */ ;/**  * Returns the value mapped by {@code name} if it exists, coercing it if necessary.  * Returns the empty string if no such mapping exists.  * @param name the name of the property  * @return the value or an empty string  */ public String optString(String name) {     return optString(name, ""). }
true;public;2;5;/**  * Returns the value mapped by {@code name} if it exists, coercing it if necessary.  * Returns {@code fallback} if no such mapping exists.  * @param name the name of the property  * @param fallback a fallback value  * @return the value or {@code fallback}  */ ;/**  * Returns the value mapped by {@code name} if it exists, coercing it if necessary.  * Returns {@code fallback} if no such mapping exists.  * @param name the name of the property  * @param fallback a fallback value  * @return the value or {@code fallback}  */ public String optString(String name, String fallback) {     Object object = opt(name).     String result = JSON.toString(object).     return result != null ? result : fallback. }
true;public;1;9;/**  * Returns the value mapped by {@code name} if it exists and is a {@code  * JSONArray}.  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or is not a {@code  *     JSONArray}.  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a {@code  * JSONArray}.  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or is not a {@code  *     JSONArray}.  */ public JSONArray getJSONArray(String name) throws JSONException {     Object object = get(name).     if (object instanceof JSONArray) {         return (JSONArray) object.     } else {         throw JSON.typeMismatch(name, object, "JSONArray").     } }
true;public;1;4;/**  * Returns the value mapped by {@code name} if it exists and is a {@code  * JSONArray}. Returns null otherwise.  * @param name the name of the property  * @return the value or {@code null}  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a {@code  * JSONArray}. Returns null otherwise.  * @param name the name of the property  * @return the value or {@code null}  */ public JSONArray optJSONArray(String name) {     Object object = opt(name).     return object instanceof JSONArray ? (JSONArray) object : null. }
true;public;1;9;/**  * Returns the value mapped by {@code name} if it exists and is a {@code  * JSONObject}.  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or is not a {@code  *     JSONObject}.  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a {@code  * JSONObject}.  * @param name the name of the property  * @return the value  * @throws JSONException if the mapping doesn't exist or is not a {@code  *     JSONObject}.  */ public JSONObject getJSONObject(String name) throws JSONException {     Object object = get(name).     if (object instanceof JSONObject) {         return (JSONObject) object.     } else {         throw JSON.typeMismatch(name, object, "JSONObject").     } }
true;public;1;4;/**  * Returns the value mapped by {@code name} if it exists and is a {@code  * JSONObject}. Returns null otherwise.  * @param name the name of the property  * @return the value or {@code null}  */ ;/**  * Returns the value mapped by {@code name} if it exists and is a {@code  * JSONObject}. Returns null otherwise.  * @param name the name of the property  * @return the value or {@code null}  */ public JSONObject optJSONObject(String name) {     Object object = opt(name).     return object instanceof JSONObject ? (JSONObject) object : null. }
true;public;1;15;/**  * Returns an array with the values corresponding to {@code names}. The array contains  * null for names that aren't mapped. This method returns null if {@code names} is  * either null or empty.  * @param names the names of the properties  * @return the array  */ ;/**  * Returns an array with the values corresponding to {@code names}. The array contains  * null for names that aren't mapped. This method returns null if {@code names} is  * either null or empty.  * @param names the names of the properties  * @return the array  */ public JSONArray toJSONArray(JSONArray names) {     JSONArray result = new JSONArray().     if (names == null) {         return null.     }     int length = names.length().     if (length == 0) {         return null.     }     for (int i = 0. i < length. i++) {         String name = JSON.toString(names.opt(i)).         result.put(opt(name)).     }     return result. }
true;public;0;4;/* Return a raw type for API compatibility */ ;/**  * Returns an iterator of the {@code String} names in this object. The returned  * iterator supports {@link Iterator#remove() remove}, which will remove the  * corresponding mapping from this object. If this object is modified after the  * iterator is returned, the iterator's behavior is undefined. The order of the keys  * is undefined.  * @return the keys  */ /* Return a raw type for API compatibility */ @SuppressWarnings("rawtypes") public Iterator keys() {     return this.nameValuePairs.keySet().iterator(). }
true;public;0;4;/**  * Returns an array containing the string names in this object. This method returns  * null if this object contains no mappings.  * @return the array  */ ;/**  * Returns an array containing the string names in this object. This method returns  * null if this object contains no mappings.  * @return the array  */ public JSONArray names() {     return this.nameValuePairs.isEmpty() ? null : new JSONArray(new ArrayList<>(this.nameValuePairs.keySet())). }
true;public;0;11;/**  * Encodes this object as a compact JSON string, such as:  * <pre>{"query":"Pizza","locations":[94043,90210]}</pre>  * @return a string representation of the object.  */ ;/**  * Encodes this object as a compact JSON string, such as:  * <pre>{"query":"Pizza","locations":[94043,90210]}</pre>  * @return a string representation of the object.  */ @Override public String toString() {     try {         JSONStringer stringer = new JSONStringer().         writeTo(stringer).         return stringer.toString().     } catch (JSONException e) {         return null.     } }
true;public;1;5;/**  * Encodes this object as a human readable JSON string for debugging, such as: <pre>  * {  *     "query": "Pizza",  *     "locations": [  *         94043,  *         90210  *     ]  * }</pre>  * @param indentSpaces the number of spaces to indent for each level of nesting.  * @return a string representation of the object.  * @throws JSONException if an error occurs  */ ;/**  * Encodes this object as a human readable JSON string for debugging, such as: <pre>  * {  *     "query": "Pizza",  *     "locations": [  *         94043,  *         90210  *     ]  * }</pre>  * @param indentSpaces the number of spaces to indent for each level of nesting.  * @return a string representation of the object.  * @throws JSONException if an error occurs  */ public String toString(int indentSpaces) throws JSONException {     JSONStringer stringer = new JSONStringer(indentSpaces).     writeTo(stringer).     return stringer.toString(). }
false;;1;7;;void writeTo(JSONStringer stringer) throws JSONException {     stringer.object().     for (Map.Entry<String, Object> entry : this.nameValuePairs.entrySet()) {         stringer.key(entry.getKey()).value(entry.getValue()).     }     stringer.endObject(). }
true;public,static;1;20;/**  * Encodes the number as a JSON string.  * @param number a finite value. May not be {@link Double#isNaN() NaNs} or  * {@link Double#isInfinite() infinities}.  * @return the encoded value  * @throws JSONException if an error occurs  */ ;/**  * Encodes the number as a JSON string.  * @param number a finite value. May not be {@link Double#isNaN() NaNs} or  * {@link Double#isInfinite() infinities}.  * @return the encoded value  * @throws JSONException if an error occurs  */ public static String numberToString(Number number) throws JSONException {     if (number == null) {         throw new JSONException("Number must be non-null").     }     double doubleValue = number.doubleValue().     JSON.checkDouble(doubleValue).     // the original returns "-0" instead of "-0.0" for negative zero     if (number.equals(NEGATIVE_ZERO)) {         return "-0".     }     long longValue = number.longValue().     if (doubleValue == longValue) {         return Long.toString(longValue).     }     return number.toString(). }
true;public,static;1;15;/**  * Encodes {@code data} as a JSON string. This applies quotes and any necessary  * character escaping.  * @param data the string to encode. Null will be interpreted as an empty string.  * @return the quoted value  */ ;/**  * Encodes {@code data} as a JSON string. This applies quotes and any necessary  * character escaping.  * @param data the string to encode. Null will be interpreted as an empty string.  * @return the quoted value  */ public static String quote(String data) {     if (data == null) {         return "\"\"".     }     try {         JSONStringer stringer = new JSONStringer().         stringer.open(JSONStringer.Scope.NULL, "").         stringer.value(data).         stringer.close(JSONStringer.Scope.NULL, JSONStringer.Scope.NULL, "").         return stringer.toString().     } catch (JSONException e) {         throw new AssertionError().     } }
true;public,static;1;34;/**  * Wraps the given object if necessary.  * <p>  * If the object is null or , returns {@link #NULL}. If the object is a  * {@code JSONArray} or {@code JSONObject}, no wrapping is necessary. If the object is  * {@code NULL}, no wrapping is necessary. If the object is an array or  * {@code Collection}, returns an equivalent {@code JSONArray}. If the object is a  * {@code Map}, returns an equivalent {@code JSONObject}. If the object is a primitive  * wrapper type or {@code String}, returns the object. Otherwise if the object is from  * a {@code java} package, returns the result of {@code toString}. If wrapping fails,  * returns null.  * @param o the object to wrap  * @return the wrapped object  */ ;/**  * Wraps the given object if necessary.  * <p>  * If the object is null or , returns {@link #NULL}. If the object is a  * {@code JSONArray} or {@code JSONObject}, no wrapping is necessary. If the object is  * {@code NULL}, no wrapping is necessary. If the object is an array or  * {@code Collection}, returns an equivalent {@code JSONArray}. If the object is a  * {@code Map}, returns an equivalent {@code JSONObject}. If the object is a primitive  * wrapper type or {@code String}, returns the object. Otherwise if the object is from  * a {@code java} package, returns the result of {@code toString}. If wrapping fails,  * returns null.  * @param o the object to wrap  * @return the wrapped object  */ @SuppressWarnings("rawtypes") public static Object wrap(Object o) {     if (o == null) {         return NULL.     }     if (o instanceof JSONArray || o instanceof JSONObject) {         return o.     }     if (o.equals(NULL)) {         return o.     }     try {         if (o instanceof Collection) {             return new JSONArray((Collection) o).         } else if (o.getClass().isArray()) {             return new JSONArray(o).         }         if (o instanceof Map) {             return new JSONObject((Map) o).         }         if (o instanceof Boolean || o instanceof Byte || o instanceof Character || o instanceof Double || o instanceof Float || o instanceof Integer || o instanceof Long || o instanceof Short || o instanceof String) {             return o.         }         if (o.getClass().getPackage().getName().startsWith("java.")) {             return o.toString().         }     } catch (Exception ignored) {     }     return null. }
