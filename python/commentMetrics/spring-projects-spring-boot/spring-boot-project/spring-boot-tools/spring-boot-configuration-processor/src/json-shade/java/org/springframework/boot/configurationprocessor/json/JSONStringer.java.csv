commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Begins encoding a new array. Each call to this method must be paired with a call to  * {@link #endArray}.  * @return this stringer.  * @throws JSONException if processing of json failed  */ ;/**  * Begins encoding a new array. Each call to this method must be paired with a call to  * {@link #endArray}.  * @return this stringer.  * @throws JSONException if processing of json failed  */ public JSONStringer array() throws JSONException {     return open(Scope.EMPTY_ARRAY, "["). }
true;public;0;3;/**  * Ends encoding the current array.  * @return this stringer.  * @throws JSONException if processing of json failed  */ ;/**  * Ends encoding the current array.  * @return this stringer.  * @throws JSONException if processing of json failed  */ public JSONStringer endArray() throws JSONException {     return close(Scope.EMPTY_ARRAY, Scope.NONEMPTY_ARRAY, "]"). }
true;public;0;3;/**  * Begins encoding a new object. Each call to this method must be paired with a call  * to {@link #endObject}.  * @return this stringer.  * @throws JSONException if processing of json failed  */ ;/**  * Begins encoding a new object. Each call to this method must be paired with a call  * to {@link #endObject}.  * @return this stringer.  * @throws JSONException if processing of json failed  */ public JSONStringer object() throws JSONException {     return open(Scope.EMPTY_OBJECT, "{"). }
true;public;0;3;/**  * Ends encoding the current object.  * @return this stringer.  * @throws JSONException if processing of json failed  */ ;/**  * Ends encoding the current object.  * @return this stringer.  * @throws JSONException if processing of json failed  */ public JSONStringer endObject() throws JSONException {     return close(Scope.EMPTY_OBJECT, Scope.NONEMPTY_OBJECT, "}"). }
true;;2;9;/**  * Enters a new scope by appending any necessary whitespace and the given bracket.  * @param empty any necessary whitespace  * @param openBracket the open bracket  * @return this object  * @throws JSONException if processing of json failed  */ ;/**  * Enters a new scope by appending any necessary whitespace and the given bracket.  * @param empty any necessary whitespace  * @param openBracket the open bracket  * @return this object  * @throws JSONException if processing of json failed  */ JSONStringer open(Scope empty, String openBracket) throws JSONException {     if (this.stack.isEmpty() && this.out.length() > 0) {         throw new JSONException("Nesting problem: multiple top-level roots").     }     beforeValue().     this.stack.add(empty).     this.out.append(openBracket).     return this. }
true;;3;14;/**  * Closes the current scope by appending any necessary whitespace and the given  * bracket.  * @param empty any necessary whitespace  * @param nonempty the current scope  * @param closeBracket the close bracket  * @return the JSON stringer  * @throws JSONException if processing of json failed  */ ;/**  * Closes the current scope by appending any necessary whitespace and the given  * bracket.  * @param empty any necessary whitespace  * @param nonempty the current scope  * @param closeBracket the close bracket  * @return the JSON stringer  * @throws JSONException if processing of json failed  */ JSONStringer close(Scope empty, Scope nonempty, String closeBracket) throws JSONException {     Scope context = peek().     if (context != nonempty && context != empty) {         throw new JSONException("Nesting problem").     }     this.stack.remove(this.stack.size() - 1).     if (context == nonempty) {         newline().     }     this.out.append(closeBracket).     return this. }
true;private;0;6;/**  * Returns the value on the top of the stack.  * @return the scope  * @throws JSONException if processing of json failed  */ ;/**  * Returns the value on the top of the stack.  * @return the scope  * @throws JSONException if processing of json failed  */ private Scope peek() throws JSONException {     if (this.stack.isEmpty()) {         throw new JSONException("Nesting problem").     }     return this.stack.get(this.stack.size() - 1). }
true;private;1;3;/**  * Replace the value on the top of the stack with the given value.  * @param topOfStack the scope at the top of the stack  */ ;/**  * Replace the value on the top of the stack with the given value.  * @param topOfStack the scope at the top of the stack  */ private void replaceTop(Scope topOfStack) {     this.stack.set(this.stack.size() - 1, topOfStack). }
true;public;1;31;/**  * Encodes {@code value}.  * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,  * Long, Double or null. May not be {@link Double#isNaN() NaNs} or  * {@link Double#isInfinite() infinities}.  * @return this stringer.  * @throws JSONException if processing of json failed  */ ;/**  * Encodes {@code value}.  * @param value a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer,  * Long, Double or null. May not be {@link Double#isNaN() NaNs} or  * {@link Double#isInfinite() infinities}.  * @return this stringer.  * @throws JSONException if processing of json failed  */ public JSONStringer value(Object value) throws JSONException {     if (this.stack.isEmpty()) {         throw new JSONException("Nesting problem").     }     if (value instanceof JSONArray) {         ((JSONArray) value).writeTo(this).         return this.     } else if (value instanceof JSONObject) {         ((JSONObject) value).writeTo(this).         return this.     }     beforeValue().     if (value == null || value instanceof Boolean || value == JSONObject.NULL) {         this.out.append(value).     } else if (value instanceof Number) {         this.out.append(JSONObject.numberToString((Number) value)).     } else {         string(value.toString()).     }     return this. }
true;public;1;8;/**  * Encodes {@code value} to this stringer.  * @param value the value to encode  * @return this stringer.  * @throws JSONException if processing of json failed  */ ;/**  * Encodes {@code value} to this stringer.  * @param value the value to encode  * @return this stringer.  * @throws JSONException if processing of json failed  */ public JSONStringer value(boolean value) throws JSONException {     if (this.stack.isEmpty()) {         throw new JSONException("Nesting problem").     }     beforeValue().     this.out.append(value).     return this. }
true;public;1;8;/**  * Encodes {@code value} to this stringer.  * @param value a finite value. May not be {@link Double#isNaN() NaNs} or  * {@link Double#isInfinite() infinities}.  * @return this stringer.  * @throws JSONException if processing of json failed  */ ;/**  * Encodes {@code value} to this stringer.  * @param value a finite value. May not be {@link Double#isNaN() NaNs} or  * {@link Double#isInfinite() infinities}.  * @return this stringer.  * @throws JSONException if processing of json failed  */ public JSONStringer value(double value) throws JSONException {     if (this.stack.isEmpty()) {         throw new JSONException("Nesting problem").     }     beforeValue().     this.out.append(JSONObject.numberToString(value)).     return this. }
true;public;1;8;/**  * Encodes {@code value} to this stringer.  * @param value the value to encode  * @return this stringer.  * @throws JSONException if processing of json failed  */ ;/**  * Encodes {@code value} to this stringer.  * @param value the value to encode  * @return this stringer.  * @throws JSONException if processing of json failed  */ public JSONStringer value(long value) throws JSONException {     if (this.stack.isEmpty()) {         throw new JSONException("Nesting problem").     }     beforeValue().     this.out.append(value).     return this. }
false;private;1;50;;private void string(String value) {     this.out.append("\"").     for (int i = 0, length = value.length(). i < length. i++) {         char c = value.charAt(i).         /* 			 * From RFC 4627, "All Unicode characters may be placed within the quotation 			 * marks except for the characters that must be escaped: quotation mark, 			 * reverse solidus, and the control characters (U+0000 through U+001F)." 			 */         switch(c) {             case '"':             case '\\':             case '/':                 this.out.append('\\').append(c).                 break.             case '\t':                 this.out.append("\\t").                 break.             case '\b':                 this.out.append("\\b").                 break.             case '\n':                 this.out.append("\\n").                 break.             case '\r':                 this.out.append("\\r").                 break.             case '\f':                 this.out.append("\\f").                 break.             default:                 if (c <= 0x1F) {                     this.out.append(String.format("\\u%04x", (int) c)).                 } else {                     this.out.append(c).                 }                 break.         }     }     this.out.append("\""). }
false;private;0;10;;private void newline() {     if (this.indent == null) {         return.     }     this.out.append("\n").     for (int i = 0. i < this.stack.size(). i++) {         this.out.append(this.indent).     } }
true;public;1;8;/**  * Encodes the key (property name) to this stringer.  * @param name the name of the forthcoming value. May not be null.  * @return this stringer.  * @throws JSONException if processing of json failed  */ ;/**  * Encodes the key (property name) to this stringer.  * @param name the name of the forthcoming value. May not be null.  * @return this stringer.  * @throws JSONException if processing of json failed  */ public JSONStringer key(String name) throws JSONException {     if (name == null) {         throw new JSONException("Names must be non-null").     }     beforeKey().     string(name).     return this. }
true;private;0;11;/**  * Inserts any necessary separators and whitespace before a name. Also adjusts the  * stack to expect the key's value.  * @throws JSONException if processing of json failed  */ ;/**  * Inserts any necessary separators and whitespace before a name. Also adjusts the  * stack to expect the key's value.  * @throws JSONException if processing of json failed  */ private void beforeKey() throws JSONException {     Scope context = peek().     if (context == Scope.NONEMPTY_OBJECT) {         // first in object         this.out.append(',').     } else if (context != Scope.EMPTY_OBJECT) {         // not in an object!         throw new JSONException("Nesting problem").     }     newline().     replaceTop(Scope.DANGLING_KEY). }
true;private;0;22;/**  * Inserts any necessary separators and whitespace before a literal value, inline  * array, or inline object. Also adjusts the stack to expect either a closing bracket  * or another element.  * @throws JSONException if processing of json failed  */ ;/**  * Inserts any necessary separators and whitespace before a literal value, inline  * array, or inline object. Also adjusts the stack to expect either a closing bracket  * or another element.  * @throws JSONException if processing of json failed  */ private void beforeValue() throws JSONException {     if (this.stack.isEmpty()) {         return.     }     Scope context = peek().     if (context == Scope.EMPTY_ARRAY) {         // first in array         replaceTop(Scope.NONEMPTY_ARRAY).         newline().     } else if (context == Scope.NONEMPTY_ARRAY) {         // another in array         this.out.append(',').         newline().     } else if (context == Scope.DANGLING_KEY) {         // value for key         this.out.append(this.indent == null ? ":" : ": ").         replaceTop(Scope.NONEMPTY_OBJECT).     } else if (context != Scope.NULL) {         throw new JSONException("Nesting problem").     } }
true;public;0;4;/**  * Returns the encoded JSON string.  * <p>  * If invoked with unterminated arrays or unclosed objects, this method's return value  * is undefined.  * <p>  * <strong>Warning:</strong> although it contradicts the general contract of  * {@link Object#toString}, this method returns null if the stringer contains no data.  * @return the encoded JSON string.  */ ;/**  * Returns the encoded JSON string.  * <p>  * If invoked with unterminated arrays or unclosed objects, this method's return value  * is undefined.  * <p>  * <strong>Warning:</strong> although it contradicts the general contract of  * {@link Object#toString}, this method returns null if the stringer contains no data.  * @return the encoded JSON string.  */ @Override public String toString() {     return this.out.length() == 0 ? null : this.out.toString(). }
