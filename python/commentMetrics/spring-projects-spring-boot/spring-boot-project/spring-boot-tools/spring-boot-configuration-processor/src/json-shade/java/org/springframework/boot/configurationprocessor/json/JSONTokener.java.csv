# id;timestamp;commentText;codeText;commentWords;codeWords
JSONTokener -> private Object readLiteral() throws JSONException;1515446271;Reads a null, boolean, numeric or unquoted string literal value. Numeric values_will be returned as an Integer, Long, or Double, in that order of preference._@return a literal value_@throws JSONException if processing of json failed;private Object readLiteral() throws JSONException {_		String literal = nextToInternal("{}[]/\\:,=_# \t\f")___		if (literal.length() == 0) {_			throw syntaxError("Expected literal value")__		}_		else if ("null".equalsIgnoreCase(literal)) {_			return JSONObject.NULL__		}_		else if ("true".equalsIgnoreCase(literal)) {_			return Boolean.TRUE__		}_		else if ("false".equalsIgnoreCase(literal)) {_			return Boolean.FALSE__		}__		_		if (literal.indexOf('.') == -1) {_			int base = 10__			String number = literal__			if (number.startsWith("0x") || number.startsWith("0X")) {_				number = number.substring(2)__				base = 16__			}_			else if (number.startsWith("0") && number.length() > 1) {_				number = number.substring(1)__				base = 8__			}_			try {_				long longValue = Long.parseLong(number, base)__				if (longValue <= Integer.MAX_VALUE && longValue >= Integer.MIN_VALUE) {_					return (int) longValue__				}_				else {_					return longValue__				}_			}_			catch (NumberFormatException e) {_				_			}_		}__		_		try {_			return Double.valueOf(literal)__		}_		catch (NumberFormatException ignored) {_		}__		_		return new String(literal)_ _	};reads,a,null,boolean,numeric,or,unquoted,string,literal,value,numeric,values,will,be,returned,as,an,integer,long,or,double,in,that,order,of,preference,return,a,literal,value,throws,jsonexception,if,processing,of,json,failed;private,object,read,literal,throws,jsonexception,string,literal,next,to,internal,t,f,if,literal,length,0,throw,syntax,error,expected,literal,value,else,if,null,equals,ignore,case,literal,return,jsonobject,null,else,if,true,equals,ignore,case,literal,return,boolean,true,else,if,false,equals,ignore,case,literal,return,boolean,false,if,literal,index,of,1,int,base,10,string,number,literal,if,number,starts,with,0x,number,starts,with,0x,number,number,substring,2,base,16,else,if,number,starts,with,0,number,length,1,number,number,substring,1,base,8,try,long,long,value,long,parse,long,number,base,if,long,value,integer,long,value,integer,return,int,long,value,else,return,long,value,catch,number,format,exception,e,try,return,double,value,of,literal,catch,number,format,exception,ignored,return,new,string,literal
JSONTokener -> private Object readLiteral() throws JSONException;1516008705;Reads a null, boolean, numeric or unquoted string literal value. Numeric values_will be returned as an Integer, Long, or Double, in that order of preference._@return a literal value_@throws JSONException if processing of json failed;private Object readLiteral() throws JSONException {_		String literal = nextToInternal("{}[]/\\:,=_# \t\f")___		if (literal.length() == 0) {_			throw syntaxError("Expected literal value")__		}_		else if ("null".equalsIgnoreCase(literal)) {_			return JSONObject.NULL__		}_		else if ("true".equalsIgnoreCase(literal)) {_			return Boolean.TRUE__		}_		else if ("false".equalsIgnoreCase(literal)) {_			return Boolean.FALSE__		}__		_		if (literal.indexOf('.') == -1) {_			int base = 10__			String number = literal__			if (number.startsWith("0x") || number.startsWith("0X")) {_				number = number.substring(2)__				base = 16__			}_			else if (number.startsWith("0") && number.length() > 1) {_				number = number.substring(1)__				base = 8__			}_			try {_				long longValue = Long.parseLong(number, base)__				if (longValue <= Integer.MAX_VALUE && longValue >= Integer.MIN_VALUE) {_					return (int) longValue__				}_				else {_					return longValue__				}_			}_			catch (NumberFormatException e) {_				_			}_		}__		_		try {_			return Double.valueOf(literal)__		}_		catch (NumberFormatException ignored) {_		}__		_		return new String(literal)_ _	};reads,a,null,boolean,numeric,or,unquoted,string,literal,value,numeric,values,will,be,returned,as,an,integer,long,or,double,in,that,order,of,preference,return,a,literal,value,throws,jsonexception,if,processing,of,json,failed;private,object,read,literal,throws,jsonexception,string,literal,next,to,internal,t,f,if,literal,length,0,throw,syntax,error,expected,literal,value,else,if,null,equals,ignore,case,literal,return,jsonobject,null,else,if,true,equals,ignore,case,literal,return,boolean,true,else,if,false,equals,ignore,case,literal,return,boolean,false,if,literal,index,of,1,int,base,10,string,number,literal,if,number,starts,with,0x,number,starts,with,0x,number,number,substring,2,base,16,else,if,number,starts,with,0,number,length,1,number,number,substring,1,base,8,try,long,long,value,long,parse,long,number,base,if,long,value,integer,long,value,integer,return,int,long,value,else,return,long,value,catch,number,format,exception,e,try,return,double,value,of,literal,catch,number,format,exception,ignored,return,new,string,literal
JSONTokener -> private Object readLiteral() throws JSONException;1516665640;Reads a null, boolean, numeric or unquoted string literal value. Numeric values_will be returned as an Integer, Long, or Double, in that order of preference._@return a literal value_@throws JSONException if processing of json failed;private Object readLiteral() throws JSONException {_		String literal = nextToInternal("{}[]/\\:,=_# \t\f")___		if (literal.isEmpty()) {_			throw syntaxError("Expected literal value")__		}_		else if ("null".equalsIgnoreCase(literal)) {_			return JSONObject.NULL__		}_		else if ("true".equalsIgnoreCase(literal)) {_			return Boolean.TRUE__		}_		else if ("false".equalsIgnoreCase(literal)) {_			return Boolean.FALSE__		}__		_		if (literal.indexOf('.') == -1) {_			int base = 10__			String number = literal__			if (number.startsWith("0x") || number.startsWith("0X")) {_				number = number.substring(2)__				base = 16__			}_			else if (number.startsWith("0") && number.length() > 1) {_				number = number.substring(1)__				base = 8__			}_			try {_				long longValue = Long.parseLong(number, base)__				if (longValue <= Integer.MAX_VALUE && longValue >= Integer.MIN_VALUE) {_					return (int) longValue__				}_				else {_					return longValue__				}_			}_			catch (NumberFormatException e) {_				_			}_		}__		_		try {_			return Double.valueOf(literal)__		}_		catch (NumberFormatException ignored) {_		}__		_		return new String(literal)_ _	};reads,a,null,boolean,numeric,or,unquoted,string,literal,value,numeric,values,will,be,returned,as,an,integer,long,or,double,in,that,order,of,preference,return,a,literal,value,throws,jsonexception,if,processing,of,json,failed;private,object,read,literal,throws,jsonexception,string,literal,next,to,internal,t,f,if,literal,is,empty,throw,syntax,error,expected,literal,value,else,if,null,equals,ignore,case,literal,return,jsonobject,null,else,if,true,equals,ignore,case,literal,return,boolean,true,else,if,false,equals,ignore,case,literal,return,boolean,false,if,literal,index,of,1,int,base,10,string,number,literal,if,number,starts,with,0x,number,starts,with,0x,number,number,substring,2,base,16,else,if,number,starts,with,0,number,length,1,number,number,substring,1,base,8,try,long,long,value,long,parse,long,number,base,if,long,value,integer,long,value,integer,return,int,long,value,else,return,long,value,catch,number,format,exception,e,try,return,double,value,of,literal,catch,number,format,exception,ignored,return,new,string,literal
JSONTokener -> private Object readLiteral() throws JSONException;1518087233;Reads a null, boolean, numeric or unquoted string literal value. Numeric values_will be returned as an Integer, Long, or Double, in that order of preference._@return a literal value_@throws JSONException if processing of json failed;private Object readLiteral() throws JSONException {_		String literal = nextToInternal("{}[]/\\:,=_# \t\f")___		if (literal.isEmpty()) {_			throw syntaxError("Expected literal value")__		}_		else if ("null".equalsIgnoreCase(literal)) {_			return JSONObject.NULL__		}_		else if ("true".equalsIgnoreCase(literal)) {_			return Boolean.TRUE__		}_		else if ("false".equalsIgnoreCase(literal)) {_			return Boolean.FALSE__		}__		_		if (literal.indexOf('.') == -1) {_			int base = 10__			String number = literal__			if (number.startsWith("0x") || number.startsWith("0X")) {_				number = number.substring(2)__				base = 16__			}_			else if (number.startsWith("0") && number.length() > 1) {_				number = number.substring(1)__				base = 8__			}_			try {_				long longValue = Long.parseLong(number, base)__				if (longValue <= Integer.MAX_VALUE && longValue >= Integer.MIN_VALUE) {_					return (int) longValue__				}_				else {_					return longValue__				}_			}_			catch (NumberFormatException e) {_				_			}_		}__		_		try {_			return Double.valueOf(literal)__		}_		catch (NumberFormatException ignored) {_		}__		_		return new String(literal)_ _	};reads,a,null,boolean,numeric,or,unquoted,string,literal,value,numeric,values,will,be,returned,as,an,integer,long,or,double,in,that,order,of,preference,return,a,literal,value,throws,jsonexception,if,processing,of,json,failed;private,object,read,literal,throws,jsonexception,string,literal,next,to,internal,t,f,if,literal,is,empty,throw,syntax,error,expected,literal,value,else,if,null,equals,ignore,case,literal,return,jsonobject,null,else,if,true,equals,ignore,case,literal,return,boolean,true,else,if,false,equals,ignore,case,literal,return,boolean,false,if,literal,index,of,1,int,base,10,string,number,literal,if,number,starts,with,0x,number,starts,with,0x,number,number,substring,2,base,16,else,if,number,starts,with,0,number,length,1,number,number,substring,1,base,8,try,long,long,value,long,parse,long,number,base,if,long,value,integer,long,value,integer,return,int,long,value,else,return,long,value,catch,number,format,exception,e,try,return,double,value,of,literal,catch,number,format,exception,ignored,return,new,string,literal
JSONTokener -> private void skipToEndOfLine();1515446271;Advances the position until after the next newline character. If the line is_terminated by "\r\n", the '\n' must be consumed as whitespace by the caller.;private void skipToEndOfLine() {_		for (_ this.pos < this.in.length()_ this.pos++) {_			char c = this.in.charAt(this.pos)__			if (c == '\r' || c == '\n') {_				this.pos++__				break__			}_		}_	};advances,the,position,until,after,the,next,newline,character,if,the,line,is,terminated,by,r,n,the,n,must,be,consumed,as,whitespace,by,the,caller;private,void,skip,to,end,of,line,for,this,pos,this,in,length,this,pos,char,c,this,in,char,at,this,pos,if,c,r,c,n,this,pos,break
JSONTokener -> private void skipToEndOfLine();1516008705;Advances the position until after the next newline character. If the line is_terminated by "\r\n", the '\n' must be consumed as whitespace by the caller.;private void skipToEndOfLine() {_		for (_ this.pos < this.in.length()_ this.pos++) {_			char c = this.in.charAt(this.pos)__			if (c == '\r' || c == '\n') {_				this.pos++__				break__			}_		}_	};advances,the,position,until,after,the,next,newline,character,if,the,line,is,terminated,by,r,n,the,n,must,be,consumed,as,whitespace,by,the,caller;private,void,skip,to,end,of,line,for,this,pos,this,in,length,this,pos,char,c,this,in,char,at,this,pos,if,c,r,c,n,this,pos,break
JSONTokener -> private void skipToEndOfLine();1516665640;Advances the position until after the next newline character. If the line is_terminated by "\r\n", the '\n' must be consumed as whitespace by the caller.;private void skipToEndOfLine() {_		for (_ this.pos < this.in.length()_ this.pos++) {_			char c = this.in.charAt(this.pos)__			if (c == '\r' || c == '\n') {_				this.pos++__				break__			}_		}_	};advances,the,position,until,after,the,next,newline,character,if,the,line,is,terminated,by,r,n,the,n,must,be,consumed,as,whitespace,by,the,caller;private,void,skip,to,end,of,line,for,this,pos,this,in,length,this,pos,char,c,this,in,char,at,this,pos,if,c,r,c,n,this,pos,break
JSONTokener -> private void skipToEndOfLine();1518087233;Advances the position until after the next newline character. If the line is_terminated by "\r\n", the '\n' must be consumed as whitespace by the caller.;private void skipToEndOfLine() {_		for (_ this.pos < this.in.length()_ this.pos++) {_			char c = this.in.charAt(this.pos)__			if (c == '\r' || c == '\n') {_				this.pos++__				break__			}_		}_	};advances,the,position,until,after,the,next,newline,character,if,the,line,is,terminated,by,r,n,the,n,must,be,consumed,as,whitespace,by,the,caller;private,void,skip,to,end,of,line,for,this,pos,this,in,length,this,pos,char,c,this,in,char,at,this,pos,if,c,r,c,n,this,pos,break
JSONTokener -> public JSONException syntaxError(String message);1515446271;Returns an exception containing the given message plus the current position and the_entire input string._@param message the message_@return an exception;public JSONException syntaxError(String message) {_		return new JSONException(message + this)__	};returns,an,exception,containing,the,given,message,plus,the,current,position,and,the,entire,input,string,param,message,the,message,return,an,exception;public,jsonexception,syntax,error,string,message,return,new,jsonexception,message,this
JSONTokener -> public JSONException syntaxError(String message);1516008705;Returns an exception containing the given message plus the current position and the_entire input string._@param message the message_@return an exception;public JSONException syntaxError(String message) {_		return new JSONException(message + this)__	};returns,an,exception,containing,the,given,message,plus,the,current,position,and,the,entire,input,string,param,message,the,message,return,an,exception;public,jsonexception,syntax,error,string,message,return,new,jsonexception,message,this
JSONTokener -> public JSONException syntaxError(String message);1516665640;Returns an exception containing the given message plus the current position and the_entire input string._@param message the message_@return an exception;public JSONException syntaxError(String message) {_		return new JSONException(message + this)__	};returns,an,exception,containing,the,given,message,plus,the,current,position,and,the,entire,input,string,param,message,the,message,return,an,exception;public,jsonexception,syntax,error,string,message,return,new,jsonexception,message,this
JSONTokener -> public JSONException syntaxError(String message);1518087233;Returns an exception containing the given message plus the current position and the_entire input string._@param message the message_@return an exception;public JSONException syntaxError(String message) {_		return new JSONException(message + this)__	};returns,an,exception,containing,the,given,message,plus,the,current,position,and,the,entire,input,string,param,message,the,message,return,an,exception;public,jsonexception,syntax,error,string,message,return,new,jsonexception,message,this
JSONTokener -> public Object nextValue() throws JSONException;1515446271;Returns the next value from the input._@return a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,_Double or {@link JSONObject#NULL}._@throws JSONException if the input is malformed.;public Object nextValue() throws JSONException {_		int c = nextCleanInternal()__		switch (c) {_		case -1:_			throw syntaxError("End of input")___		case '{':_			return readObject()___		case '[':_			return readArray()___		case '\'':_		case '"':_			return nextString((char) c)___		default:_			this.pos--__			return readLiteral()__		}_	};returns,the,next,value,from,the,input,return,a,link,jsonobject,link,jsonarray,string,boolean,integer,long,double,or,link,jsonobject,null,throws,jsonexception,if,the,input,is,malformed;public,object,next,value,throws,jsonexception,int,c,next,clean,internal,switch,c,case,1,throw,syntax,error,end,of,input,case,return,read,object,case,return,read,array,case,case,return,next,string,char,c,default,this,pos,return,read,literal
JSONTokener -> public Object nextValue() throws JSONException;1516008705;Returns the next value from the input._@return a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,_Double or {@link JSONObject#NULL}._@throws JSONException if the input is malformed.;public Object nextValue() throws JSONException {_		int c = nextCleanInternal()__		switch (c) {_		case -1:_			throw syntaxError("End of input")___		case '{':_			return readObject()___		case '[':_			return readArray()___		case '\'':_		case '"':_			return nextString((char) c)___		default:_			this.pos--__			return readLiteral()__		}_	};returns,the,next,value,from,the,input,return,a,link,jsonobject,link,jsonarray,string,boolean,integer,long,double,or,link,jsonobject,null,throws,jsonexception,if,the,input,is,malformed;public,object,next,value,throws,jsonexception,int,c,next,clean,internal,switch,c,case,1,throw,syntax,error,end,of,input,case,return,read,object,case,return,read,array,case,case,return,next,string,char,c,default,this,pos,return,read,literal
JSONTokener -> public Object nextValue() throws JSONException;1516665640;Returns the next value from the input._@return a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,_Double or {@link JSONObject#NULL}._@throws JSONException if the input is malformed.;public Object nextValue() throws JSONException {_		int c = nextCleanInternal()__		switch (c) {_		case -1:_			throw syntaxError("End of input")___		case '{':_			return readObject()___		case '[':_			return readArray()___		case '\'':_		case '"':_			return nextString((char) c)___		default:_			this.pos--__			return readLiteral()__		}_	};returns,the,next,value,from,the,input,return,a,link,jsonobject,link,jsonarray,string,boolean,integer,long,double,or,link,jsonobject,null,throws,jsonexception,if,the,input,is,malformed;public,object,next,value,throws,jsonexception,int,c,next,clean,internal,switch,c,case,1,throw,syntax,error,end,of,input,case,return,read,object,case,return,read,array,case,case,return,next,string,char,c,default,this,pos,return,read,literal
JSONTokener -> public Object nextValue() throws JSONException;1518087233;Returns the next value from the input._@return a {@link JSONObject}, {@link JSONArray}, String, Boolean, Integer, Long,_Double or {@link JSONObject#NULL}._@throws JSONException if the input is malformed.;public Object nextValue() throws JSONException {_		int c = nextCleanInternal()__		switch (c) {_		case -1:_			throw syntaxError("End of input")___		case '{':_			return readObject()___		case '[':_			return readArray()___		case '\'':_		case '"':_			return nextString((char) c)___		default:_			this.pos--__			return readLiteral()__		}_	};returns,the,next,value,from,the,input,return,a,link,jsonobject,link,jsonarray,string,boolean,integer,long,double,or,link,jsonobject,null,throws,jsonexception,if,the,input,is,malformed;public,object,next,value,throws,jsonexception,int,c,next,clean,internal,switch,c,case,1,throw,syntax,error,end,of,input,case,return,read,object,case,return,read,array,case,case,return,next,string,char,c,default,this,pos,return,read,literal
JSONTokener -> public String nextString(char quote) throws JSONException;1515446271;Returns the string up to but not including {@code quote}, unescaping any character_escape sequences encountered along the way. The opening quote should have already_been read. This consumes the closing quote, but does not include it in the returned_string._@param quote either ' or "._@return the string up to but not including {@code quote}_@throws NumberFormatException if any unicode escape sequences are malformed._@throws JSONException if processing of json failed;public String nextString(char quote) throws JSONException {_		_		StringBuilder builder = null___		_		int start = this.pos___		while (this.pos < this.in.length()) {_			int c = this.in.charAt(this.pos++)__			if (c == quote) {_				if (builder == null) {_					_					return new String(this.in.substring(start, this.pos - 1))__				}_				else {_					builder.append(this.in, start, this.pos - 1)__					return builder.toString()__				}_			}__			if (c == '\\') {_				if (this.pos == this.in.length()) {_					throw syntaxError("Unterminated escape sequence")__				}_				if (builder == null) {_					builder = new StringBuilder()__				}_				builder.append(this.in, start, this.pos - 1)__				builder.append(readEscapeCharacter())__				start = this.pos__			}_		}__		throw syntaxError("Unterminated string")__	};returns,the,string,up,to,but,not,including,code,quote,unescaping,any,character,escape,sequences,encountered,along,the,way,the,opening,quote,should,have,already,been,read,this,consumes,the,closing,quote,but,does,not,include,it,in,the,returned,string,param,quote,either,or,return,the,string,up,to,but,not,including,code,quote,throws,number,format,exception,if,any,unicode,escape,sequences,are,malformed,throws,jsonexception,if,processing,of,json,failed;public,string,next,string,char,quote,throws,jsonexception,string,builder,builder,null,int,start,this,pos,while,this,pos,this,in,length,int,c,this,in,char,at,this,pos,if,c,quote,if,builder,null,return,new,string,this,in,substring,start,this,pos,1,else,builder,append,this,in,start,this,pos,1,return,builder,to,string,if,c,if,this,pos,this,in,length,throw,syntax,error,unterminated,escape,sequence,if,builder,null,builder,new,string,builder,builder,append,this,in,start,this,pos,1,builder,append,read,escape,character,start,this,pos,throw,syntax,error,unterminated,string
JSONTokener -> public String nextString(char quote) throws JSONException;1516008705;Returns the string up to but not including {@code quote}, unescaping any character_escape sequences encountered along the way. The opening quote should have already_been read. This consumes the closing quote, but does not include it in the returned_string._@param quote either ' or "._@return the string up to but not including {@code quote}_@throws NumberFormatException if any unicode escape sequences are malformed._@throws JSONException if processing of json failed;public String nextString(char quote) throws JSONException {_		_		StringBuilder builder = null___		_		int start = this.pos___		while (this.pos < this.in.length()) {_			int c = this.in.charAt(this.pos++)__			if (c == quote) {_				if (builder == null) {_					_					return new String(this.in.substring(start, this.pos - 1))__				}_				else {_					builder.append(this.in, start, this.pos - 1)__					return builder.toString()__				}_			}__			if (c == '\\') {_				if (this.pos == this.in.length()) {_					throw syntaxError("Unterminated escape sequence")__				}_				if (builder == null) {_					builder = new StringBuilder()__				}_				builder.append(this.in, start, this.pos - 1)__				builder.append(readEscapeCharacter())__				start = this.pos__			}_		}__		throw syntaxError("Unterminated string")__	};returns,the,string,up,to,but,not,including,code,quote,unescaping,any,character,escape,sequences,encountered,along,the,way,the,opening,quote,should,have,already,been,read,this,consumes,the,closing,quote,but,does,not,include,it,in,the,returned,string,param,quote,either,or,return,the,string,up,to,but,not,including,code,quote,throws,number,format,exception,if,any,unicode,escape,sequences,are,malformed,throws,jsonexception,if,processing,of,json,failed;public,string,next,string,char,quote,throws,jsonexception,string,builder,builder,null,int,start,this,pos,while,this,pos,this,in,length,int,c,this,in,char,at,this,pos,if,c,quote,if,builder,null,return,new,string,this,in,substring,start,this,pos,1,else,builder,append,this,in,start,this,pos,1,return,builder,to,string,if,c,if,this,pos,this,in,length,throw,syntax,error,unterminated,escape,sequence,if,builder,null,builder,new,string,builder,builder,append,this,in,start,this,pos,1,builder,append,read,escape,character,start,this,pos,throw,syntax,error,unterminated,string
JSONTokener -> public String nextString(char quote) throws JSONException;1516665640;Returns the string up to but not including {@code quote}, unescaping any character_escape sequences encountered along the way. The opening quote should have already_been read. This consumes the closing quote, but does not include it in the returned_string._@param quote either ' or "._@return the string up to but not including {@code quote}_@throws NumberFormatException if any unicode escape sequences are malformed._@throws JSONException if processing of json failed;public String nextString(char quote) throws JSONException {_		_		StringBuilder builder = null___		_		int start = this.pos___		while (this.pos < this.in.length()) {_			int c = this.in.charAt(this.pos++)__			if (c == quote) {_				if (builder == null) {_					_					return new String(this.in.substring(start, this.pos - 1))__				}_				else {_					builder.append(this.in, start, this.pos - 1)__					return builder.toString()__				}_			}__			if (c == '\\') {_				if (this.pos == this.in.length()) {_					throw syntaxError("Unterminated escape sequence")__				}_				if (builder == null) {_					builder = new StringBuilder()__				}_				builder.append(this.in, start, this.pos - 1)__				builder.append(readEscapeCharacter())__				start = this.pos__			}_		}__		throw syntaxError("Unterminated string")__	};returns,the,string,up,to,but,not,including,code,quote,unescaping,any,character,escape,sequences,encountered,along,the,way,the,opening,quote,should,have,already,been,read,this,consumes,the,closing,quote,but,does,not,include,it,in,the,returned,string,param,quote,either,or,return,the,string,up,to,but,not,including,code,quote,throws,number,format,exception,if,any,unicode,escape,sequences,are,malformed,throws,jsonexception,if,processing,of,json,failed;public,string,next,string,char,quote,throws,jsonexception,string,builder,builder,null,int,start,this,pos,while,this,pos,this,in,length,int,c,this,in,char,at,this,pos,if,c,quote,if,builder,null,return,new,string,this,in,substring,start,this,pos,1,else,builder,append,this,in,start,this,pos,1,return,builder,to,string,if,c,if,this,pos,this,in,length,throw,syntax,error,unterminated,escape,sequence,if,builder,null,builder,new,string,builder,builder,append,this,in,start,this,pos,1,builder,append,read,escape,character,start,this,pos,throw,syntax,error,unterminated,string
JSONTokener -> public String nextString(char quote) throws JSONException;1518087233;Returns the string up to but not including {@code quote}, unescaping any character_escape sequences encountered along the way. The opening quote should have already_been read. This consumes the closing quote, but does not include it in the returned_string._@param quote either ' or "._@return the string up to but not including {@code quote}_@throws NumberFormatException if any unicode escape sequences are malformed._@throws JSONException if processing of json failed;public String nextString(char quote) throws JSONException {_		_		StringBuilder builder = null___		_		int start = this.pos___		while (this.pos < this.in.length()) {_			int c = this.in.charAt(this.pos++)__			if (c == quote) {_				if (builder == null) {_					_					return new String(this.in.substring(start, this.pos - 1))__				}_				else {_					builder.append(this.in, start, this.pos - 1)__					return builder.toString()__				}_			}__			if (c == '\\') {_				if (this.pos == this.in.length()) {_					throw syntaxError("Unterminated escape sequence")__				}_				if (builder == null) {_					builder = new StringBuilder()__				}_				builder.append(this.in, start, this.pos - 1)__				builder.append(readEscapeCharacter())__				start = this.pos__			}_		}__		throw syntaxError("Unterminated string")__	};returns,the,string,up,to,but,not,including,code,quote,unescaping,any,character,escape,sequences,encountered,along,the,way,the,opening,quote,should,have,already,been,read,this,consumes,the,closing,quote,but,does,not,include,it,in,the,returned,string,param,quote,either,or,return,the,string,up,to,but,not,including,code,quote,throws,number,format,exception,if,any,unicode,escape,sequences,are,malformed,throws,jsonexception,if,processing,of,json,failed;public,string,next,string,char,quote,throws,jsonexception,string,builder,builder,null,int,start,this,pos,while,this,pos,this,in,length,int,c,this,in,char,at,this,pos,if,c,quote,if,builder,null,return,new,string,this,in,substring,start,this,pos,1,else,builder,append,this,in,start,this,pos,1,return,builder,to,string,if,c,if,this,pos,this,in,length,throw,syntax,error,unterminated,escape,sequence,if,builder,null,builder,new,string,builder,builder,append,this,in,start,this,pos,1,builder,append,read,escape,character,start,this,pos,throw,syntax,error,unterminated,string
JSONTokener -> private JSONObject readObject() throws JSONException;1515446271;Reads a sequence of key/value pairs and the trailing closing brace '}' of an_object. The opening brace '{' should have already been read._@return an object_@throws JSONException if processing of json failed;private JSONObject readObject() throws JSONException {_		JSONObject result = new JSONObject()___		_		int first = nextCleanInternal()__		if (first == '}') {_			return result__		}_		else if (first != -1) {_			this.pos--__		}__		while (true) {_			Object name = nextValue()__			if (!(name instanceof String)) {_				if (name == null) {_					throw syntaxError("Names cannot be null")__				}_				else {_					throw syntaxError("Names must be strings, but " + name_							+ " is of type " + name.getClass().getName())__				}_			}__			_			int separator = nextCleanInternal()__			if (separator != ':' && separator != '=') {_				throw syntaxError("Expected ':' after " + name)__			}_			if (this.pos < this.in.length() && this.in.charAt(this.pos) == '>') {_				this.pos++__			}__			result.put((String) name, nextValue())___			switch (nextCleanInternal()) {_			case '}':_				return result__			case '_':_			case ',':_				continue__			default:_				throw syntaxError("Unterminated object")__			}_		}_	};reads,a,sequence,of,key,value,pairs,and,the,trailing,closing,brace,of,an,object,the,opening,brace,should,have,already,been,read,return,an,object,throws,jsonexception,if,processing,of,json,failed;private,jsonobject,read,object,throws,jsonexception,jsonobject,result,new,jsonobject,int,first,next,clean,internal,if,first,return,result,else,if,first,1,this,pos,while,true,object,name,next,value,if,name,instanceof,string,if,name,null,throw,syntax,error,names,cannot,be,null,else,throw,syntax,error,names,must,be,strings,but,name,is,of,type,name,get,class,get,name,int,separator,next,clean,internal,if,separator,separator,throw,syntax,error,expected,after,name,if,this,pos,this,in,length,this,in,char,at,this,pos,this,pos,result,put,string,name,next,value,switch,next,clean,internal,case,return,result,case,case,continue,default,throw,syntax,error,unterminated,object
JSONTokener -> private JSONObject readObject() throws JSONException;1516008705;Reads a sequence of key/value pairs and the trailing closing brace '}' of an_object. The opening brace '{' should have already been read._@return an object_@throws JSONException if processing of json failed;private JSONObject readObject() throws JSONException {_		JSONObject result = new JSONObject()___		_		int first = nextCleanInternal()__		if (first == '}') {_			return result__		}_		else if (first != -1) {_			this.pos--__		}__		while (true) {_			Object name = nextValue()__			if (!(name instanceof String)) {_				if (name == null) {_					throw syntaxError("Names cannot be null")__				}_				else {_					throw syntaxError("Names must be strings, but " + name_							+ " is of type " + name.getClass().getName())__				}_			}__			_			int separator = nextCleanInternal()__			if (separator != ':' && separator != '=') {_				throw syntaxError("Expected ':' after " + name)__			}_			if (this.pos < this.in.length() && this.in.charAt(this.pos) == '>') {_				this.pos++__			}__			result.put((String) name, nextValue())___			switch (nextCleanInternal()) {_			case '}':_				return result__			case '_':_			case ',':_				continue__			default:_				throw syntaxError("Unterminated object")__			}_		}_	};reads,a,sequence,of,key,value,pairs,and,the,trailing,closing,brace,of,an,object,the,opening,brace,should,have,already,been,read,return,an,object,throws,jsonexception,if,processing,of,json,failed;private,jsonobject,read,object,throws,jsonexception,jsonobject,result,new,jsonobject,int,first,next,clean,internal,if,first,return,result,else,if,first,1,this,pos,while,true,object,name,next,value,if,name,instanceof,string,if,name,null,throw,syntax,error,names,cannot,be,null,else,throw,syntax,error,names,must,be,strings,but,name,is,of,type,name,get,class,get,name,int,separator,next,clean,internal,if,separator,separator,throw,syntax,error,expected,after,name,if,this,pos,this,in,length,this,in,char,at,this,pos,this,pos,result,put,string,name,next,value,switch,next,clean,internal,case,return,result,case,case,continue,default,throw,syntax,error,unterminated,object
JSONTokener -> private JSONObject readObject() throws JSONException;1516665640;Reads a sequence of key/value pairs and the trailing closing brace '}' of an_object. The opening brace '{' should have already been read._@return an object_@throws JSONException if processing of json failed;private JSONObject readObject() throws JSONException {_		JSONObject result = new JSONObject()___		_		int first = nextCleanInternal()__		if (first == '}') {_			return result__		}_		else if (first != -1) {_			this.pos--__		}__		while (true) {_			Object name = nextValue()__			if (!(name instanceof String)) {_				if (name == null) {_					throw syntaxError("Names cannot be null")__				}_				else {_					throw syntaxError("Names must be strings, but " + name_							+ " is of type " + name.getClass().getName())__				}_			}__			_			int separator = nextCleanInternal()__			if (separator != ':' && separator != '=') {_				throw syntaxError("Expected ':' after " + name)__			}_			if (this.pos < this.in.length() && this.in.charAt(this.pos) == '>') {_				this.pos++__			}__			result.put((String) name, nextValue())___			switch (nextCleanInternal()) {_			case '}':_				return result__			case '_':_			case ',':_				continue__			default:_				throw syntaxError("Unterminated object")__			}_		}_	};reads,a,sequence,of,key,value,pairs,and,the,trailing,closing,brace,of,an,object,the,opening,brace,should,have,already,been,read,return,an,object,throws,jsonexception,if,processing,of,json,failed;private,jsonobject,read,object,throws,jsonexception,jsonobject,result,new,jsonobject,int,first,next,clean,internal,if,first,return,result,else,if,first,1,this,pos,while,true,object,name,next,value,if,name,instanceof,string,if,name,null,throw,syntax,error,names,cannot,be,null,else,throw,syntax,error,names,must,be,strings,but,name,is,of,type,name,get,class,get,name,int,separator,next,clean,internal,if,separator,separator,throw,syntax,error,expected,after,name,if,this,pos,this,in,length,this,in,char,at,this,pos,this,pos,result,put,string,name,next,value,switch,next,clean,internal,case,return,result,case,case,continue,default,throw,syntax,error,unterminated,object
JSONTokener -> private JSONObject readObject() throws JSONException;1518087233;Reads a sequence of key/value pairs and the trailing closing brace '}' of an_object. The opening brace '{' should have already been read._@return an object_@throws JSONException if processing of json failed;private JSONObject readObject() throws JSONException {_		JSONObject result = new JSONObject()___		_		int first = nextCleanInternal()__		if (first == '}') {_			return result__		}_		else if (first != -1) {_			this.pos--__		}__		while (true) {_			Object name = nextValue()__			if (!(name instanceof String)) {_				if (name == null) {_					throw syntaxError("Names cannot be null")__				}_				else {_					throw syntaxError("Names must be strings, but " + name_							+ " is of type " + name.getClass().getName())__				}_			}__			_			int separator = nextCleanInternal()__			if (separator != ':' && separator != '=') {_				throw syntaxError("Expected ':' after " + name)__			}_			if (this.pos < this.in.length() && this.in.charAt(this.pos) == '>') {_				this.pos++__			}__			result.put((String) name, nextValue())___			switch (nextCleanInternal()) {_			case '}':_				return result__			case '_':_			case ',':_				continue__			default:_				throw syntaxError("Unterminated object")__			}_		}_	};reads,a,sequence,of,key,value,pairs,and,the,trailing,closing,brace,of,an,object,the,opening,brace,should,have,already,been,read,return,an,object,throws,jsonexception,if,processing,of,json,failed;private,jsonobject,read,object,throws,jsonexception,jsonobject,result,new,jsonobject,int,first,next,clean,internal,if,first,return,result,else,if,first,1,this,pos,while,true,object,name,next,value,if,name,instanceof,string,if,name,null,throw,syntax,error,names,cannot,be,null,else,throw,syntax,error,names,must,be,strings,but,name,is,of,type,name,get,class,get,name,int,separator,next,clean,internal,if,separator,separator,throw,syntax,error,expected,after,name,if,this,pos,this,in,length,this,in,char,at,this,pos,this,pos,result,put,string,name,next,value,switch,next,clean,internal,case,return,result,case,case,continue,default,throw,syntax,error,unterminated,object
JSONTokener -> private JSONArray readArray() throws JSONException;1515446271;Reads a sequence of values and the trailing closing brace ']' of an array. The_opening brace '[' should have already been read. Note that "[]" yields an empty_array, but "[,]" returns a two-element array equivalent to "[null,null]"._@return an array_@throws JSONException if processing of json failed;private JSONArray readArray() throws JSONException {_		JSONArray result = new JSONArray()___		_		boolean hasTrailingSeparator = false___		while (true) {_			switch (nextCleanInternal()) {_			case -1:_				throw syntaxError("Unterminated array")__			case ']':_				if (hasTrailingSeparator) {_					result.put(null)__				}_				return result__			case ',':_			case '_':_				_				result.put(null)__				hasTrailingSeparator = true__				continue__			default:_				this.pos--__			}__			result.put(nextValue())___			switch (nextCleanInternal()) {_			case ']':_				return result__			case ',':_			case '_':_				hasTrailingSeparator = true__				continue__			default:_				throw syntaxError("Unterminated array")__			}_		}_	};reads,a,sequence,of,values,and,the,trailing,closing,brace,of,an,array,the,opening,brace,should,have,already,been,read,note,that,yields,an,empty,array,but,returns,a,two,element,array,equivalent,to,null,null,return,an,array,throws,jsonexception,if,processing,of,json,failed;private,jsonarray,read,array,throws,jsonexception,jsonarray,result,new,jsonarray,boolean,has,trailing,separator,false,while,true,switch,next,clean,internal,case,1,throw,syntax,error,unterminated,array,case,if,has,trailing,separator,result,put,null,return,result,case,case,result,put,null,has,trailing,separator,true,continue,default,this,pos,result,put,next,value,switch,next,clean,internal,case,return,result,case,case,has,trailing,separator,true,continue,default,throw,syntax,error,unterminated,array
JSONTokener -> private JSONArray readArray() throws JSONException;1516008705;Reads a sequence of values and the trailing closing brace ']' of an array. The_opening brace '[' should have already been read. Note that "[]" yields an empty_array, but "[,]" returns a two-element array equivalent to "[null,null]"._@return an array_@throws JSONException if processing of json failed;private JSONArray readArray() throws JSONException {_		JSONArray result = new JSONArray()___		_		boolean hasTrailingSeparator = false___		while (true) {_			switch (nextCleanInternal()) {_			case -1:_				throw syntaxError("Unterminated array")__			case ']':_				if (hasTrailingSeparator) {_					result.put(null)__				}_				return result__			case ',':_			case '_':_				_				result.put(null)__				hasTrailingSeparator = true__				continue__			default:_				this.pos--__			}__			result.put(nextValue())___			switch (nextCleanInternal()) {_			case ']':_				return result__			case ',':_			case '_':_				hasTrailingSeparator = true__				continue__			default:_				throw syntaxError("Unterminated array")__			}_		}_	};reads,a,sequence,of,values,and,the,trailing,closing,brace,of,an,array,the,opening,brace,should,have,already,been,read,note,that,yields,an,empty,array,but,returns,a,two,element,array,equivalent,to,null,null,return,an,array,throws,jsonexception,if,processing,of,json,failed;private,jsonarray,read,array,throws,jsonexception,jsonarray,result,new,jsonarray,boolean,has,trailing,separator,false,while,true,switch,next,clean,internal,case,1,throw,syntax,error,unterminated,array,case,if,has,trailing,separator,result,put,null,return,result,case,case,result,put,null,has,trailing,separator,true,continue,default,this,pos,result,put,next,value,switch,next,clean,internal,case,return,result,case,case,has,trailing,separator,true,continue,default,throw,syntax,error,unterminated,array
JSONTokener -> private JSONArray readArray() throws JSONException;1516665640;Reads a sequence of values and the trailing closing brace ']' of an array. The_opening brace '[' should have already been read. Note that "[]" yields an empty_array, but "[,]" returns a two-element array equivalent to "[null,null]"._@return an array_@throws JSONException if processing of json failed;private JSONArray readArray() throws JSONException {_		JSONArray result = new JSONArray()___		_		boolean hasTrailingSeparator = false___		while (true) {_			switch (nextCleanInternal()) {_			case -1:_				throw syntaxError("Unterminated array")__			case ']':_				if (hasTrailingSeparator) {_					result.put(null)__				}_				return result__			case ',':_			case '_':_				_				result.put(null)__				hasTrailingSeparator = true__				continue__			default:_				this.pos--__			}__			result.put(nextValue())___			switch (nextCleanInternal()) {_			case ']':_				return result__			case ',':_			case '_':_				hasTrailingSeparator = true__				continue__			default:_				throw syntaxError("Unterminated array")__			}_		}_	};reads,a,sequence,of,values,and,the,trailing,closing,brace,of,an,array,the,opening,brace,should,have,already,been,read,note,that,yields,an,empty,array,but,returns,a,two,element,array,equivalent,to,null,null,return,an,array,throws,jsonexception,if,processing,of,json,failed;private,jsonarray,read,array,throws,jsonexception,jsonarray,result,new,jsonarray,boolean,has,trailing,separator,false,while,true,switch,next,clean,internal,case,1,throw,syntax,error,unterminated,array,case,if,has,trailing,separator,result,put,null,return,result,case,case,result,put,null,has,trailing,separator,true,continue,default,this,pos,result,put,next,value,switch,next,clean,internal,case,return,result,case,case,has,trailing,separator,true,continue,default,throw,syntax,error,unterminated,array
JSONTokener -> private JSONArray readArray() throws JSONException;1518087233;Reads a sequence of values and the trailing closing brace ']' of an array. The_opening brace '[' should have already been read. Note that "[]" yields an empty_array, but "[,]" returns a two-element array equivalent to "[null,null]"._@return an array_@throws JSONException if processing of json failed;private JSONArray readArray() throws JSONException {_		JSONArray result = new JSONArray()___		_		boolean hasTrailingSeparator = false___		while (true) {_			switch (nextCleanInternal()) {_			case -1:_				throw syntaxError("Unterminated array")__			case ']':_				if (hasTrailingSeparator) {_					result.put(null)__				}_				return result__			case ',':_			case '_':_				_				result.put(null)__				hasTrailingSeparator = true__				continue__			default:_				this.pos--__			}__			result.put(nextValue())___			switch (nextCleanInternal()) {_			case ']':_				return result__			case ',':_			case '_':_				hasTrailingSeparator = true__				continue__			default:_				throw syntaxError("Unterminated array")__			}_		}_	};reads,a,sequence,of,values,and,the,trailing,closing,brace,of,an,array,the,opening,brace,should,have,already,been,read,note,that,yields,an,empty,array,but,returns,a,two,element,array,equivalent,to,null,null,return,an,array,throws,jsonexception,if,processing,of,json,failed;private,jsonarray,read,array,throws,jsonexception,jsonarray,result,new,jsonarray,boolean,has,trailing,separator,false,while,true,switch,next,clean,internal,case,1,throw,syntax,error,unterminated,array,case,if,has,trailing,separator,result,put,null,return,result,case,case,result,put,null,has,trailing,separator,true,continue,default,this,pos,result,put,next,value,switch,next,clean,internal,case,return,result,case,case,has,trailing,separator,true,continue,default,throw,syntax,error,unterminated,array
JSONTokener -> @Override 	public String toString();1515446271;Returns the current position and the entire input string._@return the current position and the entire input string.;@Override_	public String toString() {_		_		return " at character " + this.pos + " of " + this.in__	};returns,the,current,position,and,the,entire,input,string,return,the,current,position,and,the,entire,input,string;override,public,string,to,string,return,at,character,this,pos,of,this,in
JSONTokener -> @Override 	public String toString();1516008705;Returns the current position and the entire input string._@return the current position and the entire input string.;@Override_	public String toString() {_		_		return " at character " + this.pos + " of " + this.in__	};returns,the,current,position,and,the,entire,input,string,return,the,current,position,and,the,entire,input,string;override,public,string,to,string,return,at,character,this,pos,of,this,in
JSONTokener -> @Override 	public String toString();1516665640;Returns the current position and the entire input string._@return the current position and the entire input string.;@Override_	public String toString() {_		_		return " at character " + this.pos + " of " + this.in__	};returns,the,current,position,and,the,entire,input,string,return,the,current,position,and,the,entire,input,string;override,public,string,to,string,return,at,character,this,pos,of,this,in
JSONTokener -> @Override 	public String toString();1518087233;Returns the current position and the entire input string._@return the current position and the entire input string.;@Override_	public String toString() {_		_		return " at character " + this.pos + " of " + this.in__	};returns,the,current,position,and,the,entire,input,string,return,the,current,position,and,the,entire,input,string;override,public,string,to,string,return,at,character,this,pos,of,this,in
JSONTokener -> public JSONTokener(String in);1515446271;@param in JSON encoded string. Null is not permitted and will yield a tokener that_throws {@code NullPointerExceptions} when methods are called.;public JSONTokener(String in) {_		_		if (in != null && in.startsWith("\ufeff")) {_			in = in.substring(1)__		}_		this.in = in__	};param,in,json,encoded,string,null,is,not,permitted,and,will,yield,a,tokener,that,throws,code,null,pointer,exceptions,when,methods,are,called;public,jsontokener,string,in,if,in,null,in,starts,with,ufeff,in,in,substring,1,this,in,in
JSONTokener -> public JSONTokener(String in);1516008705;@param in JSON encoded string. Null is not permitted and will yield a tokener that_throws {@code NullPointerExceptions} when methods are called.;public JSONTokener(String in) {_		_		if (in != null && in.startsWith("\ufeff")) {_			in = in.substring(1)__		}_		this.in = in__	};param,in,json,encoded,string,null,is,not,permitted,and,will,yield,a,tokener,that,throws,code,null,pointer,exceptions,when,methods,are,called;public,jsontokener,string,in,if,in,null,in,starts,with,ufeff,in,in,substring,1,this,in,in
JSONTokener -> public JSONTokener(String in);1516665640;@param in JSON encoded string. Null is not permitted and will yield a tokener that_throws {@code NullPointerExceptions} when methods are called.;public JSONTokener(String in) {_		_		if (in != null && in.startsWith("\ufeff")) {_			in = in.substring(1)__		}_		this.in = in__	};param,in,json,encoded,string,null,is,not,permitted,and,will,yield,a,tokener,that,throws,code,null,pointer,exceptions,when,methods,are,called;public,jsontokener,string,in,if,in,null,in,starts,with,ufeff,in,in,substring,1,this,in,in
JSONTokener -> public JSONTokener(String in);1518087233;@param in JSON encoded string. Null is not permitted and will yield a tokener that_throws {@code NullPointerExceptions} when methods are called.;public JSONTokener(String in) {_		_		if (in != null && in.startsWith("\ufeff")) {_			in = in.substring(1)__		}_		this.in = in__	};param,in,json,encoded,string,null,is,not,permitted,and,will,yield,a,tokener,that,throws,code,null,pointer,exceptions,when,methods,are,called;public,jsontokener,string,in,if,in,null,in,starts,with,ufeff,in,in,substring,1,this,in,in
JSONTokener -> private char readEscapeCharacter() throws JSONException;1515446271;Unescapes the character identified by the character or characters that immediately_follow a backslash. The backslash '\' should have already been read. This supports_both unicode escapes "u000A" and two-character escapes "\n"._@return the unescaped char_@throws NumberFormatException if any unicode escape sequences are malformed._@throws JSONException if processing of json failed;private char readEscapeCharacter() throws JSONException {_		char escaped = this.in.charAt(this.pos++)__		switch (escaped) {_		case 'u':_			if (this.pos + 4 > this.in.length()) {_				throw syntaxError("Unterminated escape sequence")__			}_			String hex = this.in.substring(this.pos, this.pos + 4)__			this.pos += 4__			return (char) Integer.parseInt(hex, 16)___		case 't':_			return '\t'___		case 'b':_			return '\b'___		case 'n':_			return '\n'___		case 'r':_			return '\r'___		case 'f':_			return '\f'___		case '\'':_		case '"':_		case '\\':_		default:_			return escaped__		}_	};unescapes,the,character,identified,by,the,character,or,characters,that,immediately,follow,a,backslash,the,backslash,should,have,already,been,read,this,supports,both,unicode,escapes,u000a,and,two,character,escapes,n,return,the,unescaped,char,throws,number,format,exception,if,any,unicode,escape,sequences,are,malformed,throws,jsonexception,if,processing,of,json,failed;private,char,read,escape,character,throws,jsonexception,char,escaped,this,in,char,at,this,pos,switch,escaped,case,u,if,this,pos,4,this,in,length,throw,syntax,error,unterminated,escape,sequence,string,hex,this,in,substring,this,pos,this,pos,4,this,pos,4,return,char,integer,parse,int,hex,16,case,t,return,t,case,b,return,b,case,n,return,n,case,r,return,r,case,f,return,f,case,case,case,default,return,escaped
JSONTokener -> private char readEscapeCharacter() throws JSONException;1516008705;Unescapes the character identified by the character or characters that immediately_follow a backslash. The backslash '\' should have already been read. This supports_both unicode escapes "u000A" and two-character escapes "\n"._@return the unescaped char_@throws NumberFormatException if any unicode escape sequences are malformed._@throws JSONException if processing of json failed;private char readEscapeCharacter() throws JSONException {_		char escaped = this.in.charAt(this.pos++)__		switch (escaped) {_		case 'u':_			if (this.pos + 4 > this.in.length()) {_				throw syntaxError("Unterminated escape sequence")__			}_			String hex = this.in.substring(this.pos, this.pos + 4)__			this.pos += 4__			return (char) Integer.parseInt(hex, 16)___		case 't':_			return '\t'___		case 'b':_			return '\b'___		case 'n':_			return '\n'___		case 'r':_			return '\r'___		case 'f':_			return '\f'___		case '\'':_		case '"':_		case '\\':_		default:_			return escaped__		}_	};unescapes,the,character,identified,by,the,character,or,characters,that,immediately,follow,a,backslash,the,backslash,should,have,already,been,read,this,supports,both,unicode,escapes,u000a,and,two,character,escapes,n,return,the,unescaped,char,throws,number,format,exception,if,any,unicode,escape,sequences,are,malformed,throws,jsonexception,if,processing,of,json,failed;private,char,read,escape,character,throws,jsonexception,char,escaped,this,in,char,at,this,pos,switch,escaped,case,u,if,this,pos,4,this,in,length,throw,syntax,error,unterminated,escape,sequence,string,hex,this,in,substring,this,pos,this,pos,4,this,pos,4,return,char,integer,parse,int,hex,16,case,t,return,t,case,b,return,b,case,n,return,n,case,r,return,r,case,f,return,f,case,case,case,default,return,escaped
JSONTokener -> private char readEscapeCharacter() throws JSONException;1516665640;Unescapes the character identified by the character or characters that immediately_follow a backslash. The backslash '\' should have already been read. This supports_both unicode escapes "u000A" and two-character escapes "\n"._@return the unescaped char_@throws NumberFormatException if any unicode escape sequences are malformed._@throws JSONException if processing of json failed;private char readEscapeCharacter() throws JSONException {_		char escaped = this.in.charAt(this.pos++)__		switch (escaped) {_		case 'u':_			if (this.pos + 4 > this.in.length()) {_				throw syntaxError("Unterminated escape sequence")__			}_			String hex = this.in.substring(this.pos, this.pos + 4)__			this.pos += 4__			return (char) Integer.parseInt(hex, 16)___		case 't':_			return '\t'___		case 'b':_			return '\b'___		case 'n':_			return '\n'___		case 'r':_			return '\r'___		case 'f':_			return '\f'___		case '\'':_		case '"':_		case '\\':_		default:_			return escaped__		}_	};unescapes,the,character,identified,by,the,character,or,characters,that,immediately,follow,a,backslash,the,backslash,should,have,already,been,read,this,supports,both,unicode,escapes,u000a,and,two,character,escapes,n,return,the,unescaped,char,throws,number,format,exception,if,any,unicode,escape,sequences,are,malformed,throws,jsonexception,if,processing,of,json,failed;private,char,read,escape,character,throws,jsonexception,char,escaped,this,in,char,at,this,pos,switch,escaped,case,u,if,this,pos,4,this,in,length,throw,syntax,error,unterminated,escape,sequence,string,hex,this,in,substring,this,pos,this,pos,4,this,pos,4,return,char,integer,parse,int,hex,16,case,t,return,t,case,b,return,b,case,n,return,n,case,r,return,r,case,f,return,f,case,case,case,default,return,escaped
JSONTokener -> private char readEscapeCharacter() throws JSONException;1518087233;Unescapes the character identified by the character or characters that immediately_follow a backslash. The backslash '\' should have already been read. This supports_both unicode escapes "u000A" and two-character escapes "\n"._@return the unescaped char_@throws NumberFormatException if any unicode escape sequences are malformed._@throws JSONException if processing of json failed;private char readEscapeCharacter() throws JSONException {_		char escaped = this.in.charAt(this.pos++)__		switch (escaped) {_		case 'u':_			if (this.pos + 4 > this.in.length()) {_				throw syntaxError("Unterminated escape sequence")__			}_			String hex = this.in.substring(this.pos, this.pos + 4)__			this.pos += 4__			return (char) Integer.parseInt(hex, 16)___		case 't':_			return '\t'___		case 'b':_			return '\b'___		case 'n':_			return '\n'___		case 'r':_			return '\r'___		case 'f':_			return '\f'___		case '\'':_		case '"':_		case '\\':_		default:_			return escaped__		}_	};unescapes,the,character,identified,by,the,character,or,characters,that,immediately,follow,a,backslash,the,backslash,should,have,already,been,read,this,supports,both,unicode,escapes,u000a,and,two,character,escapes,n,return,the,unescaped,char,throws,number,format,exception,if,any,unicode,escape,sequences,are,malformed,throws,jsonexception,if,processing,of,json,failed;private,char,read,escape,character,throws,jsonexception,char,escaped,this,in,char,at,this,pos,switch,escaped,case,u,if,this,pos,4,this,in,length,throw,syntax,error,unterminated,escape,sequence,string,hex,this,in,substring,this,pos,this,pos,4,this,pos,4,return,char,integer,parse,int,hex,16,case,t,return,t,case,b,return,b,case,n,return,n,case,r,return,r,case,f,return,f,case,case,case,default,return,escaped
JSONTokener -> private String nextToInternal(String excluded);1515446271;Returns the string up to but not including any of the given characters or a newline_character. This does not consume the excluded character._@return the string up to but not including any of the given characters or a newline_character;private String nextToInternal(String excluded) {_		int start = this.pos__		for (_ this.pos < this.in.length()_ this.pos++) {_			char c = this.in.charAt(this.pos)__			if (c == '\r' || c == '\n' || excluded.indexOf(c) != -1) {_				return this.in.substring(start, this.pos)__			}_		}_		return this.in.substring(start)__	};returns,the,string,up,to,but,not,including,any,of,the,given,characters,or,a,newline,character,this,does,not,consume,the,excluded,character,return,the,string,up,to,but,not,including,any,of,the,given,characters,or,a,newline,character;private,string,next,to,internal,string,excluded,int,start,this,pos,for,this,pos,this,in,length,this,pos,char,c,this,in,char,at,this,pos,if,c,r,c,n,excluded,index,of,c,1,return,this,in,substring,start,this,pos,return,this,in,substring,start
JSONTokener -> private String nextToInternal(String excluded);1516008705;Returns the string up to but not including any of the given characters or a newline_character. This does not consume the excluded character._@return the string up to but not including any of the given characters or a newline_character;private String nextToInternal(String excluded) {_		int start = this.pos__		for (_ this.pos < this.in.length()_ this.pos++) {_			char c = this.in.charAt(this.pos)__			if (c == '\r' || c == '\n' || excluded.indexOf(c) != -1) {_				return this.in.substring(start, this.pos)__			}_		}_		return this.in.substring(start)__	};returns,the,string,up,to,but,not,including,any,of,the,given,characters,or,a,newline,character,this,does,not,consume,the,excluded,character,return,the,string,up,to,but,not,including,any,of,the,given,characters,or,a,newline,character;private,string,next,to,internal,string,excluded,int,start,this,pos,for,this,pos,this,in,length,this,pos,char,c,this,in,char,at,this,pos,if,c,r,c,n,excluded,index,of,c,1,return,this,in,substring,start,this,pos,return,this,in,substring,start
JSONTokener -> private String nextToInternal(String excluded);1516665640;Returns the string up to but not including any of the given characters or a newline_character. This does not consume the excluded character._@return the string up to but not including any of the given characters or a newline_character;private String nextToInternal(String excluded) {_		int start = this.pos__		for (_ this.pos < this.in.length()_ this.pos++) {_			char c = this.in.charAt(this.pos)__			if (c == '\r' || c == '\n' || excluded.indexOf(c) != -1) {_				return this.in.substring(start, this.pos)__			}_		}_		return this.in.substring(start)__	};returns,the,string,up,to,but,not,including,any,of,the,given,characters,or,a,newline,character,this,does,not,consume,the,excluded,character,return,the,string,up,to,but,not,including,any,of,the,given,characters,or,a,newline,character;private,string,next,to,internal,string,excluded,int,start,this,pos,for,this,pos,this,in,length,this,pos,char,c,this,in,char,at,this,pos,if,c,r,c,n,excluded,index,of,c,1,return,this,in,substring,start,this,pos,return,this,in,substring,start
JSONTokener -> private String nextToInternal(String excluded);1518087233;Returns the string up to but not including any of the given characters or a newline_character. This does not consume the excluded character._@return the string up to but not including any of the given characters or a newline_character;private String nextToInternal(String excluded) {_		int start = this.pos__		for (_ this.pos < this.in.length()_ this.pos++) {_			char c = this.in.charAt(this.pos)__			if (c == '\r' || c == '\n' || excluded.indexOf(c) != -1) {_				return this.in.substring(start, this.pos)__			}_		}_		return this.in.substring(start)__	};returns,the,string,up,to,but,not,including,any,of,the,given,characters,or,a,newline,character,this,does,not,consume,the,excluded,character,return,the,string,up,to,but,not,including,any,of,the,given,characters,or,a,newline,character;private,string,next,to,internal,string,excluded,int,start,this,pos,for,this,pos,this,in,length,this,pos,char,c,this,in,char,at,this,pos,if,c,r,c,n,excluded,index,of,c,1,return,this,in,substring,start,this,pos,return,this,in,substring,start
