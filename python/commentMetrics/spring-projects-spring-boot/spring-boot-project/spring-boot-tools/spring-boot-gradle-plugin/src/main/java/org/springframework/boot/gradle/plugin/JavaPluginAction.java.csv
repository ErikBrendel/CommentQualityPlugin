commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Class<? extends Plugin<? extends Project>> getPluginClass() {     return JavaPlugin.class. }
false;public;1;11;;@Override public void execute(Project project) {     disableJarTask(project).     configureBuildTask(project).     BootJar bootJar = configureBootJarTask(project).     configureArtifactPublication(bootJar).     configureBootRunTask(project).     configureUtf8Encoding(project).     configureParametersCompilerArg(project).     configureAdditionalMetadataLocations(project). }
false;private;1;3;;private void disableJarTask(Project project) {     project.getTasks().getByName(JavaPlugin.JAR_TASK_NAME).setEnabled(false). }
false;private;1;4;;private void configureBuildTask(Project project) {     project.getTasks().getByName(BasePlugin.ASSEMBLE_TASK_NAME).dependsOn(this.singlePublishedArtifact). }
false;private;1;17;;private BootJar configureBootJarTask(Project project) {     BootJar bootJar = project.getTasks().create(SpringBootPlugin.BOOT_JAR_TASK_NAME, BootJar.class).     bootJar.setDescription("Assembles an executable jar archive containing the main" + " classes and their dependencies.").     bootJar.setGroup(BasePlugin.BUILD_GROUP).     bootJar.classpath((Callable<FileCollection>) () -> {         JavaPluginConvention convention = project.getConvention().getPlugin(JavaPluginConvention.class).         SourceSet mainSourceSet = convention.getSourceSets().getByName(SourceSet.MAIN_SOURCE_SET_NAME).         return mainSourceSet.getRuntimeClasspath().     }).     bootJar.conventionMapping("mainClassName", new MainClassConvention(project, bootJar::getClasspath)).     return bootJar. }
false;private;1;4;;private void configureArtifactPublication(BootJar bootJar) {     ArchivePublishArtifact artifact = new ArchivePublishArtifact(bootJar).     this.singlePublishedArtifact.addCandidate(artifact). }
false;private;1;17;;private void configureBootRunTask(Project project) {     JavaPluginConvention javaConvention = project.getConvention().getPlugin(JavaPluginConvention.class).     BootRun run = project.getTasks().create("bootRun", BootRun.class).     run.setDescription("Runs this project as a Spring Boot application.").     run.setGroup(ApplicationPlugin.APPLICATION_GROUP).     run.classpath(javaConvention.getSourceSets().findByName(SourceSet.MAIN_SOURCE_SET_NAME).getRuntimeClasspath()).     run.getConventionMapping().map("jvmArgs", () -> {         if (project.hasProperty("applicationDefaultJvmArgs")) {             return project.property("applicationDefaultJvmArgs").         }         return Collections.emptyList().     }).     run.conventionMapping("main", new MainClassConvention(project, run::getClasspath)). }
false;private;1;8;;private void configureUtf8Encoding(Project project) {     project.afterEvaluate((evaluated) -> evaluated.getTasks().withType(JavaCompile.class, (compile) -> {         if (compile.getOptions().getEncoding() == null) {             compile.getOptions().setEncoding("UTF-8").         }     })). }
false;private;1;8;;private void configureParametersCompilerArg(Project project) {     project.getTasks().withType(JavaCompile.class, (compile) -> {         List<String> compilerArgs = compile.getOptions().getCompilerArgs().         if (!compilerArgs.contains(PARAMETERS_COMPILER_ARG)) {             compilerArgs.add(PARAMETERS_COMPILER_ARG).         }     }). }
false;private;1;4;;private void configureAdditionalMetadataLocations(Project project) {     project.afterEvaluate((evaluated) -> evaluated.getTasks().withType(JavaCompile.class, this::configureAdditionalMetadataLocations)). }
false;private;1;3;;private void configureAdditionalMetadataLocations(JavaCompile compile) {     compile.doFirst(new AdditionalMetadataLocationsConfigurer()). }
false;public;1;12;;@Override public void execute(Task task) {     if (!(task instanceof JavaCompile)) {         return.     }     JavaCompile compile = (JavaCompile) task.     if (hasConfigurationProcessorOnClasspath(compile)) {         findMatchingSourceSet(compile).ifPresent((sourceSet) -> configureAdditionalMetadataLocations(compile, sourceSet)).     } }
false;private;1;7;;private boolean hasConfigurationProcessorOnClasspath(JavaCompile compile) {     Set<File> files = (compile.getOptions().getAnnotationProcessorPath() != null) ? compile.getOptions().getAnnotationProcessorPath().getFiles() : compile.getClasspath().getFiles().     return files.stream().map(File::getName).anyMatch((name) -> name.startsWith("spring-boot-configuration-processor")). }
false;private;1;7;;private Optional<SourceSet> findMatchingSourceSet(JavaCompile compile) {     return compile.getProject().getConvention().getPlugin(JavaPluginConvention.class).getSourceSets().stream().filter((sourceSet) -> sourceSet.getCompileJavaTaskName().equals(compile.getName())).findFirst(). }
false;private;2;8;;private void configureAdditionalMetadataLocations(JavaCompile compile, SourceSet sourceSet) {     String locations = StringUtils.collectionToCommaDelimitedString(sourceSet.getResources().getSrcDirs()).     compile.getOptions().getCompilerArgs().add("-Aorg.springframework.boot.configurationprocessor.additionalMetadataLocations=" + locations). }
