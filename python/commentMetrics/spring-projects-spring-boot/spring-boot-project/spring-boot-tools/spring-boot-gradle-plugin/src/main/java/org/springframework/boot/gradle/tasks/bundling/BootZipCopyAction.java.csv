commented;modifiers;parameterAmount;loc;comment;code
false;public;1;31;;@Override public WorkResult execute(CopyActionProcessingStream stream) {     ZipArchiveOutputStream zipStream.     Spec<FileTreeElement> loaderEntries.     try {         FileOutputStream fileStream = new FileOutputStream(this.output).         writeLaunchScriptIfNecessary(fileStream).         zipStream = new ZipArchiveOutputStream(fileStream).         if (this.encoding != null) {             zipStream.setEncoding(this.encoding).         }         loaderEntries = writeLoaderClassesIfNecessary(zipStream).     } catch (IOException ex) {         throw new GradleException("Failed to create " + this.output, ex).     }     try {         stream.process(new ZipStreamAction(zipStream, this.output, this.preserveFileTimestamps, this.requiresUnpack, createExclusionSpec(loaderEntries), this.compressionResolver)).     } finally {         try {             zipStream.close().         } catch (IOException ex) {         // Continue         }     }     return () -> true. }
false;private;1;5;;@SuppressWarnings("unchecked") private Spec<FileTreeElement> createExclusionSpec(Spec<FileTreeElement> loaderEntries) {     return Specs.union(loaderEntries, this.exclusions). }
false;private;1;7;;private Spec<FileTreeElement> writeLoaderClassesIfNecessary(ZipArchiveOutputStream out) {     if (!this.includeDefaultLoader) {         return Specs.satisfyNone().     }     return writeLoaderClasses(out). }
false;private;1;26;;private Spec<FileTreeElement> writeLoaderClasses(ZipArchiveOutputStream out) {     try (ZipInputStream in = new ZipInputStream(getClass().getResourceAsStream("/META-INF/loader/spring-boot-loader.jar"))) {         Set<String> entries = new HashSet<>().         java.util.zip.ZipEntry entry.         while ((entry = in.getNextEntry()) != null) {             if (entry.isDirectory() && !entry.getName().startsWith("META-INF/")) {                 writeDirectory(new ZipArchiveEntry(entry), out).                 entries.add(entry.getName()).             } else if (entry.getName().endsWith(".class")) {                 writeClass(new ZipArchiveEntry(entry), in, out).             }         }         return (element) -> {             String path = element.getRelativePath().getPathString().             if (element.isDirectory() && !path.endsWith(("/"))) {                 path += "/".             }             return entries.contains(path).         }.     } catch (IOException ex) {         throw new GradleException("Failed to write loader classes", ex).     } }
false;private;2;6;;private void writeDirectory(ZipArchiveEntry entry, ZipArchiveOutputStream out) throws IOException {     prepareEntry(entry, UnixStat.DIR_FLAG | UnixStat.DEFAULT_DIR_PERM).     out.putArchiveEntry(entry).     out.closeArchiveEntry(). }
false;private;3;11;;private void writeClass(ZipArchiveEntry entry, ZipInputStream in, ZipArchiveOutputStream out) throws IOException {     prepareEntry(entry, UnixStat.FILE_FLAG | UnixStat.DEFAULT_FILE_PERM).     out.putArchiveEntry(entry).     byte[] buffer = new byte[4096].     int read.     while ((read = in.read(buffer)) > 0) {         out.write(buffer, 0, read).     }     out.closeArchiveEntry(). }
false;private;2;6;;private void prepareEntry(ZipArchiveEntry entry, int unixMode) {     if (!this.preserveFileTimestamps) {         entry.setTime(CONSTANT_TIME_FOR_ZIP_ENTRIES).     }     entry.setUnixMode(unixMode). }
false;private;1;13;;private void writeLaunchScriptIfNecessary(FileOutputStream fileStream) {     try {         if (this.launchScript != null) {             fileStream.write(new DefaultLaunchScript(this.launchScript.getScript(), this.launchScript.getProperties()).toByteArray()).             this.output.setExecutable(true).         }     } catch (IOException ex) {         throw new GradleException("Failed to write launch script to " + this.output, ex).     } }
false;public;1;18;;@Override public void processFile(FileCopyDetailsInternal details) {     if (this.exclusions.isSatisfiedBy(details)) {         return.     }     try {         if (details.isDirectory()) {             createDirectory(details).         } else {             createFile(details).         }     } catch (IOException ex) {         throw new GradleException("Failed to add " + details + " to " + this.output, ex).     } }
false;private;1;8;;private void createDirectory(FileCopyDetailsInternal details) throws IOException {     ZipArchiveEntry archiveEntry = new ZipArchiveEntry(details.getRelativePath().getPathString() + '/').     archiveEntry.setUnixMode(UnixStat.DIR_FLAG | details.getMode()).     archiveEntry.setTime(getTime(details)).     this.zipStream.putArchiveEntry(archiveEntry).     this.zipStream.closeArchiveEntry(). }
false;private;1;13;;private void createFile(FileCopyDetailsInternal details) throws IOException {     String relativePath = details.getRelativePath().getPathString().     ZipArchiveEntry archiveEntry = new ZipArchiveEntry(relativePath).     archiveEntry.setUnixMode(UnixStat.FILE_FLAG | details.getMode()).     archiveEntry.setTime(getTime(details)).     ZipCompression compression = this.compressionType.apply(details).     if (compression == ZipCompression.STORED) {         prepareStoredEntry(details, archiveEntry).     }     this.zipStream.putArchiveEntry(archiveEntry).     details.copyTo(this.zipStream).     this.zipStream.closeArchiveEntry(). }
false;private;2;13;;private void prepareStoredEntry(FileCopyDetailsInternal details, ZipArchiveEntry archiveEntry) throws IOException {     archiveEntry.setMethod(java.util.zip.ZipEntry.STORED).     archiveEntry.setSize(details.getSize()).     archiveEntry.setCompressedSize(details.getSize()).     Crc32OutputStream crcStream = new Crc32OutputStream().     details.copyTo(crcStream).     archiveEntry.setCrc(crcStream.getCrc()).     if (this.requiresUnpack.isSatisfiedBy(details)) {         archiveEntry.setComment("UNPACK:" + FileUtils.sha1Hash(details.getFile())).     } }
false;private;1;4;;private long getTime(FileCopyDetails details) {     return this.preserveFileTimestamps ? details.getLastModified() : CONSTANT_TIME_FOR_ZIP_ENTRIES. }
false;public;1;4;;@Override public void write(int b) throws IOException {     this.crc32.update(b). }
false;public;1;4;;@Override public void write(byte[] b) throws IOException {     this.crc32.update(b). }
false;public;3;4;;@Override public void write(byte[] b, int off, int len) throws IOException {     this.crc32.update(b, off, len). }
false;private;0;3;;private long getCrc() {     return this.crc32.getValue(). }
