commented;modifiers;parameterAmount;loc;comment;code
false;private;1;5;;private Action<CopySpec> classpathFiles(Spec<File> filter) {     return (copySpec) -> copySpec.from((Callable<Iterable<File>>) () -> (this.classpath != null) ? this.classpath.filter(filter) : Collections.emptyList()). }
false;public;0;5;;@Override public void copy() {     this.support.configureManifest(this, getMainClassName()).     super.copy(). }
false;protected;0;4;;@Override protected CopyAction createCopyAction() {     return this.support.createCopyAction(this). }
false;public;0;11;;@Override public String getMainClassName() {     if (this.mainClassName == null) {         String manifestStartClass = (String) getManifest().getAttributes().get("Start-Class").         if (manifestStartClass != null) {             setMainClassName(manifestStartClass).         }     }     return this.mainClassName. }
false;public;1;4;;@Override public void setMainClassName(String mainClassName) {     this.mainClassName = mainClassName. }
false;public;1;4;;@Override public void requiresUnpack(String... patterns) {     this.support.requiresUnpack(patterns). }
false;public;1;4;;@Override public void requiresUnpack(Spec<FileTreeElement> spec) {     this.support.requiresUnpack(spec). }
false;public;0;4;;@Override public LaunchScriptConfiguration getLaunchScript() {     return this.support.getLaunchScript(). }
false;public;0;4;;@Override public void launchScript() {     enableLaunchScriptIfNecessary(). }
false;public;1;4;;@Override public void launchScript(Action<LaunchScriptConfiguration> action) {     action.execute(enableLaunchScriptIfNecessary()). }
false;public;0;4;;@Override public FileCollection getClasspath() {     return this.classpath. }
false;public;1;7;;@Override public void classpath(Object... classpath) {     FileCollection existingClasspath = this.classpath.     this.classpath = getProject().files((existingClasspath != null) ? existingClasspath : Collections.emptyList(), classpath). }
false;public;1;3;;public void setClasspath(Object classpath) {     this.classpath = getProject().files(classpath). }
false;public;1;3;;public void setClasspath(FileCollection classpath) {     this.classpath = getProject().files(classpath). }
false;public;0;4;;@Override public boolean isExcludeDevtools() {     return this.support.isExcludeDevtools(). }
false;public;1;4;;@Override public void setExcludeDevtools(boolean excludeDevtools) {     this.support.setExcludeDevtools(excludeDevtools). }
true;public;0;6;/**  * Returns a {@code CopySpec} that can be used to add content to the {@code BOOT-INF}  * directory of the jar.  * @return a {@code CopySpec} for {@code BOOT-INF}  * @since 2.0.3  */ ;/**  * Returns a {@code CopySpec} that can be used to add content to the {@code BOOT-INF}  * directory of the jar.  * @return a {@code CopySpec} for {@code BOOT-INF}  * @since 2.0.3  */ @Internal public CopySpec getBootInf() {     CopySpec child = getProject().copySpec().     this.bootInf.with(child).     return child. }
true;public;1;5;/**  * Calls the given {@code action} to add content to the {@code BOOT-INF} directory of  * the jar.  * @param action the {@code Action} to call  * @return the {@code CopySpec} for {@code BOOT-INF} that was passed to the  * {@code Action}  * @since 2.0.3  */ ;/**  * Calls the given {@code action} to add content to the {@code BOOT-INF} directory of  * the jar.  * @param action the {@code Action} to call  * @return the {@code CopySpec} for {@code BOOT-INF} that was passed to the  * {@code Action}  * @since 2.0.3  */ public CopySpec bootInf(Action<CopySpec> action) {     CopySpec bootInf = getBootInf().     action.execute(bootInf).     return bootInf. }
true;protected;1;6;/**  * Returns the {@link ZipCompression} that should be used when adding the file  * represented by the given {@code details} to the jar.  * <p>  * By default, any file in {@code BOOT-INF/lib/} is stored and all other files are  * deflated.  * @param details the details  * @return the compression to use  */ ;/**  * Returns the {@link ZipCompression} that should be used when adding the file  * represented by the given {@code details} to the jar.  * <p>  * By default, any file in {@code BOOT-INF/lib/} is stored and all other files are  * deflated.  * @param details the details  * @return the compression to use  */ protected ZipCompression resolveZipCompression(FileCopyDetails details) {     if (details.getRelativePath().getPathString().startsWith("BOOT-INF/lib/")) {         return ZipCompression.STORED.     }     return ZipCompression.DEFLATED. }
false;private;0;8;;private LaunchScriptConfiguration enableLaunchScriptIfNecessary() {     LaunchScriptConfiguration launchScript = this.support.getLaunchScript().     if (launchScript == null) {         launchScript = new LaunchScriptConfiguration(this).         this.support.setLaunchScript(launchScript).     }     return launchScript. }
