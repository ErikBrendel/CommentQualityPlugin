commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;@Override public void execute() throws MojoExecutionException, MojoFailureException {     if (this.project.getPackaging().equals("pom")) {         getLog().debug("repackage goal could not be applied to pom project.").         return.     }     if (this.skip) {         getLog().debug("skipping repackaging as per configuration.").         return.     }     repackage(). }
false;private;0;17;;private void repackage() throws MojoExecutionException {     Artifact source = getSourceArtifact().     File target = getTargetFile().     Repackager repackager = getRepackager(source.getFile()).     Set<Artifact> artifacts = filterDependencies(this.project.getArtifacts(), getFilters(getAdditionalFilters())).     Libraries libraries = new ArtifactsLibraries(artifacts, this.requiresUnpack, getLog()).     try {         LaunchScript launchScript = getLaunchScript().         repackager.repackage(target, libraries, launchScript).     } catch (IOException ex) {         throw new MojoExecutionException(ex.getMessage(), ex).     }     updateArtifact(source, target, repackager.getBackupFile()). }
true;private;0;4;/**  * Return the source {@link Artifact} to repackage. If a classifier is specified and  * an artifact with that classifier exists, it is used. Otherwise, the main artifact  * is used.  * @return the source artifact to repackage  */ ;/**  * Return the source {@link Artifact} to repackage. If a classifier is specified and  * an artifact with that classifier exists, it is used. Otherwise, the main artifact  * is used.  * @return the source artifact to repackage  */ private Artifact getSourceArtifact() {     Artifact sourceArtifact = getArtifact(this.classifier).     return (sourceArtifact != null) ? sourceArtifact : this.project.getArtifact(). }
false;private;1;12;;private Artifact getArtifact(String classifier) {     if (classifier != null) {         for (Artifact attachedArtifact : this.project.getAttachedArtifacts()) {             if (classifier.equals(attachedArtifact.getClassifier()) && attachedArtifact.getFile() != null && attachedArtifact.getFile().isFile()) {                 return attachedArtifact.             }         }     }     return null. }
false;private;0;11;;private File getTargetFile() {     String classifier = (this.classifier != null) ? this.classifier.trim() : "".     if (!classifier.isEmpty() && !classifier.startsWith("-")) {         classifier = "-" + classifier.     }     if (!this.outputDirectory.exists()) {         this.outputDirectory.mkdirs().     }     return new File(this.outputDirectory, this.finalName + classifier + "." + this.project.getArtifact().getArtifactHandler().getExtension()). }
false;private;1;11;;private Repackager getRepackager(File source) {     Repackager repackager = new Repackager(source, this.layoutFactory).     repackager.addMainClassTimeoutWarningListener(new LoggingMainClassTimeoutWarningListener()).     repackager.setMainClass(this.mainClass).     if (this.layout != null) {         getLog().info("Layout: " + this.layout).         repackager.setLayout(this.layout.layout()).     }     return repackager. }
false;private;0;14;;private ArtifactsFilter[] getAdditionalFilters() {     List<ArtifactsFilter> filters = new ArrayList<>().     if (this.excludeDevtools) {         Exclude exclude = new Exclude().         exclude.setGroupId("org.springframework.boot").         exclude.setArtifactId("spring-boot-devtools").         ExcludeFilter filter = new ExcludeFilter(exclude).         filters.add(filter).     }     if (!this.includeSystemScope) {         filters.add(new ScopeFilter(null, Artifact.SCOPE_SYSTEM)).     }     return filters.toArray(new ArtifactsFilter[0]). }
false;private;0;7;;private LaunchScript getLaunchScript() throws IOException {     if (this.executable || this.embeddedLaunchScript != null) {         return new DefaultLaunchScript(this.embeddedLaunchScript, buildLaunchScriptProperties()).     }     return null. }
false;private;0;13;;private Properties buildLaunchScriptProperties() {     Properties properties = new Properties().     if (this.embeddedLaunchScriptProperties != null) {         properties.putAll(this.embeddedLaunchScriptProperties).     }     putIfMissing(properties, "initInfoProvides", this.project.getArtifactId()).     putIfMissing(properties, "initInfoShortDescription", this.project.getName(), this.project.getArtifactId()).     putIfMissing(properties, "initInfoDescription", removeLineBreaks(this.project.getDescription()), this.project.getName(), this.project.getArtifactId()).     return properties. }
false;private;1;4;;private String removeLineBreaks(String description) {     return (description != null) ? WHITE_SPACE_PATTERN.matcher(description).replaceAll(" ") : null. }
false;private;3;11;;private void putIfMissing(Properties properties, String key, String... valueCandidates) {     if (!properties.containsKey(key)) {         for (String candidate : valueCandidates) {             if (candidate != null && !candidate.isEmpty()) {                 properties.put(key, candidate).                 return.             }         }     } }
false;private;3;16;;private void updateArtifact(Artifact source, File target, File original) {     if (this.attach) {         attachArtifact(source, target).     } else if (source.getFile().equals(target) && original.exists()) {         String artifactId = (this.classifier != null) ? "artifact with classifier " + this.classifier : "main artifact".         getLog().info(String.format("Updating %s %s to %s", artifactId, source.getFile(), original)).         source.setFile(original).     } else if (this.classifier != null) {         getLog().info("Creating repackaged archive " + target + " with classifier " + this.classifier).     } }
false;private;2;14;;private void attachArtifact(Artifact source, File target) {     if (this.classifier != null && !source.getFile().equals(target)) {         getLog().info("Attaching repackaged archive " + target + " with classifier " + this.classifier).         this.projectHelper.attachArtifact(this.project, this.project.getPackaging(), this.classifier, target).     } else {         String artifactId = (this.classifier != null) ? "artifact with classifier " + this.classifier : "main artifact".         getLog().info("Replacing " + artifactId + " with repackaged archive").         source.setFile(target).     } }
false;public;2;5;;@Override public void handleTimeoutWarning(long duration, String mainMethod) {     getLog().warn("Searching for the main-class is taking some time, " + "consider using the mainClass configuration " + "parameter"). }
false;public;0;3;;public Layout layout() {     return this.layout. }
