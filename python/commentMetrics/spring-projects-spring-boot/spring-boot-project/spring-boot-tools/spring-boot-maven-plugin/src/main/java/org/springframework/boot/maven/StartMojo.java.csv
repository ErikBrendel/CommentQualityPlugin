commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;13;;@Override protected void runWithForkedJvm(File workingDirectory, List<String> args, Map<String, String> environmentVariables) throws MojoExecutionException, MojoFailureException {     RunProcess runProcess = runProcess(workingDirectory, args, environmentVariables).     try {         waitForSpringApplication().     } catch (MojoExecutionException | MojoFailureException ex) {         runProcess.kill().         throw ex.     } }
false;private;3;12;;private RunProcess runProcess(File workingDirectory, List<String> args, Map<String, String> environmentVariables) throws MojoExecutionException {     try {         RunProcess runProcess = new RunProcess(workingDirectory, new JavaExecutable().toString()).         runProcess.run(false, args, environmentVariables).         return runProcess.     } catch (Exception ex) {         throw new MojoExecutionException("Could not exec java", ex).     } }
false;protected;0;10;;@Override protected RunArguments resolveApplicationArguments() {     RunArguments applicationArguments = super.resolveApplicationArguments().     applicationArguments.getArgs().addLast(ENABLE_MBEAN_PROPERTY).     if (isFork()) {         applicationArguments.getArgs().addLast(JMX_NAME_PROPERTY_PREFIX + this.jmxName).     }     return applicationArguments. }
false;protected;0;14;;@Override protected RunArguments resolveJvmArguments() {     RunArguments jvmArguments = super.resolveJvmArguments().     if (isFork()) {         List<String> remoteJmxArguments = new ArrayList<>().         remoteJmxArguments.add("-Dcom.sun.management.jmxremote").         remoteJmxArguments.add("-Dcom.sun.management.jmxremote.port=" + this.jmxPort).         remoteJmxArguments.add("-Dcom.sun.management.jmxremote.authenticate=false").         remoteJmxArguments.add("-Dcom.sun.management.jmxremote.ssl=false").         remoteJmxArguments.add("-Djava.rmi.server.hostname=127.0.0.1").         jvmArguments.getArgs().addAll(remoteJmxArguments).     }     return jvmArguments. }
false;protected;2;10;;@Override protected void runWithMavenJvm(String startClassName, String... arguments) throws MojoExecutionException {     IsolatedThreadGroup threadGroup = new IsolatedThreadGroup(startClassName).     Thread launchThread = new Thread(threadGroup, new LaunchRunner(startClassName, arguments), startClassName + ".main()").     launchThread.setContextClassLoader(new URLClassLoader(getClassPathUrls())).     launchThread.start().     waitForSpringApplication(this.wait, this.maxAttempts). }
false;private;2;27;;private void waitForSpringApplication(long wait, int maxAttempts) throws MojoExecutionException {     SpringApplicationAdminClient client = new SpringApplicationAdminClient(ManagementFactory.getPlatformMBeanServer(), this.jmxName).     getLog().debug("Waiting for spring application to start...").     for (int i = 0. i < maxAttempts. i++) {         if (client.isReady()) {             return.         }         String message = "Spring application is not ready yet, waiting " + wait + "ms (attempt " + (i + 1) + ")".         getLog().debug(message).         synchronized (this.lock) {             try {                 this.lock.wait(wait).             } catch (InterruptedException ex) {                 Thread.currentThread().interrupt().                 throw new IllegalStateException("Interrupted while waiting for Spring Boot app to start.").             }         }     }     throw new MojoExecutionException("Spring application did not start before the configured timeout (" + (wait * maxAttempts) + "ms"). }
false;private;0;19;;private void waitForSpringApplication() throws MojoFailureException, MojoExecutionException {     try {         if (isFork()) {             waitForForkedSpringApplication().         } else {             doWaitForSpringApplication(ManagementFactory.getPlatformMBeanServer()).         }     } catch (IOException ex) {         throw new MojoFailureException("Could not contact Spring Boot application", ex).     } catch (Exception ex) {         throw new MojoExecutionException("Could not figure out if the application has started", ex).     } }
false;private;0;25;;private void waitForForkedSpringApplication() throws IOException, MojoFailureException, MojoExecutionException {     try {         getLog().debug("Connecting to local MBeanServer at port " + this.jmxPort).         try (JMXConnector connector = execute(this.wait, this.maxAttempts, new CreateJmxConnector(this.jmxPort))) {             if (connector == null) {                 throw new MojoExecutionException("JMX MBean server was not reachable before the configured " + "timeout (" + (this.wait * this.maxAttempts) + "ms").             }             getLog().debug("Connected to local MBeanServer at port " + this.jmxPort).             MBeanServerConnection connection = connector.getMBeanServerConnection().             doWaitForSpringApplication(connection).         }     } catch (IOException ex) {         throw ex.     } catch (Exception ex) {         throw new MojoExecutionException("Failed to connect to MBean server at port " + this.jmxPort, ex).     } }
false;private;1;15;;private void doWaitForSpringApplication(MBeanServerConnection connection) throws IOException, MojoExecutionException, MojoFailureException {     final SpringApplicationAdminClient client = new SpringApplicationAdminClient(connection, this.jmxName).     try {         execute(this.wait, this.maxAttempts, () -> (client.isReady() ? true : null)).     } catch (ReflectionException ex) {         throw new MojoExecutionException("Unable to retrieve 'ready' attribute", ex.getCause()).     } catch (Exception ex) {         throw new MojoFailureException("Could not invoke shutdown operation", ex).     } }
true;public;3;26;/**  * Execute a task, retrying it on failure.  * @param <T> the result type  * @param wait the wait time  * @param maxAttempts the maximum number of attempts  * @param callback the task to execute (possibly multiple times). The callback should  * return {@code null} to indicate that another attempt should be made  * @return the result  * @throws Exception in case of execution errors  */ ;/**  * Execute a task, retrying it on failure.  * @param <T> the result type  * @param wait the wait time  * @param maxAttempts the maximum number of attempts  * @param callback the task to execute (possibly multiple times). The callback should  * return {@code null} to indicate that another attempt should be made  * @return the result  * @throws Exception in case of execution errors  */ public <T> T execute(long wait, int maxAttempts, Callable<T> callback) throws Exception {     getLog().debug("Waiting for spring application to start...").     for (int i = 0. i < maxAttempts. i++) {         T result = callback.call().         if (result != null) {             return result.         }         String message = "Spring application is not ready yet, waiting " + wait + "ms (attempt " + (i + 1) + ")".         getLog().debug(message).         synchronized (this.lock) {             try {                 this.lock.wait(wait).             } catch (InterruptedException ex) {                 Thread.currentThread().interrupt().                 throw new IllegalStateException("Interrupted while waiting for Spring Boot app to start.").             }         }     }     throw new MojoExecutionException("Spring application did not start before the configured " + "timeout (" + (wait * maxAttempts) + "ms"). }
false;public;0;15;;@Override public JMXConnector call() throws Exception {     try {         return SpringApplicationAdminClient.connect(this.port).     } catch (IOException ex) {         if (hasCauseWithType(ex, ConnectException.class)) {             String message = "MBean server at port " + this.port + " is not up yet...".             getLog().debug(message).             return null.         }         throw ex.     } }
false;private;2;4;;private boolean hasCauseWithType(Throwable t, Class<? extends Exception> type) {     return type.isAssignableFrom(t.getClass()) || t.getCause() != null && hasCauseWithType(t.getCause(), type). }
