commented;modifiers;parameterAmount;loc;comment;code
false;public;0;20;;@Override public void execute() throws MojoExecutionException, MojoFailureException {     if (this.skip) {         getLog().debug("skipping stop as per configuration.").         return.     }     getLog().info("Stopping application...").     try {         if (isForked()) {             stopForkedProcess().         } else {             stop().         }     } catch (IOException ex) {         // The response won't be received as the server has died - ignoring         getLog().debug("Service is not reachable anymore (" + ex.getMessage() + ")").     } }
false;private;0;8;;private boolean isForked() {     if (this.fork != null) {         return this.fork.     }     String property = this.project.getProperties().getProperty("_spring.boot.fork.enabled").     return Boolean.valueOf(property). }
false;private;0;8;;private void stopForkedProcess() throws IOException, MojoFailureException, MojoExecutionException {     try (JMXConnector connector = SpringApplicationAdminClient.connect(this.jmxPort)) {         MBeanServerConnection connection = connector.getMBeanServerConnection().         doStop(connection).     } }
false;private;0;3;;private void stop() throws IOException, MojoFailureException, MojoExecutionException {     doStop(ManagementFactory.getPlatformMBeanServer()). }
false;private;1;12;;private void doStop(MBeanServerConnection connection) throws IOException, MojoExecutionException {     try {         new SpringApplicationAdminClient(connection, this.jmxName).stop().     } catch (InstanceNotFoundException ex) {         throw new MojoExecutionException("Spring application lifecycle JMX bean not found (fork is " + this.fork + "). Could not stop application gracefully", ex).     } }
