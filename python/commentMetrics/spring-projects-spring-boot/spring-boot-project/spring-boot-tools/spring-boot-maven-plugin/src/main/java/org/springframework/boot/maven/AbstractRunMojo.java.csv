commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public void execute() throws MojoExecutionException, MojoFailureException {     if (this.skip) {         getLog().debug("skipping run as per configuration.").         return.     }     run(getStartClass()). }
true;protected;0;4;/**  * Specify if the application process should be forked.  * @return {@code true} if the application process should be forked  */ ;/**  * Specify if the application process should be forked.  * @return {@code true} if the application process should be forked  */ protected boolean isFork() {     return (Boolean.TRUE.equals(this.fork) || (this.fork == null && enableForkByDefault())). }
true;protected;0;4;/**  * Specify if fork should be enabled by default.  * @return {@code true} if fork should be enabled by default  * @see #logDisabledFork()  */ ;/**  * Specify if fork should be enabled by default.  * @return {@code true} if fork should be enabled by default  * @see #logDisabledFork()  */ protected boolean enableForkByDefault() {     return hasAgent() || hasJvmArgs() || hasEnvVariables() || hasWorkingDirectorySet(). }
false;private;0;4;;private boolean hasAgent() {     File[] configuredAgents = determineAgents().     return (configuredAgents != null && configuredAgents.length > 0). }
false;private;0;5;;private boolean hasJvmArgs() {     return (this.jvmArguments != null && !this.jvmArguments.isEmpty()) || (this.systemPropertyVariables != null && !this.systemPropertyVariables.isEmpty()). }
false;private;0;4;;private boolean hasEnvVariables() {     return (this.environmentVariables != null && !this.environmentVariables.isEmpty()). }
false;private;0;3;;private boolean hasWorkingDirectorySet() {     return this.workingDirectory != null. }
false;private;1;13;;private void run(String startClassName) throws MojoExecutionException, MojoFailureException {     boolean fork = isFork().     this.project.getProperties().setProperty("_spring.boot.fork.enabled", Boolean.toString(fork)).     if (fork) {         doRunWithForkedJvm(startClassName).     } else {         logDisabledFork().         runWithMavenJvm(startClassName, resolveApplicationArguments().asArray()).     } }
true;protected;0;17;/**  * Log a warning indicating that fork mode has been explicitly disabled while some  * conditions are present that require to enable it.  * @see #enableForkByDefault()  */ ;/**  * Log a warning indicating that fork mode has been explicitly disabled while some  * conditions are present that require to enable it.  * @see #enableForkByDefault()  */ protected void logDisabledFork() {     if (getLog().isWarnEnabled()) {         if (hasAgent()) {             getLog().warn("Fork mode disabled, ignoring agent").         }         if (hasJvmArgs()) {             RunArguments runArguments = resolveJvmArguments().             getLog().warn("Fork mode disabled, ignoring JVM argument(s) [" + Arrays.stream(runArguments.asArray()).collect(Collectors.joining(" ")) + "]").         }         if (hasWorkingDirectorySet()) {             getLog().warn("Fork mode disabled, ignoring working directory configuration").         }     } }
false;private;1;10;;private void doRunWithForkedJvm(String startClassName) throws MojoExecutionException, MojoFailureException {     List<String> args = new ArrayList<>().     addAgents(args).     addJvmArgs(args).     addClasspath(args).     args.add(startClassName).     addArgs(args).     runWithForkedJvm(this.workingDirectory, args, determineEnvironmentVariables()). }
true;protected,abstract;3;3;/**  * Run with a forked VM, using the specified command line arguments.  * @param workingDirectory the working directory of the forked JVM  * @param args the arguments (JVM arguments and application arguments)  * @param environmentVariables the environment variables  * @throws MojoExecutionException in case of MOJO execution errors  * @throws MojoFailureException in case of MOJO failures  */ ;/**  * Run with a forked VM, using the specified command line arguments.  * @param workingDirectory the working directory of the forked JVM  * @param args the arguments (JVM arguments and application arguments)  * @param environmentVariables the environment variables  * @throws MojoExecutionException in case of MOJO execution errors  * @throws MojoFailureException in case of MOJO failures  */ protected abstract void runWithForkedJvm(File workingDirectory, List<String> args, Map<String, String> environmentVariables) throws MojoExecutionException, MojoFailureException.
true;protected,abstract;2;2;/**  * Run with the current VM, using the specified arguments.  * @param startClassName the class to run  * @param arguments the class arguments  * @throws MojoExecutionException in case of MOJO execution errors  * @throws MojoFailureException in case of MOJO failures  */ ;/**  * Run with the current VM, using the specified arguments.  * @param startClassName the class to run  * @param arguments the class arguments  * @throws MojoExecutionException in case of MOJO execution errors  * @throws MojoFailureException in case of MOJO failures  */ protected abstract void runWithMavenJvm(String startClassName, String... arguments) throws MojoExecutionException, MojoFailureException.
true;protected;0;5;/**  * Resolve the application arguments to use.  * @return a {@link RunArguments} defining the application arguments  */ ;/**  * Resolve the application arguments to use.  * @return a {@link RunArguments} defining the application arguments  */ protected RunArguments resolveApplicationArguments() {     RunArguments runArguments = new RunArguments(this.arguments).     addActiveProfileArgument(runArguments).     return runArguments. }
true;protected;0;3;/**  * Resolve the environment variables to use.  * @return an {@link EnvVariables} defining the environment variables  */ ;/**  * Resolve the environment variables to use.  * @return an {@link EnvVariables} defining the environment variables  */ protected EnvVariables resolveEnvVariables() {     return new EnvVariables(this.environmentVariables). }
false;private;1;5;;private void addArgs(List<String> args) {     RunArguments applicationArguments = resolveApplicationArguments().     Collections.addAll(args, applicationArguments.asArray()).     logArguments("Application argument(s): ", this.arguments). }
false;private;0;5;;private Map<String, String> determineEnvironmentVariables() {     EnvVariables envVariables = resolveEnvVariables().     logArguments("Environment variable(s): ", envVariables.asArray()).     return envVariables.asMap(). }
true;protected;0;12;/**  * Resolve the JVM arguments to use.  * @return a {@link RunArguments} defining the JVM arguments  */ ;/**  * Resolve the JVM arguments to use.  * @return a {@link RunArguments} defining the JVM arguments  */ protected RunArguments resolveJvmArguments() {     StringBuilder stringBuilder = new StringBuilder().     if (this.systemPropertyVariables != null) {         stringBuilder.append(this.systemPropertyVariables.entrySet().stream().map((e) -> SystemPropertyFormatter.format(e.getKey(), e.getValue())).collect(Collectors.joining(" "))).     }     if (this.jvmArguments != null) {         stringBuilder.append(" ").append(this.jvmArguments).     }     return new RunArguments(stringBuilder.toString()). }
false;private;1;5;;private void addJvmArgs(List<String> args) {     RunArguments jvmArguments = resolveJvmArguments().     Collections.addAll(args, jvmArguments.asArray()).     logArguments("JVM argument(s): ", jvmArguments.asArray()). }
false;private;1;14;;private void addAgents(List<String> args) {     File[] configuredAgents = determineAgents().     if (configuredAgents != null) {         if (getLog().isInfoEnabled()) {             getLog().info("Attaching agents: " + Arrays.asList(configuredAgents)).         }         for (File agent : configuredAgents) {             args.add("-javaagent:" + agent).         }     }     if (this.noverify) {         args.add("-noverify").     } }
false;private;0;3;;private File[] determineAgents() {     return (this.agents != null) ? this.agents : this.agent. }
false;private;1;13;;private void addActiveProfileArgument(RunArguments arguments) {     if (this.profiles.length > 0) {         StringBuilder arg = new StringBuilder("--spring.profiles.active=").         for (int i = 0. i < this.profiles.length. i++) {             arg.append(this.profiles[i]).             if (i < this.profiles.length - 1) {                 arg.append(",").             }         }         arguments.getArgs().addFirst(arg.toString()).         logArguments("Active profile(s): ", this.profiles).     } }
false;private;1;19;;private void addClasspath(List<String> args) throws MojoExecutionException {     try {         StringBuilder classpath = new StringBuilder().         for (URL ele : getClassPathUrls()) {             if (classpath.length() > 0) {                 classpath.append(File.pathSeparator).             }             classpath.append(new File(ele.toURI())).         }         if (getLog().isDebugEnabled()) {             getLog().debug("Classpath for forked process: " + classpath).         }         args.add("-cp").         args.add(classpath.toString()).     } catch (Exception ex) {         throw new MojoExecutionException("Could not build classpath", ex).     } }
false;private;0;17;;private String getStartClass() throws MojoExecutionException {     String mainClass = this.mainClass.     if (mainClass == null) {         try {             mainClass = MainClassFinder.findSingleMainClass(this.classesDirectory, SPRING_BOOT_APPLICATION_CLASS_NAME).         } catch (IOException ex) {             throw new MojoExecutionException(ex.getMessage(), ex).         }     }     if (mainClass == null) {         throw new MojoExecutionException("Unable to find a suitable main class, " + "please add a 'mainClass' property").     }     return mainClass. }
false;protected;0;13;;protected URL[] getClassPathUrls() throws MojoExecutionException {     try {         List<URL> urls = new ArrayList<>().         addUserDefinedFolders(urls).         addResources(urls).         addProjectClasses(urls).         addDependencies(urls).         return urls.toArray(new URL[0]).     } catch (IOException ex) {         throw new MojoExecutionException("Unable to build classpath", ex).     } }
false;private;1;7;;private void addUserDefinedFolders(List<URL> urls) throws MalformedURLException {     if (this.folders != null) {         for (String folder : this.folders) {             urls.add(new File(folder).toURI().toURL()).         }     } }
false;private;1;10;;private void addResources(List<URL> urls) throws IOException {     if (this.addResources) {         for (Resource resource : this.project.getResources()) {             File directory = new File(resource.getDirectory()).             urls.add(directory.toURI().toURL()).             FileUtils.removeDuplicatesFromOutputDirectory(this.classesDirectory, directory).         }     } }
false;private;1;3;;private void addProjectClasses(List<URL> urls) throws MalformedURLException {     urls.add(this.classesDirectory.toURI().toURL()). }
false;private;1;12;;private void addDependencies(List<URL> urls) throws MalformedURLException, MojoExecutionException {     FilterArtifacts filters = (this.useTestClasspath ? getFilters() : getFilters(new TestArtifactFilter())).     Set<Artifact> artifacts = filterDependencies(this.project.getArtifacts(), filters).     for (Artifact artifact : artifacts) {         if (artifact.getFile() != null) {             urls.add(artifact.getFile().toURI().toURL()).         }     } }
false;private;2;6;;private void logArguments(String message, String[] args) {     if (getLog().isDebugEnabled()) {         getLog().debug(Arrays.stream(args).collect(Collectors.joining(" ", message, ""))).     } }
false;protected;1;4;;@Override protected String getArtifactFeature(Artifact artifact) {     return artifact.getScope(). }
false;public;2;9;;@Override public void uncaughtException(Thread thread, Throwable ex) {     if (!(ex instanceof ThreadDeath)) {         synchronized (this.monitor) {             this.exception = (this.exception != null) ? this.exception : ex.         }         getLog().warn(ex).     } }
false;public;0;10;;public void rethrowUncaughtException() throws MojoExecutionException {     synchronized (this.monitor) {         if (this.exception != null) {             throw new MojoExecutionException("An exception occurred while running. " + this.exception.getMessage(), this.exception).         }     } }
false;public;0;23;;@Override public void run() {     Thread thread = Thread.currentThread().     ClassLoader classLoader = thread.getContextClassLoader().     try {         Class<?> startClass = classLoader.loadClass(this.startClassName).         Method mainMethod = startClass.getMethod("main", String[].class).         if (!mainMethod.isAccessible()) {             mainMethod.setAccessible(true).         }         mainMethod.invoke(null, new Object[] { this.args }).     } catch (NoSuchMethodException ex) {         Exception wrappedEx = new Exception("The specified mainClass doesn't contain a " + "main method with appropriate signature.", ex).         thread.getThreadGroup().uncaughtException(thread, wrappedEx).     } catch (Exception ex) {         thread.getThreadGroup().uncaughtException(thread, ex).     } }
false;public,static;2;9;;public static String format(String key, String value) {     if (key == null) {         return "".     }     if (value == null || value.isEmpty()) {         return String.format("-D%s", key).     }     return String.format("-D%s=\"%s\"", key, value). }
