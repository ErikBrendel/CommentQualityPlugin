commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;18;;protected void addAnnotations(Map<String, String> annotations) {     annotations.put("Configuration", "org.springframework.context.annotation.Configuration").     annotations.put("ConditionalOnClass", "org.springframework.boot.autoconfigure.condition.ConditionalOnClass").     annotations.put("ConditionalOnBean", "org.springframework.boot.autoconfigure.condition.ConditionalOnBean").     annotations.put("ConditionalOnSingleCandidate", "org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate").     annotations.put("ConditionalOnWebApplication", "org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication").     annotations.put("AutoConfigureBefore", "org.springframework.boot.autoconfigure.AutoConfigureBefore").     annotations.put("AutoConfigureAfter", "org.springframework.boot.autoconfigure.AutoConfigureAfter").     annotations.put("AutoConfigureOrder", "org.springframework.boot.autoconfigure.AutoConfigureOrder"). }
false;private;1;11;;private void addValueExtractors(Map<String, ValueExtractor> attributes) {     attributes.put("Configuration", ValueExtractor.allFrom("value")).     attributes.put("ConditionalOnClass", new OnClassConditionValueExtractor()).     attributes.put("ConditionalOnBean", new OnBeanConditionValueExtractor()).     attributes.put("ConditionalOnSingleCandidate", new OnBeanConditionValueExtractor()).     attributes.put("ConditionalOnWebApplication", ValueExtractor.allFrom("type")).     attributes.put("AutoConfigureBefore", ValueExtractor.allFrom("value", "name")).     attributes.put("AutoConfigureAfter", ValueExtractor.allFrom("value", "name")).     attributes.put("AutoConfigureOrder", ValueExtractor.allFrom("value")). }
false;public;0;4;;@Override public SourceVersion getSupportedSourceVersion() {     return SourceVersion.latestSupported(). }
false;public;2;16;;@Override public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {     for (Map.Entry<String, String> entry : this.annotations.entrySet()) {         process(roundEnv, entry.getKey(), entry.getValue()).     }     if (roundEnv.processingOver()) {         try {             writeProperties().         } catch (Exception ex) {             throw new IllegalStateException("Failed to write metadata", ex).         }     }     return false. }
false;private;3;14;;private void process(RoundEnvironment roundEnv, String propertyKey, String annotationName) {     TypeElement annotationType = this.processingEnv.getElementUtils().getTypeElement(annotationName).     if (annotationType != null) {         for (Element element : roundEnv.getElementsAnnotatedWith(annotationType)) {             Element enclosingElement = element.getEnclosingElement().             if (enclosingElement != null && enclosingElement.getKind() == ElementKind.PACKAGE) {                 processElement(element, propertyKey, annotationName).             }         }     } }
false;private;3;17;;private void processElement(Element element, String propertyKey, String annotationName) {     try {         String qualifiedName = Elements.getQualifiedName(element).         AnnotationMirror annotation = getAnnotation(element, annotationName).         if (qualifiedName != null && annotation != null) {             List<Object> values = getValues(propertyKey, annotation).             this.properties.put(qualifiedName + "." + propertyKey, toCommaDelimitedString(values)).             this.properties.put(qualifiedName, "").         }     } catch (Exception ex) {         throw new IllegalStateException("Error processing configuration meta-data on " + element, ex).     } }
false;private;2;10;;private AnnotationMirror getAnnotation(Element element, String type) {     if (element != null) {         for (AnnotationMirror annotation : element.getAnnotationMirrors()) {             if (type.equals(annotation.getAnnotationType().toString())) {                 return annotation.             }         }     }     return null. }
false;private;1;8;;private String toCommaDelimitedString(List<Object> list) {     StringBuilder result = new StringBuilder().     for (Object item : list) {         result.append((result.length() != 0) ? "," : "").         result.append(item).     }     return result.toString(). }
false;private;2;7;;private List<Object> getValues(String propertyKey, AnnotationMirror annotation) {     ValueExtractor extractor = this.valueExtractors.get(propertyKey).     if (extractor == null) {         return Collections.emptyList().     }     return extractor.getValues(annotation). }
false;private;0;9;;private void writeProperties() throws IOException {     if (!this.properties.isEmpty()) {         FileObject file = this.processingEnv.getFiler().createResource(StandardLocation.CLASS_OUTPUT, "", PROPERTIES_PATH).         try (OutputStream outputStream = file.openOutputStream()) {             this.properties.store(outputStream, null).         }     } }
false;;1;1;;List<Object> getValues(AnnotationMirror annotation).
false;static;1;3;;static ValueExtractor allFrom(String... names) {     return new NamedValuesExtractor(names). }
false;protected;1;12;;@SuppressWarnings("unchecked") protected Stream<Object> extractValues(AnnotationValue annotationValue) {     if (annotationValue == null) {         return Stream.empty().     }     Object value = annotationValue.getValue().     if (value instanceof List) {         return ((List<AnnotationValue>) value).stream().map((annotation) -> extractValue(annotation.getValue())).     }     return Stream.of(extractValue(value)). }
false;private;1;6;;private Object extractValue(Object value) {     if (value instanceof DeclaredType) {         return Elements.getQualifiedName(((DeclaredType) value).asElement()).     }     return value. }
false;public;1;10;;@Override public List<Object> getValues(AnnotationMirror annotation) {     List<Object> result = new ArrayList<>().     annotation.getElementValues().forEach((key, value) -> {         if (this.names.contains(key.getSimpleName().toString())) {             extractValues(value).forEach(result::add).         }     }).     return result. }
false;public;1;13;;@Override public List<Object> getValues(AnnotationMirror annotation) {     Map<String, AnnotationValue> attributes = new LinkedHashMap<>().     annotation.getElementValues().forEach((key, value) -> attributes.put(key.getSimpleName().toString(), value)).     if (attributes.containsKey("name")) {         return Collections.emptyList().     }     List<Object> result = new ArrayList<>().     extractValues(attributes.get("value")).forEach(result::add).     extractValues(attributes.get("type")).forEach(result::add).     return result. }
false;public;1;6;;@Override public List<Object> getValues(AnnotationMirror annotation) {     List<Object> values = super.getValues(annotation).     values.sort(this::compare).     return values. }
false;private;2;5;;private int compare(Object o1, Object o2) {     return Comparator.comparing(this::isSpringClass).thenComparing(String.CASE_INSENSITIVE_ORDER).compare(o1.toString(), o2.toString()). }
false;private;1;3;;private boolean isSpringClass(String type) {     return type.startsWith("org.springframework"). }
