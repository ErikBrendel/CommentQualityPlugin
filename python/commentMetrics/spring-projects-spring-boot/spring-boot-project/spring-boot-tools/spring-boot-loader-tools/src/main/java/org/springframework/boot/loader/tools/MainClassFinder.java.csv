commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;3;;private static boolean isClassFile(File file) {     return file.isFile() && file.getName().endsWith(DOT_CLASS). }
false;private,static;1;3;;private static boolean isPackageFolder(File file) {     return file.isDirectory() && !file.getName().startsWith("."). }
true;public,static;1;3;/**  * Find the main class from a given folder.  * @param rootFolder the root folder to search  * @return the main class or {@code null}  * @throws IOException if the folder cannot be read  */ ;/**  * Find the main class from a given folder.  * @param rootFolder the root folder to search  * @return the main class or {@code null}  * @throws IOException if the folder cannot be read  */ public static String findMainClass(File rootFolder) throws IOException {     return doWithMainClasses(rootFolder, MainClass::getName). }
true;public,static;1;3;/**  * Find a single main class from the given {@code rootFolder}.  * @param rootFolder the root folder to search  * @return the main class or {@code null}  * @throws IOException if the folder cannot be read  */ ;/**  * Find a single main class from the given {@code rootFolder}.  * @param rootFolder the root folder to search  * @return the main class or {@code null}  * @throws IOException if the folder cannot be read  */ public static String findSingleMainClass(File rootFolder) throws IOException {     return findSingleMainClass(rootFolder, null). }
true;public,static;2;6;/**  * Find a single main class from the given {@code rootFolder}. A main class annotated  * with an annotation with the given {@code annotationName} will be preferred over a  * main class with no such annotation.  * @param rootFolder the root folder to search  * @param annotationName the name of the annotation that may be present on the main  * class  * @return the main class or {@code null}  * @throws IOException if the folder cannot be read  */ ;/**  * Find a single main class from the given {@code rootFolder}. A main class annotated  * with an annotation with the given {@code annotationName} will be preferred over a  * main class with no such annotation.  * @param rootFolder the root folder to search  * @param annotationName the name of the annotation that may be present on the main  * class  * @return the main class or {@code null}  * @throws IOException if the folder cannot be read  */ public static String findSingleMainClass(File rootFolder, String annotationName) throws IOException {     SingleMainClassCallback callback = new SingleMainClassCallback(annotationName).     MainClassFinder.doWithMainClasses(rootFolder, callback).     return callback.getMainClassName(). }
true;static;2;35;/**  * Perform the given callback operation on all main classes from the given root  * folder.  * @param <T> the result type  * @param rootFolder the root folder  * @param callback the callback  * @return the first callback result or {@code null}  * @throws IOException in case of I/O errors  */ ;/**  * Perform the given callback operation on all main classes from the given root  * folder.  * @param <T> the result type  * @param rootFolder the root folder  * @param callback the callback  * @return the first callback result or {@code null}  * @throws IOException in case of I/O errors  */ static <T> T doWithMainClasses(File rootFolder, MainClassCallback<T> callback) throws IOException {     if (!rootFolder.exists()) {         // nothing to do         return null.     }     if (!rootFolder.isDirectory()) {         throw new IllegalArgumentException("Invalid root folder '" + rootFolder + "'").     }     String prefix = rootFolder.getAbsolutePath() + "/".     Deque<File> stack = new ArrayDeque<>().     stack.push(rootFolder).     while (!stack.isEmpty()) {         File file = stack.pop().         if (file.isFile()) {             try (InputStream inputStream = new FileInputStream(file)) {                 ClassDescriptor classDescriptor = createClassDescriptor(inputStream).                 if (classDescriptor != null && classDescriptor.isMainMethodFound()) {                     String className = convertToClassName(file.getAbsolutePath(), prefix).                     T result = callback.doWith(new MainClass(className, classDescriptor.getAnnotationNames())).                     if (result != null) {                         return result.                     }                 }             }         }         if (file.isDirectory()) {             pushAllSorted(stack, file.listFiles(PACKAGE_FOLDER_FILTER)).             pushAllSorted(stack, file.listFiles(CLASS_FILE_FILTER)).         }     }     return null. }
false;private,static;2;6;;private static void pushAllSorted(Deque<File> stack, File[] files) {     Arrays.sort(files, Comparator.comparing(File::getName)).     for (File file : files) {         stack.push(file).     } }
true;public,static;2;4;/**  * Find the main class in a given jar file.  * @param jarFile the jar file to search  * @param classesLocation the location within the jar containing classes  * @return the main class or {@code null}  * @throws IOException if the jar file cannot be read  */ ;/**  * Find the main class in a given jar file.  * @param jarFile the jar file to search  * @param classesLocation the location within the jar containing classes  * @return the main class or {@code null}  * @throws IOException if the jar file cannot be read  */ public static String findMainClass(JarFile jarFile, String classesLocation) throws IOException {     return doWithMainClasses(jarFile, classesLocation, MainClass::getName). }
true;public,static;2;4;/**  * Find a single main class in a given jar file.  * @param jarFile the jar file to search  * @param classesLocation the location within the jar containing classes  * @return the main class or {@code null}  * @throws IOException if the jar file cannot be read  */ ;/**  * Find a single main class in a given jar file.  * @param jarFile the jar file to search  * @param classesLocation the location within the jar containing classes  * @return the main class or {@code null}  * @throws IOException if the jar file cannot be read  */ public static String findSingleMainClass(JarFile jarFile, String classesLocation) throws IOException {     return findSingleMainClass(jarFile, classesLocation, null). }
true;public,static;3;6;/**  * Find a single main class in a given jar file. A main class annotated with an  * annotation with the given {@code annotationName} will be preferred over a main  * class with no such annotation.  * @param jarFile the jar file to search  * @param classesLocation the location within the jar containing classes  * @param annotationName the name of the annotation that may be present on the main  * class  * @return the main class or {@code null}  * @throws IOException if the jar file cannot be read  */ ;/**  * Find a single main class in a given jar file. A main class annotated with an  * annotation with the given {@code annotationName} will be preferred over a main  * class with no such annotation.  * @param jarFile the jar file to search  * @param classesLocation the location within the jar containing classes  * @param annotationName the name of the annotation that may be present on the main  * class  * @return the main class or {@code null}  * @throws IOException if the jar file cannot be read  */ public static String findSingleMainClass(JarFile jarFile, String classesLocation, String annotationName) throws IOException {     SingleMainClassCallback callback = new SingleMainClassCallback(annotationName).     MainClassFinder.doWithMainClasses(jarFile, classesLocation, callback).     return callback.getMainClassName(). }
true;static;3;21;/**  * Perform the given callback operation on all main classes from the given jar.  * @param <T> the result type  * @param jarFile the jar file to search  * @param classesLocation the location within the jar containing classes  * @param callback the callback  * @return the first callback result or {@code null}  * @throws IOException in case of I/O errors  */ ;/**  * Perform the given callback operation on all main classes from the given jar.  * @param <T> the result type  * @param jarFile the jar file to search  * @param classesLocation the location within the jar containing classes  * @param callback the callback  * @return the first callback result or {@code null}  * @throws IOException in case of I/O errors  */ static <T> T doWithMainClasses(JarFile jarFile, String classesLocation, MainClassCallback<T> callback) throws IOException {     List<JarEntry> classEntries = getClassEntries(jarFile, classesLocation).     classEntries.sort(new ClassEntryComparator()).     for (JarEntry entry : classEntries) {         try (InputStream inputStream = new BufferedInputStream(jarFile.getInputStream(entry))) {             ClassDescriptor classDescriptor = createClassDescriptor(inputStream).             if (classDescriptor != null && classDescriptor.isMainMethodFound()) {                 String className = convertToClassName(entry.getName(), classesLocation).                 T result = callback.doWith(new MainClass(className, classDescriptor.getAnnotationNames())).                 if (result != null) {                     return result.                 }             }         }     }     return null. }
false;private,static;2;9;;private static String convertToClassName(String name, String prefix) {     name = name.replace('/', '.').     name = name.replace('\\', '.').     name = name.substring(0, name.length() - DOT_CLASS.length()).     if (prefix != null) {         name = name.substring(prefix.length()).     }     return name. }
false;private,static;2;14;;private static List<JarEntry> getClassEntries(JarFile source, String classesLocation) {     classesLocation = (classesLocation != null) ? classesLocation : "".     Enumeration<JarEntry> sourceEntries = source.entries().     List<JarEntry> classEntries = new ArrayList<>().     while (sourceEntries.hasMoreElements()) {         JarEntry entry = sourceEntries.nextElement().         if (entry.getName().startsWith(classesLocation) && entry.getName().endsWith(DOT_CLASS)) {             classEntries.add(entry).         }     }     return classEntries. }
false;private,static;1;11;;private static ClassDescriptor createClassDescriptor(InputStream inputStream) {     try {         ClassReader classReader = new ClassReader(inputStream).         ClassDescriptor classDescriptor = new ClassDescriptor().         classReader.accept(classDescriptor, ClassReader.SKIP_CODE).         return classDescriptor.     } catch (IOException ex) {         return null.     } }
false;public;2;10;;@Override public int compare(JarEntry o1, JarEntry o2) {     Integer d1 = getDepth(o1).     Integer d2 = getDepth(o2).     int depthCompare = d1.compareTo(d2).     if (depthCompare != 0) {         return depthCompare.     }     return o1.getName().compareTo(o2.getName()). }
false;private;1;3;;private int getDepth(JarEntry entry) {     return entry.getName().split("/").length. }
false;public;2;5;;@Override public AnnotationVisitor visitAnnotation(String desc, boolean visible) {     this.annotationNames.add(Type.getType(desc).getClassName()).     return null. }
false;public;5;10;;@Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {     if (isAccess(access, Opcodes.ACC_PUBLIC, Opcodes.ACC_STATIC) && MAIN_METHOD_NAME.equals(name) && MAIN_METHOD_TYPE.getDescriptor().equals(desc)) {         this.mainMethodFound = true.     }     return null. }
false;private;2;8;;private boolean isAccess(int access, int... requiredOpsCodes) {     for (int requiredOpsCode : requiredOpsCodes) {         if ((access & requiredOpsCode) == 0) {             return false.         }     }     return true. }
false;;0;3;;boolean isMainMethodFound() {     return this.mainMethodFound. }
false;;0;3;;Set<String> getAnnotationNames() {     return this.annotationNames. }
true;;1;1;/**  * Handle the specified main class.  * @param mainClass the main class  * @return a non-null value if processing should end or {@code null} to continue  */ ;/**  * Handle the specified main class.  * @param mainClass the main class  * @return a non-null value if processing should end or {@code null} to continue  */ T doWith(MainClass mainClass).
false;;0;3;;String getName() {     return this.name. }
false;;0;3;;Set<String> getAnnotationNames() {     return this.annotationNames. }
false;public;1;17;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     MainClass other = (MainClass) obj.     if (!this.name.equals(other.name)) {         return false.     }     return true. }
false;public;0;4;;@Override public int hashCode() {     return this.name.hashCode(). }
false;public;0;4;;@Override public String toString() {     return this.name. }
false;public;1;5;;@Override public Object doWith(MainClass mainClass) {     this.mainClasses.add(mainClass).     return null. }
false;private;0;20;;private String getMainClassName() {     Set<MainClass> matchingMainClasses = new LinkedHashSet<>().     if (this.annotationName != null) {         for (MainClass mainClass : this.mainClasses) {             if (mainClass.getAnnotationNames().contains(this.annotationName)) {                 matchingMainClasses.add(mainClass).             }         }     }     if (matchingMainClasses.isEmpty()) {         matchingMainClasses.addAll(this.mainClasses).     }     if (matchingMainClasses.size() > 1) {         throw new IllegalStateException("Unable to find a single main class from the following candidates " + matchingMainClasses).     }     return (matchingMainClasses.isEmpty() ? null : matchingMainClasses.iterator().next().getName()). }
