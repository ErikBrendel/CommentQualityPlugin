commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;17;/**  * Utility to remove duplicate files from an "output" directory if they already exist  * in an "origin". Recursively scans the origin directory looking for files (not  * directories) that exist in both places and deleting the copy.  * @param outputDirectory the output directory  * @param originDirectory the origin directory  */ ;/**  * Utility to remove duplicate files from an "output" directory if they already exist  * in an "origin". Recursively scans the origin directory looking for files (not  * directories) that exist in both places and deleting the copy.  * @param outputDirectory the output directory  * @param originDirectory the origin directory  */ public static void removeDuplicatesFromOutputDirectory(File outputDirectory, File originDirectory) {     if (originDirectory.isDirectory()) {         for (String name : originDirectory.list()) {             File targetFile = new File(outputDirectory, name).             if (targetFile.exists() && targetFile.canWrite()) {                 if (!targetFile.isDirectory()) {                     targetFile.delete().                 } else {                     FileUtils.removeDuplicatesFromOutputDirectory(targetFile, new File(originDirectory, name)).                 }             }         }     } }
true;public,static;1;15;/**  * Generate a SHA.1 Hash for a given file.  * @param file the file to hash  * @return the hash value as a String  * @throws IOException if the file cannot be read  */ ;/**  * Generate a SHA.1 Hash for a given file.  * @param file the file to hash  * @return the hash value as a String  * @throws IOException if the file cannot be read  */ public static String sha1Hash(File file) throws IOException {     try {         try (DigestInputStream inputStream = new DigestInputStream(new FileInputStream(file), MessageDigest.getInstance("SHA-1"))) {             byte[] buffer = new byte[4098].             while (inputStream.read(buffer) != -1) {             // Read the entire stream             }             return bytesToHex(inputStream.getMessageDigest().digest()).         }     } catch (NoSuchAlgorithmException ex) {         throw new IllegalStateException(ex).     } }
false;private,static;1;7;;private static String bytesToHex(byte[] bytes) {     StringBuilder hex = new StringBuilder().     for (byte b : bytes) {         hex.append(String.format("%02x", b)).     }     return hex.toString(). }
