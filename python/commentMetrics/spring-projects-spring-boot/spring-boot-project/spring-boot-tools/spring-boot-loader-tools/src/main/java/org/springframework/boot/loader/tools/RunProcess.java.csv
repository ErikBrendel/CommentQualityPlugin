commented;modifiers;parameterAmount;loc;comment;code
false;public;2;3;;public int run(boolean waitForProcess, String... args) throws IOException {     return run(waitForProcess, Arrays.asList(args), Collections.emptyMap()). }
false;public;3;30;;public int run(boolean waitForProcess, Collection<String> args, Map<String, String> environmentVariables) throws IOException {     ProcessBuilder builder = new ProcessBuilder(this.command).     builder.directory(this.workingDirectory).     builder.command().addAll(args).     builder.environment().putAll(environmentVariables).     builder.redirectErrorStream(true).     builder.inheritIO().     try {         Process process = builder.start().         this.process = process.         SignalUtils.attachSignalHandler(this::handleSigInt).         if (waitForProcess) {             try {                 return process.waitFor().             } catch (InterruptedException ex) {                 Thread.currentThread().interrupt().                 return 1.             }         }         return 5.     } finally {         if (waitForProcess) {             this.endTime = System.currentTimeMillis().             this.process = null.         }     } }
true;public;0;3;/**  * Return the running process.  * @return the process or {@code null}  */ ;/**  * Return the running process.  * @return the process or {@code null}  */ public Process getRunningProcess() {     return this.process. }
true;public;0;7;/**  * Return if the process was stopped.  * @return {@code true} if stopped  */ ;/**  * Return if the process was stopped.  * @return {@code true} if stopped  */ public boolean handleSigInt() {     // if the process has just ended, probably due to this SIGINT, consider handled.     if (hasJustEnded()) {         return true.     }     return doKill(). }
true;public;0;3;/**  * Kill this process.  */ ;/**  * Kill this process.  */ public void kill() {     doKill(). }
false;private;0;16;;private boolean doKill() {     // destroy the running process     Process process = this.process.     if (process != null) {         try {             process.destroy().             process.waitFor().             this.process = null.             return true.         } catch (InterruptedException ex) {             Thread.currentThread().interrupt().         }     }     return false. }
false;public;0;3;;public boolean hasJustEnded() {     return System.currentTimeMillis() < (this.endTime + JUST_ENDED_LIMIT). }
