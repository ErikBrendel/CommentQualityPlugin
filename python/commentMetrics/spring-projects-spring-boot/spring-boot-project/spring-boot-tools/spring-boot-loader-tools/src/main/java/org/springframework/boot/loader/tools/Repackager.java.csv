commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Add a listener that will be triggered to display a warning if searching for the  * main class takes too long.  * @param listener the listener to add  */ ;/**  * Add a listener that will be triggered to display a warning if searching for the  * main class takes too long.  * @param listener the listener to add  */ public void addMainClassTimeoutWarningListener(MainClassTimeoutWarningListener listener) {     this.mainClassTimeoutListeners.add(listener). }
true;public;1;3;/**  * Sets the main class that should be run. If not specified the value from the  * MANIFEST will be used, or if no manifest entry is found the archive will be  * searched for a suitable class.  * @param mainClass the main class name  */ ;/**  * Sets the main class that should be run. If not specified the value from the  * MANIFEST will be used, or if no manifest entry is found the archive will be  * searched for a suitable class.  * @param mainClass the main class name  */ public void setMainClass(String mainClass) {     this.mainClass = mainClass. }
true;public;1;3;/**  * Sets if source files should be backed up when they would be overwritten.  * @param backupSource if source files should be backed up  */ ;/**  * Sets if source files should be backed up when they would be overwritten.  * @param backupSource if source files should be backed up  */ public void setBackupSource(boolean backupSource) {     this.backupSource = backupSource. }
true;public;1;6;/**  * Sets the layout to use for the jar. Defaults to {@link Layouts#forFile(File)}.  * @param layout the layout  */ ;/**  * Sets the layout to use for the jar. Defaults to {@link Layouts#forFile(File)}.  * @param layout the layout  */ public void setLayout(Layout layout) {     if (layout == null) {         throw new IllegalArgumentException("Layout must not be null").     }     this.layout = layout. }
true;public;1;3;/**  * Sets the layout factory for the jar. The factory can be used when no specific  * layout is specified.  * @param layoutFactory the layout factory to set  */ ;/**  * Sets the layout factory for the jar. The factory can be used when no specific  * layout is specified.  * @param layoutFactory the layout factory to set  */ public void setLayoutFactory(LayoutFactory layoutFactory) {     this.layoutFactory = layoutFactory. }
true;public;1;3;/**  * Repackage the source file so that it can be run using '{@literal java -jar}'.  * @param libraries the libraries required to run the archive  * @throws IOException if the file cannot be repackaged  */ ;/**  * Repackage the source file so that it can be run using '{@literal java -jar}'.  * @param libraries the libraries required to run the archive  * @throws IOException if the file cannot be repackaged  */ public void repackage(Libraries libraries) throws IOException {     repackage(this.source, libraries). }
true;public;2;3;/**  * Repackage to the given destination so that it can be launched using '  * {@literal java -jar}'.  * @param destination the destination file (may be the same as the source)  * @param libraries the libraries required to run the archive  * @throws IOException if the file cannot be repackaged  */ ;/**  * Repackage to the given destination so that it can be launched using '  * {@literal java -jar}'.  * @param destination the destination file (may be the same as the source)  * @param libraries the libraries required to run the archive  * @throws IOException if the file cannot be repackaged  */ public void repackage(File destination, Libraries libraries) throws IOException {     repackage(destination, libraries, null). }
true;public;3;33;/**  * Repackage to the given destination so that it can be launched using '  * {@literal java -jar}'.  * @param destination the destination file (may be the same as the source)  * @param libraries the libraries required to run the archive  * @param launchScript an optional launch script prepended to the front of the jar  * @throws IOException if the file cannot be repackaged  * @since 1.3.0  */ ;/**  * Repackage to the given destination so that it can be launched using '  * {@literal java -jar}'.  * @param destination the destination file (may be the same as the source)  * @param libraries the libraries required to run the archive  * @param launchScript an optional launch script prepended to the front of the jar  * @throws IOException if the file cannot be repackaged  * @since 1.3.0  */ public void repackage(File destination, Libraries libraries, LaunchScript launchScript) throws IOException {     if (destination == null || destination.isDirectory()) {         throw new IllegalArgumentException("Invalid destination").     }     if (libraries == null) {         throw new IllegalArgumentException("Libraries must not be null").     }     if (this.layout == null) {         this.layout = getLayoutFactory().getLayout(this.source).     }     destination = destination.getAbsoluteFile().     File workingSource = this.source.     if (alreadyRepackaged() && this.source.equals(destination)) {         return.     }     if (this.source.equals(destination)) {         workingSource = getBackupFile().         workingSource.delete().         renameFile(this.source, workingSource).     }     destination.delete().     try {         try (JarFile jarFileSource = new JarFile(workingSource)) {             repackage(jarFileSource, destination, libraries, launchScript).         }     } finally {         if (!this.backupSource && !this.source.equals(workingSource)) {             deleteFile(workingSource).         }     } }
false;private;0;12;;private LayoutFactory getLayoutFactory() {     if (this.layoutFactory != null) {         return this.layoutFactory.     }     List<LayoutFactory> factories = SpringFactoriesLoader.loadFactories(LayoutFactory.class, null).     if (factories.isEmpty()) {         return new DefaultLayoutFactory().     }     Assert.state(factories.size() == 1, "No unique LayoutFactory found").     return factories.get(0). }
true;public,final;0;3;/**  * Return the {@link File} to use to backup the original source.  * @return the file to use to backup the original source  */ ;/**  * Return the {@link File} to use to backup the original source.  * @return the file to use to backup the original source  */ public final File getBackupFile() {     return new File(this.source.getParentFile(), this.source.getName() + ".original"). }
false;private;0;7;;private boolean alreadyRepackaged() throws IOException {     try (JarFile jarFile = new JarFile(this.source)) {         Manifest manifest = jarFile.getManifest().         return (manifest != null && manifest.getMainAttributes().getValue(BOOT_VERSION_ATTRIBUTE) != null).     } }
false;private;4;17;;private void repackage(JarFile sourceJar, File destination, Libraries libraries, LaunchScript launchScript) throws IOException {     WritableLibraries writeableLibraries = new WritableLibraries(libraries).     try (JarWriter writer = new JarWriter(destination, launchScript)) {         writer.writeManifest(buildManifest(sourceJar)).         writeLoaderClasses(writer).         if (this.layout instanceof RepackagingLayout) {             writer.writeEntries(sourceJar, new RenamingEntryTransformer(((RepackagingLayout) this.layout).getRepackagedClassesLocation()), writeableLibraries).         } else {             writer.writeEntries(sourceJar, writeableLibraries).         }         writeableLibraries.write(writer).     } }
false;private;1;8;;private void writeLoaderClasses(JarWriter writer) throws IOException {     if (this.layout instanceof CustomLoaderLayout) {         ((CustomLoaderLayout) this.layout).writeLoadedClasses(writer).     } else if (this.layout.isExecutable()) {         writer.writeLoaderClasses().     } }
false;private;1;10;;private boolean isZip(File file) {     try {         try (FileInputStream fileInputStream = new FileInputStream(file)) {             return isZip(fileInputStream).         }     } catch (IOException ex) {         return false.     } }
false;private;1;8;;private boolean isZip(InputStream inputStream) throws IOException {     for (byte magicByte : ZIP_FILE_HEADER) {         if (inputStream.read() != magicByte) {             return false.         }     }     return true. }
false;private;1;38;;private Manifest buildManifest(JarFile source) throws IOException {     Manifest manifest = source.getManifest().     if (manifest == null) {         manifest = new Manifest().         manifest.getMainAttributes().putValue("Manifest-Version", "1.0").     }     manifest = new Manifest(manifest).     String startClass = this.mainClass.     if (startClass == null) {         startClass = manifest.getMainAttributes().getValue(MAIN_CLASS_ATTRIBUTE).     }     if (startClass == null) {         startClass = findMainMethodWithTimeoutWarning(source).     }     String launcherClassName = this.layout.getLauncherClassName().     if (launcherClassName != null) {         manifest.getMainAttributes().putValue(MAIN_CLASS_ATTRIBUTE, launcherClassName).         if (startClass == null) {             throw new IllegalStateException("Unable to find main class").         }         manifest.getMainAttributes().putValue(START_CLASS_ATTRIBUTE, startClass).     } else if (startClass != null) {         manifest.getMainAttributes().putValue(MAIN_CLASS_ATTRIBUTE, startClass).     }     String bootVersion = getClass().getPackage().getImplementationVersion().     manifest.getMainAttributes().putValue(BOOT_VERSION_ATTRIBUTE, bootVersion).     manifest.getMainAttributes().putValue(BOOT_CLASSES_ATTRIBUTE, (this.layout instanceof RepackagingLayout) ? ((RepackagingLayout) this.layout).getRepackagedClassesLocation() : this.layout.getClassesLocation()).     String lib = this.layout.getLibraryDestination("", LibraryScope.COMPILE).     if (StringUtils.hasLength(lib)) {         manifest.getMainAttributes().putValue(BOOT_LIB_ATTRIBUTE, lib).     }     return manifest. }
false;private;1;11;;private String findMainMethodWithTimeoutWarning(JarFile source) throws IOException {     long startTime = System.currentTimeMillis().     String mainMethod = findMainMethod(source).     long duration = System.currentTimeMillis() - startTime.     if (duration > FIND_WARNING_TIMEOUT) {         for (MainClassTimeoutWarningListener listener : this.mainClassTimeoutListeners) {             listener.handleTimeoutWarning(duration, mainMethod).         }     }     return mainMethod. }
false;protected;1;4;;protected String findMainMethod(JarFile source) throws IOException {     return MainClassFinder.findSingleMainClass(source, this.layout.getClassesLocation(), SPRING_BOOT_APPLICATION_CLASS_NAME). }
false;private;2;6;;private void renameFile(File file, File dest) {     if (!file.renameTo(dest)) {         throw new IllegalStateException("Unable to rename '" + file + "' to '" + dest + "'").     } }
false;private;1;5;;private void deleteFile(File file) {     if (!file.delete()) {         throw new IllegalStateException("Unable to delete '" + file + "'").     } }
true;;2;1;/**  * Handle a timeout warning.  * @param duration the amount of time it took to find the main method  * @param mainMethod the main method that was actually found  */ ;/**  * Handle a timeout warning.  * @param duration the amount of time it took to find the main method  * @param mainMethod the main method that was actually found  */ void handleTimeoutWarning(long duration, String mainMethod).
false;public;1;36;;@Override public JarArchiveEntry transform(JarArchiveEntry entry) {     if (entry.getName().equals("META-INF/INDEX.LIST")) {         return null.     }     if ((entry.getName().startsWith("META-INF/") && !entry.getName().equals("META-INF/aop.xml") && !entry.getName().endsWith(".kotlin_module")) || entry.getName().startsWith("BOOT-INF/") || entry.getName().equals("module-info.class")) {         return entry.     }     JarArchiveEntry renamedEntry = new JarArchiveEntry(this.namePrefix + entry.getName()).     renamedEntry.setTime(entry.getTime()).     renamedEntry.setSize(entry.getSize()).     renamedEntry.setMethod(entry.getMethod()).     if (entry.getComment() != null) {         renamedEntry.setComment(entry.getComment()).     }     renamedEntry.setCompressedSize(entry.getCompressedSize()).     renamedEntry.setCrc(entry.getCrc()).     if (entry.getCreationTime() != null) {         renamedEntry.setCreationTime(entry.getCreationTime()).     }     if (entry.getExtra() != null) {         renamedEntry.setExtra(entry.getExtra()).     }     if (entry.getLastAccessTime() != null) {         renamedEntry.setLastAccessTime(entry.getLastAccessTime()).     }     if (entry.getLastModifiedTime() != null) {         renamedEntry.setLastModifiedTime(entry.getLastModifiedTime()).     }     return renamedEntry. }
false;public;1;5;;@Override public boolean requiresUnpack(String name) {     Library library = this.libraryEntryNames.get(name).     return library != null && library.isUnpackRequired(). }
false;public;1;9;;@Override public String sha1Hash(String name) throws IOException {     Library library = this.libraryEntryNames.get(name).     if (library == null) {         throw new IllegalArgumentException("No library found for entry name '" + name + "'").     }     return FileUtils.sha1Hash(library.getFile()). }
false;private;1;7;;private void write(JarWriter writer) throws IOException {     for (Entry<String, Library> entry : this.libraryEntryNames.entrySet()) {         writer.writeNestedLibrary(entry.getKey().substring(0, entry.getKey().lastIndexOf('/') + 1), entry.getValue()).     } }
