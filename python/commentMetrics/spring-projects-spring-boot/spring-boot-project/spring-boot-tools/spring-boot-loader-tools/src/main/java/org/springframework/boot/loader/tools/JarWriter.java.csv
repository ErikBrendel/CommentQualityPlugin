commented;modifiers;parameterAmount;loc;comment;code
false;private;1;12;;private void setExecutableFilePermission(File file) {     try {         Path path = file.toPath().         Set<PosixFilePermission> permissions = new HashSet<>(Files.getPosixFilePermissions(path)).         permissions.add(PosixFilePermission.OWNER_EXECUTE).         Files.setPosixFilePermissions(path, permissions).     } catch (Throwable ex) {     // Ignore and continue creating the jar     } }
true;public;1;4;/**  * Write the specified manifest.  * @param manifest the manifest to write  * @throws IOException of the manifest cannot be written  */ ;/**  * Write the specified manifest.  * @param manifest the manifest to write  * @throws IOException of the manifest cannot be written  */ public void writeManifest(Manifest manifest) throws IOException {     JarArchiveEntry entry = new JarArchiveEntry("META-INF/MANIFEST.MF").     writeEntry(entry, manifest::write). }
true;public;1;3;/**  * Write all entries from the specified jar file.  * @param jarFile the source jar file  * @throws IOException if the entries cannot be written  */ ;/**  * Write all entries from the specified jar file.  * @param jarFile the source jar file  * @throws IOException if the entries cannot be written  */ public void writeEntries(JarFile jarFile) throws IOException {     this.writeEntries(jarFile, new IdentityEntryTransformer(), NEVER_UNPACK). }
false;;2;3;;void writeEntries(JarFile jarFile, UnpackHandler unpackHandler) throws IOException {     this.writeEntries(jarFile, new IdentityEntryTransformer(), unpackHandler). }
false;;3;16;;void writeEntries(JarFile jarFile, EntryTransformer entryTransformer, UnpackHandler unpackHandler) throws IOException {     Enumeration<JarEntry> entries = jarFile.entries().     while (entries.hasMoreElements()) {         JarArchiveEntry entry = new JarArchiveEntry(entries.nextElement()).         setUpEntry(jarFile, entry).         try (ZipHeaderPeekInputStream inputStream = new ZipHeaderPeekInputStream(jarFile.getInputStream(entry))) {             EntryWriter entryWriter = new InputStreamEntryWriter(inputStream, true).             JarArchiveEntry transformedEntry = entryTransformer.transform(entry).             if (transformedEntry != null) {                 writeEntry(transformedEntry, entryWriter, unpackHandler).             }         }     } }
false;private;2;11;;private void setUpEntry(JarFile jarFile, JarArchiveEntry entry) throws IOException {     try (ZipHeaderPeekInputStream inputStream = new ZipHeaderPeekInputStream(jarFile.getInputStream(entry))) {         if (inputStream.hasZipHeader() && entry.getMethod() != ZipEntry.STORED) {             new CrcAndSize(inputStream).setupStoredEntry(entry).         } else {             entry.setCompressedSize(-1).         }     } }
true;public;2;5;/**  * Writes an entry. The {@code inputStream} is closed once the entry has been written  * @param entryName the name of the entry  * @param inputStream the stream from which the entry's data can be read  * @throws IOException if the write fails  */ ;/**  * Writes an entry. The {@code inputStream} is closed once the entry has been written  * @param entryName the name of the entry  * @param inputStream the stream from which the entry's data can be read  * @throws IOException if the write fails  */ @Override public void writeEntry(String entryName, InputStream inputStream) throws IOException {     JarArchiveEntry entry = new JarArchiveEntry(entryName).     writeEntry(entry, new InputStreamEntryWriter(inputStream, true)). }
true;public;2;9;/**  * Write a nested library.  * @param destination the destination of the library  * @param library the library  * @throws IOException if the write fails  */ ;/**  * Write a nested library.  * @param destination the destination of the library  * @param library the library  * @throws IOException if the write fails  */ public void writeNestedLibrary(String destination, Library library) throws IOException {     File file = library.getFile().     JarArchiveEntry entry = new JarArchiveEntry(destination + library.getName()).     entry.setTime(getNestedLibraryTime(file)).     new CrcAndSize(file).setupStoredEntry(entry).     writeEntry(entry, new InputStreamEntryWriter(new FileInputStream(file), true), new LibraryUnpackHandler(library)). }
false;private;1;17;;private long getNestedLibraryTime(File file) {     try {         try (JarFile jarFile = new JarFile(file)) {             Enumeration<JarEntry> entries = jarFile.entries().             while (entries.hasMoreElements()) {                 JarEntry entry = entries.nextElement().                 if (!entry.isDirectory()) {                     return entry.getTime().                 }             }         }     } catch (Exception ex) {     // Ignore and just use the source file timestamp     }     return file.lastModified(). }
true;public;0;4;/**  * Write the required spring-boot-loader classes to the JAR.  * @throws IOException if the classes cannot be written  */ ;/**  * Write the required spring-boot-loader classes to the JAR.  * @throws IOException if the classes cannot be written  */ @Override public void writeLoaderClasses() throws IOException {     writeLoaderClasses(NESTED_LOADER_JAR). }
true;public;1;14;/**  * Write the required spring-boot-loader classes to the JAR.  * @param loaderJarResourceName the name of the resource containing the loader classes  * to be written  * @throws IOException if the classes cannot be written  */ ;/**  * Write the required spring-boot-loader classes to the JAR.  * @param loaderJarResourceName the name of the resource containing the loader classes  * to be written  * @throws IOException if the classes cannot be written  */ @Override public void writeLoaderClasses(String loaderJarResourceName) throws IOException {     URL loaderJar = getClass().getClassLoader().getResource(loaderJarResourceName).     try (JarInputStream inputStream = new JarInputStream(new BufferedInputStream(loaderJar.openStream()))) {         JarEntry entry.         while ((entry = inputStream.getNextJarEntry()) != null) {             if (entry.getName().endsWith(".class")) {                 writeEntry(new JarArchiveEntry(entry), new InputStreamEntryWriter(inputStream, false)).             }         }     } }
true;public;0;4;/**  * Close the writer.  * @throws IOException if the file cannot be closed  */ ;/**  * Close the writer.  * @throws IOException if the file cannot be closed  */ @Override public void close() throws IOException {     this.jarOutput.close(). }
false;private;2;4;;private void writeEntry(JarArchiveEntry entry, EntryWriter entryWriter) throws IOException {     writeEntry(entry, entryWriter, NEVER_UNPACK). }
true;private;3;26;/**  * Perform the actual write of a {@link JarEntry}. All other write methods delegate to  * this one.  * @param entry the entry to write  * @param entryWriter the entry writer or {@code null} if there is no content  * @param unpackHandler handles possible unpacking for the entry  * @throws IOException in case of I/O errors  */ ;/**  * Perform the actual write of a {@link JarEntry}. All other write methods delegate to  * this one.  * @param entry the entry to write  * @param entryWriter the entry writer or {@code null} if there is no content  * @param unpackHandler handles possible unpacking for the entry  * @throws IOException in case of I/O errors  */ private void writeEntry(JarArchiveEntry entry, EntryWriter entryWriter, UnpackHandler unpackHandler) throws IOException {     String parent = entry.getName().     if (parent.endsWith("/")) {         parent = parent.substring(0, parent.length() - 1).         entry.setUnixMode(UnixStat.DIR_FLAG | UnixStat.DEFAULT_DIR_PERM).     } else {         entry.setUnixMode(UnixStat.FILE_FLAG | UnixStat.DEFAULT_FILE_PERM).     }     if (parent.lastIndexOf('/') != -1) {         parent = parent.substring(0, parent.lastIndexOf('/') + 1).         if (!parent.isEmpty()) {             writeEntry(new JarArchiveEntry(parent), null, unpackHandler).         }     }     if (this.writtenEntries.add(entry.getName())) {         entryWriter = addUnpackCommentIfNecessary(entry, entryWriter, unpackHandler).         this.jarOutput.putArchiveEntry(entry).         if (entryWriter != null) {             entryWriter.write(this.jarOutput).         }         this.jarOutput.closeArchiveEntry().     } }
false;private;3;11;;private EntryWriter addUnpackCommentIfNecessary(JarArchiveEntry entry, EntryWriter entryWriter, UnpackHandler unpackHandler) throws IOException {     if (entryWriter == null || !unpackHandler.requiresUnpack(entry.getName())) {         return entryWriter.     }     ByteArrayOutputStream output = new ByteArrayOutputStream().     entryWriter.write(output).     entry.setComment("UNPACK:" + unpackHandler.sha1Hash(entry.getName())).     return new InputStreamEntryWriter(new ByteArrayInputStream(output.toByteArray()), true). }
true;;1;1;/**  * Write entry data to the specified output stream.  * @param outputStream the destination for the data  * @throws IOException in case of I/O errors  */ ;/**  * Write entry data to the specified output stream.  * @param outputStream the destination for the data  * @throws IOException in case of I/O errors  */ void write(OutputStream outputStream) throws IOException.
false;public;1;12;;@Override public void write(OutputStream outputStream) throws IOException {     byte[] buffer = new byte[BUFFER_SIZE].     int bytesRead.     while ((bytesRead = this.inputStream.read(buffer)) != -1) {         outputStream.write(buffer, 0, bytesRead).     }     outputStream.flush().     if (this.close) {         this.inputStream.close().     } }
false;public;0;12;;@Override public int read() throws IOException {     int read = (this.headerStream != null) ? this.headerStream.read() : -1.     if (read != -1) {         this.position++.         if (this.position >= this.headerLength) {             this.headerStream = null.         }         return read.     }     return super.read(). }
false;public;1;4;;@Override public int read(byte[] b) throws IOException {     return read(b, 0, b.length). }
false;public;3;19;;@Override public int read(byte[] b, int off, int len) throws IOException {     int read = (this.headerStream != null) ? this.headerStream.read(b, off, len) : -1.     if (read <= 0) {         return readRemainder(b, off, len).     }     this.position += read.     if (read < len) {         int remainderRead = readRemainder(b, off + read, len - read).         if (remainderRead > 0) {             read += remainderRead.         }     }     if (this.position >= this.headerLength) {         this.headerStream = null.     }     return read. }
false;public;0;3;;public boolean hasZipHeader() {     return Arrays.equals(this.header, ZIP_HEADER). }
false;private;3;7;;private int readRemainder(byte[] b, int off, int len) throws IOException {     int read = super.read(b, off, len).     if (read > 0) {         this.position += read.     }     return read. }
false;private;1;8;;private void load(InputStream inputStream) throws IOException {     byte[] buffer = new byte[BUFFER_SIZE].     int bytesRead.     while ((bytesRead = inputStream.read(buffer)) != -1) {         this.crc.update(buffer, 0, bytesRead).         this.size += bytesRead.     } }
false;public;1;6;;public void setupStoredEntry(JarArchiveEntry entry) {     entry.setSize(this.size).     entry.setCompressedSize(this.size).     entry.setCrc(this.crc.getValue()).     entry.setMethod(ZipEntry.STORED). }
false;;1;1;;JarArchiveEntry transform(JarArchiveEntry jarEntry).
false;public;1;4;;@Override public JarArchiveEntry transform(JarArchiveEntry jarEntry) {     return jarEntry. }
false;;1;1;;boolean requiresUnpack(String name).
false;;1;1;;String sha1Hash(String name) throws IOException.
false;public;1;4;;@Override public boolean requiresUnpack(String name) {     return false. }
false;public;1;4;;@Override public String sha1Hash(String name) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public boolean requiresUnpack(String name) {     return this.library.isUnpackRequired(). }
false;public;1;4;;@Override public String sha1Hash(String name) throws IOException {     return FileUtils.sha1Hash(this.library.getFile()). }
