commented;modifiers;parameterAmount;loc;comment;code
false;;5;32;;void load(byte[] data, int dataOffset, RandomAccessData variableData, int variableOffset, JarEntryFilter filter) throws IOException {     // Load fixed part     this.header = data.     this.headerOffset = dataOffset.     long nameLength = Bytes.littleEndianValue(data, dataOffset + 28, 2).     long extraLength = Bytes.littleEndianValue(data, dataOffset + 30, 2).     long commentLength = Bytes.littleEndianValue(data, dataOffset + 32, 2).     this.localHeaderOffset = Bytes.littleEndianValue(data, dataOffset + 42, 4).     // Load variable part     dataOffset += 46.     if (variableData != null) {         data = variableData.read(variableOffset + 46, nameLength + extraLength + commentLength).         dataOffset = 0.     }     this.name = new AsciiBytes(data, dataOffset, (int) nameLength).     if (filter != null) {         this.name = filter.apply(this.name).     }     this.extra = NO_EXTRA.     this.comment = NO_COMMENT.     if (extraLength > 0) {         this.extra = new byte[(int) extraLength].         System.arraycopy(data, (int) (dataOffset + nameLength), this.extra, 0, this.extra.length).     }     if (commentLength > 0) {         this.comment = new AsciiBytes(data, (int) (dataOffset + nameLength + extraLength), (int) commentLength).     } }
false;public;0;3;;public AsciiBytes getName() {     return this.name. }
false;public;2;4;;@Override public boolean hasName(CharSequence name, char suffix) {     return this.name.matches(name, suffix). }
false;public;0;3;;public boolean isDirectory() {     return this.name.endsWith(SLASH). }
false;public;0;4;;@Override public int getMethod() {     return (int) Bytes.littleEndianValue(this.header, this.headerOffset + 10, 2). }
false;public;0;4;;public long getTime() {     long datetime = Bytes.littleEndianValue(this.header, this.headerOffset + 12, 4).     return decodeMsDosFormatDateTime(datetime). }
true;private;1;8;/**  * Decode MS-DOS Date Time details. See  * <a href="http://mindprod.com/jgloss/zip.html">mindprod.com/jgloss/zip.html</a> for  * more details of the format.  * @param datetime the date and time  * @return the date and time as milliseconds since the epoch  */ ;/**  * Decode MS-DOS Date Time details. See  * <a href="http://mindprod.com/jgloss/zip.html">mindprod.com/jgloss/zip.html</a> for  * more details of the format.  * @param datetime the date and time  * @return the date and time as milliseconds since the epoch  */ private long decodeMsDosFormatDateTime(long datetime) {     LocalDateTime localDateTime = LocalDateTime.of((int) (((datetime >> 25) & 0x7f) + 1980), (int) ((datetime >> 21) & 0x0f), (int) ((datetime >> 16) & 0x1f), (int) ((datetime >> 11) & 0x1f), (int) ((datetime >> 5) & 0x3f), (int) ((datetime << 1) & 0x3e)).     return localDateTime.toEpochSecond(ZoneId.systemDefault().getRules().getOffset(localDateTime)) * 1000. }
false;public;0;3;;public long getCrc() {     return Bytes.littleEndianValue(this.header, this.headerOffset + 16, 4). }
false;public;0;4;;@Override public long getCompressedSize() {     return Bytes.littleEndianValue(this.header, this.headerOffset + 20, 4). }
false;public;0;4;;@Override public long getSize() {     return Bytes.littleEndianValue(this.header, this.headerOffset + 24, 4). }
false;public;0;3;;public byte[] getExtra() {     return this.extra. }
false;public;0;3;;public AsciiBytes getComment() {     return this.comment. }
false;public;0;4;;@Override public long getLocalHeaderOffset() {     return this.localHeaderOffset. }
false;public;0;7;;@Override public CentralDirectoryFileHeader clone() {     byte[] header = new byte[46].     System.arraycopy(this.header, this.headerOffset, header, 0, header.length).     return new CentralDirectoryFileHeader(header, 0, this.name, header, this.comment, this.localHeaderOffset). }
false;public,static;3;7;;public static CentralDirectoryFileHeader fromRandomAccessData(RandomAccessData data, int offset, JarEntryFilter filter) throws IOException {     CentralDirectoryFileHeader fileHeader = new CentralDirectoryFileHeader().     byte[] bytes = data.read(offset, 46).     fileHeader.load(bytes, 0, data, offset, filter).     return fileHeader. }
