commented;modifiers;parameterAmount;loc;comment;code
false;private;2;5;;private byte[] createBlockFromEndOfData(RandomAccessData data, int size) throws IOException {     int length = (int) Math.min(data.getSize(), size).     return data.read(data.getSize() - length, length). }
false;private;0;10;;private boolean isValid() {     if (this.block.length < MINIMUM_SIZE || Bytes.littleEndianValue(this.block, this.offset + 0, 4) != SIGNATURE) {         return false.     }     // Total size must be the structure size + comment     long commentLength = Bytes.littleEndianValue(this.block, this.offset + COMMENT_LENGTH_OFFSET, 2).     return this.size == MINIMUM_SIZE + commentLength. }
true;public;1;6;/**  * Returns the location in the data that the archive actually starts. For most files  * the archive data will start at 0, however, it is possible to have prefixed bytes  * (often used for startup scripts) at the beginning of the data.  * @param data the source data  * @return the offset within the data where the archive begins  */ ;/**  * Returns the location in the data that the archive actually starts. For most files  * the archive data will start at 0, however, it is possible to have prefixed bytes  * (often used for startup scripts) at the beginning of the data.  * @param data the source data  * @return the offset within the data where the archive begins  */ public long getStartOfArchive(RandomAccessData data) {     long length = Bytes.littleEndianValue(this.block, this.offset + 12, 4).     long specifiedOffset = Bytes.littleEndianValue(this.block, this.offset + 16, 4).     long actualOffset = data.getSize() - this.size - length.     return actualOffset - specifiedOffset. }
true;public;1;5;/**  * Return the bytes of the "Central directory" based on the offset indicated in this  * record.  * @param data the source data  * @return the central directory data  */ ;/**  * Return the bytes of the "Central directory" based on the offset indicated in this  * record.  * @param data the source data  * @return the central directory data  */ public RandomAccessData getCentralDirectory(RandomAccessData data) {     long offset = Bytes.littleEndianValue(this.block, this.offset + 16, 4).     long length = Bytes.littleEndianValue(this.block, this.offset + 12, 4).     return data.getSubsection(offset, length). }
true;public;0;7;/**  * Return the number of ZIP entries in the file.  * @return the number of records in the zip  */ ;/**  * Return the number of ZIP entries in the file.  * @return the number of records in the zip  */ public int getNumberOfRecords() {     long numberOfRecords = Bytes.littleEndianValue(this.block, this.offset + 10, 2).     if (numberOfRecords == 0xFFFF) {         throw new IllegalStateException("Zip64 archives are not supported").     }     return (int) numberOfRecords. }
