commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;12;;@Override protected URLConnection openConnection(URL url) throws IOException {     if (this.jarFile != null && isUrlInJarFile(url, this.jarFile)) {         return JarURLConnection.get(url, this.jarFile).     }     try {         return JarURLConnection.get(url, getRootJarFileFromUrl(url)).     } catch (Exception ex) {         return openFallbackConnection(url, ex).     } }
false;private;2;6;;private boolean isUrlInJarFile(URL url, JarFile jarFile) throws MalformedURLException {     // Try the path first to save building a new url string each time     return url.getPath().startsWith(jarFile.getUrl().getPath()) && url.toString().startsWith(jarFile.getUrlString()). }
false;private;2;17;;private URLConnection openFallbackConnection(URL url, Exception reason) throws IOException {     try {         return openConnection(getFallbackHandler(), url).     } catch (Exception ex) {         if (reason instanceof IOException) {             log(false, "Unable to open fallback handler", ex).             throw (IOException) reason.         }         log(true, "Unable to open fallback handler", ex).         if (reason instanceof RuntimeException) {             throw (RuntimeException) reason.         }         throw new IllegalStateException(reason).     } }
false;private;3;11;;private void log(boolean warning, String message, Exception cause) {     try {         Level level = warning ? Level.WARNING : Level.FINEST.         Logger.getLogger(getClass().getName()).log(level, message, cause).     } catch (Exception ex) {         if (warning) {             System.err.println("WARNING: " + message).         }     } }
false;private;0;16;;private URLStreamHandler getFallbackHandler() {     if (this.fallbackHandler != null) {         return this.fallbackHandler.     }     for (String handlerClassName : FALLBACK_HANDLERS) {         try {             Class<?> handlerClass = Class.forName(handlerClassName).             this.fallbackHandler = (URLStreamHandler) handlerClass.newInstance().             return this.fallbackHandler.         } catch (Exception ex) {         // Ignore         }     }     throw new IllegalStateException("Unable to find fallback handler"). }
false;private;2;4;;private URLConnection openConnection(URLStreamHandler handler, URL url) throws Exception {     return new URL(null, url.toExternalForm(), handler).openConnection(). }
false;protected;4;9;;@Override protected void parseURL(URL context, String spec, int start, int limit) {     if (spec.regionMatches(true, 0, JAR_PROTOCOL, 0, JAR_PROTOCOL.length())) {         setFile(context, getFileFromSpec(spec.substring(start, limit))).     } else {         setFile(context, getFileFromContext(context, spec.substring(start, limit))).     } }
false;private;1;13;;private String getFileFromSpec(String spec) {     int separatorIndex = spec.lastIndexOf("!/").     if (separatorIndex == -1) {         throw new IllegalArgumentException("No !/ in spec '" + spec + "'").     }     try {         new URL(spec.substring(0, separatorIndex)).         return spec.     } catch (MalformedURLException ex) {         throw new IllegalArgumentException("Invalid spec URL '" + spec + "'", ex).     } }
false;private;2;15;;private String getFileFromContext(URL context, String spec) {     String file = context.getFile().     if (spec.startsWith("/")) {         return trimToJarRoot(file) + SEPARATOR + spec.substring(1).     }     if (file.endsWith("/")) {         return file + spec.     }     int lastSlashIndex = file.lastIndexOf('/').     if (lastSlashIndex == -1) {         throw new IllegalArgumentException("No / found in context URL's file '" + file + "'").     }     return file.substring(0, lastSlashIndex + 1) + spec. }
false;private;1;8;;private String trimToJarRoot(String file) {     int lastSeparatorIndex = file.lastIndexOf(SEPARATOR).     if (lastSeparatorIndex == -1) {         throw new IllegalArgumentException("No !/ found in context URL's file '" + file + "'").     }     return file.substring(0, lastSeparatorIndex). }
false;private;2;11;;private void setFile(URL context, String file) {     String path = normalize(file).     String query = null.     int queryIndex = path.lastIndexOf('?').     if (queryIndex != -1) {         query = path.substring(queryIndex + 1).         path = path.substring(0, queryIndex).     }     setURL(context, JAR_PROTOCOL, null, -1, null, null, path, query, context.getRef()). }
false;private;1;10;;private String normalize(String file) {     if (!file.contains(CURRENT_DIR) && !file.contains(PARENT_DIR)) {         return file.     }     int afterLastSeparatorIndex = file.lastIndexOf(SEPARATOR) + SEPARATOR.length().     String afterSeparator = file.substring(afterLastSeparatorIndex).     afterSeparator = replaceParentDir(afterSeparator).     afterSeparator = replaceCurrentDir(afterSeparator).     return file.substring(0, afterLastSeparatorIndex) + afterSeparator. }
false;private;1;14;;private String replaceParentDir(String file) {     int parentDirIndex.     while ((parentDirIndex = file.indexOf(PARENT_DIR)) >= 0) {         int precedingSlashIndex = file.lastIndexOf('/', parentDirIndex - 1).         if (precedingSlashIndex >= 0) {             file = file.substring(0, precedingSlashIndex) + file.substring(parentDirIndex + 3).         } else {             file = file.substring(parentDirIndex + 4).         }     }     return file. }
false;private;1;3;;private String replaceCurrentDir(String file) {     return CURRENT_DIR_PATTERN.matcher(file).replaceAll("/"). }
false;protected;1;4;;@Override protected int hashCode(URL u) {     return hashCode(u.getProtocol(), u.getFile()). }
false;private;2;17;;private int hashCode(String protocol, String file) {     int result = (protocol != null) ? protocol.hashCode() : 0.     int separatorIndex = file.indexOf(SEPARATOR).     if (separatorIndex == -1) {         return result + file.hashCode().     }     String source = file.substring(0, separatorIndex).     String entry = canonicalize(file.substring(separatorIndex + 2)).     try {         result += new URL(source).hashCode().     } catch (MalformedURLException ex) {         result += source.hashCode().     }     result += entry.hashCode().     return result. }
false;protected;2;29;;@Override protected boolean sameFile(URL u1, URL u2) {     if (!u1.getProtocol().equals("jar") || !u2.getProtocol().equals("jar")) {         return false.     }     int separator1 = u1.getFile().indexOf(SEPARATOR).     int separator2 = u2.getFile().indexOf(SEPARATOR).     if (separator1 == -1 || separator2 == -1) {         return super.sameFile(u1, u2).     }     String nested1 = u1.getFile().substring(separator1 + SEPARATOR.length()).     String nested2 = u2.getFile().substring(separator2 + SEPARATOR.length()).     if (!nested1.equals(nested2)) {         String canonical1 = canonicalize(nested1).         String canonical2 = canonicalize(nested2).         if (!canonical1.equals(canonical2)) {             return false.         }     }     String root1 = u1.getFile().substring(0, separator1).     String root2 = u2.getFile().substring(0, separator2).     try {         return super.sameFile(new URL(root1), new URL(root2)).     } catch (MalformedURLException ex) {     // Continue     }     return super.sameFile(u1, u2). }
false;private;1;3;;private String canonicalize(String path) {     return path.replace(SEPARATOR, "/"). }
false;public;1;9;;public JarFile getRootJarFileFromUrl(URL url) throws IOException {     String spec = url.getFile().     int separatorIndex = spec.indexOf(SEPARATOR).     if (separatorIndex == -1) {         throw new MalformedURLException("Jar URL does not contain !/ separator").     }     String name = spec.substring(0, separatorIndex).     return getRootJarFile(name). }
false;private;1;19;;private JarFile getRootJarFile(String name) throws IOException {     try {         if (!name.startsWith(FILE_PROTOCOL)) {             throw new IllegalStateException("Not a file URL").         }         String path = name.substring(FILE_PROTOCOL.length()).         File file = new File(URLDecoder.decode(path, "UTF-8")).         Map<File, JarFile> cache = rootFileCache.get().         JarFile result = (cache != null) ? cache.get(file) : null.         if (result == null) {             result = new JarFile(file).             addToRootFileCache(file, result).         }         return result.     } catch (Exception ex) {         throw new IOException("Unable to open root Jar file '" + name + "'", ex).     } }
true;static;2;8;/**  * Add the given {@link JarFile} to the root file cache.  * @param sourceFile the source file to add  * @param jarFile the jar file.  */ ;/**  * Add the given {@link JarFile} to the root file cache.  * @param sourceFile the source file to add  * @param jarFile the jar file.  */ static void addToRootFileCache(File sourceFile, JarFile jarFile) {     Map<File, JarFile> cache = rootFileCache.get().     if (cache == null) {         cache = new ConcurrentHashMap<>().         rootFileCache = new SoftReference<>(cache).     }     cache.put(sourceFile, jarFile). }
true;public,static;1;4;/**  * Set if a generic static exception can be thrown when a URL cannot be connected.  * This optimization is used during class loading to save creating lots of exceptions  * which are then swallowed.  * @param useFastConnectionExceptions if fast connection exceptions can be used.  */ ;/**  * Set if a generic static exception can be thrown when a URL cannot be connected.  * This optimization is used during class loading to save creating lots of exceptions  * which are then swallowed.  * @param useFastConnectionExceptions if fast connection exceptions can be used.  */ public static void setUseFastConnectionExceptions(boolean useFastConnectionExceptions) {     JarURLConnection.setUseFastExceptions(useFastConnectionExceptions). }
