commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the underlying File.  * @return the underlying file  */ ;/**  * Returns the underlying File.  * @return the underlying file  */ public File getFile() {     return this.fileAccess.file. }
false;public;0;4;;@Override public InputStream getInputStream() throws IOException {     return new DataInputStream(). }
false;public;2;7;;@Override public RandomAccessData getSubsection(long offset, long length) {     if (offset < 0 || length < 0 || offset + length > this.length) {         throw new IndexOutOfBoundsException().     }     return new RandomAccessDataFile(this.fileAccess, this.offset + offset, length). }
false;public;0;4;;@Override public byte[] read() throws IOException {     return read(0, this.length). }
false;public;2;12;;@Override public byte[] read(long offset, long length) throws IOException {     if (offset > this.length) {         throw new IndexOutOfBoundsException().     }     if (offset + length > this.length) {         throw new EOFException().     }     byte[] bytes = new byte[(int) length].     read(bytes, offset, 0, bytes.length).     return bytes. }
false;private;1;6;;private int readByte(long position) throws IOException {     if (position >= this.length) {         return -1.     }     return this.fileAccess.readByte(this.offset + position). }
false;private;4;7;;private int read(byte[] bytes, long position, int offset, int length) throws IOException {     if (position > this.length) {         return -1.     }     return this.fileAccess.read(bytes, this.offset + position, offset, length). }
false;public;0;4;;@Override public long getSize() {     return this.length. }
false;public;0;3;;public void close() throws IOException {     this.fileAccess.close(). }
false;public;0;8;;@Override public int read() throws IOException {     int read = RandomAccessDataFile.this.readByte(this.position).     if (read > -1) {         moveOn(1).     }     return read. }
false;public;1;4;;@Override public int read(byte[] b) throws IOException {     return read(b, 0, (b != null) ? b.length : 0). }
false;public;3;7;;@Override public int read(byte[] b, int off, int len) throws IOException {     if (b == null) {         throw new NullPointerException("Bytes must not be null").     }     return doRead(b, off, len). }
true;public;3;11;/**  * Perform the actual read.  * @param b the bytes to read or {@code null} when reading a single byte  * @param off the offset of the byte array  * @param len the length of data to read  * @return the number of bytes read into {@code b} or the actual read byte if  * {@code b} is {@code null}. Returns -1 when the end of the stream is reached  * @throws IOException in case of I/O errors  */ ;/**  * Perform the actual read.  * @param b the bytes to read or {@code null} when reading a single byte  * @param off the offset of the byte array  * @param len the length of data to read  * @return the number of bytes read into {@code b} or the actual read byte if  * {@code b} is {@code null}. Returns -1 when the end of the stream is reached  * @throws IOException in case of I/O errors  */ public int doRead(byte[] b, int off, int len) throws IOException {     if (len == 0) {         return 0.     }     int cappedLen = cap(len).     if (cappedLen <= 0) {         return -1.     }     return (int) moveOn(RandomAccessDataFile.this.read(b, this.position, off, cappedLen)). }
false;public;1;4;;@Override public long skip(long n) throws IOException {     return (n <= 0) ? 0 : moveOn(cap(n)). }
true;private;1;3;/**  * Cap the specified value such that it cannot exceed the number of bytes  * remaining.  * @param n the value to cap  * @return the capped value  */ ;/**  * Cap the specified value such that it cannot exceed the number of bytes  * remaining.  * @param n the value to cap  * @return the capped value  */ private int cap(long n) {     return (int) Math.min(RandomAccessDataFile.this.length - this.position, n). }
true;private;1;4;/**  * Move the stream position forwards the specified amount.  * @param amount the amount to move  * @return the amount moved  */ ;/**  * Move the stream position forwards the specified amount.  * @param amount the amount to move  * @return the amount moved  */ private long moveOn(int amount) {     this.position += amount.     return amount. }
false;private;4;8;;private int read(byte[] bytes, long position, int offset, int length) throws IOException {     synchronized (this.monitor) {         openIfNecessary().         this.randomAccessFile.seek(position).         return this.randomAccessFile.read(bytes, offset, length).     } }
false;private;0;11;;private void openIfNecessary() {     if (this.randomAccessFile == null) {         try {             this.randomAccessFile = new RandomAccessFile(this.file, "r").         } catch (FileNotFoundException ex) {             throw new IllegalArgumentException(String.format("File %s must exist", this.file.getAbsolutePath())).         }     } }
false;private;0;8;;private void close() throws IOException {     synchronized (this.monitor) {         if (this.randomAccessFile != null) {             this.randomAccessFile.close().             this.randomAccessFile = null.         }     } }
false;private;1;7;;private int readByte(long position) throws IOException {     synchronized (this.monitor) {         openIfNecessary().         this.randomAccessFile.seek(position).         return this.randomAccessFile.read().     } }
