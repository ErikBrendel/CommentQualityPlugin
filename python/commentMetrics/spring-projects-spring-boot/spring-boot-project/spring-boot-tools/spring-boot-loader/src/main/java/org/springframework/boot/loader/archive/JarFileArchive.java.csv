commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public URL getUrl() throws MalformedURLException {     if (this.url != null) {         return this.url.     }     return this.jarFile.getUrl(). }
false;public;0;4;;@Override public Manifest getManifest() throws IOException {     return this.jarFile.getManifest(). }
false;public;1;10;;@Override public List<Archive> getNestedArchives(EntryFilter filter) throws IOException {     List<Archive> nestedArchives = new ArrayList<>().     for (Entry entry : this) {         if (filter.matches(entry)) {             nestedArchives.add(getNestedArchive(entry)).         }     }     return Collections.unmodifiableList(nestedArchives). }
false;public;0;4;;@Override public Iterator<Entry> iterator() {     return new EntryIterator(this.jarFile.entries()). }
false;protected;1;14;;protected Archive getNestedArchive(Entry entry) throws IOException {     JarEntry jarEntry = ((JarFileEntry) entry).getJarEntry().     if (jarEntry.getComment().startsWith(UNPACK_MARKER)) {         return getUnpackedNestedArchive(jarEntry).     }     try {         JarFile jarFile = this.jarFile.getNestedJarFile(jarEntry).         return new JarFileArchive(jarFile).     } catch (Exception ex) {         throw new IllegalStateException("Failed to get nested archive for entry " + entry.getName(), ex).     } }
false;private;1;11;;private Archive getUnpackedNestedArchive(JarEntry jarEntry) throws IOException {     String name = jarEntry.getName().     if (name.lastIndexOf('/') != -1) {         name = name.substring(name.lastIndexOf('/') + 1).     }     File file = new File(getTempUnpackFolder(), name).     if (!file.exists() || file.length() != jarEntry.getSize()) {         unpack(jarEntry, file).     }     return new JarFileArchive(file, file.toURI().toURL()). }
false;private;0;7;;private File getTempUnpackFolder() {     if (this.tempUnpackFolder == null) {         File tempFolder = new File(System.getProperty("java.io.tmpdir")).         this.tempUnpackFolder = createUnpackFolder(tempFolder).     }     return this.tempUnpackFolder. }
false;private;1;13;;private File createUnpackFolder(File parent) {     int attempts = 0.     while (attempts++ < 1000) {         String fileName = new File(this.jarFile.getName()).getName().         File unpackFolder = new File(parent, fileName + "-spring-boot-libs-" + UUID.randomUUID()).         if (unpackFolder.mkdirs()) {             return unpackFolder.         }     }     throw new IllegalStateException("Failed to create unpack folder in directory '" + parent + "'"). }
false;private;2;11;;private void unpack(JarEntry entry, File file) throws IOException {     try (InputStream inputStream = this.jarFile.getInputStream(entry).         OutputStream outputStream = new FileOutputStream(file)) {         byte[] buffer = new byte[BUFFER_SIZE].         int bytesRead.         while ((bytesRead = inputStream.read(buffer)) != -1) {             outputStream.write(buffer, 0, bytesRead).         }         outputStream.flush().     } }
false;public;0;9;;@Override public String toString() {     try {         return getUrl().toString().     } catch (Exception ex) {         return "jar archive".     } }
false;public;0;4;;@Override public boolean hasNext() {     return this.enumeration.hasMoreElements(). }
false;public;0;4;;@Override public Entry next() {     return new JarFileEntry(this.enumeration.nextElement()). }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException("remove"). }
false;public;0;3;;public JarEntry getJarEntry() {     return this.jarEntry. }
false;public;0;4;;@Override public boolean isDirectory() {     return this.jarEntry.isDirectory(). }
false;public;0;4;;@Override public String getName() {     return this.jarEntry.getName(). }
