commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData) { }
false;public;2;9;;@Override public void visitFileHeader(CentralDirectoryFileHeader fileHeader, int dataOffset) {     AsciiBytes name = fileHeader.getName().     if (name.startsWith(META_INF) && name.endsWith(SIGNATURE_FILE_EXTENSION)) {         JarFile.this.signed = true.     } }
false;public;0;3;;@Override public void visitEnd() { }
false;private;0;24;;private CentralDirectoryVisitor centralDirectoryVisitor() {     return new CentralDirectoryVisitor() {          @Override         public void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData) {         }          @Override         public void visitFileHeader(CentralDirectoryFileHeader fileHeader, int dataOffset) {             AsciiBytes name = fileHeader.getName().             if (name.startsWith(META_INF) && name.endsWith(SIGNATURE_FILE_EXTENSION)) {                 JarFile.this.signed = true.             }         }          @Override         public void visitEnd() {         }     }. }
false;protected,final;0;3;;protected final RandomAccessDataFile getRootJarFile() {     return this.rootFile. }
false;;0;3;;RandomAccessData getData() {     return this.data. }
false;public;0;14;;@Override public Manifest getManifest() throws IOException {     Manifest manifest = (this.manifest != null) ? this.manifest.get() : null.     if (manifest == null) {         try {             manifest = this.manifestSupplier.get().         } catch (RuntimeException ex) {             throw new IOException(ex).         }         this.manifest = new SoftReference<>(manifest).     }     return manifest. }
false;public;0;4;;@Override public boolean hasMoreElements() {     return iterator.hasNext(). }
false;public;0;4;;@Override public java.util.jar.JarEntry nextElement() {     return iterator.next(). }
false;public;0;17;;@Override public Enumeration<java.util.jar.JarEntry> entries() {     final Iterator<JarEntry> iterator = this.entries.iterator().     return new Enumeration<java.util.jar.JarEntry>() {          @Override         public boolean hasMoreElements() {             return iterator.hasNext().         }          @Override         public java.util.jar.JarEntry nextElement() {             return iterator.next().         }     }. }
false;public;1;3;;public JarEntry getJarEntry(CharSequence name) {     return this.entries.getEntry(name). }
false;public;1;4;;@Override public JarEntry getJarEntry(String name) {     return (JarEntry) getEntry(name). }
false;public;1;3;;public boolean containsEntry(String name) {     return this.entries.containsEntry(name). }
false;public;1;4;;@Override public ZipEntry getEntry(String name) {     return this.entries.getEntry(name). }
false;public,synchronized;1;7;;@Override public synchronized InputStream getInputStream(ZipEntry entry) throws IOException {     if (entry instanceof JarEntry) {         return this.entries.getInputStream((JarEntry) entry).     }     return getInputStream((entry != null) ? entry.getName() : null). }
false;;1;3;;InputStream getInputStream(String name) throws IOException {     return this.entries.getInputStream(name). }
true;public,synchronized;1;3;/**  * Return a nested {@link JarFile} loaded from the specified entry.  * @param entry the zip entry  * @return a {@link JarFile} for the entry  * @throws IOException if the nested jar file cannot be read  */ ;/**  * Return a nested {@link JarFile} loaded from the specified entry.  * @param entry the zip entry  * @return a {@link JarFile} for the entry  * @throws IOException if the nested jar file cannot be read  */ public synchronized JarFile getNestedJarFile(ZipEntry entry) throws IOException {     return getNestedJarFile((JarEntry) entry). }
true;public,synchronized;1;9;/**  * Return a nested {@link JarFile} loaded from the specified entry.  * @param entry the zip entry  * @return a {@link JarFile} for the entry  * @throws IOException if the nested jar file cannot be read  */ ;/**  * Return a nested {@link JarFile} loaded from the specified entry.  * @param entry the zip entry  * @return a {@link JarFile} for the entry  * @throws IOException if the nested jar file cannot be read  */ public synchronized JarFile getNestedJarFile(JarEntry entry) throws IOException {     try {         return createJarFileFromEntry(entry).     } catch (Exception ex) {         throw new IOException("Unable to open nested jar file '" + entry.getName() + "'", ex).     } }
false;private;1;6;;private JarFile createJarFileFromEntry(JarEntry entry) throws IOException {     if (entry.isDirectory()) {         return createJarFileFromDirectoryEntry(entry).     }     return createJarFileFromFileEntry(entry). }
false;private;1;13;;private JarFile createJarFileFromDirectoryEntry(JarEntry entry) throws IOException {     AsciiBytes name = entry.getAsciiBytesName().     JarEntryFilter filter = (candidate) -> {         if (candidate.startsWith(name) && !candidate.equals(name)) {             return candidate.substring(name.length()).         }         return null.     }.     return new JarFile(this.rootFile, this.pathFromRoot + "!/" + entry.getName().substring(0, name.length() - 1), this.data, filter, JarFileType.NESTED_DIRECTORY, this.manifestSupplier). }
false;private;1;11;;private JarFile createJarFileFromFileEntry(JarEntry entry) throws IOException {     if (entry.getMethod() != ZipEntry.STORED) {         throw new IllegalStateException("Unable to open nested entry '" + entry.getName() + "'. It has been compressed and nested " + "jar files must be stored without compression. Please check the " + "mechanism used to create your executable jar file").     }     RandomAccessData entryData = this.entries.getEntryData(entry.getName()).     return new JarFile(this.rootFile, this.pathFromRoot + "!/" + entry.getName(), entryData, JarFileType.NESTED_JAR). }
false;public;0;4;;@Override public int size() {     return this.entries.getSize(). }
false;public;0;7;;@Override public void close() throws IOException {     super.close().     if (this.type == JarFileType.DIRECT) {         this.rootFile.close().     } }
false;;0;6;;String getUrlString() throws MalformedURLException {     if (this.urlString == null) {         this.urlString = getUrl().toString().     }     return this.urlString. }
true;public;0;9;/**  * Return a URL that can be used to access this JAR file. NOTE: the specified URL  * cannot be serialized and or cloned.  * @return the URL  * @throws MalformedURLException if the URL is malformed  */ ;/**  * Return a URL that can be used to access this JAR file. NOTE: the specified URL  * cannot be serialized and or cloned.  * @return the URL  * @throws MalformedURLException if the URL is malformed  */ public URL getUrl() throws MalformedURLException {     if (this.url == null) {         Handler handler = new Handler(this).         String file = this.rootFile.getFile().toURI() + this.pathFromRoot + "!/".         // Fix UNC paths         file = file.replace("file:////", "file://").         this.url = new URL("jar", "", -1, file, handler).     }     return this.url. }
false;public;0;4;;@Override public String toString() {     return getName(). }
false;public;0;4;;@Override public String getName() {     return this.rootFile.getFile() + this.pathFromRoot. }
false;;0;3;;boolean isSigned() {     return this.signed. }
false;;1;21;;void setupEntryCertificates(JarEntry entry) {     // happening that often.     try {         try (JarInputStream inputStream = new JarInputStream(getData().getInputStream())) {             java.util.jar.JarEntry certEntry = inputStream.getNextJarEntry().             while (certEntry != null) {                 inputStream.closeEntry().                 if (entry.getName().equals(certEntry.getName())) {                     setCertificates(entry, certEntry).                 }                 setCertificates(getJarEntry(certEntry.getName()), certEntry).                 certEntry = inputStream.getNextJarEntry().             }         }     } catch (IOException ex) {         throw new IllegalStateException(ex).     } }
false;private;2;5;;private void setCertificates(JarEntry entry, java.util.jar.JarEntry certEntry) {     if (entry != null) {         entry.setCertificates(certEntry).     } }
false;public;0;3;;public void clearCache() {     this.entries.clearCache(). }
false;protected;0;3;;protected String getPathFromRoot() {     return this.pathFromRoot. }
false;;0;3;;JarFileType getType() {     return this.type. }
true;public,static;0;6;/**  * Register a {@literal 'java.protocol.handler.pkgs'} property so that a  * {@link URLStreamHandler} will be located to deal with jar URLs.  */ ;/**  * Register a {@literal 'java.protocol.handler.pkgs'} property so that a  * {@link URLStreamHandler} will be located to deal with jar URLs.  */ public static void registerUrlProtocolHandler() {     String handlers = System.getProperty(PROTOCOL_HANDLER, "").     System.setProperty(PROTOCOL_HANDLER, ("".equals(handlers) ? HANDLERS_PACKAGE : handlers + "|" + HANDLERS_PACKAGE)).     resetCachedUrlHandlers(). }
true;private,static;0;8;/**  * Reset any cached handlers just in case a jar protocol has already been used. We  * reset the handler by trying to set a null {@link URLStreamHandlerFactory} which  * should have no effect other than clearing the handlers cache.  */ ;/**  * Reset any cached handlers just in case a jar protocol has already been used. We  * reset the handler by trying to set a null {@link URLStreamHandlerFactory} which  * should have no effect other than clearing the handlers cache.  */ private static void resetCachedUrlHandlers() {     try {         URL.setURLStreamHandlerFactory(null).     } catch (Error ex) {     // Ignore     } }
