commented;modifiers;parameterAmount;loc;comment;code
false;protected,final;0;3;;protected final Archive getArchive() {     return this.archive. }
false;protected;0;13;;@Override protected String getMainClass() throws Exception {     Manifest manifest = this.archive.getManifest().     String mainClass = null.     if (manifest != null) {         mainClass = manifest.getMainAttributes().getValue("Start-Class").     }     if (mainClass == null) {         throw new IllegalStateException("No 'Start-Class' manifest entry specified in " + this).     }     return mainClass. }
false;protected;0;7;;@Override protected List<Archive> getClassPathArchives() throws Exception {     List<Archive> archives = new ArrayList<>(this.archive.getNestedArchives(this::isNestedArchive)).     postProcessClassPathArchives(archives).     return archives. }
true;protected,abstract;1;1;/**  * Determine if the specified {@link JarEntry} is a nested item that should be added  * to the classpath. The method is called once for each entry.  * @param entry the jar entry  * @return {@code true} if the entry is a nested item (jar or folder)  */ ;/**  * Determine if the specified {@link JarEntry} is a nested item that should be added  * to the classpath. The method is called once for each entry.  * @param entry the jar entry  * @return {@code true} if the entry is a nested item (jar or folder)  */ protected abstract boolean isNestedArchive(Archive.Entry entry).
true;protected;1;2;/**  * Called to post-process archive entries before they are used. Implementations can  * add and remove entries.  * @param archives the archives  * @throws Exception if the post processing fails  */ ;/**  * Called to post-process archive entries before they are used. Implementations can  * add and remove entries.  * @param archives the archives  * @throws Exception if the post processing fails  */ protected void postProcessClassPathArchives(List<Archive> archives) throws Exception { }
