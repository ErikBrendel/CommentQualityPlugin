commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public int length() {     return this.length. }
false;public;1;14;;public boolean startsWith(AsciiBytes prefix) {     if (this == prefix) {         return true.     }     if (prefix.length > this.length) {         return false.     }     for (int i = 0. i < prefix.length. i++) {         if (this.bytes[i + this.offset] != prefix.bytes[i + prefix.offset]) {             return false.         }     }     return true. }
false;public;1;15;;public boolean endsWith(AsciiBytes postfix) {     if (this == postfix) {         return true.     }     if (postfix.length > this.length) {         return false.     }     for (int i = 0. i < postfix.length. i++) {         if (this.bytes[this.offset + (this.length - 1) - i] != postfix.bytes[postfix.offset + (postfix.length - 1) - i]) {             return false.         }     }     return true. }
false;public;1;3;;public AsciiBytes substring(int beginIndex) {     return substring(beginIndex, this.length). }
false;public;2;7;;public AsciiBytes substring(int beginIndex, int endIndex) {     int length = endIndex - beginIndex.     if (this.offset + length > this.bytes.length) {         throw new IndexOutOfBoundsException().     }     return new AsciiBytes(this.bytes, this.offset + beginIndex, length). }
false;public;2;29;;public boolean matches(CharSequence name, char suffix) {     int charIndex = 0.     int nameLen = name.length().     int totalLen = nameLen + ((suffix != 0) ? 1 : 0).     for (int i = this.offset. i < this.offset + this.length. i++) {         int b = this.bytes[i].         int remainingUtfBytes = getNumberOfUtfBytes(b) - 1.         b &= INITIAL_BYTE_BITMASK[remainingUtfBytes].         for (int j = 0. j < remainingUtfBytes. j++) {             b = (b << 6) + (this.bytes[++i] & SUBSEQUENT_BYTE_BITMASK).         }         char c = getChar(name, suffix, charIndex++).         if (b <= 0xFFFF) {             if (c != b) {                 return false.             }         } else {             if (c != ((b >> 0xA) + 0xD7C0)) {                 return false.             }             c = getChar(name, suffix, charIndex++).             if (c != ((b & 0x3FF) + 0xDC00)) {                 return false.             }         }     }     return charIndex == totalLen. }
false;private;3;9;;private char getChar(CharSequence name, char suffix, int index) {     if (index < name.length()) {         return name.charAt(index).     }     if (index == name.length()) {         return suffix.     }     return 0. }
false;private;1;11;;private int getNumberOfUtfBytes(int b) {     if ((b & 0x80) == 0) {         return 1.     }     int numberOfUtfBytes = 0.     while ((b & 0x80) != 0) {         b <<= 1.         numberOfUtfBytes++.     }     return numberOfUtfBytes. }
false;public;1;21;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (this == obj) {         return true.     }     if (obj.getClass() == AsciiBytes.class) {         AsciiBytes other = (AsciiBytes) obj.         if (this.length == other.length) {             for (int i = 0. i < this.length. i++) {                 if (this.bytes[this.offset + i] != other.bytes[other.offset + i]) {                     return false.                 }             }             return true.         }     }     return false. }
false;public;0;23;;@Override public int hashCode() {     int hash = this.hash.     if (hash == 0 && this.bytes.length > 0) {         for (int i = this.offset. i < this.offset + this.length. i++) {             int b = this.bytes[i].             int remainingUtfBytes = getNumberOfUtfBytes(b) - 1.             b &= INITIAL_BYTE_BITMASK[remainingUtfBytes].             for (int j = 0. j < remainingUtfBytes. j++) {                 b = (b << 6) + (this.bytes[++i] & SUBSEQUENT_BYTE_BITMASK).             }             if (b <= 0xFFFF) {                 hash = 31 * hash + b.             } else {                 hash = 31 * hash + ((b >> 0xA) + 0xD7C0).                 hash = 31 * hash + ((b & 0x3FF) + 0xDC00).             }         }         this.hash = hash.     }     return hash. }
false;public;0;13;;@Override public String toString() {     if (this.string == null) {         if (this.length == 0) {             this.string = EMPTY_STRING.         } else {             this.string = new String(this.bytes, this.offset, this.length, StandardCharsets.UTF_8).         }     }     return this.string. }
false;static;1;3;;static String toString(byte[] bytes) {     return new String(bytes, StandardCharsets.UTF_8). }
false;public,static;1;8;;public static int hashCode(CharSequence charSequence) {     // We're compatible with String's hashCode()     if (charSequence instanceof StringSequence) {         // ... but save making an unnecessary String for StringSequence         return charSequence.hashCode().     }     return charSequence.toString().hashCode(). }
false;public,static;2;3;;public static int hashCode(int hash, char suffix) {     return (suffix != 0) ? (31 * hash + suffix) : hash. }
