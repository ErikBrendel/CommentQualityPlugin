commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;6;/**  * Resolve ${...} placeholders in the given text, replacing them with corresponding  * system property values.  * @param text the String to resolve  * @return the resolved String  * @throws IllegalArgumentException if there is an unresolvable placeholder  * @see #PLACEHOLDER_PREFIX  * @see #PLACEHOLDER_SUFFIX  */ ;/**  * Resolve ${...} placeholders in the given text, replacing them with corresponding  * system property values.  * @param text the String to resolve  * @return the resolved String  * @throws IllegalArgumentException if there is an unresolvable placeholder  * @see #PLACEHOLDER_PREFIX  * @see #PLACEHOLDER_SUFFIX  */ public static String resolvePlaceholders(String text) {     if (text == null) {         return text.     }     return parseStringValue(null, text, text, new HashSet<>()). }
true;public,static;2;6;/**  * Resolve ${...} placeholders in the given text, replacing them with corresponding  * system property values.  * @param properties a properties instance to use in addition to System  * @param text the String to resolve  * @return the resolved String  * @throws IllegalArgumentException if there is an unresolvable placeholder  * @see #PLACEHOLDER_PREFIX  * @see #PLACEHOLDER_SUFFIX  */ ;/**  * Resolve ${...} placeholders in the given text, replacing them with corresponding  * system property values.  * @param properties a properties instance to use in addition to System  * @param text the String to resolve  * @return the resolved String  * @throws IllegalArgumentException if there is an unresolvable placeholder  * @see #PLACEHOLDER_PREFIX  * @see #PLACEHOLDER_SUFFIX  */ public static String resolvePlaceholders(Properties properties, String text) {     if (text == null) {         return text.     }     return parseStringValue(properties, text, text, new HashSet<>()). }
false;private,static;4;61;;private static String parseStringValue(Properties properties, String value, String current, Set<String> visitedPlaceholders) {     StringBuilder buf = new StringBuilder(current).     int startIndex = current.indexOf(PLACEHOLDER_PREFIX).     while (startIndex != -1) {         int endIndex = findPlaceholderEndIndex(buf, startIndex).         if (endIndex != -1) {             String placeholder = buf.substring(startIndex + PLACEHOLDER_PREFIX.length(), endIndex).             String originalPlaceholder = placeholder.             if (!visitedPlaceholders.add(originalPlaceholder)) {                 throw new IllegalArgumentException("Circular placeholder reference '" + originalPlaceholder + "' in property definitions").             }             // Recursive invocation, parsing placeholders contained in the             // placeholder             // key.             placeholder = parseStringValue(properties, value, placeholder, visitedPlaceholders).             // Now obtain the value for the fully resolved key...             String propVal = resolvePlaceholder(properties, value, placeholder).             if (propVal == null && VALUE_SEPARATOR != null) {                 int separatorIndex = placeholder.indexOf(VALUE_SEPARATOR).                 if (separatorIndex != -1) {                     String actualPlaceholder = placeholder.substring(0, separatorIndex).                     String defaultValue = placeholder.substring(separatorIndex + VALUE_SEPARATOR.length()).                     propVal = resolvePlaceholder(properties, value, actualPlaceholder).                     if (propVal == null) {                         propVal = defaultValue.                     }                 }             }             if (propVal != null) {                 // Recursive invocation, parsing placeholders contained in the                 // previously resolved placeholder value.                 propVal = parseStringValue(properties, value, propVal, visitedPlaceholders).                 buf.replace(startIndex, endIndex + PLACEHOLDER_SUFFIX.length(), propVal).                 startIndex = buf.indexOf(PLACEHOLDER_PREFIX, startIndex + propVal.length()).             } else {                 // Proceed with unprocessed value.                 startIndex = buf.indexOf(PLACEHOLDER_PREFIX, endIndex + PLACEHOLDER_SUFFIX.length()).             }             visitedPlaceholders.remove(originalPlaceholder).         } else {             startIndex = -1.         }     }     return buf.toString(). }
false;private,static;3;8;;private static String resolvePlaceholder(Properties properties, String text, String placeholderName) {     String propVal = getProperty(placeholderName, null, text).     if (propVal != null) {         return propVal.     }     return (properties != null) ? properties.getProperty(placeholderName) : null. }
false;public,static;1;3;;public static String getProperty(String key) {     return getProperty(key, null, ""). }
false;public,static;2;3;;public static String getProperty(String key, String defaultValue) {     return getProperty(key, defaultValue, ""). }
true;public,static;3;27;/**  * Search the System properties and environment variables for a value with the  * provided key. Environment variables in {@code UPPER_CASE} style are allowed where  * System properties would normally be {@code lower.case}.  * @param key the key to resolve  * @param defaultValue the default value  * @param text optional extra context for an error message if the key resolution fails  * (e.g. if System properties are not accessible)  * @return a static property value or null of not found  */ ;/**  * Search the System properties and environment variables for a value with the  * provided key. Environment variables in {@code UPPER_CASE} style are allowed where  * System properties would normally be {@code lower.case}.  * @param key the key to resolve  * @param defaultValue the default value  * @param text optional extra context for an error message if the key resolution fails  * (e.g. if System properties are not accessible)  * @return a static property value or null of not found  */ public static String getProperty(String key, String defaultValue, String text) {     try {         String propVal = System.getProperty(key).         if (propVal == null) {             // Fall back to searching the system environment.             propVal = System.getenv(key).         }         if (propVal == null) {             // Try with underscores.             String name = key.replace('.', '_').             propVal = System.getenv(name).         }         if (propVal == null) {             // Try uppercase with underscores as well.             String name = key.toUpperCase(Locale.ENGLISH).replace('.', '_').             propVal = System.getenv(name).         }         if (propVal != null) {             return propVal.         }     } catch (Throwable ex) {         System.err.println("Could not resolve key '" + key + "' in '" + text + "' as system property or in environment: " + ex).     }     return defaultValue. }
false;private,static;2;23;;private static int findPlaceholderEndIndex(CharSequence buf, int startIndex) {     int index = startIndex + PLACEHOLDER_PREFIX.length().     int withinNestedPlaceholder = 0.     while (index < buf.length()) {         if (substringMatch(buf, index, PLACEHOLDER_SUFFIX)) {             if (withinNestedPlaceholder > 0) {                 withinNestedPlaceholder--.                 index = index + PLACEHOLDER_SUFFIX.length().             } else {                 return index.             }         } else if (substringMatch(buf, index, SIMPLE_PREFIX)) {             withinNestedPlaceholder++.             index = index + SIMPLE_PREFIX.length().         } else {             index++.         }     }     return -1. }
false;private,static;3;10;;private static boolean substringMatch(CharSequence str, int index, CharSequence substring) {     for (int j = 0. j < substring.length(). j++) {         int i = index + j.         if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {             return false.         }     }     return true. }
