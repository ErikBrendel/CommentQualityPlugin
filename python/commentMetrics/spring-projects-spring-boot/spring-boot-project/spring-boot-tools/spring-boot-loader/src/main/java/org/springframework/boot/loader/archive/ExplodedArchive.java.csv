commented;modifiers;parameterAmount;loc;comment;code
false;private;1;4;;private File getManifestFile(File root) {     File metaInf = new File(root, "META-INF").     return new File(metaInf, "MANIFEST.MF"). }
false;public;0;4;;@Override public URL getUrl() throws MalformedURLException {     return this.root.toURI().toURL(). }
false;public;0;9;;@Override public Manifest getManifest() throws IOException {     if (this.manifest == null && this.manifestFile.exists()) {         try (FileInputStream inputStream = new FileInputStream(this.manifestFile)) {             this.manifest = new Manifest(inputStream).         }     }     return this.manifest. }
false;public;1;10;;@Override public List<Archive> getNestedArchives(EntryFilter filter) throws IOException {     List<Archive> nestedArchives = new ArrayList<>().     for (Entry entry : this) {         if (filter.matches(entry)) {             nestedArchives.add(getNestedArchive(entry)).         }     }     return Collections.unmodifiableList(nestedArchives). }
false;public;0;4;;@Override public Iterator<Entry> iterator() {     return new FileEntryIterator(this.root, this.recursive). }
false;protected;1;5;;protected Archive getNestedArchive(Entry entry) throws IOException {     File file = ((FileEntry) entry).getFile().     return (file.isDirectory() ? new ExplodedArchive(file) : new JarFileArchive(file)). }
false;public;0;9;;@Override public String toString() {     try {         return getUrl().toString().     } catch (Exception ex) {         return "exploded archive".     } }
false;public;0;4;;@Override public boolean hasNext() {     return this.current != null. }
false;public;0;15;;@Override public Entry next() {     if (this.current == null) {         throw new NoSuchElementException().     }     File file = this.current.     if (file.isDirectory() && (this.recursive || file.getParentFile().equals(this.root))) {         this.stack.addFirst(listFiles(file)).     }     this.current = poll().     String name = file.toURI().getPath().substring(this.root.toURI().getPath().length()).     return new FileEntry(name, file). }
false;private;1;8;;private Iterator<File> listFiles(File file) {     File[] files = file.listFiles().     if (files == null) {         return Collections.<File>emptyList().iterator().     }     Arrays.sort(files, this.entryComparator).     return Arrays.asList(files).iterator(). }
false;private;0;12;;private File poll() {     while (!this.stack.isEmpty()) {         while (this.stack.peek().hasNext()) {             File file = this.stack.peek().next().             if (!SKIPPED_NAMES.contains(file.getName())) {                 return file.             }         }         this.stack.poll().     }     return null. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException("remove"). }
false;public;2;4;;@Override public int compare(File o1, File o2) {     return o1.getAbsolutePath().compareTo(o2.getAbsolutePath()). }
false;public;0;3;;public File getFile() {     return this.file. }
false;public;0;4;;@Override public boolean isDirectory() {     return this.file.isDirectory(). }
false;public;0;4;;@Override public String getName() {     return this.name. }
