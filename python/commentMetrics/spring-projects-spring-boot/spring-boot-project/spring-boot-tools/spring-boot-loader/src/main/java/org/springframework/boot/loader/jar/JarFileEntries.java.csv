commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;8;;@Override protected boolean removeEldestEntry(Map.Entry<Integer, FileHeader> eldest) {     if (JarFileEntries.this.jarFile.isSigned()) {         return false.     }     return size() >= ENTRY_CACHE_SIZE. }
false;public;2;9;;@Override public void visitStart(CentralDirectoryEndRecord endRecord, RandomAccessData centralDirectoryData) {     int maxSize = endRecord.getNumberOfRecords().     this.centralDirectoryData = centralDirectoryData.     this.hashCodes = new int[maxSize].     this.centralDirectoryOffsets = new int[maxSize].     this.positions = new int[maxSize]. }
false;public;2;7;;@Override public void visitFileHeader(CentralDirectoryFileHeader fileHeader, int dataOffset) {     AsciiBytes name = applyFilter(fileHeader.getName()).     if (name != null) {         add(name, dataOffset).     } }
false;private;2;6;;private void add(AsciiBytes name, int dataOffset) {     this.hashCodes[this.size] = name.hashCode().     this.centralDirectoryOffsets[this.size] = dataOffset.     this.positions[this.size] = this.size.     this.size++. }
false;public;0;9;;@Override public void visitEnd() {     sort(0, this.size - 1).     int[] positions = this.positions.     this.positions = new int[positions.length].     for (int i = 0. i < this.size. i++) {         this.positions[positions[i]] = i.     } }
false;;0;3;;int getSize() {     return this.size. }
false;private;2;27;;private void sort(int left, int right) {     // Quick sort algorithm, uses hashCodes as the source but sorts all arrays     if (left < right) {         int pivot = this.hashCodes[left + (right - left) / 2].         int i = left.         int j = right.         while (i <= j) {             while (this.hashCodes[i] < pivot) {                 i++.             }             while (this.hashCodes[j] > pivot) {                 j--.             }             if (i <= j) {                 swap(i, j).                 i++.                 j--.             }         }         if (left < j) {             sort(left, j).         }         if (right > i) {             sort(i, right).         }     } }
false;private;2;5;;private void swap(int i, int j) {     swap(this.hashCodes, i, j).     swap(this.centralDirectoryOffsets, i, j).     swap(this.positions, i, j). }
false;private;3;5;;private void swap(int[] array, int i, int j) {     int temp = array[i].     array[i] = array[j].     array[j] = temp. }
false;public;0;4;;@Override public Iterator<JarEntry> iterator() {     return new EntryIterator(). }
false;public;1;3;;public boolean containsEntry(CharSequence name) {     return getEntry(name, FileHeader.class, true) != null. }
false;public;1;3;;public JarEntry getEntry(CharSequence name) {     return getEntry(name, JarEntry.class, true). }
false;public;1;4;;public InputStream getInputStream(String name) throws IOException {     FileHeader entry = getEntry(name, FileHeader.class, false).     return getInputStream(entry). }
false;public;1;10;;public InputStream getInputStream(FileHeader entry) throws IOException {     if (entry == null) {         return null.     }     InputStream inputStream = getEntryData(entry).getInputStream().     if (entry.getMethod() == ZipEntry.DEFLATED) {         inputStream = new ZipInflaterInputStream(inputStream, (int) entry.getSize()).     }     return inputStream. }
false;public;1;7;;public RandomAccessData getEntryData(String name) throws IOException {     FileHeader entry = getEntry(name, FileHeader.class, false).     if (entry == null) {         return null.     }     return getEntryData(entry). }
false;private;1;12;;private RandomAccessData getEntryData(FileHeader entry) throws IOException {     // aspectjrt-1.7.4.jar has a different ext bytes length in the     // local directory to the central directory. We need to re-read     // here to skip them     RandomAccessData data = this.jarFile.getData().     byte[] localHeader = data.read(entry.getLocalHeaderOffset(), LOCAL_FILE_HEADER_SIZE).     long nameLength = Bytes.littleEndianValue(localHeader, 26, 2).     long extraLength = Bytes.littleEndianValue(localHeader, 28, 2).     return data.getSubsection(entry.getLocalHeaderOffset() + LOCAL_FILE_HEADER_SIZE + nameLength + extraLength, entry.getCompressedSize()). }
false;private;3;19;;private <T extends FileHeader> T getEntry(CharSequence name, Class<T> type, boolean cacheEntry) {     T entry = doGetEntry(name, type, cacheEntry, null).     if (!isMetaInfEntry(name) && isMultiReleaseJar()) {         int version = RUNTIME_VERSION.         AsciiBytes nameAlias = (entry instanceof JarEntry) ? ((JarEntry) entry).getAsciiBytesName() : new AsciiBytes(name.toString()).         while (version > BASE_VERSION) {             T versionedEntry = doGetEntry("META-INF/versions/" + version + "/" + name, type, cacheEntry, nameAlias).             if (versionedEntry != null) {                 return versionedEntry.             }             version--.         }     }     return entry. }
false;private;1;3;;private boolean isMetaInfEntry(CharSequence name) {     return name.toString().startsWith(META_INF_PREFIX). }
false;private;0;21;;private boolean isMultiReleaseJar() {     Boolean multiRelease = this.multiReleaseJar.     if (multiRelease != null) {         return multiRelease.     }     try {         Manifest manifest = this.jarFile.getManifest().         if (manifest == null) {             multiRelease = false.         } else {             Attributes attributes = manifest.getMainAttributes().             multiRelease = attributes.containsKey(MULTI_RELEASE).         }     } catch (IOException ex) {         multiRelease = false.     }     this.multiReleaseJar = multiRelease.     return multiRelease. }
false;private;4;10;;private <T extends FileHeader> T doGetEntry(CharSequence name, Class<T> type, boolean cacheEntry, AsciiBytes nameAlias) {     int hashCode = AsciiBytes.hashCode(name).     T entry = getEntry(hashCode, name, NO_SUFFIX, type, cacheEntry, nameAlias).     if (entry == null) {         hashCode = AsciiBytes.hashCode(hashCode, SLASH).         entry = getEntry(hashCode, name, SLASH, type, cacheEntry, nameAlias).     }     return entry. }
false;private;6;12;;private <T extends FileHeader> T getEntry(int hashCode, CharSequence name, char suffix, Class<T> type, boolean cacheEntry, AsciiBytes nameAlias) {     int index = getFirstIndex(hashCode).     while (index >= 0 && index < this.size && this.hashCodes[index] == hashCode) {         T entry = getEntry(index, type, cacheEntry, nameAlias).         if (entry.hasName(name, suffix)) {             return entry.         }         index++.     }     return null. }
false;private;4;23;;@SuppressWarnings("unchecked") private <T extends FileHeader> T getEntry(int index, Class<T> type, boolean cacheEntry, AsciiBytes nameAlias) {     try {         FileHeader cached = this.entriesCache.get(index).         FileHeader entry = (cached != null) ? cached : CentralDirectoryFileHeader.fromRandomAccessData(this.centralDirectoryData, this.centralDirectoryOffsets[index], this.filter).         if (CentralDirectoryFileHeader.class.equals(entry.getClass()) && type.equals(JarEntry.class)) {             entry = new JarEntry(this.jarFile, (CentralDirectoryFileHeader) entry, nameAlias).         }         if (cacheEntry && cached != entry) {             this.entriesCache.put(index, entry).         }         return (T) entry.     } catch (IOException ex) {         throw new IllegalStateException(ex).     } }
false;private;1;10;;private int getFirstIndex(int hashCode) {     int index = Arrays.binarySearch(this.hashCodes, 0, this.size, hashCode).     if (index < 0) {         return -1.     }     while (index > 0 && this.hashCodes[index - 1] == hashCode) {         index--.     }     return index. }
false;public;0;3;;public void clearCache() {     this.entriesCache.clear(). }
false;private;1;3;;private AsciiBytes applyFilter(AsciiBytes name) {     return (this.filter != null) ? this.filter.apply(name) : name. }
false;public;0;4;;@Override public boolean hasNext() {     return this.index < JarFileEntries.this.size. }
false;public;0;9;;@Override public JarEntry next() {     if (!hasNext()) {         throw new NoSuchElementException().     }     int entryIndex = JarFileEntries.this.positions[this.index].     this.index++.     return getEntry(entryIndex, JarEntry.class, false, null). }
