commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@Bean public static JsonMarshalTestersBeanPostProcessor jsonMarshalTestersBeanPostProcessor() {     return new JsonMarshalTestersBeanPostProcessor(). }
false;public;0;6;;@Bean @Scope("prototype") public FactoryBean<BasicJsonTester> basicJsonTesterFactoryBean() {     return new JsonTesterFactoryBean<BasicJsonTester, Void>(BasicJsonTester.class, null). }
false;public;1;7;;@Bean @Scope("prototype") @ConditionalOnBean(ObjectMapper.class) public FactoryBean<JacksonTester<?>> jacksonTesterFactoryBean(ObjectMapper mapper) {     return new JsonTesterFactoryBean<>(JacksonTester.class, mapper). }
false;public;1;6;;@Bean @Scope("prototype") @ConditionalOnBean(Gson.class) public FactoryBean<GsonTester<?>> gsonTesterFactoryBean(Gson gson) {     return new JsonTesterFactoryBean<>(GsonTester.class, gson). }
false;public;1;6;;@Bean @Scope("prototype") @ConditionalOnBean(Jsonb.class) public FactoryBean<JsonbTester<?>> jsonbTesterFactoryBean(Jsonb jsonb) {     return new JsonTesterFactoryBean<>(JsonbTester.class, jsonb). }
false;public;0;4;;@Override public boolean isSingleton() {     return false. }
false;public;0;20;;@Override @SuppressWarnings("unchecked") public T getObject() throws Exception {     if (this.marshaller == null) {         Constructor<?> constructor = this.objectType.getDeclaredConstructor().         ReflectionUtils.makeAccessible(constructor).         return (T) BeanUtils.instantiateClass(constructor).     }     Constructor<?>[] constructors = this.objectType.getDeclaredConstructors().     for (Constructor<?> constructor : constructors) {         if (constructor.getParameterCount() == 1 && constructor.getParameterTypes()[0].isInstance(this.marshaller)) {             ReflectionUtils.makeAccessible(constructor).             return (T) BeanUtils.instantiateClass(constructor, this.marshaller).         }     }     throw new IllegalStateException(this.objectType + " does not have a usable constructor"). }
false;public;0;4;;@Override public Class<?> getObjectType() {     return this.objectType. }
false;public;2;7;;@Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {     ReflectionUtils.doWithFields(bean.getClass(), (field) -> processField(bean, field)).     return bean. }
false;private;2;9;;private void processField(Object bean, Field field) {     if (AbstractJsonMarshalTester.class.isAssignableFrom(field.getType())) {         initializeTester(bean, field, bean.getClass(), ResolvableType.forField(field).getGeneric()).     } else if (BasicJsonTester.class.isAssignableFrom(field.getType())) {         initializeTester(bean, field, bean.getClass()).     } }
false;private;3;7;;private void initializeTester(Object bean, Field field, Object... args) {     ReflectionUtils.makeAccessible(field).     Object tester = ReflectionUtils.getField(field, bean).     if (tester != null) {         ReflectionTestUtils.invokeMethod(tester, "initialize", args).     } }
