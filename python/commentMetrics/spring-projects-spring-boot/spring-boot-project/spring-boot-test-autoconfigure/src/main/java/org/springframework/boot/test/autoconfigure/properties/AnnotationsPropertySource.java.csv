commented;modifiers;parameterAmount;loc;comment;code
false;private;1;5;;private Map<String, Object> getProperties(Class<?> source) {     Map<String, Object> properties = new LinkedHashMap<>().     collectProperties(source, source, properties, new HashSet<>()).     return Collections.unmodifiableMap(properties). }
false;private;4;18;;private void collectProperties(Class<?> root, Class<?> source, Map<String, Object> properties, Set<Class<?>> seen) {     if (source != null && seen.add(source)) {         for (Annotation annotation : getMergedAnnotations(root, source)) {             if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation)) {                 PropertyMapping typeMapping = annotation.annotationType().getAnnotation(PropertyMapping.class).                 for (Method attribute : annotation.annotationType().getDeclaredMethods()) {                     collectProperties(annotation, attribute, typeMapping, properties).                 }                 collectProperties(root, annotation.annotationType(), properties, seen).             }         }         collectProperties(root, source.getSuperclass(), properties, seen).     } }
false;private;2;16;;private List<Annotation> getMergedAnnotations(Class<?> root, Class<?> source) {     List<Annotation> mergedAnnotations = new ArrayList<>().     Annotation[] annotations = AnnotationUtils.getAnnotations(source).     if (annotations != null) {         for (Annotation annotation : annotations) {             if (!AnnotationUtils.isInJavaLangAnnotationPackage(annotation)) {                 Annotation mergedAnnotation = findMergedAnnotation(root, annotation.annotationType()).                 if (mergedAnnotation != null) {                     mergedAnnotations.add(mergedAnnotation).                 }             }         }     }     return mergedAnnotations. }
false;private;2;10;;private Annotation findMergedAnnotation(Class<?> source, Class<? extends Annotation> annotationType) {     if (source == null) {         return null.     }     Annotation mergedAnnotation = AnnotatedElementUtils.getMergedAnnotation(source, annotationType).     return (mergedAnnotation != null) ? mergedAnnotation : findMergedAnnotation(source.getSuperclass(), annotationType). }
false;private;4;20;;private void collectProperties(Annotation annotation, Method attribute, PropertyMapping typeMapping, Map<String, Object> properties) {     PropertyMapping attributeMapping = AnnotationUtils.getAnnotation(attribute, PropertyMapping.class).     SkipPropertyMapping skip = getMappingType(typeMapping, attributeMapping).     if (skip == SkipPropertyMapping.YES) {         return.     }     ReflectionUtils.makeAccessible(attribute).     Object value = ReflectionUtils.invokeMethod(attribute, annotation).     if (skip == SkipPropertyMapping.ON_DEFAULT_VALUE) {         Object defaultValue = AnnotationUtils.getDefaultValue(annotation, attribute.getName()).         if (ObjectUtils.nullSafeEquals(value, defaultValue)) {             return.         }     }     String name = getName(typeMapping, attributeMapping, attribute).     putProperties(name, value, properties). }
false;private;2;10;;private SkipPropertyMapping getMappingType(PropertyMapping typeMapping, PropertyMapping attributeMapping) {     if (attributeMapping != null) {         return attributeMapping.skip().     }     if (typeMapping != null) {         return typeMapping.skip().     }     return SkipPropertyMapping.YES. }
false;private;3;9;;private String getName(PropertyMapping typeMapping, PropertyMapping attributeMapping, Method attribute) {     String prefix = (typeMapping != null) ? typeMapping.value() : "".     String name = (attributeMapping != null) ? attributeMapping.value() : "".     if (!StringUtils.hasText(name)) {         name = toKebabCase(attribute.getName()).     }     return dotAppend(prefix, name). }
false;private;1;10;;private String toKebabCase(String name) {     Matcher matcher = CAMEL_CASE_PATTERN.matcher(name).     StringBuffer result = new StringBuffer().     while (matcher.find()) {         matcher.appendReplacement(result, matcher.group(1) + '-' + StringUtils.uncapitalize(matcher.group(2))).     }     matcher.appendTail(result).     return result.toString().toLowerCase(Locale.ENGLISH). }
false;private;2;6;;private String dotAppend(String prefix, String postfix) {     if (StringUtils.hasText(prefix)) {         return prefix.endsWith(".") ? prefix + postfix : prefix + "." + postfix.     }     return postfix. }
false;private;3;12;;private void putProperties(String name, Object value, Map<String, Object> properties) {     if (ObjectUtils.isArray(value)) {         Object[] array = ObjectUtils.toObjectArray(value).         for (int i = 0. i < array.length. i++) {             properties.put(name + "[" + i + "]", array[i]).         }     } else {         properties.put(name, value).     } }
false;public;1;4;;@Override public boolean containsProperty(String name) {     return this.properties.containsKey(name). }
false;public;1;4;;@Override public Object getProperty(String name) {     return this.properties.get(name). }
false;public;0;4;;@Override public String[] getPropertyNames() {     return StringUtils.toStringArray(this.properties.keySet()). }
false;public;0;3;;public boolean isEmpty() {     return this.properties.isEmpty(). }
false;public;1;10;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     return this.properties.equals(((AnnotationsPropertySource) obj).properties). }
false;public;0;4;;@Override public int hashCode() {     return this.properties.hashCode(). }
