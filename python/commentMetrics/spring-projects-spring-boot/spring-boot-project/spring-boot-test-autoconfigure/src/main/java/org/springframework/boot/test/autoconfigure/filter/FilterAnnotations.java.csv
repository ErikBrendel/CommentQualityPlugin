commented;modifiers;parameterAmount;loc;comment;code
false;private;1;12;;private List<TypeFilter> createTypeFilters(Filter[] filters) {     List<TypeFilter> typeFilters = new ArrayList<>().     for (Filter filter : filters) {         for (Class<?> filterClass : filter.classes()) {             typeFilters.add(createTypeFilter(filter.type(), filterClass)).         }         for (String pattern : filter.pattern()) {             typeFilters.add(createTypeFilter(filter.type(), pattern)).         }     }     return Collections.unmodifiableList(typeFilters). }
false;private;2;17;;@SuppressWarnings("unchecked") private TypeFilter createTypeFilter(FilterType filterType, Class<?> filterClass) {     switch(filterType) {         case ANNOTATION:             Assert.isAssignable(Annotation.class, filterClass, "An error occurred while processing an ANNOTATION type filter: ").             return new AnnotationTypeFilter((Class<Annotation>) filterClass).         case ASSIGNABLE_TYPE:             return new AssignableTypeFilter(filterClass).         case CUSTOM:             Assert.isAssignable(TypeFilter.class, filterClass, "An error occurred while processing a CUSTOM type filter: ").             return BeanUtils.instantiateClass(filterClass, TypeFilter.class).     }     throw new IllegalArgumentException("Filter type not supported with Class value: " + filterType). }
false;private;2;10;;private TypeFilter createTypeFilter(FilterType filterType, String pattern) {     switch(filterType) {         case ASPECTJ:             return new AspectJTypeFilter(pattern, this.classLoader).         case REGEX:             return new RegexPatternTypeFilter(Pattern.compile(pattern)).     }     throw new IllegalArgumentException("Filter type not supported with String pattern: " + filterType). }
false;public;0;4;;@Override public Iterator<TypeFilter> iterator() {     return this.filters.iterator(). }
false;public;2;9;;public boolean anyMatches(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException {     for (TypeFilter filter : this) {         if (filter.match(metadataReader, metadataReaderFactory)) {             return true.         }     }     return false. }
