commented;modifiers;parameterAmount;loc;comment;code
true;public;0;16;/**  * Analyse the {@link ConfigurableEnvironment environment} and attempt to rename  * legacy properties if a replacement exists.  * @return a report of the migration  */ ;/**  * Analyse the {@link ConfigurableEnvironment environment} and attempt to rename  * legacy properties if a replacement exists.  * @return a report of the migration  */ public PropertiesMigrationReport getReport() {     PropertiesMigrationReport report = new PropertiesMigrationReport().     Map<String, List<PropertyMigration>> properties = getMatchingProperties(deprecatedFilter()).     if (properties.isEmpty()) {         return report.     }     properties.forEach((name, candidates) -> {         PropertySource<?> propertySource = mapPropertiesWithReplacement(report, name, candidates).         if (propertySource != null) {             this.environment.getPropertySources().addBefore(name, propertySource).         }     }).     return report. }
false;private;3;19;;private PropertySource<?> mapPropertiesWithReplacement(PropertiesMigrationReport report, String name, List<PropertyMigration> properties) {     report.add(name, properties).     List<PropertyMigration> renamed = properties.stream().filter(PropertyMigration::isCompatibleType).collect(Collectors.toList()).     if (renamed.isEmpty()) {         return null.     }     String target = "migrate-" + name.     Map<String, OriginTrackedValue> content = new LinkedHashMap<>().     for (PropertyMigration candidate : renamed) {         OriginTrackedValue value = OriginTrackedValue.of(candidate.getProperty().getValue(), candidate.getProperty().getOrigin()).         content.put(candidate.getMetadata().getDeprecation().getReplacement(), value).     }     return new OriginTrackedMapPropertySource(target, content). }
false;private;1;18;;private Map<String, List<PropertyMigration>> getMatchingProperties(Predicate<ConfigurationMetadataProperty> filter) {     MultiValueMap<String, PropertyMigration> result = new LinkedMultiValueMap<>().     List<ConfigurationMetadataProperty> candidates = this.allProperties.values().stream().filter(filter).collect(Collectors.toList()).     getPropertySourcesAsMap().forEach((name, source) -> {         candidates.forEach((metadata) -> {             ConfigurationProperty configurationProperty = source.getConfigurationProperty(ConfigurationPropertyName.of(metadata.getId())).             if (configurationProperty != null) {                 result.add(name, new PropertyMigration(configurationProperty, metadata, determineReplacementMetadata(metadata))).             }         }).     }).     return result. }
false;private;1;13;;private ConfigurationMetadataProperty determineReplacementMetadata(ConfigurationMetadataProperty metadata) {     String replacementId = metadata.getDeprecation().getReplacement().     if (StringUtils.hasText(replacementId)) {         ConfigurationMetadataProperty replacement = this.allProperties.get(replacementId).         if (replacement != null) {             return replacement.         }         return detectMapValueReplacement(replacementId).     }     return null. }
false;private;1;7;;private ConfigurationMetadataProperty detectMapValueReplacement(String fullId) {     int lastDot = fullId.lastIndexOf('.').     if (lastDot != -1) {         return this.allProperties.get(fullId.substring(0, lastDot)).     }     return null. }
false;private;0;4;;private Predicate<ConfigurationMetadataProperty> deprecatedFilter() {     return (property) -> property.getDeprecation() != null && property.getDeprecation().getLevel() == Deprecation.Level.ERROR. }
false;private;0;8;;private Map<String, ConfigurationPropertySource> getPropertySourcesAsMap() {     Map<String, ConfigurationPropertySource> map = new LinkedHashMap<>().     for (ConfigurationPropertySource source : ConfigurationPropertySources.get(this.environment)) {         map.put(determinePropertySourceName(source), source).     }     return map. }
false;private;1;6;;private String determinePropertySourceName(ConfigurationPropertySource source) {     if (source.getUnderlyingSource() instanceof PropertySource) {         return ((PropertySource<?>) source.getUnderlyingSource()).getName().     }     return source.getUnderlyingSource().toString(). }
