commented;modifiers;parameterAmount;loc;comment;code
true;public;2;8;/**  * Create a {@link ReactiveHealthIndicatorRegistry} based on the specified health  * indicators. Each {@link HealthIndicator} are wrapped to a  * {@link HealthIndicatorReactiveAdapter}. If two instances share the same name, the  * reactive variant takes precedence.  * @param reactiveHealthIndicators the {@link ReactiveHealthIndicator} instances  * mapped by name  * @param healthIndicators the {@link HealthIndicator} instances mapped by name if  * any.  * @return a {@link ReactiveHealthIndicator} that delegates to the specified  * {@code reactiveHealthIndicators}.  */ ;/**  * Create a {@link ReactiveHealthIndicatorRegistry} based on the specified health  * indicators. Each {@link HealthIndicator} are wrapped to a  * {@link HealthIndicatorReactiveAdapter}. If two instances share the same name, the  * reactive variant takes precedence.  * @param reactiveHealthIndicators the {@link ReactiveHealthIndicator} instances  * mapped by name  * @param healthIndicators the {@link HealthIndicator} instances mapped by name if  * any.  * @return a {@link ReactiveHealthIndicator} that delegates to the specified  * {@code reactiveHealthIndicators}.  */ public ReactiveHealthIndicatorRegistry createReactiveHealthIndicatorRegistry(Map<String, ReactiveHealthIndicator> reactiveHealthIndicators, Map<String, HealthIndicator> healthIndicators) {     Assert.notNull(reactiveHealthIndicators, "ReactiveHealthIndicators must not be null").     return initialize(new DefaultReactiveHealthIndicatorRegistry(), reactiveHealthIndicators, healthIndicators). }
false;protected;3;10;;protected <T extends ReactiveHealthIndicatorRegistry> T initialize(T registry, Map<String, ReactiveHealthIndicator> reactiveHealthIndicators, Map<String, HealthIndicator> healthIndicators) {     merge(reactiveHealthIndicators, healthIndicators).forEach((beanName, indicator) -> {         String name = this.healthIndicatorNameFactory.apply(beanName).         registry.register(name, indicator).     }).     return registry. }
false;private;2;15;;private Map<String, ReactiveHealthIndicator> merge(Map<String, ReactiveHealthIndicator> reactiveHealthIndicators, Map<String, HealthIndicator> healthIndicators) {     if (ObjectUtils.isEmpty(healthIndicators)) {         return reactiveHealthIndicators.     }     Map<String, ReactiveHealthIndicator> allIndicators = new LinkedHashMap<>(reactiveHealthIndicators).     healthIndicators.forEach((beanName, indicator) -> {         String name = this.healthIndicatorNameFactory.apply(beanName).         allIndicators.computeIfAbsent(name, (n) -> new HealthIndicatorReactiveAdapter(indicator)).     }).     return allIndicators. }
