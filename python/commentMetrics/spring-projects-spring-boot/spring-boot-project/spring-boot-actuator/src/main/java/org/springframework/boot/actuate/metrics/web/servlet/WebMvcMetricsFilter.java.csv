commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected boolean shouldNotFilterAsyncDispatch() {     return false. }
false;protected;3;6;;@Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {     filterAndRecordMetrics(request, response, filterChain). }
false;private;3;25;;private void filterAndRecordMetrics(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws IOException, ServletException {     TimingContext timingContext = TimingContext.get(request).     if (timingContext == null) {         timingContext = startAndAttachTimingContext(request).     }     try {         filterChain.doFilter(request, response).         if (!request.isAsyncStarted()) {             // Only record when async processing has finished or never been started.             // If async was started by something further down the chain we wait             // until the second filter invocation (but we'll be using the             // TimingContext that was attached to the first)             Throwable exception = (Throwable) request.getAttribute(DispatcherServlet.EXCEPTION_ATTRIBUTE).             record(timingContext, response, request, exception).         }     } catch (NestedServletException ex) {         response.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value()).         record(timingContext, response, request, ex.getCause()).         throw ex.     } }
false;private;1;6;;private TimingContext startAndAttachTimingContext(HttpServletRequest request) {     Timer.Sample timerSample = Timer.start(this.registry).     TimingContext timingContext = new TimingContext(timerSample).     timingContext.attachTo(request).     return timingContext. }
false;private;1;6;;private Set<Timed> getTimedAnnotations(Object handler) {     if (!(handler instanceof HandlerMethod)) {         return Collections.emptySet().     }     return getTimedAnnotations((HandlerMethod) handler). }
false;private;1;7;;private Set<Timed> getTimedAnnotations(HandlerMethod handler) {     Set<Timed> timed = findTimedAnnotations(handler.getMethod()).     if (timed.isEmpty()) {         return findTimedAnnotations(handler.getBeanType()).     }     return timed. }
false;private;1;3;;private Set<Timed> findTimedAnnotations(AnnotatedElement element) {     return AnnotationUtils.getDeclaredRepeatableAnnotations(element, Timed.class). }
false;private;4;19;;private void record(TimingContext timingContext, HttpServletResponse response, HttpServletRequest request, Throwable exception) {     Object handlerObject = request.getAttribute(HandlerMapping.BEST_MATCHING_HANDLER_ATTRIBUTE).     Set<Timed> annotations = getTimedAnnotations(handlerObject).     Timer.Sample timerSample = timingContext.getTimerSample().     Supplier<Iterable<Tag>> tags = () -> this.tagsProvider.getTags(request, response, handlerObject, exception).     if (annotations.isEmpty()) {         if (this.autoTimeRequests) {             stop(timerSample, tags, Timer.builder(this.metricName)).         }     } else {         for (Timed annotation : annotations) {             stop(timerSample, tags, Timer.builder(annotation, this.metricName)).         }     } }
false;private;3;4;;private void stop(Timer.Sample timerSample, Supplier<Iterable<Tag>> tags, Builder builder) {     timerSample.stop(builder.tags(tags.get()).register(this.registry)). }
false;public;0;3;;public Timer.Sample getTimerSample() {     return this.timerSample. }
false;public;1;3;;public void attachTo(HttpServletRequest request) {     request.setAttribute(ATTRIBUTE, this). }
false;public,static;1;3;;public static TimingContext get(HttpServletRequest request) {     return (TimingContext) request.getAttribute(ATTRIBUTE). }
