commented;modifiers;parameterAmount;loc;comment;code
true;public;0;16;/**  * Return a {@link CachesReport} of all available {@link Cache caches}.  * @return a caches reports  */ ;/**  * Return a {@link CachesReport} of all available {@link Cache caches}.  * @return a caches reports  */ @ReadOperation public CachesReport caches() {     Map<String, Map<String, CacheDescriptor>> descriptors = new LinkedHashMap<>().     getCacheEntries(matchAll(), matchAll()).forEach((entry) -> {         String cacheName = entry.getName().         String cacheManager = entry.getCacheManager().         Map<String, CacheDescriptor> cacheManagerDescriptors = descriptors.computeIfAbsent(cacheManager, (key) -> new LinkedHashMap<>()).         cacheManagerDescriptors.put(cacheName, new CacheDescriptor(entry.getTarget())).     }).     Map<String, CacheManagerDescriptor> cacheManagerDescriptors = new LinkedHashMap<>().     descriptors.forEach((name, entries) -> cacheManagerDescriptors.put(name, new CacheManagerDescriptor(entries))).     return new CachesReport(cacheManagerDescriptors). }
true;public;2;5;/**  * Return a {@link CacheDescriptor} for the specified cache.  * @param cache the name of the cache  * @param cacheManager the name of the cacheManager (can be {@code null}  * @return the descriptor of the cache or {@code null} if no such cache exists  * @throws NonUniqueCacheException if more than one cache with that name exists and no  * {@code cacheManager} was provided to identify a unique candidate  */ ;/**  * Return a {@link CacheDescriptor} for the specified cache.  * @param cache the name of the cache  * @param cacheManager the name of the cacheManager (can be {@code null}  * @return the descriptor of the cache or {@code null} if no such cache exists  * @throws NonUniqueCacheException if more than one cache with that name exists and no  * {@code cacheManager} was provided to identify a unique candidate  */ @ReadOperation public CacheEntry cache(@Selector String cache, @Nullable String cacheManager) {     return extractUniqueCacheEntry(cache, getCacheEntries((name) -> name.equals(cache), isNameMatch(cacheManager))). }
true;public;0;4;/**  * Clear all the available {@link Cache caches}.  */ ;/**  * Clear all the available {@link Cache caches}.  */ @DeleteOperation public void clearCaches() {     getCacheEntries(matchAll(), matchAll()).forEach(this::clearCache). }
true;public;2;6;/**  * Clear the specific {@link Cache}.  * @param cache the name of the cache  * @param cacheManager the name of the cacheManager (can be {@code null} to match all)  * @return {@code true} if the cache was cleared or {@code false} if no such cache  * exists  * @throws NonUniqueCacheException if more than one cache with that name exists and no  * {@code cacheManager} was provided to identify a unique candidate  */ ;/**  * Clear the specific {@link Cache}.  * @param cache the name of the cache  * @param cacheManager the name of the cacheManager (can be {@code null} to match all)  * @return {@code true} if the cache was cleared or {@code false} if no such cache  * exists  * @throws NonUniqueCacheException if more than one cache with that name exists and no  * {@code cacheManager} was provided to identify a unique candidate  */ @DeleteOperation public boolean clearCache(@Selector String cache, @Nullable String cacheManager) {     CacheEntry entry = extractUniqueCacheEntry(cache, getCacheEntries((name) -> name.equals(cache), isNameMatch(cacheManager))).     return (entry != null && clearCache(entry)). }
false;private;2;7;;private List<CacheEntry> getCacheEntries(Predicate<String> cacheNamePredicate, Predicate<String> cacheManagerNamePredicate) {     return this.cacheManagers.keySet().stream().filter(cacheManagerNamePredicate).flatMap((cacheManagerName) -> getCacheEntries(cacheManagerName, cacheNamePredicate).stream()).collect(Collectors.toList()). }
false;private;2;8;;private List<CacheEntry> getCacheEntries(String cacheManagerName, Predicate<String> cacheNamePredicate) {     CacheManager cacheManager = this.cacheManagers.get(cacheManagerName).     return cacheManager.getCacheNames().stream().filter(cacheNamePredicate).map(cacheManager::getCache).filter(Objects::nonNull).map((cache) -> new CacheEntry(cache, cacheManagerName)).collect(Collectors.toList()). }
false;private;2;8;;private CacheEntry extractUniqueCacheEntry(String cache, List<CacheEntry> entries) {     if (entries.size() > 1) {         throw new NonUniqueCacheException(cache, entries.stream().map(CacheEntry::getCacheManager).distinct().collect(Collectors.toList())).     }     return (!entries.isEmpty() ? entries.get(0) : null). }
false;private;1;10;;private boolean clearCache(CacheEntry entry) {     String cacheName = entry.getName().     String cacheManager = entry.getCacheManager().     Cache cache = this.cacheManagers.get(cacheManager).getCache(cacheName).     if (cache != null) {         cache.clear().         return true.     }     return false. }
false;private;1;3;;private Predicate<String> isNameMatch(String name) {     return (name != null) ? ((requested) -> requested.equals(name)) : matchAll(). }
false;private;0;3;;private Predicate<String> matchAll() {     return (name) -> true. }
false;public;0;3;;public Map<String, CacheManagerDescriptor> getCacheManagers() {     return this.cacheManagers. }
false;public;0;3;;public Map<String, CacheDescriptor> getCaches() {     return this.caches. }
true;public;0;3;/**  * Return the fully qualified name of the native cache.  * @return the fully qualified name of the native cache  */ ;/**  * Return the fully qualified name of the native cache.  * @return the fully qualified name of the native cache  */ public String getTarget() {     return this.target. }
false;public;0;3;;public String getName() {     return this.name. }
false;public;0;3;;public String getCacheManager() {     return this.cacheManager. }
