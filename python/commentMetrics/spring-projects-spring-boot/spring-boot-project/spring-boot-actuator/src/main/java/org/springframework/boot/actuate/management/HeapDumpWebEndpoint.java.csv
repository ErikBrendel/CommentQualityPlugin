commented;modifiers;parameterAmount;loc;comment;code
false;public;1;26;;@ReadOperation public WebEndpointResponse<Resource> heapDump(@Nullable Boolean live) {     try {         if (this.lock.tryLock(this.timeout, TimeUnit.MILLISECONDS)) {             try {                 return new WebEndpointResponse<>(dumpHeap((live != null) ? live : true)).             } finally {                 this.lock.unlock().             }         }     } catch (InterruptedException ex) {         Thread.currentThread().interrupt().     } catch (IOException ex) {         return new WebEndpointResponse<>(WebEndpointResponse.STATUS_INTERNAL_SERVER_ERROR).     } catch (HeapDumperUnavailableException ex) {         return new WebEndpointResponse<>(WebEndpointResponse.STATUS_SERVICE_UNAVAILABLE).     }     return new WebEndpointResponse<>(WebEndpointResponse.STATUS_TOO_MANY_REQUESTS). }
false;private;1;8;;private Resource dumpHeap(boolean live) throws IOException, InterruptedException {     if (this.heapDumper == null) {         this.heapDumper = createHeapDumper().     }     File file = createTempFile(live).     this.heapDumper.dumpHeap(file, live).     return new TemporaryFileSystemResource(file). }
false;private;1;7;;private File createTempFile(boolean live) throws IOException {     String date = new SimpleDateFormat("yyyy-MM-dd-HH-mm").format(new Date()).     File file = File.createTempFile("heapdump" + date + (live ? "-live" : ""), ".hprof").     file.delete().     return file. }
true;protected;0;3;/**  * Factory method used to create the {@link HeapDumper}.  * @return the heap dumper to use  * @throws HeapDumperUnavailableException if the heap dumper cannot be created  */ ;/**  * Factory method used to create the {@link HeapDumper}.  * @return the heap dumper to use  * @throws HeapDumperUnavailableException if the heap dumper cannot be created  */ protected HeapDumper createHeapDumper() throws HeapDumperUnavailableException {     return new HotSpotDiagnosticMXBeanHeapDumper(). }
true;;2;1;/**  * Dump the current heap to the specified file.  * @param file the file to dump the heap to  * @param live if only <em>live</em> objects (i.e. objects that are reachable from  * others) should be dumped  * @throws IOException on IO error  * @throws InterruptedException on thread interruption  */ ;/**  * Dump the current heap to the specified file.  * @param file the file to dump the heap to  * @param live if only <em>live</em> objects (i.e. objects that are reachable from  * others) should be dumped  * @throws IOException on IO error  * @throws InterruptedException on thread interruption  */ void dumpHeap(File file, boolean live) throws IOException, InterruptedException.
false;public;2;5;;@Override public void dumpHeap(File file, boolean live) {     ReflectionUtils.invokeMethod(this.dumpHeapMethod, this.diagnosticMXBean, file.getAbsolutePath(), live). }
false;public;0;4;;@Override public boolean isOpen() {     return readableChannel.isOpen(). }
false;public;0;4;;@Override public void close() throws IOException {     closeThenDeleteFile(readableChannel). }
false;public;1;4;;@Override public int read(ByteBuffer dst) throws IOException {     return readableChannel.read(dst). }
false;public;0;22;;@Override public ReadableByteChannel readableChannel() throws IOException {     ReadableByteChannel readableChannel = super.readableChannel().     return new ReadableByteChannel() {          @Override         public boolean isOpen() {             return readableChannel.isOpen().         }          @Override         public void close() throws IOException {             closeThenDeleteFile(readableChannel).         }          @Override         public int read(ByteBuffer dst) throws IOException {             return readableChannel.read(dst).         }     }. }
false;public;0;4;;@Override public void close() throws IOException {     closeThenDeleteFile(this.in). }
false;public;0;11;;@Override public InputStream getInputStream() throws IOException {     return new FilterInputStream(super.getInputStream()) {          @Override         public void close() throws IOException {             closeThenDeleteFile(this.in).         }     }. }
false;private;1;8;;private void closeThenDeleteFile(Closeable closeable) throws IOException {     try {         closeable.close().     } finally {         deleteFile().     } }
false;private;0;10;;private void deleteFile() {     try {         Files.delete(getFile().toPath()).     } catch (IOException ex) {         TemporaryFileSystemResource.this.logger.warn("Failed to delete temporary heap dump file '" + getFile() + "'", ex).     } }
false;public;0;5;;@Override public boolean isFile() {     // Prevent zero-copy so we can delete the file on close     return false. }
