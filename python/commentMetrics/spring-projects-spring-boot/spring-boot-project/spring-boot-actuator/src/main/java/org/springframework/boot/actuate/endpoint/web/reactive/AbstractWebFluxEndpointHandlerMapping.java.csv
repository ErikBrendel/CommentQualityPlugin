commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;11;;@Override protected void initHandlerMethods() {     for (ExposableWebEndpoint endpoint : this.endpoints) {         for (WebOperation operation : endpoint.getOperations()) {             registerMappingForOperation(endpoint, operation).         }     }     if (StringUtils.hasText(this.endpointMapping.getPath())) {         registerLinksMapping().     } }
false;protected;2;6;;@Override protected HandlerMethod createHandlerMethod(Object handler, Method method) {     HandlerMethod handlerMethod = super.createHandlerMethod(handler, method).     return new WebFluxEndpointHandlerMethod(handlerMethod.getBean(), handlerMethod.getMethod()). }
false;private;2;15;;private void registerMappingForOperation(ExposableWebEndpoint endpoint, WebOperation operation) {     ReactiveWebOperation reactiveWebOperation = wrapReactiveWebOperation(endpoint, operation, new ReactiveWebOperationAdapter(operation)).     if (operation.getType() == OperationType.WRITE) {         registerMapping(createRequestMappingInfo(operation), new WriteOperationHandler((reactiveWebOperation)), this.handleWriteMethod).     } else {         registerMapping(createRequestMappingInfo(operation), new ReadOperationHandler((reactiveWebOperation)), this.handleReadMethod).     } }
true;protected;3;4;/**  * Hook point that allows subclasses to wrap the {@link ReactiveWebOperation} before  * it's called. Allows additional features, such as security, to be added.  * @param endpoint the source endpoint  * @param operation the source operation  * @param reactiveWebOperation the reactive web operation to wrap  * @return a wrapped reactive web operation  */ ;/**  * Hook point that allows subclasses to wrap the {@link ReactiveWebOperation} before  * it's called. Allows additional features, such as security, to be added.  * @param endpoint the source endpoint  * @param operation the source operation  * @param reactiveWebOperation the reactive web operation to wrap  * @return a wrapped reactive web operation  */ protected ReactiveWebOperation wrapReactiveWebOperation(ExposableWebEndpoint endpoint, WebOperation operation, ReactiveWebOperation reactiveWebOperation) {     return reactiveWebOperation. }
false;private;1;13;;private RequestMappingInfo createRequestMappingInfo(WebOperation operation) {     WebOperationRequestPredicate predicate = operation.getRequestPredicate().     PatternsRequestCondition patterns = new PatternsRequestCondition(pathPatternParser.parse(this.endpointMapping.createSubPath(predicate.getPath()))).     RequestMethodsRequestCondition methods = new RequestMethodsRequestCondition(RequestMethod.valueOf(predicate.getHttpMethod().name())).     ConsumesRequestCondition consumes = new ConsumesRequestCondition(StringUtils.toStringArray(predicate.getConsumes())).     ProducesRequestCondition produces = new ProducesRequestCondition(StringUtils.toStringArray(predicate.getProduces())).     return new RequestMappingInfo(null, patterns, methods, null, null, consumes, produces, null). }
false;private;0;13;;private void registerLinksMapping() {     PatternsRequestCondition patterns = new PatternsRequestCondition(pathPatternParser.parse(this.endpointMapping.getPath())).     RequestMethodsRequestCondition methods = new RequestMethodsRequestCondition(RequestMethod.GET).     ProducesRequestCondition produces = new ProducesRequestCondition(StringUtils.toStringArray(this.endpointMediaTypes.getProduced())).     RequestMappingInfo mapping = new RequestMappingInfo(patterns, methods, null, null, null, produces, null).     LinksHandler linksHandler = getLinksHandler().     registerMapping(mapping, linksHandler, ReflectionUtils.findMethod(linksHandler.getClass(), "links", ServerWebExchange.class)). }
false;protected;3;5;;@Override protected CorsConfiguration initCorsConfiguration(Object handler, Method method, RequestMappingInfo mapping) {     return this.corsConfiguration. }
false;protected;1;4;;@Override protected boolean isHandler(Class<?> beanType) {     return false. }
false;protected;2;5;;@Override protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {     return null. }
true;protected,abstract;0;1;/**  * Return the Handler providing actuator links at the root endpoint.  * @return the links handler  */ ;/**  * Return the Handler providing actuator links at the root endpoint.  * @return the links handler  */ protected abstract LinksHandler getLinksHandler().
true;public;0;3;/**  * Return the web endpoints being mapped.  * @return the endpoints  */ ;/**  * Return the web endpoints being mapped.  * @return the endpoints  */ public Collection<ExposableWebEndpoint> getEndpoints() {     return this.endpoints. }
false;public;1;5;;@Override public Object invoke(InvocationContext context) {     return Mono.create((sink) -> Schedulers.elastic().schedule(() -> invoke(context, sink))). }
false;private;2;9;;private void invoke(InvocationContext context, MonoSink<Object> sink) {     try {         Object result = this.invoker.invoke(context).         sink.success(result).     } catch (Exception ex) {         sink.error(ex).     } }
false;;1;1;;Object links(ServerWebExchange exchange).
false;;2;2;;Mono<ResponseEntity<Object>> handle(ServerWebExchange exchange, Map<String, String> body).
false;private;1;7;;private OperationInvoker getInvoker(WebOperation operation) {     OperationInvoker invoker = operation::invoke.     if (operation.isBlocking()) {         invoker = new ElasticSchedulerInvoker(invoker).     }     return invoker. }
false;private;0;8;;private Supplier<Mono<? extends SecurityContext>> getSecurityContextSupplier() {     if (ClassUtils.isPresent("org.springframework.security.core.context.ReactiveSecurityContextHolder", getClass().getClassLoader())) {         return this::springSecurityContext.     }     return this::emptySecurityContext. }
false;public;0;6;;public Mono<? extends SecurityContext> springSecurityContext() {     return ReactiveSecurityContextHolder.getContext().map((securityContext) -> new ReactiveSecurityContext(securityContext.getAuthentication())).switchIfEmpty(Mono.just(new ReactiveSecurityContext(null))). }
false;public;0;3;;public Mono<SecurityContext> emptySecurityContext() {     return Mono.just(SecurityContext.NONE). }
false;public;2;11;;@Override public Mono<ResponseEntity<Object>> handle(ServerWebExchange exchange, Map<String, String> body) {     Map<String, Object> arguments = getArguments(exchange, body).     return this.securityContextSupplier.get().map((securityContext) -> new InvocationContext(securityContext, arguments)).flatMap((invocationContext) -> handleResult((Publisher<?>) this.invoker.invoke(invocationContext), exchange.getRequest().getMethod())). }
false;private;2;11;;private Map<String, Object> getArguments(ServerWebExchange exchange, Map<String, String> body) {     Map<String, Object> arguments = new LinkedHashMap<>().     arguments.putAll(getTemplateVariables(exchange)).     if (body != null) {         arguments.putAll(body).     }     exchange.getRequest().getQueryParams().forEach((name, values) -> arguments.put(name, (values.size() != 1) ? values : values.get(0))).     return arguments. }
false;private;1;3;;private Map<String, String> getTemplateVariables(ServerWebExchange exchange) {     return exchange.getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE). }
false;private;2;9;;private Mono<ResponseEntity<Object>> handleResult(Publisher<?> result, HttpMethod httpMethod) {     return Mono.from(result).map(this::toResponseEntity).onErrorMap(InvalidEndpointRequestException.class, (ex) -> new ResponseStatusException(HttpStatus.BAD_REQUEST, ex.getReason())).defaultIfEmpty(new ResponseEntity<>((httpMethod != HttpMethod.GET) ? HttpStatus.NO_CONTENT : HttpStatus.NOT_FOUND)). }
false;private;1;8;;private ResponseEntity<Object> toResponseEntity(Object response) {     if (!(response instanceof WebEndpointResponse)) {         return new ResponseEntity<>(response, HttpStatus.OK).     }     WebEndpointResponse<?> webEndpointResponse = (WebEndpointResponse<?>) response.     return new ResponseEntity<>(webEndpointResponse.getBody(), HttpStatus.valueOf(webEndpointResponse.getStatus())). }
false;public;0;4;;@Override public String toString() {     return "Actuator web endpoint '" + this.operationId + "'". }
false;public;2;5;;@ResponseBody public Publisher<ResponseEntity<Object>> handle(ServerWebExchange exchange, @RequestBody(required = false) Map<String, String> body) {     return this.operation.handle(exchange, body). }
false;public;1;4;;@ResponseBody public Publisher<ResponseEntity<Object>> handle(ServerWebExchange exchange) {     return this.operation.handle(exchange, null). }
false;public;0;4;;@Override public String toString() {     return getBean().toString(). }
false;public;0;6;;@Override public HandlerMethod createWithResolvedBean() {     HandlerMethod handlerMethod = super.createWithResolvedBean().     return new WebFluxEndpointHandlerMethod(handlerMethod.getBean(), handlerMethod.getMethod()). }
false;public;0;4;;@Override public Principal getPrincipal() {     return this.authentication. }
false;public;1;9;;@Override public boolean isUserInRole(String role) {     if (!role.startsWith(this.roleVoter.getRolePrefix())) {         role = this.roleVoter.getRolePrefix() + role.     }     return this.roleVoter.vote(this.authentication, null, Collections.singletonList(new SecurityConfig(role))) == AccessDecisionVoter.ACCESS_GRANTED. }
