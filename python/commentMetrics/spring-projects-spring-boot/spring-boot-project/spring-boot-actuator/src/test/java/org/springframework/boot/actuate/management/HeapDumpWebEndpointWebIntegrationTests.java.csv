commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void configureEndpoint() {     this.endpoint = context.getBean(TestHeapDumpWebEndpoint.class).     this.endpoint.setAvailable(true). }
false;public;0;6;;@Test public void invokeWhenNotAvailableShouldReturnServiceUnavailableStatus() {     this.endpoint.setAvailable(false).     client.get().uri("/actuator/heapdump").exchange().expectStatus().isEqualTo(HttpStatus.SERVICE_UNAVAILABLE). }
false;public;0;7;;@Test public void getRequestShouldReturnHeapDumpInResponseBody() throws Exception {     client.get().uri("/actuator/heapdump").exchange().expectStatus().isOk().expectHeader().contentType(MediaType.APPLICATION_OCTET_STREAM).expectBody(String.class).isEqualTo("HEAPDUMP").     assertHeapDumpFileIsDeleted(). }
false;private;0;7;;private void assertHeapDumpFileIsDeleted() throws InterruptedException {     long end = System.currentTimeMillis() + 5000.     while (System.currentTimeMillis() < end && this.endpoint.file.exists()) {         Thread.sleep(100).     }     assertThat(this.endpoint.file.exists()).isFalse(). }
false;public;0;4;;@Bean public HeapDumpWebEndpoint endpoint() {     return new TestHeapDumpWebEndpoint(). }
false;public;0;3;;public void reset() {     this.available = true. }
false;protected;0;14;;@Override protected HeapDumper createHeapDumper() {     return (file, live) -> {         this.file = file.         if (!TestHeapDumpWebEndpoint.this.available) {             throw new HeapDumperUnavailableException("Not available", null).         }         if (file.exists()) {             throw new IOException("File exists").         }         FileCopyUtils.copy(TestHeapDumpWebEndpoint.this.heapDump.getBytes(), file).     }. }
false;public;1;3;;public void setAvailable(boolean available) {     this.available = available. }
