commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.classLoader = classLoader. }
false;public;1;6;;@Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException {     Assert.isInstanceOf(ConfigurableListableBeanFactory.class, beanFactory, "Mock beans can only be used with a ConfigurableListableBeanFactory").     this.beanFactory = beanFactory. }
false;public;1;8;;@Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {     Assert.isInstanceOf(BeanDefinitionRegistry.class, beanFactory, "@MockBean can only be used on bean factories that " + "implement BeanDefinitionRegistry").     postProcessBeanFactory(beanFactory, (BeanDefinitionRegistry) beanFactory). }
false;private;2;13;;private void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry) {     beanFactory.registerSingleton(MockitoBeans.class.getName(), this.mockitoBeans).     DefinitionsParser parser = new DefinitionsParser(this.definitions).     for (Class<?> configurationClass : getConfigurationClasses(beanFactory)) {         parser.parse(configurationClass).     }     Set<Definition> definitions = parser.getDefinitions().     for (Definition definition : definitions) {         Field field = parser.getField(definition).         register(beanFactory, registry, definition, field).     } }
false;private;1;10;;private Set<Class<?>> getConfigurationClasses(ConfigurableListableBeanFactory beanFactory) {     Set<Class<?>> configurationClasses = new LinkedHashSet<>().     for (BeanDefinition beanDefinition : getConfigurationBeanDefinitions(beanFactory).values()) {         configurationClasses.add(ClassUtils.resolveClassName(beanDefinition.getBeanClassName(), this.classLoader)).     }     return configurationClasses. }
false;private;1;11;;private Map<String, BeanDefinition> getConfigurationBeanDefinitions(ConfigurableListableBeanFactory beanFactory) {     Map<String, BeanDefinition> definitions = new LinkedHashMap<>().     for (String beanName : beanFactory.getBeanDefinitionNames()) {         BeanDefinition definition = beanFactory.getBeanDefinition(beanName).         if (definition.getAttribute(CONFIGURATION_CLASS_ATTRIBUTE) != null) {             definitions.put(beanName, definition).         }     }     return definitions. }
false;private;4;9;;private void register(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry, Definition definition, Field field) {     if (definition instanceof MockDefinition) {         registerMock(beanFactory, registry, (MockDefinition) definition, field).     } else if (definition instanceof SpyDefinition) {         registerSpy(beanFactory, registry, (SpyDefinition) definition, field).     } }
false;private;4;19;;private void registerMock(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry, MockDefinition definition, Field field) {     RootBeanDefinition beanDefinition = createBeanDefinition(definition).     String beanName = getBeanName(beanFactory, registry, definition, beanDefinition).     String transformedBeanName = BeanFactoryUtils.transformedBeanName(beanName).     if (registry.containsBeanDefinition(transformedBeanName)) {         BeanDefinition existing = registry.getBeanDefinition(transformedBeanName).         copyBeanDefinitionDetails(existing, beanDefinition).         registry.removeBeanDefinition(transformedBeanName).     }     registry.registerBeanDefinition(transformedBeanName, beanDefinition).     Object mock = definition.createMock(beanName + " bean").     beanFactory.registerSingleton(transformedBeanName, mock).     this.mockitoBeans.add(mock).     this.beanNameRegistry.put(definition, beanName).     if (field != null) {         this.fieldRegistry.put(field, beanName).     } }
false;private;1;9;;private RootBeanDefinition createBeanDefinition(MockDefinition mockDefinition) {     RootBeanDefinition definition = new RootBeanDefinition(mockDefinition.getTypeToMock().resolve()).     definition.setTargetType(mockDefinition.getTypeToMock()).     if (mockDefinition.getQualifier() != null) {         mockDefinition.getQualifier().applyTo(definition).     }     return definition. }
false;private;4;25;;private String getBeanName(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry, MockDefinition mockDefinition, RootBeanDefinition beanDefinition) {     if (StringUtils.hasLength(mockDefinition.getName())) {         return mockDefinition.getName().     }     Set<String> existingBeans = getExistingBeans(beanFactory, mockDefinition.getTypeToMock(), mockDefinition.getQualifier()).     if (existingBeans.isEmpty()) {         return MockitoPostProcessor.beanNameGenerator.generateBeanName(beanDefinition, registry).     }     if (existingBeans.size() == 1) {         return existingBeans.iterator().next().     }     String primaryCandidate = determinePrimaryCandidate(registry, existingBeans, mockDefinition.getTypeToMock()).     if (primaryCandidate != null) {         return primaryCandidate.     }     throw new IllegalStateException("Unable to register mock bean " + mockDefinition.getTypeToMock() + " expected a single matching bean to replace but found " + existingBeans). }
false;private;2;3;;private void copyBeanDefinitionDetails(BeanDefinition from, RootBeanDefinition to) {     to.setPrimary(from.isPrimary()). }
false;private;4;11;;private void registerSpy(ConfigurableListableBeanFactory beanFactory, BeanDefinitionRegistry registry, SpyDefinition spyDefinition, Field field) {     Set<String> existingBeans = getExistingBeans(beanFactory, spyDefinition.getTypeToSpy(), spyDefinition.getQualifier()).     if (ObjectUtils.isEmpty(existingBeans)) {         createSpy(registry, spyDefinition, field).     } else {         registerSpies(registry, spyDefinition, field, existingBeans).     } }
false;private;3;10;;private Set<String> getExistingBeans(ConfigurableListableBeanFactory beanFactory, ResolvableType type, QualifierDefinition qualifier) {     Set<String> candidates = new TreeSet<>().     for (String candidate : getExistingBeans(beanFactory, type)) {         if (qualifier == null || qualifier.matches(beanFactory, candidate)) {             candidates.add(candidate).         }     }     return candidates. }
false;private;2;15;;private Set<String> getExistingBeans(ConfigurableListableBeanFactory beanFactory, ResolvableType type) {     Set<String> beans = new LinkedHashSet<>(Arrays.asList(beanFactory.getBeanNamesForType(type))).     String typeName = type.resolve(Object.class).getName().     for (String beanName : beanFactory.getBeanNamesForType(FactoryBean.class)) {         beanName = BeanFactoryUtils.transformedBeanName(beanName).         BeanDefinition beanDefinition = beanFactory.getBeanDefinition(beanName).         if (typeName.equals(beanDefinition.getAttribute(FACTORY_BEAN_OBJECT_TYPE))) {             beans.add(beanName).         }     }     beans.removeIf(this::isScopedTarget).     return beans. }
false;private;1;8;;private boolean isScopedTarget(String beanName) {     try {         return ScopedProxyUtils.isScopedTarget(beanName).     } catch (Throwable ex) {         return false.     } }
false;private;3;9;;private void createSpy(BeanDefinitionRegistry registry, SpyDefinition spyDefinition, Field field) {     RootBeanDefinition beanDefinition = new RootBeanDefinition(spyDefinition.getTypeToSpy().resolve()).     String beanName = MockitoPostProcessor.beanNameGenerator.generateBeanName(beanDefinition, registry).     registry.registerBeanDefinition(beanName, beanDefinition).     registerSpy(spyDefinition, field, beanName). }
false;private;4;11;;private void registerSpies(BeanDefinitionRegistry registry, SpyDefinition spyDefinition, Field field, Collection<String> existingBeans) {     try {         String beanName = determineBeanName(existingBeans, spyDefinition, registry).         registerSpy(spyDefinition, field, beanName).     } catch (RuntimeException ex) {         throw new IllegalStateException("Unable to register spy bean " + spyDefinition.getTypeToSpy(), ex).     } }
false;private;3;11;;private String determineBeanName(Collection<String> existingBeans, SpyDefinition definition, BeanDefinitionRegistry registry) {     if (StringUtils.hasText(definition.getName())) {         return definition.getName().     }     if (existingBeans.size() == 1) {         return existingBeans.iterator().next().     }     return determinePrimaryCandidate(registry, existingBeans, definition.getTypeToSpy()). }
false;private;3;17;;private String determinePrimaryCandidate(BeanDefinitionRegistry registry, Collection<String> candidateBeanNames, ResolvableType type) {     String primaryBeanName = null.     for (String candidateBeanName : candidateBeanNames) {         BeanDefinition beanDefinition = registry.getBeanDefinition(candidateBeanName).         if (beanDefinition.isPrimary()) {             if (primaryBeanName != null) {                 throw new NoUniqueBeanDefinitionException(type.resolve(), candidateBeanNames.size(), "more than one 'primary' bean found among candidates: " + Arrays.asList(candidateBeanNames)).             }             primaryBeanName = candidateBeanName.         }     }     return primaryBeanName. }
false;private;3;7;;private void registerSpy(SpyDefinition definition, Field field, String beanName) {     this.spies.put(beanName, definition).     this.beanNameRegistry.put(definition, beanName).     if (field != null) {         this.fieldRegistry.put(field, beanName).     } }
false;protected,final;2;8;;protected final Object createSpyIfNecessary(Object bean, String beanName) throws BeansException {     SpyDefinition definition = this.spies.get(beanName).     if (definition != null) {         bean = definition.createSpy(beanName, bean).     }     return bean. }
false;public;4;8;;@Override public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, final Object bean, String beanName) throws BeansException {     ReflectionUtils.doWithFields(bean.getClass(), (field) -> postProcessField(bean, field)).     return pvs. }
false;private;2;6;;private void postProcessField(Object bean, Field field) {     String beanName = this.fieldRegistry.get(field).     if (StringUtils.hasText(beanName)) {         inject(field, bean, beanName).     } }
false;;3;6;;void inject(Field field, Object target, Definition definition) {     String beanName = this.beanNameRegistry.get(definition).     Assert.state(StringUtils.hasLength(beanName), () -> "No bean found for definition " + definition).     inject(field, target, beanName). }
false;private;3;12;;private void inject(Field field, Object target, String beanName) {     try {         field.setAccessible(true).         Assert.state(ReflectionUtils.getField(field, target) == null, () -> "The field " + field + " cannot have an existing value").         Object bean = this.beanFactory.getBean(beanName, field.getType()).         ReflectionUtils.setField(field, target, bean).     } catch (Throwable ex) {         throw new BeanCreationException("Could not inject field: " + field, ex).     } }
false;public;0;4;;@Override public int getOrder() {     return Ordered.LOWEST_PRECEDENCE - 10. }
true;public,static;1;3;/**  * Register the processor with a {@link BeanDefinitionRegistry}. Not required when  * using the {@link SpringRunner} as registration is automatic.  * @param registry the bean definition registry  */ ;/**  * Register the processor with a {@link BeanDefinitionRegistry}. Not required when  * using the {@link SpringRunner} as registration is automatic.  * @param registry the bean definition registry  */ public static void register(BeanDefinitionRegistry registry) {     register(registry, null). }
true;public,static;2;4;/**  * Register the processor with a {@link BeanDefinitionRegistry}. Not required when  * using the {@link SpringRunner} as registration is automatic.  * @param registry the bean definition registry  * @param definitions the initial mock/spy definitions  */ ;/**  * Register the processor with a {@link BeanDefinitionRegistry}. Not required when  * using the {@link SpringRunner} as registration is automatic.  * @param registry the bean definition registry  * @param definitions the initial mock/spy definitions  */ public static void register(BeanDefinitionRegistry registry, Set<Definition> definitions) {     register(registry, MockitoPostProcessor.class, definitions). }
true;public,static;3;13;/**  * Register the processor with a {@link BeanDefinitionRegistry}. Not required when  * using the {@link SpringRunner} as registration is automatic.  * @param registry the bean definition registry  * @param postProcessor the post processor class to register  * @param definitions the initial mock/spy definitions  */ ;/**  * Register the processor with a {@link BeanDefinitionRegistry}. Not required when  * using the {@link SpringRunner} as registration is automatic.  * @param registry the bean definition registry  * @param postProcessor the post processor class to register  * @param definitions the initial mock/spy definitions  */ @SuppressWarnings("unchecked") public static void register(BeanDefinitionRegistry registry, Class<? extends MockitoPostProcessor> postProcessor, Set<Definition> definitions) {     SpyPostProcessor.register(registry).     BeanDefinition definition = getOrAddBeanDefinition(registry, postProcessor).     ValueHolder constructorArg = definition.getConstructorArgumentValues().getIndexedArgumentValue(0, Set.class).     Set<Definition> existing = (Set<Definition>) constructorArg.getValue().     if (definitions != null) {         existing.addAll(definitions).     } }
false;private,static;2;14;;private static BeanDefinition getOrAddBeanDefinition(BeanDefinitionRegistry registry, Class<? extends MockitoPostProcessor> postProcessor) {     if (!registry.containsBeanDefinition(BEAN_NAME)) {         RootBeanDefinition definition = new RootBeanDefinition(postProcessor).         definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE).         ConstructorArgumentValues constructorArguments = definition.getConstructorArgumentValues().         constructorArguments.addIndexedArgumentValue(0, new LinkedHashSet<MockDefinition>()).         registry.registerBeanDefinition(BEAN_NAME, definition).         return definition.     }     return registry.getBeanDefinition(BEAN_NAME). }
false;public;0;4;;@Override public int getOrder() {     return Ordered.HIGHEST_PRECEDENCE. }
false;public;2;5;;@Override public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {     return this.mockitoPostProcessor.createSpyIfNecessary(bean, beanName). }
false;public;2;8;;@Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {     if (bean instanceof FactoryBean) {         return bean.     }     return this.mockitoPostProcessor.createSpyIfNecessary(bean, beanName). }
false;public,static;1;12;;public static void register(BeanDefinitionRegistry registry) {     if (!registry.containsBeanDefinition(BEAN_NAME)) {         RootBeanDefinition definition = new RootBeanDefinition(SpyPostProcessor.class).         definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE).         ConstructorArgumentValues constructorArguments = definition.getConstructorArgumentValues().         constructorArguments.addIndexedArgumentValue(0, new RuntimeBeanReference(MockitoPostProcessor.BEAN_NAME)).         registry.registerBeanDefinition(BEAN_NAME, definition).     } }
