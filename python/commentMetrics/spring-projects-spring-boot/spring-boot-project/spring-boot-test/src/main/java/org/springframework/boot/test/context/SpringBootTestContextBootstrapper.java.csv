commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;@Override public TestContext buildTestContext() {     TestContext context = super.buildTestContext().     verifyConfiguration(context.getTestClass()).     WebEnvironment webEnvironment = getWebEnvironment(context.getTestClass()).     if (webEnvironment == WebEnvironment.MOCK && deduceWebApplicationType() == WebApplicationType.SERVLET) {         context.setAttribute(ACTIVATE_SERVLET_LISTENER, true).     } else if (webEnvironment != null && webEnvironment.isEmbedded()) {         context.setAttribute(ACTIVATE_SERVLET_LISTENER, false).     }     return context. }
false;protected;0;11;;@Override protected Set<Class<? extends TestExecutionListener>> getDefaultTestExecutionListenerClasses() {     Set<Class<? extends TestExecutionListener>> listeners = super.getDefaultTestExecutionListenerClasses().     List<DefaultTestExecutionListenersPostProcessor> postProcessors = SpringFactoriesLoader.loadFactories(DefaultTestExecutionListenersPostProcessor.class, getClass().getClassLoader()).     for (DefaultTestExecutionListenersPostProcessor postProcessor : postProcessors) {         listeners = postProcessor.postProcessDefaultTestExecutionListeners(listeners).     }     return listeners. }
false;protected;2;11;;@Override protected ContextLoader resolveContextLoader(Class<?> testClass, List<ContextConfigurationAttributes> configAttributesList) {     Class<?>[] classes = getClasses(testClass).     if (!ObjectUtils.isEmpty(classes)) {         for (ContextConfigurationAttributes configAttributes : configAttributesList) {             addConfigAttributesClasses(configAttributes, classes).         }     }     return super.resolveContextLoader(testClass, configAttributesList). }
false;private;2;9;;private void addConfigAttributesClasses(ContextConfigurationAttributes configAttributes, Class<?>[] classes) {     List<Class<?>> combined = new ArrayList<>().     combined.addAll(Arrays.asList(classes)).     if (configAttributes.getClasses() != null) {         combined.addAll(Arrays.asList(configAttributes.getClasses())).     }     configAttributes.setClasses(ClassUtils.toClassArray(combined)). }
false;protected;1;5;;@Override protected Class<? extends ContextLoader> getDefaultContextLoaderClass(Class<?> testClass) {     return SpringBootContextLoader.class. }
false;protected;1;30;;@Override protected MergedContextConfiguration processMergedContextConfiguration(MergedContextConfiguration mergedConfig) {     Class<?>[] classes = getOrFindConfigurationClasses(mergedConfig).     List<String> propertySourceProperties = getAndProcessPropertySourceProperties(mergedConfig).     mergedConfig = createModifiedConfig(mergedConfig, classes, StringUtils.toStringArray(propertySourceProperties)).     WebEnvironment webEnvironment = getWebEnvironment(mergedConfig.getTestClass()).     if (webEnvironment != null && isWebEnvironmentSupported(mergedConfig)) {         WebApplicationType webApplicationType = getWebApplicationType(mergedConfig).         if (webApplicationType == WebApplicationType.SERVLET && (webEnvironment.isEmbedded() || webEnvironment == WebEnvironment.MOCK)) {             WebAppConfiguration webAppConfiguration = AnnotatedElementUtils.findMergedAnnotation(mergedConfig.getTestClass(), WebAppConfiguration.class).             String resourceBasePath = (webAppConfiguration != null) ? webAppConfiguration.value() : "src/main/webapp".             mergedConfig = new WebMergedContextConfiguration(mergedConfig, resourceBasePath).         } else if (webApplicationType == WebApplicationType.REACTIVE && (webEnvironment.isEmbedded() || webEnvironment == WebEnvironment.MOCK)) {             return new ReactiveWebMergedContextConfiguration(mergedConfig).         }     }     return mergedConfig. }
false;private;1;11;;private WebApplicationType getWebApplicationType(MergedContextConfiguration configuration) {     ConfigurationPropertySource source = new MapConfigurationPropertySource(TestPropertySourceUtils.convertInlinedPropertiesToMap(configuration.getPropertySourceProperties())).     Binder binder = new Binder(source).     return binder.bind("spring.main.web-application-type", Bindable.of(WebApplicationType.class)).orElseGet(this::deduceWebApplicationType). }
false;private;0;13;;private WebApplicationType deduceWebApplicationType() {     if (ClassUtils.isPresent(REACTIVE_WEB_ENVIRONMENT_CLASS, null) && !ClassUtils.isPresent(MVC_WEB_ENVIRONMENT_CLASS, null) && !ClassUtils.isPresent(JERSEY_WEB_ENVIRONMENT_CLASS, null)) {         return WebApplicationType.REACTIVE.     }     for (String className : WEB_ENVIRONMENT_CLASSES) {         if (!ClassUtils.isPresent(className, null)) {             return WebApplicationType.NONE.         }     }     return WebApplicationType.SERVLET. }
false;private;1;11;;private boolean isWebEnvironmentSupported(MergedContextConfiguration mergedConfig) {     Class<?> testClass = mergedConfig.getTestClass().     ContextHierarchy hierarchy = AnnotationUtils.getAnnotation(testClass, ContextHierarchy.class).     if (hierarchy == null || hierarchy.value().length == 0) {         return true.     }     ContextConfiguration[] configurations = hierarchy.value().     return isFromConfiguration(mergedConfig, configurations[configurations.length - 1]). }
false;private;2;13;;private boolean isFromConfiguration(MergedContextConfiguration candidateConfig, ContextConfiguration configuration) {     ContextConfigurationAttributes attributes = new ContextConfigurationAttributes(candidateConfig.getTestClass(), configuration).     Set<Class<?>> configurationClasses = new HashSet<>(Arrays.asList(attributes.getClasses())).     for (Class<?> candidate : candidateConfig.getClasses()) {         if (configurationClasses.contains(candidate)) {             return true.         }     }     return false. }
false;protected;1;16;;protected Class<?>[] getOrFindConfigurationClasses(MergedContextConfiguration mergedConfig) {     Class<?>[] classes = mergedConfig.getClasses().     if (containsNonTestComponent(classes) || mergedConfig.hasLocations()) {         return classes.     }     Class<?> found = new AnnotatedClassFinder(SpringBootConfiguration.class).findFromClass(mergedConfig.getTestClass()).     Assert.state(found != null, "Unable to find a @SpringBootConfiguration, you need to use " + "@ContextConfiguration or @SpringBootTest(classes=...) " + "with your test").     logger.info("Found @SpringBootConfiguration " + found.getName() + " for test " + mergedConfig.getTestClass()).     return merge(found, classes). }
false;private;1;8;;private boolean containsNonTestComponent(Class<?>[] classes) {     for (Class<?> candidate : classes) {         if (!AnnotatedElementUtils.isAnnotated(candidate, TestConfiguration.class)) {             return true.         }     }     return false. }
false;private;2;6;;private Class<?>[] merge(Class<?> head, Class<?>[] existing) {     Class<?>[] result = new Class<?>[existing.length + 1].     result[0] = head.     System.arraycopy(existing, 0, result, 1, existing.length).     return result. }
false;private;1;11;;private List<String> getAndProcessPropertySourceProperties(MergedContextConfiguration mergedConfig) {     List<String> propertySourceProperties = new ArrayList<>(Arrays.asList(mergedConfig.getPropertySourceProperties())).     String differentiator = getDifferentiatorPropertySourceProperty().     if (differentiator != null) {         propertySourceProperties.add(differentiator).     }     processPropertySourceProperties(mergedConfig, propertySourceProperties).     return propertySourceProperties. }
true;protected;0;3;/**  * Return a "differentiator" property to ensure that there is something to  * differentiate regular tests and bootstrapped tests. Without this property a cached  * context could be returned that wasn't created by this bootstrapper. By default uses  * the bootstrapper class as a property.  * @return the differentiator or {@code null}  */ ;/**  * Return a "differentiator" property to ensure that there is something to  * differentiate regular tests and bootstrapped tests. Without this property a cached  * context could be returned that wasn't created by this bootstrapper. By default uses  * the bootstrapper class as a property.  * @return the differentiator or {@code null}  */ protected String getDifferentiatorPropertySourceProperty() {     return getClass().getName() + "=true". }
true;protected;2;14;/**  * Post process the property source properties, adding or removing elements as  * required.  * @param mergedConfig the merged context configuration  * @param propertySourceProperties the property source properties to process  */ ;/**  * Post process the property source properties, adding or removing elements as  * required.  * @param mergedConfig the merged context configuration  * @param propertySourceProperties the property source properties to process  */ protected void processPropertySourceProperties(MergedContextConfiguration mergedConfig, List<String> propertySourceProperties) {     Class<?> testClass = mergedConfig.getTestClass().     String[] properties = getProperties(testClass).     if (!ObjectUtils.isEmpty(properties)) {         // Added first so that inlined properties from @TestPropertySource take         // precedence         propertySourceProperties.addAll(0, Arrays.asList(properties)).     }     if (getWebEnvironment(testClass) == WebEnvironment.RANDOM_PORT) {         propertySourceProperties.add("server.port=0").     } }
true;protected;1;4;/**  * Return the {@link WebEnvironment} type for this test or null if undefined.  * @param testClass the source test class  * @return the {@link WebEnvironment} or {@code null}  */ ;/**  * Return the {@link WebEnvironment} type for this test or null if undefined.  * @param testClass the source test class  * @return the {@link WebEnvironment} or {@code null}  */ protected WebEnvironment getWebEnvironment(Class<?> testClass) {     SpringBootTest annotation = getAnnotation(testClass).     return (annotation != null) ? annotation.webEnvironment() : null. }
false;protected;1;4;;protected Class<?>[] getClasses(Class<?> testClass) {     SpringBootTest annotation = getAnnotation(testClass).     return (annotation != null) ? annotation.classes() : null. }
false;protected;1;4;;protected String[] getProperties(Class<?> testClass) {     SpringBootTest annotation = getAnnotation(testClass).     return (annotation != null) ? annotation.properties() : null. }
false;protected;1;3;;protected SpringBootTest getAnnotation(Class<?> testClass) {     return AnnotatedElementUtils.getMergedAnnotation(testClass, SpringBootTest.class). }
false;protected;1;12;;protected void verifyConfiguration(Class<?> testClass) {     SpringBootTest springBootTest = getAnnotation(testClass).     if (springBootTest != null && (springBootTest.webEnvironment() == WebEnvironment.DEFINED_PORT || springBootTest.webEnvironment() == WebEnvironment.RANDOM_PORT) && getAnnotation(WebAppConfiguration.class, testClass) != null) {         throw new IllegalStateException("@WebAppConfiguration should only be used " + "with @SpringBootTest when @SpringBootTest is configured with a " + "mock web environment. Please remove @WebAppConfiguration or " + "reconfigure @SpringBootTest.").     } }
false;private;2;4;;private <T extends Annotation> T getAnnotation(Class<T> annotationType, Class<?> testClass) {     return AnnotatedElementUtils.getMergedAnnotation(testClass, annotationType). }
true;protected,final;2;5;/**  * Create a new {@link MergedContextConfiguration} with different classes.  * @param mergedConfig the source config  * @param classes the replacement classes  * @return a new {@link MergedContextConfiguration}  */ ;/**  * Create a new {@link MergedContextConfiguration} with different classes.  * @param mergedConfig the source config  * @param classes the replacement classes  * @return a new {@link MergedContextConfiguration}  */ protected final MergedContextConfiguration createModifiedConfig(MergedContextConfiguration mergedConfig, Class<?>[] classes) {     return createModifiedConfig(mergedConfig, classes, mergedConfig.getPropertySourceProperties()). }
true;protected,final;3;11;/**  * Create a new {@link MergedContextConfiguration} with different classes and  * properties.  * @param mergedConfig the source config  * @param classes the replacement classes  * @param propertySourceProperties the replacement properties  * @return a new {@link MergedContextConfiguration}  */ ;/**  * Create a new {@link MergedContextConfiguration} with different classes and  * properties.  * @param mergedConfig the source config  * @param classes the replacement classes  * @param propertySourceProperties the replacement properties  * @return a new {@link MergedContextConfiguration}  */ protected final MergedContextConfiguration createModifiedConfig(MergedContextConfiguration mergedConfig, Class<?>[] classes, String[] propertySourceProperties) {     return new MergedContextConfiguration(mergedConfig.getTestClass(), mergedConfig.getLocations(), classes, mergedConfig.getContextInitializerClasses(), mergedConfig.getActiveProfiles(), mergedConfig.getPropertySourceLocations(), propertySourceProperties, mergedConfig.getContextCustomizers(), mergedConfig.getContextLoader(), getCacheAwareContextLoaderDelegate(), mergedConfig.getParent()). }
