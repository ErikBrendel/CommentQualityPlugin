commented;modifiers;parameterAmount;loc;comment;code
false;public;2;9;;@Override public void customizeContext(ConfigurableApplicationContext context, MergedContextConfiguration mergedContextConfiguration) {     BeanDefinitionRegistry registry = getBeanDefinitionRegistry(context).     AnnotatedBeanDefinitionReader reader = new AnnotatedBeanDefinitionReader(registry).     registerCleanupPostProcessor(registry, reader).     registerImportsConfiguration(registry, reader). }
false;private;2;7;;private void registerCleanupPostProcessor(BeanDefinitionRegistry registry, AnnotatedBeanDefinitionReader reader) {     BeanDefinition definition = registerBean(registry, reader, ImportsCleanupPostProcessor.BEAN_NAME, ImportsCleanupPostProcessor.class).     definition.getConstructorArgumentValues().addIndexedArgumentValue(0, this.testClass). }
false;private;2;6;;private void registerImportsConfiguration(BeanDefinitionRegistry registry, AnnotatedBeanDefinitionReader reader) {     BeanDefinition definition = registerBean(registry, reader, ImportsConfiguration.BEAN_NAME, ImportsConfiguration.class).     definition.setAttribute(TEST_CLASS_ATTRIBUTE, this.testClass). }
false;private;1;10;;private BeanDefinitionRegistry getBeanDefinitionRegistry(ApplicationContext context) {     if (context instanceof BeanDefinitionRegistry) {         return (BeanDefinitionRegistry) context.     }     if (context instanceof AbstractApplicationContext) {         return (BeanDefinitionRegistry) ((AbstractApplicationContext) context).getBeanFactory().     }     throw new IllegalStateException("Could not locate BeanDefinitionRegistry"). }
false;private;4;6;;@SuppressWarnings("unchecked") private BeanDefinition registerBean(BeanDefinitionRegistry registry, AnnotatedBeanDefinitionReader reader, String beanName, Class<?> type) {     reader.registerBean(type, beanName).     return registry.getBeanDefinition(beanName). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     }     if (obj == null || obj.getClass() != getClass()) {         return false.     }     // ImportSelectors are flexible so the only safe cache key is the test class     ImportsContextCustomizer other = (ImportsContextCustomizer) obj.     return this.key.equals(other.key). }
false;public;0;4;;@Override public int hashCode() {     return this.key.hashCode(). }
false;public;0;4;;@Override public String toString() {     return new ToStringCreator(this).append("key", this.key).toString(). }
false;public;1;4;;@Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException {     this.beanFactory = (ConfigurableListableBeanFactory) beanFactory. }
false;public;1;9;;@Override public String[] selectImports(AnnotationMetadata importingClassMetadata) {     BeanDefinition definition = this.beanFactory.getBeanDefinition(ImportsConfiguration.BEAN_NAME).     Object testClass = (definition != null) ? definition.getAttribute(TEST_CLASS_ATTRIBUTE) : null.     return (testClass != null) ? new String[] { ((Class<?>) testClass).getName() } : NO_IMPORTS. }
false;public;1;4;;@Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException { }
false;public;1;16;;@Override public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException {     try {         String[] names = registry.getBeanDefinitionNames().         for (String name : names) {             BeanDefinition definition = registry.getBeanDefinition(name).             if (this.testClass.getName().equals(definition.getBeanClassName())) {                 registry.removeBeanDefinition(name).             }         }         registry.removeBeanDefinition(ImportsConfiguration.BEAN_NAME).     } catch (NoSuchBeanDefinitionException ex) {     } }
false;private;3;12;;private void collectClassAnnotations(Class<?> classType, Set<Annotation> annotations, Set<Class<?>> seen) {     if (seen.add(classType)) {         collectElementAnnotations(classType, annotations, seen).         for (Class<?> interfaceType : classType.getInterfaces()) {             collectClassAnnotations(interfaceType, annotations, seen).         }         if (classType.getSuperclass() != null) {             collectClassAnnotations(classType.getSuperclass(), annotations, seen).         }     } }
false;private;3;10;;private void collectElementAnnotations(AnnotatedElement element, Set<Annotation> annotations, Set<Class<?>> seen) {     for (Annotation annotation : element.getDeclaredAnnotations()) {         if (!isIgnoredAnnotation(annotation)) {             annotations.add(annotation).             collectClassAnnotations(annotation.annotationType(), annotations, seen).         }     } }
false;private;1;8;;private boolean isIgnoredAnnotation(Annotation annotation) {     for (AnnotationFilter annotationFilter : ANNOTATION_FILTERS) {         if (annotationFilter.isIgnored(annotation)) {             return true.         }     }     return false. }
false;private;2;17;;private Set<Object> determineImports(Set<Annotation> annotations, Class<?> testClass) {     Set<Object> determinedImports = new LinkedHashSet<>().     AnnotationMetadata testClassMetadata = new StandardAnnotationMetadata(testClass).     for (Annotation annotation : annotations) {         for (Class<?> source : getImports(annotation)) {             Set<Object> determinedSourceImports = determineImports(source, testClassMetadata).             if (determinedSourceImports == null) {                 return null.             }             determinedImports.addAll(determinedSourceImports).         }     }     return determinedImports. }
false;private;1;6;;private Class<?>[] getImports(Annotation annotation) {     if (annotation instanceof Import) {         return ((Import) annotation).value().     }     return NO_IMPORTS. }
false;private;2;16;;private Set<Object> determineImports(Class<?> source, AnnotationMetadata metadata) {     if (DeterminableImports.class.isAssignableFrom(source)) {         // We can determine the imports         return ((DeterminableImports) instantiate(source)).determineImports(metadata).     }     if (ImportSelector.class.isAssignableFrom(source) || ImportBeanDefinitionRegistrar.class.isAssignableFrom(source)) {         // use anything to determine the imports so we can't be sure         return null.     }     // The source itself is the import     return Collections.singleton(source.getName()). }
false;private;1;14;;@SuppressWarnings("unchecked") private <T> T instantiate(Class<T> source) {     try {         Constructor<?> constructor = source.getDeclaredConstructor().         ReflectionUtils.makeAccessible(constructor).         return (T) constructor.newInstance().     } catch (Throwable ex) {         throw new IllegalStateException("Unable to instantiate DeterminableImportSelector " + source.getName(), ex).     } }
false;public;1;5;;@Override public boolean equals(Object obj) {     return (obj != null && getClass() == obj.getClass() && this.key.equals(((ContextCustomizerKey) obj).key)). }
false;public;0;4;;@Override public int hashCode() {     return this.key.hashCode(). }
false;public;0;4;;@Override public String toString() {     return this.key.toString(). }
false;;1;1;;boolean isIgnored(Annotation annotation).
false;public;1;4;;@Override public boolean isIgnored(Annotation annotation) {     return AnnotationUtils.isInJavaLangAnnotationPackage(annotation). }
false;public;1;5;;@Override public boolean isIgnored(Annotation annotation) {     return "kotlin.Metadata".equals(annotation.annotationType().getName()) || isInKotlinAnnotationPackage(annotation). }
false;private;1;3;;private boolean isInKotlinAnnotationPackage(Annotation annotation) {     return annotation.annotationType().getName().startsWith("kotlin.annotation."). }
false;public;1;5;;@Override public boolean isIgnored(Annotation annotation) {     return annotation.annotationType().getName().startsWith("org.spockframework.") || annotation.annotationType().getName().startsWith("spock."). }
