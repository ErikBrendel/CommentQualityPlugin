commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public void parse(Class<?> source) {     parseElement(source).     ReflectionUtils.doWithFields(source, this::parseElement). }
false;private;1;10;;private void parseElement(AnnotatedElement element) {     for (MockBean annotation : AnnotationUtils.getRepeatableAnnotations(element, MockBean.class, MockBeans.class)) {         parseMockBeanAnnotation(annotation, element).     }     for (SpyBean annotation : AnnotationUtils.getRepeatableAnnotations(element, SpyBean.class, SpyBeans.class)) {         parseSpyBeanAnnotation(annotation, element).     } }
false;private;2;16;;private void parseMockBeanAnnotation(MockBean annotation, AnnotatedElement element) {     Set<ResolvableType> typesToMock = getOrDeduceTypes(element, annotation.value()).     Assert.state(!typesToMock.isEmpty(), () -> "Unable to deduce type to mock from " + element).     if (StringUtils.hasLength(annotation.name())) {         Assert.state(typesToMock.size() == 1, "The name attribute can only be used when mocking a single class").     }     for (ResolvableType typeToMock : typesToMock) {         MockDefinition definition = new MockDefinition(annotation.name(), typeToMock, annotation.extraInterfaces(), annotation.answer(), annotation.serializable(), annotation.reset(), QualifierDefinition.forElement(element)).         addDefinition(element, definition, "mock").     } }
false;private;2;15;;private void parseSpyBeanAnnotation(SpyBean annotation, AnnotatedElement element) {     Set<ResolvableType> typesToSpy = getOrDeduceTypes(element, annotation.value()).     Assert.state(!typesToSpy.isEmpty(), () -> "Unable to deduce type to spy from " + element).     if (StringUtils.hasLength(annotation.name())) {         Assert.state(typesToSpy.size() == 1, "The name attribute can only be used when spying a single class").     }     for (ResolvableType typeToSpy : typesToSpy) {         SpyDefinition definition = new SpyDefinition(annotation.name(), typeToSpy, annotation.reset(), annotation.proxyTargetAware(), QualifierDefinition.forElement(element)).         addDefinition(element, definition, "spy").     } }
false;private;3;10;;private void addDefinition(AnnotatedElement element, Definition definition, String type) {     boolean isNewDefinition = this.definitions.add(definition).     Assert.state(isNewDefinition, () -> "Duplicate " + type + " definition " + definition).     if (element instanceof Field) {         Field field = (Field) element.         this.definitionFields.put(definition, field).     } }
false;private;2;11;;private Set<ResolvableType> getOrDeduceTypes(AnnotatedElement element, Class<?>[] value) {     Set<ResolvableType> types = new LinkedHashSet<>().     for (Class<?> clazz : value) {         types.add(ResolvableType.forClass(clazz)).     }     if (types.isEmpty() && element instanceof Field) {         types.add(ResolvableType.forField((Field) element)).     }     return types. }
false;public;0;3;;public Set<Definition> getDefinitions() {     return Collections.unmodifiableSet(this.definitions). }
false;public;1;3;;public Field getField(Definition definition) {     return this.definitionFields.get(definition). }
