commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Builder method to add more properties.  * @param pairs the property pairs to add  * @return a new {@link TestPropertyValues} instance  */ ;/**  * Builder method to add more properties.  * @param pairs the property pairs to add  * @return a new {@link TestPropertyValues} instance  */ public TestPropertyValues and(String... pairs) {     return and(Arrays.stream(pairs).map(Pair::parse)). }
false;private;1;5;;private TestPropertyValues and(Stream<Pair> pairs) {     Map<String, Object> properties = new LinkedHashMap<>(this.properties).     pairs.filter(Objects::nonNull).forEach((pair) -> pair.addTo(properties)).     return new TestPropertyValues(properties). }
true;public;1;3;/**  * Add the properties from the underlying map to the environment owned by an  * {@link ApplicationContext}.  * @param context the context with an environment to modify  */ ;/**  * Add the properties from the underlying map to the environment owned by an  * {@link ApplicationContext}.  * @param context the context with an environment to modify  */ public void applyTo(ConfigurableApplicationContext context) {     applyTo(context.getEnvironment()). }
true;public;1;3;/**  * Add the properties from the underlying map to the environment. The default property  * source used is {@link MapPropertySource}.  * @param environment the environment that needs to be modified  */ ;/**  * Add the properties from the underlying map to the environment. The default property  * source used is {@link MapPropertySource}.  * @param environment the environment that needs to be modified  */ public void applyTo(ConfigurableEnvironment environment) {     applyTo(environment, Type.MAP). }
true;public;2;3;/**  * Add the properties from the underlying map to the environment using the specified  * property source type.  * @param environment the environment that needs to be modified  * @param type the type of {@link PropertySource} to be added. See {@link Type}  */ ;/**  * Add the properties from the underlying map to the environment using the specified  * property source type.  * @param environment the environment that needs to be modified  * @param type the type of {@link PropertySource} to be added. See {@link Type}  */ public void applyTo(ConfigurableEnvironment environment, Type type) {     applyTo(environment, type, type.applySuffix("test")). }
true;public;3;8;/**  * Add the properties from the underlying map to the environment using the specified  * property source type and name.  * @param environment the environment that needs to be modified  * @param type the type of {@link PropertySource} to be added. See {@link Type}  * @param name the name for the property source  */ ;/**  * Add the properties from the underlying map to the environment using the specified  * property source type and name.  * @param environment the environment that needs to be modified  * @param type the type of {@link PropertySource} to be added. See {@link Type}  * @param name the name for the property source  */ public void applyTo(ConfigurableEnvironment environment, Type type, String name) {     Assert.notNull(environment, "Environment must not be null").     Assert.notNull(type, "Property source type must not be null").     Assert.notNull(name, "Property source name must not be null").     MutablePropertySources sources = environment.getPropertySources().     addToSources(sources, type, name).     ConfigurationPropertySources.attach(environment). }
true;public;1;9;/**  * Add the properties to the {@link System#getProperties() system properties} for the  * duration of the {@code call}, restoring previous values when the call completes.  * @param <T> the result type  * @param call the call to make  * @return the result of the call  */ ;/**  * Add the properties to the {@link System#getProperties() system properties} for the  * duration of the {@code call}, restoring previous values when the call completes.  * @param <T> the result type  * @param call the call to make  * @return the result of the call  */ public <T> T applyToSystemProperties(Callable<T> call) {     try (SystemPropertiesHandler handler = new SystemPropertiesHandler()) {         return call.call().     } catch (Exception ex) {         rethrow(ex).         throw new IllegalStateException("Original cause not rethrown", ex).     } }
false;private;1;4;;@SuppressWarnings("unchecked") private <E extends Throwable> void rethrow(Throwable e) throws E {     throw (E) e. }
false;private;3;14;;@SuppressWarnings("unchecked") private void addToSources(MutablePropertySources sources, Type type, String name) {     if (sources.contains(name)) {         PropertySource<?> propertySource = sources.get(name).         if (propertySource.getClass() == type.getSourceClass()) {             ((Map<String, Object>) propertySource.getSource()).putAll(this.properties).             return.         }     }     Map<String, Object> source = new LinkedHashMap<>(this.properties).     sources.addFirst((type.equals(Type.MAP) ? new MapPropertySource(name, source) : new SystemEnvironmentPropertySource(name, source))). }
true;public,static;1;3;/**  * Return a new {@link TestPropertyValues} with the underlying map populated with the  * given property pairs. Name-value pairs can be specified with colon (":") or equals  * ("=") separators.  * @param pairs the name-value pairs for properties that need to be added to the  * environment  * @return the new instance  */ ;/**  * Return a new {@link TestPropertyValues} with the underlying map populated with the  * given property pairs. Name-value pairs can be specified with colon (":") or equals  * ("=") separators.  * @param pairs the name-value pairs for properties that need to be added to the  * environment  * @return the new instance  */ public static TestPropertyValues of(String... pairs) {     return of(Stream.of(pairs)). }
true;public,static;1;6;/**  * Return a new {@link TestPropertyValues} with the underlying map populated with the  * given property pairs. Name-value pairs can be specified with colon (":") or equals  * ("=") separators.  * @param pairs the name-value pairs for properties that need to be added to the  * environment  * @return the new instance  */ ;/**  * Return a new {@link TestPropertyValues} with the underlying map populated with the  * given property pairs. Name-value pairs can be specified with colon (":") or equals  * ("=") separators.  * @param pairs the name-value pairs for properties that need to be added to the  * environment  * @return the new instance  */ public static TestPropertyValues of(Iterable<String> pairs) {     if (pairs == null) {         return empty().     }     return of(StreamSupport.stream(pairs.spliterator(), false)). }
true;public,static;1;6;/**  * Return a new {@link TestPropertyValues} with the underlying map populated with the  * given property pairs. Name-value pairs can be specified with colon (":") or equals  * ("=") separators.  * @param pairs the name-value pairs for properties that need to be added to the  * environment  * @return the new instance  */ ;/**  * Return a new {@link TestPropertyValues} with the underlying map populated with the  * given property pairs. Name-value pairs can be specified with colon (":") or equals  * ("=") separators.  * @param pairs the name-value pairs for properties that need to be added to the  * environment  * @return the new instance  */ public static TestPropertyValues of(Stream<String> pairs) {     if (pairs == null) {         return empty().     }     return empty().and(pairs.map(Pair::parse)). }
true;public,static;0;3;/**  * Return an empty {@link TestPropertyValues} instance.  * @return an empty instance  */ ;/**  * Return an empty {@link TestPropertyValues} instance.  * @return an empty instance  */ public static TestPropertyValues empty() {     return EMPTY. }
false;public;0;3;;public Class<? extends MapPropertySource> getSourceClass() {     return this.sourceClass. }
false;protected;1;3;;protected String applySuffix(String name) {     return (this.suffix != null) ? name + "-" + this.suffix : name. }
false;public;1;3;;public void addTo(Map<String, Object> properties) {     properties.put(this.name, this.value). }
false;public,static;1;6;;public static Pair parse(String pair) {     int index = getSeparatorIndex(pair).     String name = (index > 0) ? pair.substring(0, index) : pair.     String value = (index > 0) ? pair.substring(index + 1) : "".     return of(name.trim(), value.trim()). }
false;private,static;1;11;;private static int getSeparatorIndex(String pair) {     int colonIndex = pair.indexOf(':').     int equalIndex = pair.indexOf('=').     if (colonIndex == -1) {         return equalIndex.     }     if (equalIndex == -1) {         return colonIndex.     }     return Math.min(colonIndex, equalIndex). }
false;private,static;2;6;;private static Pair of(String name, String value) {     if (StringUtils.isEmpty(name) && StringUtils.isEmpty(value)) {         return null.     }     return new Pair(name, value). }
false;private;1;6;;private Map<String, String> apply(Map<String, ?> properties) {     Map<String, String> previous = new LinkedHashMap<>().     properties.forEach((name, value) -> previous.put(name, setOrClear(name, (String) value))).     return previous. }
false;public;0;4;;@Override public void close() {     this.previous.forEach(this::setOrClear). }
false;private;2;7;;private String setOrClear(String name, String value) {     Assert.notNull(name, "Name must not be null").     if (StringUtils.isEmpty(value)) {         return (String) System.getProperties().remove(name).     }     return (String) System.getProperties().setProperty(name, value). }
