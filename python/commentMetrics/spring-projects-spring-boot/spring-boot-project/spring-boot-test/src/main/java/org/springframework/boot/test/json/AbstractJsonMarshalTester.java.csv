commented;modifiers;parameterAmount;loc;comment;code
true;protected,final;2;6;/**  * Initialize the marshal tester for use.  * @param resourceLoadClass the source class used when loading relative classpath  * resources  * @param type the type under test  */ ;/**  * Initialize the marshal tester for use.  * @param resourceLoadClass the source class used when loading relative classpath  * resources  * @param type the type under test  */ protected final void initialize(Class<?> resourceLoadClass, ResolvableType type) {     if (this.resourceLoadClass == null && this.type == null) {         this.resourceLoadClass = resourceLoadClass.         this.type = type.     } }
true;protected,final;0;3;/**  * Return the type under test.  * @return the type under test  */ ;/**  * Return the type under test.  * @return the type under test  */ protected final ResolvableType getType() {     return this.type. }
true;protected,final;0;3;/**  * Return class used to load relative resources.  * @return the resource load class  */ ;/**  * Return class used to load relative resources.  * @return the resource load class  */ protected final Class<?> getResourceLoadClass() {     return this.resourceLoadClass. }
true;public;1;6;/**  * Return {@link JsonContent} from writing the specific value.  * @param value the value to write  * @return the {@link JsonContent}  * @throws IOException on write error  */ ;/**  * Return {@link JsonContent} from writing the specific value.  * @param value the value to write  * @return the {@link JsonContent}  * @throws IOException on write error  */ public JsonContent<T> write(T value) throws IOException {     verify().     Assert.notNull(value, "Value must not be null").     String json = writeObject(value, this.type).     return new JsonContent<>(this.resourceLoadClass, this.type, json). }
true;public;1;4;/**  * Return the object created from parsing the specific JSON bytes.  * @param jsonBytes the source JSON bytes  * @return the resulting object  * @throws IOException on parse error  */ ;/**  * Return the object created from parsing the specific JSON bytes.  * @param jsonBytes the source JSON bytes  * @return the resulting object  * @throws IOException on parse error  */ public T parseObject(byte[] jsonBytes) throws IOException {     verify().     return parse(jsonBytes).getObject(). }
true;public;1;5;/**  * Return {@link ObjectContent} from parsing the specific JSON bytes.  * @param jsonBytes the source JSON bytes  * @return the {@link ObjectContent}  * @throws IOException on parse error  */ ;/**  * Return {@link ObjectContent} from parsing the specific JSON bytes.  * @param jsonBytes the source JSON bytes  * @return the {@link ObjectContent}  * @throws IOException on parse error  */ public ObjectContent<T> parse(byte[] jsonBytes) throws IOException {     verify().     Assert.notNull(jsonBytes, "JsonBytes must not be null").     return read(new ByteArrayResource(jsonBytes)). }
true;public;1;4;/**  * Return the object created from parsing the specific JSON String.  * @param jsonString the source JSON string  * @return the resulting object  * @throws IOException on parse error  */ ;/**  * Return the object created from parsing the specific JSON String.  * @param jsonString the source JSON string  * @return the resulting object  * @throws IOException on parse error  */ public T parseObject(String jsonString) throws IOException {     verify().     return parse(jsonString).getObject(). }
true;public;1;5;/**  * Return {@link ObjectContent} from parsing the specific JSON String.  * @param jsonString the source JSON string  * @return the {@link ObjectContent}  * @throws IOException on parse error  */ ;/**  * Return {@link ObjectContent} from parsing the specific JSON String.  * @param jsonString the source JSON string  * @return the {@link ObjectContent}  * @throws IOException on parse error  */ public ObjectContent<T> parse(String jsonString) throws IOException {     verify().     Assert.notNull(jsonString, "JsonString must not be null").     return read(new StringReader(jsonString)). }
true;public;1;4;/**  * Return the object created from reading from the specified classpath resource.  * @param resourcePath the source resource path. May be a full path or a path relative  * to the {@code resourceLoadClass} passed to the constructor  * @return the resulting object  * @throws IOException on read error  */ ;/**  * Return the object created from reading from the specified classpath resource.  * @param resourcePath the source resource path. May be a full path or a path relative  * to the {@code resourceLoadClass} passed to the constructor  * @return the resulting object  * @throws IOException on read error  */ public T readObject(String resourcePath) throws IOException {     verify().     return read(resourcePath).getObject(). }
true;public;1;5;/**  * Return {@link ObjectContent} from reading from the specified classpath resource.  * @param resourcePath the source resource path. May be a full path or a path relative  * to the {@code resourceLoadClass} passed to the constructor  * @return the {@link ObjectContent}  * @throws IOException on read error  */ ;/**  * Return {@link ObjectContent} from reading from the specified classpath resource.  * @param resourcePath the source resource path. May be a full path or a path relative  * to the {@code resourceLoadClass} passed to the constructor  * @return the {@link ObjectContent}  * @throws IOException on read error  */ public ObjectContent<T> read(String resourcePath) throws IOException {     verify().     Assert.notNull(resourcePath, "ResourcePath must not be null").     return read(new ClassPathResource(resourcePath, this.resourceLoadClass)). }
true;public;1;4;/**  * Return the object created from reading from the specified file.  * @param file the source file  * @return the resulting object  * @throws IOException on read error  */ ;/**  * Return the object created from reading from the specified file.  * @param file the source file  * @return the resulting object  * @throws IOException on read error  */ public T readObject(File file) throws IOException {     verify().     return read(file).getObject(). }
true;public;1;5;/**  * Return {@link ObjectContent} from reading from the specified file.  * @param file the source file  * @return the {@link ObjectContent}  * @throws IOException on read error  */ ;/**  * Return {@link ObjectContent} from reading from the specified file.  * @param file the source file  * @return the {@link ObjectContent}  * @throws IOException on read error  */ public ObjectContent<T> read(File file) throws IOException {     verify().     Assert.notNull(file, "File must not be null").     return read(new FileSystemResource(file)). }
true;public;1;4;/**  * Return the object created from reading from the specified input stream.  * @param inputStream the source input stream  * @return the resulting object  * @throws IOException on read error  */ ;/**  * Return the object created from reading from the specified input stream.  * @param inputStream the source input stream  * @return the resulting object  * @throws IOException on read error  */ public T readObject(InputStream inputStream) throws IOException {     verify().     return read(inputStream).getObject(). }
true;public;1;5;/**  * Return {@link ObjectContent} from reading from the specified input stream.  * @param inputStream the source input stream  * @return the {@link ObjectContent}  * @throws IOException on read error  */ ;/**  * Return {@link ObjectContent} from reading from the specified input stream.  * @param inputStream the source input stream  * @return the {@link ObjectContent}  * @throws IOException on read error  */ public ObjectContent<T> read(InputStream inputStream) throws IOException {     verify().     Assert.notNull(inputStream, "InputStream must not be null").     return read(new InputStreamResource(inputStream)). }
true;public;1;4;/**  * Return the object created from reading from the specified resource.  * @param resource the source resource  * @return the resulting object  * @throws IOException on read error  */ ;/**  * Return the object created from reading from the specified resource.  * @param resource the source resource  * @return the resulting object  * @throws IOException on read error  */ public T readObject(Resource resource) throws IOException {     verify().     return read(resource).getObject(). }
true;public;1;8;/**  * Return {@link ObjectContent} from reading from the specified resource.  * @param resource the source resource  * @return the {@link ObjectContent}  * @throws IOException on read error  */ ;/**  * Return {@link ObjectContent} from reading from the specified resource.  * @param resource the source resource  * @return the {@link ObjectContent}  * @throws IOException on read error  */ public ObjectContent<T> read(Resource resource) throws IOException {     verify().     Assert.notNull(resource, "Resource must not be null").     InputStream inputStream = resource.getInputStream().     T object = readObject(inputStream, this.type).     closeQuietly(inputStream).     return new ObjectContent<>(this.type, object). }
true;public;1;4;/**  * Return the object created from reading from the specified reader.  * @param reader the source reader  * @return the resulting object  * @throws IOException on read error  */ ;/**  * Return the object created from reading from the specified reader.  * @param reader the source reader  * @return the resulting object  * @throws IOException on read error  */ public T readObject(Reader reader) throws IOException {     verify().     return read(reader).getObject(). }
true;public;1;7;/**  * Return {@link ObjectContent} from reading from the specified reader.  * @param reader the source reader  * @return the {@link ObjectContent}  * @throws IOException on read error  */ ;/**  * Return {@link ObjectContent} from reading from the specified reader.  * @param reader the source reader  * @return the {@link ObjectContent}  * @throws IOException on read error  */ public ObjectContent<T> read(Reader reader) throws IOException {     verify().     Assert.notNull(reader, "Reader must not be null").     T object = readObject(reader, this.type).     closeQuietly(reader).     return new ObjectContent<>(this.type, object). }
false;private;1;7;;private void closeQuietly(Closeable closeable) {     try {         closeable.close().     } catch (IOException ex) {     } }
false;private;0;5;;private void verify() {     Assert.state(this.resourceLoadClass != null, "Uninitialized JsonMarshalTester (ResourceLoadClass is null)").     Assert.state(this.type != null, "Uninitialized JsonMarshalTester (Type is null)"). }
true;protected,abstract;2;2;/**  * Write the specified object to a JSON string.  * @param value the source value (never {@code null})  * @param type the resulting type (never {@code null})  * @return the JSON string  * @throws IOException on write error  */ ;/**  * Write the specified object to a JSON string.  * @param value the source value (never {@code null})  * @param type the resulting type (never {@code null})  * @return the JSON string  * @throws IOException on write error  */ protected abstract String writeObject(T value, ResolvableType type) throws IOException.
true;protected;2;5;/**  * Read from the specified input stream to create an object of the specified type. The  * default implementation delegates to {@link #readObject(Reader, ResolvableType)}.  * @param inputStream the source input stream (never {@code null})  * @param type the resulting type (never {@code null})  * @return the resulting object  * @throws IOException on read error  */ ;/**  * Read from the specified input stream to create an object of the specified type. The  * default implementation delegates to {@link #readObject(Reader, ResolvableType)}.  * @param inputStream the source input stream (never {@code null})  * @param type the resulting type (never {@code null})  * @return the resulting object  * @throws IOException on read error  */ protected T readObject(InputStream inputStream, ResolvableType type) throws IOException {     BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)).     return readObject(reader, type). }
true;protected,abstract;2;2;/**  * Read from the specified reader to create an object of the specified type.  * @param reader the source reader (never {@code null})  * @param type the resulting type (never {@code null})  * @return the resulting object  * @throws IOException on read error  */ ;/**  * Read from the specified reader to create an object of the specified type.  * @param reader the source reader (never {@code null})  * @param type the resulting type (never {@code null})  * @return the resulting object  * @throws IOException on read error  */ protected abstract T readObject(Reader reader, ResolvableType type) throws IOException.
false;public;2;5;;public void initFields(Object testInstance, M marshaller) {     Assert.notNull(testInstance, "TestInstance must not be null").     Assert.notNull(marshaller, "Marshaller must not be null").     initFields(testInstance, () -> marshaller). }
false;public;2;6;;public void initFields(Object testInstance, final ObjectFactory<M> marshaller) {     Assert.notNull(testInstance, "TestInstance must not be null").     Assert.notNull(marshaller, "Marshaller must not be null").     ReflectionUtils.doWithFields(testInstance.getClass(), (field) -> doWithField(field, testInstance, marshaller)). }
false;protected;3;10;;protected void doWithField(Field field, Object test, ObjectFactory<M> marshaller) {     if (this.testerClass.isAssignableFrom(field.getType())) {         ReflectionUtils.makeAccessible(field).         Object existingValue = ReflectionUtils.getField(field, test).         if (existingValue == null) {             setupField(field, test, marshaller).         }     } }
false;private;3;5;;private void setupField(Field field, Object test, ObjectFactory<M> marshaller) {     ResolvableType type = ResolvableType.forField(field).getGeneric().     ReflectionUtils.setField(field, test, createTester(test.getClass(), type, marshaller.getObject())). }
false;protected,abstract;3;2;;protected abstract AbstractJsonMarshalTester<Object> createTester(Class<?> resourceLoadClass, ResolvableType type, M marshaller).
