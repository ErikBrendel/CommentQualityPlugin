commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Set {@link UndertowBuilderCustomizer}s that should be applied to the Undertow  * {@link Builder}. Calling this method will replace any existing customizers.  * @param customizers the customizers to set  */ ;/**  * Set {@link UndertowBuilderCustomizer}s that should be applied to the Undertow  * {@link Builder}. Calling this method will replace any existing customizers.  * @param customizers the customizers to set  */ public void setBuilderCustomizers(Collection<? extends UndertowBuilderCustomizer> customizers) {     Assert.notNull(customizers, "Customizers must not be null").     this.builderCustomizers = new ArrayList<>(customizers). }
true;public;0;3;/**  * Returns a mutable collection of the {@link UndertowBuilderCustomizer}s that will be  * applied to the Undertow {@link Builder}.  * @return the customizers that will be applied  */ ;/**  * Returns a mutable collection of the {@link UndertowBuilderCustomizer}s that will be  * applied to the Undertow {@link Builder}.  * @return the customizers that will be applied  */ public Collection<UndertowBuilderCustomizer> getBuilderCustomizers() {     return this.builderCustomizers. }
false;public;1;5;;@Override public void addBuilderCustomizers(UndertowBuilderCustomizer... customizers) {     Assert.notNull(customizers, "Customizers must not be null").     this.builderCustomizers.addAll(Arrays.asList(customizers)). }
true;public;1;5;/**  * Set {@link UndertowDeploymentInfoCustomizer}s that should be applied to the  * Undertow {@link DeploymentInfo}. Calling this method will replace any existing  * customizers.  * @param customizers the customizers to set  */ ;/**  * Set {@link UndertowDeploymentInfoCustomizer}s that should be applied to the  * Undertow {@link DeploymentInfo}. Calling this method will replace any existing  * customizers.  * @param customizers the customizers to set  */ public void setDeploymentInfoCustomizers(Collection<? extends UndertowDeploymentInfoCustomizer> customizers) {     Assert.notNull(customizers, "Customizers must not be null").     this.deploymentInfoCustomizers = new ArrayList<>(customizers). }
true;public;0;3;/**  * Returns a mutable collection of the {@link UndertowDeploymentInfoCustomizer}s that  * will be applied to the Undertow {@link DeploymentInfo}.  * @return the customizers that will be applied  */ ;/**  * Returns a mutable collection of the {@link UndertowDeploymentInfoCustomizer}s that  * will be applied to the Undertow {@link DeploymentInfo}.  * @return the customizers that will be applied  */ public Collection<UndertowDeploymentInfoCustomizer> getDeploymentInfoCustomizers() {     return this.deploymentInfoCustomizers. }
false;public;1;6;;@Override public void addDeploymentInfoCustomizers(UndertowDeploymentInfoCustomizer... customizers) {     Assert.notNull(customizers, "UndertowDeploymentInfoCustomizers must not be null").     this.deploymentInfoCustomizers.addAll(Arrays.asList(customizers)). }
false;public;1;7;;@Override public WebServer getWebServer(ServletContextInitializer... initializers) {     DeploymentManager manager = createDeploymentManager(initializers).     int port = getPort().     Builder builder = createBuilder(port).     return getUndertowWebServer(builder, manager, port). }
false;private;1;25;;private Builder createBuilder(int port) {     Builder builder = Undertow.builder().     if (this.bufferSize != null) {         builder.setBufferSize(this.bufferSize).     }     if (this.ioThreads != null) {         builder.setIoThreads(this.ioThreads).     }     if (this.workerThreads != null) {         builder.setWorkerThreads(this.workerThreads).     }     if (this.directBuffers != null) {         builder.setDirectBuffers(this.directBuffers).     }     if (getSsl() != null && getSsl().isEnabled()) {         customizeSsl(builder).     } else {         builder.addHttpListener(port, getListenAddress()).     }     for (UndertowBuilderCustomizer customizer : this.builderCustomizers) {         customizer.customize(builder).     }     return builder. }
false;private;1;7;;private void customizeSsl(Builder builder) {     new SslBuilderCustomizer(getPort(), getAddress(), getSsl(), getSslStoreProvider()).customize(builder).     if (getHttp2() != null) {         builder.setServerOption(UndertowOptions.ENABLE_HTTP2, getHttp2().isEnabled()).     } }
false;private;0;6;;private String getListenAddress() {     if (getAddress() == null) {         return "0.0.0.0".     }     return getAddress().getHostAddress(). }
false;private;1;37;;private DeploymentManager createDeploymentManager(ServletContextInitializer... initializers) {     DeploymentInfo deployment = Servlets.deployment().     registerServletContainerInitializerToDriveServletContextInitializers(deployment, initializers).     deployment.setClassLoader(getServletClassLoader()).     deployment.setContextPath(getContextPath()).     deployment.setDisplayName(getDisplayName()).     deployment.setDeploymentName("spring-boot").     if (isRegisterDefaultServlet()) {         deployment.addServlet(Servlets.servlet("default", DefaultServlet.class)).     }     configureErrorPages(deployment).     deployment.setServletStackTraces(ServletStackTraces.NONE).     deployment.setResourceManager(getDocumentRootResourceManager()).     deployment.setEagerFilterInit(this.eagerInitFilters).     configureMimeMappings(deployment).     for (UndertowDeploymentInfoCustomizer customizer : this.deploymentInfoCustomizers) {         customizer.customize(deployment).     }     if (isAccessLogEnabled()) {         configureAccessLog(deployment).     }     if (getSession().isPersistent()) {         File dir = getValidSessionStoreDir().         deployment.setSessionPersistenceManager(new FileSessionPersistence(dir)).     }     addLocaleMappings(deployment).     DeploymentManager manager = Servlets.newContainer().addDeployment(deployment).     manager.deploy().     SessionManager sessionManager = manager.getDeployment().getSessionManager().     Duration timeoutDuration = getSession().getTimeout().     int sessionTimeout = (isZeroOrLess(timeoutDuration) ? -1 : (int) timeoutDuration.getSeconds()).     sessionManager.setDefaultSessionTimeout(sessionTimeout).     return manager. }
false;private;1;4;;private boolean isZeroOrLess(Duration timeoutDuration) {     return timeoutDuration == null || timeoutDuration.isZero() || timeoutDuration.isNegative(). }
false;private;1;20;;private void configureAccessLog(DeploymentInfo deploymentInfo) {     try {         createAccessLogDirectoryIfNecessary().         XnioWorker worker = createWorker().         String prefix = (this.accessLogPrefix != null) ? this.accessLogPrefix : "access_log.".         DefaultAccessLogReceiver accessLogReceiver = new DefaultAccessLogReceiver(worker, this.accessLogDirectory, prefix, this.accessLogSuffix, this.accessLogRotate).         EventListener listener = new AccessLogShutdownListener(worker, accessLogReceiver).         deploymentInfo.addListener(new ListenerInfo(AccessLogShutdownListener.class, new ImmediateInstanceFactory<>(listener))).         deploymentInfo.addInitialHandlerChainWrapper((handler) -> createAccessLogHandler(handler, accessLogReceiver)).     } catch (IOException ex) {         throw new IllegalStateException("Failed to create AccessLogHandler", ex).     } }
false;private;2;8;;private AccessLogHandler createAccessLogHandler(HttpHandler handler, AccessLogReceiver accessLogReceiver) {     createAccessLogDirectoryIfNecessary().     String formatString = (this.accessLogPattern != null) ? this.accessLogPattern : "common".     return new AccessLogHandler(handler, accessLogReceiver, formatString, Undertow.class.getClassLoader()). }
false;private;0;7;;private void createAccessLogDirectoryIfNecessary() {     Assert.state(this.accessLogDirectory != null, "Access log directory is not set").     if (!this.accessLogDirectory.isDirectory() && !this.accessLogDirectory.mkdirs()) {         throw new IllegalStateException("Failed to create access log directory '" + this.accessLogDirectory + "'").     } }
false;private;0;5;;private XnioWorker createWorker() throws IOException {     Xnio xnio = Xnio.getInstance(Undertow.class.getClassLoader()).     return xnio.createWorker(OptionMap.builder().set(Options.THREAD_DAEMON, true).getMap()). }
false;private;1;4;;private void addLocaleMappings(DeploymentInfo deployment) {     getLocaleCharsetMappings().forEach((locale, charset) -> deployment.addLocaleCharsetMapping(locale.toString(), charset.toString())). }
false;private;2;9;;private void registerServletContainerInitializerToDriveServletContextInitializers(DeploymentInfo deployment, ServletContextInitializer... initializers) {     ServletContextInitializer[] mergedInitializers = mergeInitializers(initializers).     Initializer initializer = new Initializer(mergedInitializers).     deployment.addServletContainerInitializer(new ServletContainerInitializerInfo(Initializer.class, new ImmediateInstanceFactory<ServletContainerInitializer>(initializer), NO_CLASSES)). }
false;private;0;6;;private ClassLoader getServletClassLoader() {     if (this.resourceLoader != null) {         return this.resourceLoader.getClassLoader().     }     return getClass().getClassLoader(). }
false;private;0;35;;private ResourceManager getDocumentRootResourceManager() {     File root = getValidDocumentRoot().     File docBase = getCanonicalDocumentRoot(root).     List<URL> metaInfResourceUrls = getUrlsOfJarsWithMetaInfResources().     List<URL> resourceJarUrls = new ArrayList<>().     List<ResourceManager> managers = new ArrayList<>().     ResourceManager rootManager = (docBase.isDirectory() ? new FileResourceManager(docBase, 0) : new JarResourceManager(docBase)).     if (root != null) {         rootManager = new LoaderHidingResourceManager(rootManager).     }     managers.add(rootManager).     for (URL url : metaInfResourceUrls) {         if ("file".equals(url.getProtocol())) {             try {                 File file = new File(url.toURI()).                 if (file.isFile()) {                     resourceJarUrls.add(new URL("jar:" + url + "!/")).                 } else {                     managers.add(new FileResourceManager(new File(file, "META-INF/resources"), 0)).                 }             } catch (Exception ex) {                 throw new RuntimeException(ex).             }         } else {             resourceJarUrls.add(url).         }     }     managers.add(new MetaInfResourcesResourceManager(resourceJarUrls)).     return new CompositeResourceManager(managers.toArray(new ResourceManager[0])). }
false;private;1;9;;private File getCanonicalDocumentRoot(File docBase) {     try {         File root = (docBase != null) ? docBase : createTempDir("undertow-docbase").         return root.getCanonicalFile().     } catch (IOException ex) {         throw new IllegalStateException("Cannot get canonical document root", ex).     } }
false;private;1;5;;private void configureErrorPages(DeploymentInfo servletBuilder) {     for (ErrorPage errorPage : getErrorPages()) {         servletBuilder.addErrorPage(getUndertowErrorPage(errorPage)).     } }
false;private;1;11;;private io.undertow.servlet.api.ErrorPage getUndertowErrorPage(ErrorPage errorPage) {     if (errorPage.getStatus() != null) {         return new io.undertow.servlet.api.ErrorPage(errorPage.getPath(), errorPage.getStatusCode()).     }     if (errorPage.getException() != null) {         return new io.undertow.servlet.api.ErrorPage(errorPage.getPath(), errorPage.getException()).     }     return new io.undertow.servlet.api.ErrorPage(errorPage.getPath()). }
false;private;1;6;;private void configureMimeMappings(DeploymentInfo servletBuilder) {     for (Mapping mimeMapping : getMimeMappings()) {         servletBuilder.addMimeMapping(new MimeMapping(mimeMapping.getExtension(), mimeMapping.getMimeType())).     } }
true;protected;3;5;/**  * Factory method called to create the {@link UndertowServletWebServer}. Subclasses  * can override this method to return a different {@link UndertowServletWebServer} or  * apply additional processing to the {@link Builder} and {@link DeploymentManager}  * used to bootstrap Undertow  * @param builder the builder  * @param manager the deployment manager  * @param port the port that Undertow should listen on  * @return a new {@link UndertowServletWebServer} instance  */ ;/**  * Factory method called to create the {@link UndertowServletWebServer}. Subclasses  * can override this method to return a different {@link UndertowServletWebServer} or  * apply additional processing to the {@link Builder} and {@link DeploymentManager}  * used to bootstrap Undertow  * @param builder the builder  * @param manager the deployment manager  * @param port the port that Undertow should listen on  * @return a new {@link UndertowServletWebServer} instance  */ protected UndertowServletWebServer getUndertowWebServer(Builder builder, DeploymentManager manager, int port) {     return new UndertowServletWebServer(builder, manager, getContextPath(), isUseForwardHeaders(), port >= 0, getCompression(), getServerHeader()). }
false;public;1;4;;@Override public void setResourceLoader(ResourceLoader resourceLoader) {     this.resourceLoader = resourceLoader. }
false;public;1;4;;@Override public void setBufferSize(Integer bufferSize) {     this.bufferSize = bufferSize. }
false;public;1;4;;@Override public void setIoThreads(Integer ioThreads) {     this.ioThreads = ioThreads. }
false;public;1;4;;@Override public void setWorkerThreads(Integer workerThreads) {     this.workerThreads = workerThreads. }
false;public;1;4;;@Override public void setUseDirectBuffers(Boolean directBuffers) {     this.directBuffers = directBuffers. }
false;public;1;4;;@Override public void setAccessLogDirectory(File accessLogDirectory) {     this.accessLogDirectory = accessLogDirectory. }
false;public;1;4;;@Override public void setAccessLogPattern(String accessLogPattern) {     this.accessLogPattern = accessLogPattern. }
false;public;0;3;;public String getAccessLogPrefix() {     return this.accessLogPrefix. }
false;public;1;4;;@Override public void setAccessLogPrefix(String accessLogPrefix) {     this.accessLogPrefix = accessLogPrefix. }
false;public;1;4;;@Override public void setAccessLogSuffix(String accessLogSuffix) {     this.accessLogSuffix = accessLogSuffix. }
false;public;1;4;;@Override public void setAccessLogEnabled(boolean accessLogEnabled) {     this.accessLogEnabled = accessLogEnabled. }
false;public;0;3;;public boolean isAccessLogEnabled() {     return this.accessLogEnabled. }
false;public;1;4;;@Override public void setAccessLogRotate(boolean accessLogRotate) {     this.accessLogRotate = accessLogRotate. }
false;protected,final;0;3;;protected final boolean isUseForwardHeaders() {     return this.useForwardHeaders. }
false;public;1;4;;@Override public void setUseForwardHeaders(boolean useForwardHeaders) {     this.useForwardHeaders = useForwardHeaders. }
true;public;0;3;/**  * Return if filters should be initialized eagerly.  * @return {@code true} if filters are initialized eagerly, otherwise {@code false}.  * @since 2.0.0  */ ;/**  * Return if filters should be initialized eagerly.  * @return {@code true} if filters are initialized eagerly, otherwise {@code false}.  * @since 2.0.0  */ public boolean isEagerInitFilters() {     return this.eagerInitFilters. }
true;public;1;3;/**  * Set whether filters should be initialized eagerly.  * @param eagerInitFilters {@code true} if filters are initialized eagerly, otherwise  * {@code false}.  * @since 2.0.0  */ ;/**  * Set whether filters should be initialized eagerly.  * @param eagerInitFilters {@code true} if filters are initialized eagerly, otherwise  * {@code false}.  * @since 2.0.0  */ public void setEagerInitFilters(boolean eagerInitFilters) {     this.eagerInitFilters = eagerInitFilters. }
false;public;0;3;;@Override public void close() throws IOException { }
false;public;1;10;;@Override public Resource getResource(String path) {     for (URL url : this.metaInfResourceJarUrls) {         URLResource resource = getMetaInfResource(url, path).         if (resource != null) {             return resource.         }     }     return null. }
false;public;0;4;;@Override public boolean isResourceChangeListenerSupported() {     return false. }
false;public;1;3;;@Override public void registerResourceChangeListener(ResourceChangeListener listener) { }
false;public;1;4;;@Override public void removeResourceChangeListener(ResourceChangeListener listener) { }
false;private;2;13;;private URLResource getMetaInfResource(URL resourceJar, String path) {     try {         URL resourceUrl = new URL(resourceJar + "META-INF/resources" + path).         URLResource resource = new URLResource(resourceUrl, path).         if (resource.getContentLength() < 0) {             return null.         }         return resource.     } catch (MalformedURLException ex) {         return null.     } }
false;public;2;7;;@Override public void onStartup(Set<Class<?>> classes, ServletContext servletContext) throws ServletException {     for (ServletContextInitializer initializer : this.initializers) {         initializer.onStartup(servletContext).     } }
false;public;1;7;;@Override public Resource getResource(String path) throws IOException {     if (path.startsWith("/org/springframework/boot")) {         return null.     }     return this.delegate.getResource(path). }
false;public;0;4;;@Override public boolean isResourceChangeListenerSupported() {     return this.delegate.isResourceChangeListenerSupported(). }
false;public;1;4;;@Override public void registerResourceChangeListener(ResourceChangeListener listener) {     this.delegate.registerResourceChangeListener(listener). }
false;public;1;4;;@Override public void removeResourceChangeListener(ResourceChangeListener listener) {     this.delegate.removeResourceChangeListener(listener). }
false;public;0;4;;@Override public void close() throws IOException {     this.delegate.close(). }
false;public;1;3;;@Override public void contextInitialized(ServletContextEvent sce) { }
false;public;1;10;;@Override public void contextDestroyed(ServletContextEvent sce) {     try {         this.accessLogReceiver.close().         this.worker.shutdown().     } catch (IOException ex) {         throw new IllegalStateException(ex).     } }
