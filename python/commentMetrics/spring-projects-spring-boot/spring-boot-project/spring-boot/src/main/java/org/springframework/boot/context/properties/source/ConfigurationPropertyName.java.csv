commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns {@code true} if this {@link ConfigurationPropertyName} is empty.  * @return {@code true} if the name is empty  */ ;/**  * Returns {@code true} if this {@link ConfigurationPropertyName} is empty.  * @return {@code true} if the name is empty  */ public boolean isEmpty() {     return this.elements.getSize() == 0. }
true;public;0;4;/**  * Return if the last element in the name is indexed.  * @return {@code true} if the last element is indexed  */ ;/**  * Return if the last element in the name is indexed.  * @return {@code true} if the last element is indexed  */ public boolean isLastElementIndexed() {     int size = getNumberOfElements().     return (size > 0 && isIndexed(size - 1)). }
true;;1;3;/**  * Return if the element in the name is indexed.  * @param elementIndex the index of the element  * @return {@code true} if the element is indexed  */ ;/**  * Return if the element in the name is indexed.  * @param elementIndex the index of the element  * @return {@code true} if the element is indexed  */ boolean isIndexed(int elementIndex) {     return this.elements.getType(elementIndex).isIndexed(). }
true;public;1;3;/**  * Return if the element in the name is indexed and numeric.  * @param elementIndex the index of the element  * @return {@code true} if the element is indexed and numeric  */ ;/**  * Return if the element in the name is indexed and numeric.  * @param elementIndex the index of the element  * @return {@code true} if the element is indexed and numeric  */ public boolean isNumericIndex(int elementIndex) {     return this.elements.getType(elementIndex) == ElementType.NUMERICALLY_INDEXED. }
true;public;1;4;/**  * Return the last element in the name in the given form.  * @param form the form to return  * @return the last element  */ ;/**  * Return the last element in the name in the given form.  * @param form the form to return  * @return the last element  */ public String getLastElement(Form form) {     int size = getNumberOfElements().     return (size != 0) ? getElement(size - 1, form) : EMPTY_STRING. }
true;public;2;26;/**  * Return an element in the name in the given form.  * @param elementIndex the element index  * @param form the form to return  * @return the last element  */ ;/**  * Return an element in the name in the given form.  * @param elementIndex the element index  * @param form the form to return  * @return the last element  */ public String getElement(int elementIndex, Form form) {     CharSequence element = this.elements.get(elementIndex).     ElementType type = this.elements.getType(elementIndex).     if (type.isIndexed()) {         return element.toString().     }     if (form == Form.ORIGINAL) {         if (type != ElementType.NON_UNIFORM) {             return element.toString().         }         return convertToOriginalForm(element).toString().     }     if (form == Form.DASHED) {         if (type == ElementType.UNIFORM || type == ElementType.DASHED) {             return element.toString().         }         return convertToDashedElement(element).toString().     }     CharSequence uniformElement = this.uniformElements[elementIndex].     if (uniformElement == null) {         uniformElement = (type != ElementType.UNIFORM) ? convertToUniformElement(element) : element.         this.uniformElements[elementIndex] = uniformElement.toString().     }     return uniformElement.toString(). }
false;private;1;4;;private CharSequence convertToOriginalForm(CharSequence element) {     return convertElement(element, false, (ch, i) -> ch == '_' || ElementsParser.isValidChar(Character.toLowerCase(ch), i)). }
false;private;1;3;;private CharSequence convertToDashedElement(CharSequence element) {     return convertElement(element, true, ElementsParser::isValidChar). }
false;private;1;4;;private CharSequence convertToUniformElement(CharSequence element) {     return convertElement(element, true, (ch, i) -> ElementsParser.isAlphaNumeric(ch)). }
false;private;3;12;;private CharSequence convertElement(CharSequence element, boolean lowercase, ElementCharPredicate filter) {     StringBuilder result = new StringBuilder(element.length()).     for (int i = 0. i < element.length(). i++) {         char ch = lowercase ? Character.toLowerCase(element.charAt(i)) : element.charAt(i).         if (filter.test(ch, i)) {             result.append(ch).         }     }     return result. }
true;public;0;3;/**  * Return the total number of elements in the name.  * @return the number of elements  */ ;/**  * Return the total number of elements in the name.  * @return the number of elements  */ public int getNumberOfElements() {     return this.elements.getSize(). }
true;public;1;7;/**  * Create a new {@link ConfigurationPropertyName} by appending the given element  * value.  * @param elementValue the single element value to append  * @return a new {@link ConfigurationPropertyName}  * @throws InvalidConfigurationPropertyNameException if elementValue is not valid  */ ;/**  * Create a new {@link ConfigurationPropertyName} by appending the given element  * value.  * @param elementValue the single element value to append  * @return a new {@link ConfigurationPropertyName}  * @throws InvalidConfigurationPropertyNameException if elementValue is not valid  */ public ConfigurationPropertyName append(String elementValue) {     if (elementValue == null) {         return this.     }     Elements additionalElements = probablySingleElementOf(elementValue).     return new ConfigurationPropertyName(this.elements.append(additionalElements)). }
true;public;1;6;/**  * Return a new {@link ConfigurationPropertyName} by chopping this name to the given  * {@code size}. For example, {@code chop(1)} on the name {@code foo.bar} will return  * {@code foo}.  * @param size the size to chop  * @return the chopped name  */ ;/**  * Return a new {@link ConfigurationPropertyName} by chopping this name to the given  * {@code size}. For example, {@code chop(1)} on the name {@code foo.bar} will return  * {@code foo}.  * @param size the size to chop  * @return the chopped name  */ public ConfigurationPropertyName chop(int size) {     if (size >= getNumberOfElements()) {         return this.     }     return new ConfigurationPropertyName(this.elements.chop(size)). }
true;public;1;7;/**  * Returns {@code true} if this element is an immediate parent of the specified name.  * @param name the name to check  * @return {@code true} if this name is an ancestor  */ ;/**  * Returns {@code true} if this element is an immediate parent of the specified name.  * @param name the name to check  * @return {@code true} if this name is an ancestor  */ public boolean isParentOf(ConfigurationPropertyName name) {     Assert.notNull(name, "Name must not be null").     if (this.getNumberOfElements() != name.getNumberOfElements() - 1) {         return false.     }     return isAncestorOf(name). }
true;public;1;12;/**  * Returns {@code true} if this element is an ancestor (immediate or nested parent) of  * the specified name.  * @param name the name to check  * @return {@code true} if this name is an ancestor  */ ;/**  * Returns {@code true} if this element is an ancestor (immediate or nested parent) of  * the specified name.  * @param name the name to check  * @return {@code true} if this name is an ancestor  */ public boolean isAncestorOf(ConfigurationPropertyName name) {     Assert.notNull(name, "Name must not be null").     if (this.getNumberOfElements() >= name.getNumberOfElements()) {         return false.     }     for (int i = this.elements.getSize() - 1. i >= 0. i--) {         if (!elementEquals(this.elements, name.elements, i)) {             return false.         }     }     return true. }
false;public;1;4;;@Override public int compareTo(ConfigurationPropertyName other) {     return compare(this, other). }
false;private;2;22;;private int compare(ConfigurationPropertyName n1, ConfigurationPropertyName n2) {     int l1 = n1.getNumberOfElements().     int l2 = n2.getNumberOfElements().     int i1 = 0.     int i2 = 0.     while (i1 < l1 || i2 < l2) {         try {             ElementType type1 = (i1 < l1) ? n1.elements.getType(i1) : null.             ElementType type2 = (i2 < l2) ? n2.elements.getType(i2) : null.             String e1 = (i1 < l1) ? n1.getElement(i1++, Form.UNIFORM) : null.             String e2 = (i2 < l2) ? n2.getElement(i2++, Form.UNIFORM) : null.             int result = compare(e1, type1, e2, type2).             if (result != 0) {                 return result.             }         } catch (ArrayIndexOutOfBoundsException ex) {             throw new RuntimeException(ex).         }     }     return 0. }
false;private;4;19;;private int compare(String e1, ElementType type1, String e2, ElementType type2) {     if (e1 == null) {         return -1.     }     if (e2 == null) {         return 1.     }     int result = Boolean.compare(type2.isIndexed(), type1.isIndexed()).     if (result != 0) {         return result.     }     if (type1 == ElementType.NUMERICALLY_INDEXED && type2 == ElementType.NUMERICALLY_INDEXED) {         long v1 = Long.parseLong(e1).         long v2 = Long.parseLong(e2).         return Long.compare(v1, v2).     }     return e1.compareTo(e2). }
false;public;1;23;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     }     if (obj == null || obj.getClass() != getClass()) {         return false.     }     ConfigurationPropertyName other = (ConfigurationPropertyName) obj.     if (getNumberOfElements() != other.getNumberOfElements()) {         return false.     }     if (this.elements.canShortcutWithSource(ElementType.UNIFORM) && other.elements.canShortcutWithSource(ElementType.UNIFORM)) {         return toString().equals(other.toString()).     }     for (int i = this.elements.getSize() - 1. i >= 0. i--) {         if (!elementEquals(this.elements, other.elements, i)) {             return false.         }     }     return true. }
false;private;3;37;;private boolean elementEquals(Elements e1, Elements e2, int i) {     int l1 = e1.getLength(i).     int l2 = e2.getLength(i).     boolean indexed1 = e1.getType(i).isIndexed().     boolean indexed2 = e2.getType(i).isIndexed().     int i1 = 0.     int i2 = 0.     while (i1 < l1) {         if (i2 >= l2) {             return false.         }         char ch1 = indexed1 ? e1.charAt(i, i1) : Character.toLowerCase(e1.charAt(i, i1)).         char ch2 = indexed2 ? e2.charAt(i, i2) : Character.toLowerCase(e2.charAt(i, i2)).         if (!indexed1 && !ElementsParser.isAlphaNumeric(ch1)) {             i1++.         } else if (!indexed2 && !ElementsParser.isAlphaNumeric(ch2)) {             i2++.         } else if (ch1 != ch2) {             return false.         } else {             i1++.             i2++.         }     }     while (i2 < l2) {         char ch2 = Character.toLowerCase(e2.charAt(i, i2++)).         if (indexed2 || ElementsParser.isAlphaNumeric(ch2)) {             return false.         }     }     return true. }
false;public;0;4;;@Override public int hashCode() {     return 0. }
false;public;0;7;;@Override public String toString() {     if (this.string == null) {         this.string = buildToString().     }     return this.string. }
false;private;0;23;;private String buildToString() {     if (this.elements.canShortcutWithSource(ElementType.UNIFORM, ElementType.DASHED)) {         return this.elements.getSource().toString().     }     int elements = getNumberOfElements().     StringBuilder result = new StringBuilder(elements * 8).     for (int i = 0. i < elements. i++) {         boolean indexed = isIndexed(i).         if (result.length() > 0 && !indexed) {             result.append('.').         }         if (indexed) {             result.append("[").             result.append(getElement(i, Form.ORIGINAL)).             result.append("]").         } else {             result.append(getElement(i, Form.DASHED)).         }     }     return result.toString(). }
true;public,static;1;3;/**  * Returns if the given name is valid. If this method returns {@code true} then the  * name may be used with {@link #of(CharSequence)} without throwing an exception.  * @param name the name to test  * @return {@code true} if the name is valid  */ ;/**  * Returns if the given name is valid. If this method returns {@code true} then the  * name may be used with {@link #of(CharSequence)} without throwing an exception.  * @param name the name to test  * @return {@code true} if the name is valid  */ public static boolean isValid(CharSequence name) {     return of(name, true) != null. }
true;public,static;1;3;/**  * Return a {@link ConfigurationPropertyName} for the specified string.  * @param name the source name  * @return a {@link ConfigurationPropertyName} instance  * @throws InvalidConfigurationPropertyNameException if the name is not valid  */ ;/**  * Return a {@link ConfigurationPropertyName} for the specified string.  * @param name the source name  * @return a {@link ConfigurationPropertyName} instance  * @throws InvalidConfigurationPropertyNameException if the name is not valid  */ public static ConfigurationPropertyName of(CharSequence name) {     return of(name, false). }
true;static;2;4;/**  * Return a {@link ConfigurationPropertyName} for the specified string.  * @param name the source name  * @param returnNullIfInvalid if null should be returned if the name is not valid  * @return a {@link ConfigurationPropertyName} instance  * @throws InvalidConfigurationPropertyNameException if the name is not valid and  * {@code returnNullIfInvalid} is {@code false}  */ ;/**  * Return a {@link ConfigurationPropertyName} for the specified string.  * @param name the source name  * @param returnNullIfInvalid if null should be returned if the name is not valid  * @return a {@link ConfigurationPropertyName} instance  * @throws InvalidConfigurationPropertyNameException if the name is not valid and  * {@code returnNullIfInvalid} is {@code false}  */ static ConfigurationPropertyName of(CharSequence name, boolean returnNullIfInvalid) {     Elements elements = elementsOf(name, returnNullIfInvalid).     return (elements != null) ? new ConfigurationPropertyName(elements) : null. }
false;private,static;1;3;;private static Elements probablySingleElementOf(CharSequence name) {     return elementsOf(name, false, 1). }
false;private,static;2;3;;private static Elements elementsOf(CharSequence name, boolean returnNullIfInvalid) {     return elementsOf(name, returnNullIfInvalid, ElementsParser.DEFAULT_CAPACITY). }
false;private,static;3;28;;private static Elements elementsOf(CharSequence name, boolean returnNullIfInvalid, int parserCapacity) {     if (name == null) {         Assert.isTrue(returnNullIfInvalid, "Name must not be null").         return null.     }     if (name.length() == 0) {         return Elements.EMPTY.     }     if (name.charAt(0) == '.' || name.charAt(name.length() - 1) == '.') {         if (returnNullIfInvalid) {             return null.         }         throw new InvalidConfigurationPropertyNameException(name, Collections.singletonList('.')).     }     Elements elements = new ElementsParser(name, '.', parserCapacity).parse().     for (int i = 0. i < elements.getSize(). i++) {         if (elements.getType(i) == ElementType.NON_UNIFORM) {             if (returnNullIfInvalid) {                 return null.             }             throw new InvalidConfigurationPropertyNameException(name, getInvalidChars(elements, i)).         }     }     return elements. }
false;private,static;2;10;;private static List<Character> getInvalidChars(Elements elements, int index) {     List<Character> invalidChars = new ArrayList<>().     for (int charIndex = 0. charIndex < elements.getLength(index). charIndex++) {         char ch = elements.charAt(index, charIndex).         if (!ElementsParser.isValidChar(ch, charIndex)) {             invalidChars.add(ch).         }     }     return invalidChars. }
true;static;2;3;/**  * Create a {@link ConfigurationPropertyName} by adapting the given source. See  * {@link #adapt(CharSequence, char, Function)} for details.  * @param name the name to parse  * @param separator the separator used to split the name  * @return a {@link ConfigurationPropertyName}  */ ;/**  * Create a {@link ConfigurationPropertyName} by adapting the given source. See  * {@link #adapt(CharSequence, char, Function)} for details.  * @param name the name to parse  * @param separator the separator used to split the name  * @return a {@link ConfigurationPropertyName}  */ static ConfigurationPropertyName adapt(CharSequence name, char separator) {     return adapt(name, separator, null). }
true;static;3;13;/**  * Create a {@link ConfigurationPropertyName} by adapting the given source. The name  * is split into elements around the given {@code separator}. This method is more  * lenient than {@link #of} in that it allows mixed case names and '{@code _}'  * characters. Other invalid characters are stripped out during parsing.  * <p>  * The {@code elementValueProcessor} function may be used if additional processing is  * required on the extracted element values.  * @param name the name to parse  * @param separator the separator used to split the name  * @param elementValueProcessor a function to process element values  * @return a {@link ConfigurationPropertyName}  */ ;/**  * Create a {@link ConfigurationPropertyName} by adapting the given source. The name  * is split into elements around the given {@code separator}. This method is more  * lenient than {@link #of} in that it allows mixed case names and '{@code _}'  * characters. Other invalid characters are stripped out during parsing.  * <p>  * The {@code elementValueProcessor} function may be used if additional processing is  * required on the extracted element values.  * @param name the name to parse  * @param separator the separator used to split the name  * @param elementValueProcessor a function to process element values  * @return a {@link ConfigurationPropertyName}  */ static ConfigurationPropertyName adapt(CharSequence name, char separator, Function<CharSequence, CharSequence> elementValueProcessor) {     Assert.notNull(name, "Name must not be null").     if (name.length() == 0) {         return EMPTY.     }     Elements elements = new ElementsParser(name, separator).parse(elementValueProcessor).     if (elements.getSize() == 0) {         return EMPTY.     }     return new ConfigurationPropertyName(elements). }
false;public;1;11;;public Elements append(Elements additional) {     Assert.isTrue(additional.getSize() == 1, () -> "Element value '" + additional.getSource() + "' must be a single item").     ElementType[] type = new ElementType[this.size + 1].     System.arraycopy(this.type, 0, type, 0, this.size).     type[this.size] = additional.type[0].     CharSequence[] resolved = newResolved(this.size + 1).     resolved[this.size] = additional.get(0).     return new Elements(this.source, this.size + 1, this.start, this.end, type, resolved). }
false;public;1;5;;public Elements chop(int size) {     CharSequence[] resolved = newResolved(size).     return new Elements(this.source, size, this.start, this.end, this.type, resolved). }
false;private;1;8;;private CharSequence[] newResolved(int size) {     CharSequence[] resolved = new CharSequence[size].     if (this.resolved != null) {         System.arraycopy(this.resolved, 0, resolved, 0, Math.min(size, this.size)).     }     return resolved. }
false;public;0;3;;public int getSize() {     return this.size. }
false;public;1;8;;public CharSequence get(int index) {     if (this.resolved != null && this.resolved[index] != null) {         return this.resolved[index].     }     int start = this.start[index].     int end = this.end[index].     return this.source.subSequence(start, end). }
false;public;1;8;;public int getLength(int index) {     if (this.resolved != null && this.resolved[index] != null) {         return this.resolved[index].length().     }     int start = this.start[index].     int end = this.end[index].     return end - start. }
false;public;2;7;;public char charAt(int index, int charIndex) {     if (this.resolved != null && this.resolved[index] != null) {         return this.resolved[index].charAt(charIndex).     }     int start = this.start[index].     return this.source.charAt(start + charIndex). }
false;public;1;3;;public ElementType getType(int index) {     return this.type[index]. }
false;public;0;3;;public CharSequence getSource() {     return this.source. }
true;public;1;3;/**  * Returns if the element source can be used as a shortcut for an operation such  * as {@code equals} or {@code toString}.  * @param requiredType the required type  * @return {@code true} if all elements match at least one of the types  */ ;/**  * Returns if the element source can be used as a shortcut for an operation such  * as {@code equals} or {@code toString}.  * @param requiredType the required type  * @return {@code true} if all elements match at least one of the types  */ public boolean canShortcutWithSource(ElementType requiredType) {     return canShortcutWithSource(requiredType, requiredType). }
true;public;2;16;/**  * Returns if the element source can be used as a shortcut for an operation such  * as {@code equals} or {@code toString}.  * @param requiredType the required type  * @param alternativeType and alternative required type  * @return {@code true} if all elements match at least one of the types  */ ;/**  * Returns if the element source can be used as a shortcut for an operation such  * as {@code equals} or {@code toString}.  * @param requiredType the required type  * @param alternativeType and alternative required type  * @return {@code true} if all elements match at least one of the types  */ public boolean canShortcutWithSource(ElementType requiredType, ElementType alternativeType) {     if (this.resolved != null) {         return false.     }     for (int i = 0. i < this.size. i++) {         ElementType type = this.type[i].         if (type != requiredType && type != alternativeType) {             return false.         }         if (i > 0 && this.end[i - 1] + 1 != this.start[i]) {             return false.         }     }     return true. }
false;public;0;3;;public Elements parse() {     return parse(null). }
false;public;1;39;;public Elements parse(Function<CharSequence, CharSequence> valueProcessor) {     int length = this.source.length().     int openBracketCount = 0.     int start = 0.     ElementType type = ElementType.EMPTY.     for (int i = 0. i < length. i++) {         char ch = this.source.charAt(i).         if (ch == '[') {             if (openBracketCount == 0) {                 add(start, i, type, valueProcessor).                 start = i + 1.                 type = ElementType.NUMERICALLY_INDEXED.             }             openBracketCount++.         } else if (ch == ']') {             openBracketCount--.             if (openBracketCount == 0) {                 add(start, i, type, valueProcessor).                 start = i + 1.                 type = ElementType.EMPTY.             }         } else if (!type.isIndexed() && ch == this.separator) {             add(start, i, type, valueProcessor).             start = i + 1.             type = ElementType.EMPTY.         } else {             type = updateType(type, ch, i - start).         }     }     if (openBracketCount != 0) {         type = ElementType.NON_UNIFORM.     }     add(start, length, type, valueProcessor).     return new Elements(this.source, this.size, this.start, this.end, this.type, this.resolved). }
false;private;3;22;;private ElementType updateType(ElementType existingType, char ch, int index) {     if (existingType.isIndexed()) {         if (existingType == ElementType.NUMERICALLY_INDEXED && !isNumeric(ch)) {             return ElementType.INDEXED.         }         return existingType.     }     if (existingType == ElementType.EMPTY && isValidChar(ch, index)) {         return (index == 0) ? ElementType.UNIFORM : ElementType.NON_UNIFORM.     }     if (existingType == ElementType.UNIFORM && ch == '-') {         return ElementType.DASHED.     }     if (!isValidChar(ch, index)) {         if (existingType == ElementType.EMPTY && !isValidChar(Character.toLowerCase(ch), index)) {             return ElementType.EMPTY.         }         return ElementType.NON_UNIFORM.     }     return existingType. }
false;private;4;28;;private void add(int start, int end, ElementType type, Function<CharSequence, CharSequence> valueProcessor) {     if ((end - start) < 1 || type == ElementType.EMPTY) {         return.     }     if (this.start.length == this.size) {         this.start = expand(this.start).         this.end = expand(this.end).         this.type = expand(this.type).         this.resolved = expand(this.resolved).     }     if (valueProcessor != null) {         if (this.resolved == null) {             this.resolved = new CharSequence[this.start.length].         }         CharSequence resolved = valueProcessor.apply(this.source.subSequence(start, end)).         Elements resolvedElements = new ElementsParser(resolved, '.').parse().         Assert.state(resolvedElements.getSize() == 1, "Resolved element must not contain multiple elements").         this.resolved[this.size] = resolvedElements.get(0).         type = resolvedElements.getType(0).     }     this.start[this.size] = start.     this.end[this.size] = end.     this.type[this.size] = type.     this.size++. }
false;private;1;5;;private int[] expand(int[] src) {     int[] dest = new int[src.length + DEFAULT_CAPACITY].     System.arraycopy(src, 0, dest, 0, src.length).     return dest. }
false;private;1;5;;private ElementType[] expand(ElementType[] src) {     ElementType[] dest = new ElementType[src.length + DEFAULT_CAPACITY].     System.arraycopy(src, 0, dest, 0, src.length).     return dest. }
false;private;1;8;;private CharSequence[] expand(CharSequence[] src) {     if (src == null) {         return null.     }     CharSequence[] dest = new CharSequence[src.length + DEFAULT_CAPACITY].     System.arraycopy(src, 0, dest, 0, src.length).     return dest. }
false;public,static;2;3;;public static boolean isValidChar(char ch, int index) {     return isAlpha(ch) || isNumeric(ch) || (index != 0 && ch == '-'). }
false;public,static;1;3;;public static boolean isAlphaNumeric(char ch) {     return isAlpha(ch) || isNumeric(ch). }
false;private,static;1;3;;private static boolean isAlpha(char ch) {     return ch >= 'a' && ch <= 'z'. }
false;private,static;1;3;;private static boolean isNumeric(char ch) {     return ch >= '0' && ch <= '9'. }
false;public;0;3;;public boolean isIndexed() {     return this.indexed. }
false;;2;1;;boolean test(char ch, int index).
