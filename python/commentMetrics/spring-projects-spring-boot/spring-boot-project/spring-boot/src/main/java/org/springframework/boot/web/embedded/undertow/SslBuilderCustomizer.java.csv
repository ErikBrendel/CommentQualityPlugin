commented;modifiers;parameterAmount;loc;comment;code
false;public;1;22;;@Override public void customize(Undertow.Builder builder) {     try {         SSLContext sslContext = SSLContext.getInstance(this.ssl.getProtocol()).         sslContext.init(getKeyManagers(this.ssl, this.sslStoreProvider), getTrustManagers(this.ssl, this.sslStoreProvider), null).         builder.addHttpsListener(this.port, getListenAddress(), sslContext).         builder.setSocketOption(Options.SSL_CLIENT_AUTH_MODE, getSslClientAuthMode(this.ssl)).         if (this.ssl.getEnabledProtocols() != null) {             builder.setSocketOption(Options.SSL_ENABLED_PROTOCOLS, Sequence.of(this.ssl.getEnabledProtocols())).         }         if (this.ssl.getCiphers() != null) {             builder.setSocketOption(Options.SSL_ENABLED_CIPHER_SUITES, Sequence.of(this.ssl.getCiphers())).         }     } catch (NoSuchAlgorithmException | KeyManagementException ex) {         throw new IllegalStateException(ex).     } }
false;private;0;6;;private String getListenAddress() {     if (this.address == null) {         return "0.0.0.0".     }     return this.address.getHostAddress(). }
false;private;1;9;;private SslClientAuthMode getSslClientAuthMode(Ssl ssl) {     if (ssl.getClientAuth() == Ssl.ClientAuth.NEED) {         return SslClientAuthMode.REQUIRED.     }     if (ssl.getClientAuth() == Ssl.ClientAuth.WANT) {         return SslClientAuthMode.REQUESTED.     }     return SslClientAuthMode.NOT_REQUESTED. }
false;private;2;21;;private KeyManager[] getKeyManagers(Ssl ssl, SslStoreProvider sslStoreProvider) {     try {         KeyStore keyStore = getKeyStore(ssl, sslStoreProvider).         KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()).         char[] keyPassword = (ssl.getKeyPassword() != null) ? ssl.getKeyPassword().toCharArray() : null.         if (keyPassword == null && ssl.getKeyStorePassword() != null) {             keyPassword = ssl.getKeyStorePassword().toCharArray().         }         keyManagerFactory.init(keyStore, keyPassword).         if (ssl.getKeyAlias() != null) {             return getConfigurableAliasKeyManagers(ssl, keyManagerFactory.getKeyManagers()).         }         return keyManagerFactory.getKeyManagers().     } catch (Exception ex) {         throw new IllegalStateException(ex).     } }
false;private;2;10;;private KeyManager[] getConfigurableAliasKeyManagers(Ssl ssl, KeyManager[] keyManagers) {     for (int i = 0. i < keyManagers.length. i++) {         if (keyManagers[i] instanceof X509ExtendedKeyManager) {             keyManagers[i] = new ConfigurableAliasKeyManager((X509ExtendedKeyManager) keyManagers[i], ssl.getKeyAlias()).         }     }     return keyManagers. }
false;private;2;8;;private KeyStore getKeyStore(Ssl ssl, SslStoreProvider sslStoreProvider) throws Exception {     if (sslStoreProvider != null) {         return sslStoreProvider.getKeyStore().     }     return loadKeyStore(ssl.getKeyStoreType(), ssl.getKeyStoreProvider(), ssl.getKeyStore(), ssl.getKeyStorePassword()). }
false;private;2;12;;private TrustManager[] getTrustManagers(Ssl ssl, SslStoreProvider sslStoreProvider) {     try {         KeyStore store = getTrustStore(ssl, sslStoreProvider).         TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()).         trustManagerFactory.init(store).         return trustManagerFactory.getTrustManagers().     } catch (Exception ex) {         throw new IllegalStateException(ex).     } }
false;private;2;8;;private KeyStore getTrustStore(Ssl ssl, SslStoreProvider sslStoreProvider) throws Exception {     if (sslStoreProvider != null) {         return sslStoreProvider.getTrustStore().     }     return loadTrustStore(ssl.getTrustStoreType(), ssl.getTrustStoreProvider(), ssl.getTrustStore(), ssl.getTrustStorePassword()). }
false;private;4;4;;private KeyStore loadKeyStore(String type, String provider, String resource, String password) throws Exception {     return loadStore(type, provider, resource, password). }
false;private;4;7;;private KeyStore loadTrustStore(String type, String provider, String resource, String password) throws Exception {     if (resource == null) {         return null.     }     return loadStore(type, provider, resource, password). }
false;private;4;16;;private KeyStore loadStore(String type, String provider, String resource, String password) throws Exception {     type = (type != null) ? type : "JKS".     KeyStore store = (provider != null) ? KeyStore.getInstance(type, provider) : KeyStore.getInstance(type).     try {         URL url = ResourceUtils.getURL(resource).         store.load(url.openStream(), (password != null) ? password.toCharArray() : null).         return store.     } catch (Exception ex) {         throw new WebServerException("Could not load key store '" + resource + "'", ex).     } }
false;public;3;6;;@Override public String chooseEngineClientAlias(String[] strings, Principal[] principals, SSLEngine sslEngine) {     return this.keyManager.chooseEngineClientAlias(strings, principals, sslEngine). }
false;public;3;8;;@Override public String chooseEngineServerAlias(String s, Principal[] principals, SSLEngine sslEngine) {     if (this.alias == null) {         return this.keyManager.chooseEngineServerAlias(s, principals, sslEngine).     }     return this.alias. }
false;public;3;5;;@Override public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {     return this.keyManager.chooseClientAlias(keyType, issuers, socket). }
false;public;3;5;;@Override public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {     return this.keyManager.chooseServerAlias(keyType, issuers, socket). }
false;public;1;4;;@Override public X509Certificate[] getCertificateChain(String alias) {     return this.keyManager.getCertificateChain(alias). }
false;public;2;4;;@Override public String[] getClientAliases(String keyType, Principal[] issuers) {     return this.keyManager.getClientAliases(keyType, issuers). }
false;public;1;4;;@Override public PrivateKey getPrivateKey(String alias) {     return this.keyManager.getPrivateKey(alias). }
false;public;2;4;;@Override public String[] getServerAliases(String keyType, Principal[] issuers) {     return this.keyManager.getServerAliases(keyType, issuers). }
