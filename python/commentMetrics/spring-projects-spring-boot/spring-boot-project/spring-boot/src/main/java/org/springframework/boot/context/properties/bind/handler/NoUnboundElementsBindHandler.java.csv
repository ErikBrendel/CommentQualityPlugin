commented;modifiers;parameterAmount;loc;comment;code
false;public;4;6;;@Override public Object onSuccess(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result) {     this.boundNames.add(name).     return super.onSuccess(name, target, context, result). }
false;public;4;7;;@Override public void onFinish(ConfigurationPropertyName name, Bindable<?> target, BindContext context, Object result) throws Exception {     if (context.getDepth() == 0) {         checkNoUnboundElements(name, context).     } }
false;private;2;14;;private void checkNoUnboundElements(ConfigurationPropertyName name, BindContext context) {     Set<ConfigurationProperty> unbound = new TreeSet<>().     for (ConfigurationPropertySource source : context.getSources()) {         if (source instanceof IterableConfigurationPropertySource && this.filter.apply(source)) {             collectUnbound(name, unbound, (IterableConfigurationPropertySource) source).         }     }     if (!unbound.isEmpty()) {         throw new UnboundConfigurationPropertiesException(unbound).     } }
false;private;3;14;;private void collectUnbound(ConfigurationPropertyName name, Set<ConfigurationProperty> unbound, IterableConfigurationPropertySource source) {     IterableConfigurationPropertySource filtered = source.filter((candidate) -> isUnbound(name, candidate)).     for (ConfigurationPropertyName unboundName : filtered) {         try {             unbound.add(source.filter((candidate) -> isUnbound(name, candidate)).getConfigurationProperty(unboundName)).         } catch (Exception ex) {         }     } }
false;private;2;4;;private boolean isUnbound(ConfigurationPropertyName name, ConfigurationPropertyName candidate) {     return name.isAncestorOf(candidate) && !this.boundNames.contains(candidate). }
