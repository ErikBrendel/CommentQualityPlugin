commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;7;/**  * Start a call to a single callback instance, dealing with common generic type  * concerns and exceptions.  * @param callbackType the callback type (a {@link FunctionalInterface functional  * interface})  * @param callbackInstance the callback instance (may be a lambda)  * @param argument the primary argument passed to the callback  * @param additionalArguments any additional arguments passed to the callback  * @param <C> the callback type  * @param <A> the primary argument type  * @return a {@link Callback} instance that can be invoked.  */ ;/**  * Start a call to a single callback instance, dealing with common generic type  * concerns and exceptions.  * @param callbackType the callback type (a {@link FunctionalInterface functional  * interface})  * @param callbackInstance the callback instance (may be a lambda)  * @param argument the primary argument passed to the callback  * @param additionalArguments any additional arguments passed to the callback  * @param <C> the callback type  * @param <A> the primary argument type  * @return a {@link Callback} instance that can be invoked.  */ public static <C, A> Callback<C, A> callback(Class<C> callbackType, C callbackInstance, A argument, Object... additionalArguments) {     Assert.notNull(callbackType, "CallbackType must not be null").     Assert.notNull(callbackInstance, "CallbackInstance must not be null").     return new Callback<>(callbackType, callbackInstance, argument, additionalArguments). }
true;public,static;4;8;/**  * Start a call to callback instances, dealing with common generic type concerns and  * exceptions.  * @param callbackType the callback type (a {@link FunctionalInterface functional  * interface})  * @param callbackInstances the callback instances (elements may be lambdas)  * @param argument the primary argument passed to the callbacks  * @param additionalArguments any additional arguments passed to the callbacks  * @param <C> the callback type  * @param <A> the primary argument type  * @return a {@link Callbacks} instance that can be invoked.  */ ;/**  * Start a call to callback instances, dealing with common generic type concerns and  * exceptions.  * @param callbackType the callback type (a {@link FunctionalInterface functional  * interface})  * @param callbackInstances the callback instances (elements may be lambdas)  * @param argument the primary argument passed to the callbacks  * @param additionalArguments any additional arguments passed to the callbacks  * @param <C> the callback type  * @param <A> the primary argument type  * @return a {@link Callbacks} instance that can be invoked.  */ public static <C, A> Callbacks<C, A> callbacks(Class<C> callbackType, Collection<? extends C> callbackInstances, A argument, Object... additionalArguments) {     Assert.notNull(callbackType, "CallbackType must not be null").     Assert.notNull(callbackInstances, "CallbackInstances must not be null").     return new Callbacks<>(callbackType, callbackInstances, argument, additionalArguments). }
true;public;1;3;/**  * Use the specified logger source to report any lambda failures.  * @param loggerSource the logger source to use  * @return this instance  */ ;/**  * Use the specified logger source to report any lambda failures.  * @param loggerSource the logger source to use  * @return this instance  */ public SELF withLogger(Class<?> loggerSource) {     return withLogger(LogFactory.getLog(loggerSource)). }
true;public;1;5;/**  * Use the specified logger to report any lambda failures.  * @param logger the logger to use  * @return this instance  */ ;/**  * Use the specified logger to report any lambda failures.  * @param logger the logger to use  * @return this instance  */ public SELF withLogger(Log logger) {     Assert.notNull(logger, "Logger must not be null").     this.logger = logger.     return self(). }
true;public;1;5;/**  * Use a specific filter to determine when a callback should apply. If no explicit  * filter is set filter will be attempted using the generic type on the callback  * type.  * @param filter the filter to use  * @return this instance  */ ;/**  * Use a specific filter to determine when a callback should apply. If no explicit  * filter is set filter will be attempted using the generic type on the callback  * type.  * @param filter the filter to use  * @return this instance  */ public SELF withFilter(Filter<C, A> filter) {     Assert.notNull(filter, "Filter must not be null").     this.filter = filter.     return self(). }
false;protected,final;2;16;;protected final <R> InvocationResult<R> invoke(C callbackInstance, Supplier<R> supplier) {     if (this.filter.match(this.callbackType, callbackInstance, this.argument, this.additionalArguments)) {         try {             return InvocationResult.of(supplier.get()).         } catch (ClassCastException ex) {             if (!isLambdaGenericProblem(ex)) {                 throw ex.             }             logNonMatchingType(callbackInstance, ex).         }     }     return InvocationResult.noResult(). }
false;private;1;4;;private boolean isLambdaGenericProblem(ClassCastException ex) {     return (ex.getMessage() == null || startsWithArgumentClassName(ex.getMessage())). }
false;private;1;6;;private boolean startsWithArgumentClassName(String message) {     Predicate<Object> startsWith = (argument) -> startsWithArgumentClassName(message, argument).     return startsWith.test(this.argument) || Stream.of(this.additionalArguments).anyMatch(startsWith). }
false;private;2;29;;private boolean startsWithArgumentClassName(String message, Object argument) {     if (argument == null) {         return false.     }     Class<?> argumentType = argument.getClass().     // be cast..."     if (message.startsWith(argumentType.getName())) {         return true.     }     // On Java 11, the message starts with "class ..." a.k.a. Class.toString()     if (message.startsWith(argumentType.toString())) {         return true.     }     // On Java 9, the message used to contain the module name:     // "java.base/java.lang.String cannot be cast..."     int moduleSeparatorIndex = message.indexOf('/').     if (moduleSeparatorIndex != -1 && message.startsWith(argumentType.getName(), moduleSeparatorIndex + 1)) {         return true.     }     if (CLASS_GET_MODULE != null) {         Object module = ReflectionUtils.invokeMethod(CLASS_GET_MODULE, argumentType).         Object moduleName = ReflectionUtils.invokeMethod(MODULE_GET_NAME, module).         return message.startsWith(moduleName + "/" + argumentType.getName()).     }     return false. }
false;private;2;11;;private void logNonMatchingType(C callback, ClassCastException ex) {     if (this.logger.isDebugEnabled()) {         Class<?> expectedType = ResolvableType.forClass(this.callbackType).resolveGeneric().         String expectedTypeName = (expectedType != null) ? ClassUtils.getShortName(expectedType) + " type" : "type".         String message = "Non-matching " + expectedTypeName + " for callback " + ClassUtils.getShortName(this.callbackType) + ": " + callback.         this.logger.debug(message, ex).     } }
false;private;0;4;;@SuppressWarnings("unchecked") private SELF self() {     return (SELF) this. }
true;public;1;6;/**  * Invoke the callback instance where the callback method returns void.  * @param invoker the invoker used to invoke the callback  */ ;/**  * Invoke the callback instance where the callback method returns void.  * @param invoker the invoker used to invoke the callback  */ public void invoke(Consumer<C> invoker) {     invoke(this.callbackInstance, () -> {         invoker.accept(this.callbackInstance).         return null.     }). }
true;public;1;4;/**  * Invoke the callback instance where the callback method returns a result.  * @param invoker the invoker used to invoke the callback  * @param <R> the result type  * @return the result of the invocation (may be {@link InvocationResult#noResult}  * if the callback was not invoked)  */ ;/**  * Invoke the callback instance where the callback method returns a result.  * @param invoker the invoker used to invoke the callback  * @param <R> the result type  * @return the result of the invocation (may be {@link InvocationResult#noResult}  * if the callback was not invoked)  */ public <R> InvocationResult<R> invokeAnd(Function<C, R> invoker) {     return invoke(this.callbackInstance, () -> invoker.apply(this.callbackInstance)). }
true;public;1;8;/**  * Invoke the callback instances where the callback method returns void.  * @param invoker the invoker used to invoke the callback  */ ;/**  * Invoke the callback instances where the callback method returns void.  * @param invoker the invoker used to invoke the callback  */ public void invoke(Consumer<C> invoker) {     this.callbackInstances.forEach((callbackInstance) -> {         invoke(callbackInstance, () -> {             invoker.accept(callbackInstance).             return null.         }).     }). }
true;public;1;6;/**  * Invoke the callback instances where the callback method returns a result.  * @param invoker the invoker used to invoke the callback  * @param <R> the result type  * @return the results of the invocation (may be an empty stream if no callbacks  * could be called)  */ ;/**  * Invoke the callback instances where the callback method returns a result.  * @param invoker the invoker used to invoke the callback  * @param <R> the result type  * @return the results of the invocation (may be an empty stream if no callbacks  * could be called)  */ public <R> Stream<R> invokeAnd(Function<C, R> invoker) {     Function<C, InvocationResult<R>> mapper = (callbackInstance) -> invoke(callbackInstance, () -> invoker.apply(callbackInstance)).     return this.callbackInstances.stream().map(mapper).filter(InvocationResult::hasResult).map(InvocationResult::get). }
true;;4;2;/**  * Determine if the given callback matches and should be invoked.  * @param callbackType the callback type (the functional interface)  * @param callbackInstance the callback instance (the implementation)  * @param argument the primary argument  * @param additionalArguments any additional arguments  * @return if the callback matches and should be invoked  */ ;/**  * Determine if the given callback matches and should be invoked.  * @param callbackType the callback type (the functional interface)  * @param callbackInstance the callback instance (the implementation)  * @param argument the primary argument  * @param additionalArguments any additional arguments  * @return if the callback matches and should be invoked  */ boolean match(Class<C> callbackType, C callbackInstance, A argument, Object[] additionalArguments).
true;static;0;4;/**  * Return a {@link Filter} that allows all callbacks to be invoked.  * @param <C> the callback type  * @param <A> the primary argument type  * @return an "allow all" filter  */ ;/**  * Return a {@link Filter} that allows all callbacks to be invoked.  * @param <C> the callback type  * @param <A> the primary argument type  * @return an "allow all" filter  */ static <C, A> Filter<C, A> allowAll() {     return (callbackType, callbackInstance, argument, additionalArguments) -> true. }
false;public;4;11;;@Override public boolean match(Class<C> callbackType, C callbackInstance, A argument, Object[] additionalArguments) {     ResolvableType type = ResolvableType.forClass(callbackType, callbackInstance.getClass()).     if (type.getGenerics().length == 1 && type.resolveGeneric() != null) {         return type.resolveGeneric().isInstance(argument).     }     return true. }
true;public;0;3;/**  * Return true if a result in present.  * @return if a result is present  */ ;/**  * Return true if a result in present.  * @return if a result is present  */ public boolean hasResult() {     return this != NONE. }
true;public;0;3;/**  * Return the result of the invocation or {@code null} if the callback wasn't  * suitable.  * @return the result of the invocation or {@code null}  */ ;/**  * Return the result of the invocation or {@code null} if the callback wasn't  * suitable.  * @return the result of the invocation or {@code null}  */ public R get() {     return this.value. }
true;public;1;3;/**  * Return the result of the invocation or the given fallback if the callback  * wasn't suitable.  * @param fallback the fallback to use when there is no result  * @return the result of the invocation or the fallback  */ ;/**  * Return the result of the invocation or the given fallback if the callback  * wasn't suitable.  * @param fallback the fallback to use when there is no result  * @return the result of the invocation or the fallback  */ public R get(R fallback) {     return (this != NONE) ? this.value : fallback. }
true;public,static;1;3;/**  * Create a new {@link InvocationResult} instance with the specified value.  * @param value the value (may be {@code null})  * @param <R> the result type  * @return an {@link InvocationResult}  */ ;/**  * Create a new {@link InvocationResult} instance with the specified value.  * @param value the value (may be {@code null})  * @param <R> the result type  * @return an {@link InvocationResult}  */ public static <R> InvocationResult<R> of(R value) {     return new InvocationResult<>(value). }
true;public,static;0;4;/**  * Return an {@link InvocationResult} instance representing no result.  * @param <R> the result type  * @return an {@link InvocationResult}  */ ;/**  * Return an {@link InvocationResult} instance representing no result.  * @param <R> the result type  * @return an {@link InvocationResult}  */ @SuppressWarnings("unchecked") public static <R> InvocationResult<R> noResult() {     return (InvocationResult<R>) NONE. }
