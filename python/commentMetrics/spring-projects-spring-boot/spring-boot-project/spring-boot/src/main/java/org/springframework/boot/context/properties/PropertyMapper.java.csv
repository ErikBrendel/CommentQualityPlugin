commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return a new {@link PropertyMapper} instance that applies  * {@link Source#whenNonNull() whenNonNull} to every source.  * @return a new property mapper instance  */ ;/**  * Return a new {@link PropertyMapper} instance that applies  * {@link Source#whenNonNull() whenNonNull} to every source.  * @return a new property mapper instance  */ public PropertyMapper alwaysApplyingWhenNonNull() {     return alwaysApplying(this::whenNonNull). }
false;private;1;3;;private <T> Source<T> whenNonNull(Source<T> source) {     return source.whenNonNull(). }
true;public;1;4;/**  * Return a new {@link PropertyMapper} instance that applies the given  * {@link SourceOperator} to every source.  * @param operator the source operator to apply  * @return a new property mapper instance  */ ;/**  * Return a new {@link PropertyMapper} instance that applies the given  * {@link SourceOperator} to every source.  * @param operator the source operator to apply  * @return a new property mapper instance  */ public PropertyMapper alwaysApplying(SourceOperator operator) {     Assert.notNull(operator, "Operator must not be null").     return new PropertyMapper(this, operator). }
true;public;1;8;/**  * Return a new {@link Source} from the specified value supplier that can be used to  * perform the mapping.  * @param <T> the source type  * @param supplier the value supplier  * @return a {@link Source} that can be used to complete the mapping  * @see #from(Object)  */ ;/**  * Return a new {@link Source} from the specified value supplier that can be used to  * perform the mapping.  * @param <T> the source type  * @param supplier the value supplier  * @return a {@link Source} that can be used to complete the mapping  * @see #from(Object)  */ public <T> Source<T> from(Supplier<T> supplier) {     Assert.notNull(supplier, "Supplier must not be null").     Source<T> source = getSource(supplier).     if (this.sourceOperator != null) {         source = this.sourceOperator.apply(source).     }     return source. }
true;public;1;3;/**  * Return a new {@link Source} from the specified value that can be used to perform  * the mapping.  * @param <T> the source type  * @param value the value  * @return a {@link Source} that can be used to complete the mapping  */ ;/**  * Return a new {@link Source} from the specified value that can be used to perform  * the mapping.  * @param <T> the source type  * @param value the value  * @return a {@link Source} that can be used to complete the mapping  */ public <T> Source<T> from(T value) {     return from(() -> value). }
false;private;1;7;;@SuppressWarnings("unchecked") private <T> Source<T> getSource(Supplier<T> supplier) {     if (this.parent != null) {         return this.parent.from(supplier).     }     return new Source<>(new CachingSupplier<>(supplier), (Predicate<T>) ALWAYS). }
true;public,static;0;3;/**  * Return the property mapper.  * @return the property mapper  */ ;/**  * Return the property mapper.  * @return the property mapper  */ public static PropertyMapper get() {     return INSTANCE. }
false;public;0;8;;@Override public T get() {     if (!this.hasResult) {         this.result = this.supplier.get().         this.hasResult = true.     }     return this.result. }
true;;1;1;/**  * Apply the operation to the given source.  * @param <T> the source type  * @param source the source to operate on  * @return the updated source  */ ;/**  * Apply the operation to the given source.  * @param <T> the source type  * @param source the source to operate on  * @return the updated source  */ <T> Source<T> apply(Source<T> source).
true;public;1;3;/**  * Return an adapted version of the source with {@link Integer} type.  * @param <R> the resulting type  * @param adapter an adapter to convert the current value to a number.  * @return a new adapted source instance  */ ;/**  * Return an adapted version of the source with {@link Integer} type.  * @param <R> the resulting type  * @param adapter an adapter to convert the current value to a number.  * @return a new adapted source instance  */ public <R extends Number> Source<Integer> asInt(Function<T, R> adapter) {     return as(adapter).as(Number::intValue). }
true;public;1;12;/**  * Return an adapted version of the source changed via the given adapter function.  * @param <R> the resulting type  * @param adapter the adapter to apply  * @return a new adapted source instance  */ ;/**  * Return an adapted version of the source changed via the given adapter function.  * @param <R> the resulting type  * @param adapter the adapter to apply  * @return a new adapted source instance  */ public <R> Source<R> as(Function<T, R> adapter) {     Assert.notNull(adapter, "Adapter must not be null").     Supplier<Boolean> test = () -> this.predicate.test(this.supplier.get()).     Predicate<R> predicate = (t) -> test.get().     Supplier<R> supplier = () -> {         if (test.get()) {             return adapter.apply(this.supplier.get()).         }         return null.     }.     return new Source<>(supplier, predicate). }
true;public;0;4;/**  * Return a filtered version of the source that won't map non-null values or  * suppliers that throw a {@link NullPointerException}.  * @return a new filtered source instance  */ ;/**  * Return a filtered version of the source that won't map non-null values or  * suppliers that throw a {@link NullPointerException}.  * @return a new filtered source instance  */ public Source<T> whenNonNull() {     return new Source<>(new NullPointerExceptionSafeSupplier<>(this.supplier), Objects::nonNull). }
true;public;0;3;/**  * Return a filtered version of the source that will only map values that are  * {@code true}.  * @return a new filtered source instance  */ ;/**  * Return a filtered version of the source that will only map values that are  * {@code true}.  * @return a new filtered source instance  */ public Source<T> whenTrue() {     return when(Boolean.TRUE::equals). }
true;public;0;3;/**  * Return a filtered version of the source that will only map values that are  * {@code false}.  * @return a new filtered source instance  */ ;/**  * Return a filtered version of the source that will only map values that are  * {@code false}.  * @return a new filtered source instance  */ public Source<T> whenFalse() {     return when(Boolean.FALSE::equals). }
true;public;0;3;/**  * Return a filtered version of the source that will only map values that have a  * {@code toString()} containing actual text.  * @return a new filtered source instance  */ ;/**  * Return a filtered version of the source that will only map values that have a  * {@code toString()} containing actual text.  * @return a new filtered source instance  */ public Source<T> whenHasText() {     return when((value) -> StringUtils.hasText(Objects.toString(value, null))). }
true;public;1;3;/**  * Return a filtered version of the source that will only map values equal to the  * specified {@code object}.  * @param object the object to match  * @return a new filtered source instance  */ ;/**  * Return a filtered version of the source that will only map values equal to the  * specified {@code object}.  * @param object the object to match  * @return a new filtered source instance  */ public Source<T> whenEqualTo(Object object) {     return when(object::equals). }
true;public;1;3;/**  * Return a filtered version of the source that will only map values that are an  * instance of the given type.  * @param <R> the target type  * @param target the target type to match  * @return a new filtered source instance  */ ;/**  * Return a filtered version of the source that will only map values that are an  * instance of the given type.  * @param <R> the target type  * @param target the target type to match  * @return a new filtered source instance  */ public <R extends T> Source<R> whenInstanceOf(Class<R> target) {     return when(target::isInstance).as(target::cast). }
true;public;1;4;/**  * Return a filtered version of the source that won't map values that match the  * given predicate.  * @param predicate the predicate used to filter values  * @return a new filtered source instance  */ ;/**  * Return a filtered version of the source that won't map values that match the  * given predicate.  * @param predicate the predicate used to filter values  * @return a new filtered source instance  */ public Source<T> whenNot(Predicate<T> predicate) {     Assert.notNull(predicate, "Predicate must not be null").     return new Source<>(this.supplier, predicate.negate()). }
true;public;1;4;/**  * Return a filtered version of the source that won't map values that don't match  * the given predicate.  * @param predicate the predicate used to filter values  * @return a new filtered source instance  */ ;/**  * Return a filtered version of the source that won't map values that don't match  * the given predicate.  * @param predicate the predicate used to filter values  * @return a new filtered source instance  */ public Source<T> when(Predicate<T> predicate) {     Assert.notNull(predicate, "Predicate must not be null").     return new Source<>(this.supplier, predicate). }
true;public;1;7;/**  * Complete the mapping by passing any non-filtered value to the specified  * consumer.  * @param consumer the consumer that should accept the value if it's not been  * filtered  */ ;/**  * Complete the mapping by passing any non-filtered value to the specified  * consumer.  * @param consumer the consumer that should accept the value if it's not been  * filtered  */ public void to(Consumer<T> consumer) {     Assert.notNull(consumer, "Consumer must not be null").     T value = this.supplier.get().     if (this.predicate.test(value)) {         consumer.accept(value).     } }
true;public;1;8;/**  * Complete the mapping by creating a new instance from the non-filtered value.  * @param <R> the resulting type  * @param factory the factory used to create the instance  * @return the instance  * @throws NoSuchElementException if the value has been filtered  */ ;/**  * Complete the mapping by creating a new instance from the non-filtered value.  * @param <R> the resulting type  * @param factory the factory used to create the instance  * @return the instance  * @throws NoSuchElementException if the value has been filtered  */ public <R> R toInstance(Function<T, R> factory) {     Assert.notNull(factory, "Factory must not be null").     T value = this.supplier.get().     if (!this.predicate.test(value)) {         throw new NoSuchElementException("No value present").     }     return factory.apply(value). }
true;public;1;7;/**  * Complete the mapping by calling the specified method when the value has not  * been filtered.  * @param runnable the method to call if the value has not been filtered  */ ;/**  * Complete the mapping by calling the specified method when the value has not  * been filtered.  * @param runnable the method to call if the value has not been filtered  */ public void toCall(Runnable runnable) {     Assert.notNull(runnable, "Runnable must not be null").     T value = this.supplier.get().     if (this.predicate.test(value)) {         runnable.run().     } }
false;public;0;9;;@Override public T get() {     try {         return this.supplier.get().     } catch (NullPointerException ex) {         return null.     } }
