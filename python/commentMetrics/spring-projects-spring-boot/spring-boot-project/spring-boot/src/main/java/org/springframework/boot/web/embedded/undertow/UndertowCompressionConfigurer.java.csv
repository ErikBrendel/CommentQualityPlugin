commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;10;/**  * Optionally wrap the given {@link HttpHandler} for HTTP compression support.  * @param compression the HTTP compression configuration  * @param httpHandler the HTTP handler to wrap  * @return the wrapped HTTP handler if compression is enabled, or the handler itself  */ ;/**  * Optionally wrap the given {@link HttpHandler} for HTTP compression support.  * @param compression the HTTP compression configuration  * @param httpHandler the HTTP handler to wrap  * @return the wrapped HTTP handler if compression is enabled, or the handler itself  */ public static HttpHandler configureCompression(Compression compression, HttpHandler httpHandler) {     if (compression == null || !compression.getEnabled()) {         return httpHandler.     }     ContentEncodingRepository repository = new ContentEncodingRepository().     repository.addEncodingHandler("gzip", new GzipEncodingProvider(), 50, Predicates.and(getCompressionPredicates(compression))).     return new EncodingHandler(repository).setNext(httpHandler). }
false;private,static;1;14;;private static Predicate[] getCompressionPredicates(Compression compression) {     List<Predicate> predicates = new ArrayList<>().     predicates.add(new MaxSizePredicate((int) compression.getMinResponseSize().toBytes())).     predicates.add(new CompressibleMimeTypePredicate(compression.getMimeTypes())).     if (compression.getExcludedUserAgents() != null) {         for (String agent : compression.getExcludedUserAgents()) {             RequestHeaderAttribute agentHeader = new RequestHeaderAttribute(new HttpString(HttpHeaders.USER_AGENT)).             predicates.add(Predicates.not(Predicates.regex(agentHeader, agent))).         }     }     return predicates.toArray(new Predicate[0]). }
false;public;1;14;;@Override public boolean resolve(HttpServerExchange value) {     String contentType = value.getResponseHeaders().getFirst(HttpHeaders.CONTENT_TYPE).     if (contentType != null) {         for (MimeType mimeType : this.mimeTypes) {             if (mimeType.isCompatibleWith(MimeTypeUtils.parseMimeType(contentType))) {                 return true.             }         }     }     return false. }
false;public;1;7;;@Override public boolean resolve(HttpServerExchange value) {     if (value.getResponseHeaders().contains(Headers.CONTENT_LENGTH)) {         return this.maxContentSize.resolve(value).     }     return true. }
