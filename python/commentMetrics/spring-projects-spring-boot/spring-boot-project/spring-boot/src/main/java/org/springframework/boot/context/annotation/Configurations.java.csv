commented;modifiers;parameterAmount;loc;comment;code
true;protected;1;3;/**  * Sort configuration classes into the order that they should be applied.  * @param classes the classes to sort  * @return a sorted set of classes  */ ;/**  * Sort configuration classes into the order that they should be applied.  * @param classes the classes to sort  * @return a sorted set of classes  */ protected Collection<Class<?>> sort(Collection<Class<?>> classes) {     return classes. }
false;protected,final;0;3;;protected final Set<Class<?>> getClasses() {     return this.classes. }
true;protected;1;5;/**  * Merge configurations from another source of the same type.  * @param other the other {@link Configurations} (must be of the same type as this  * instance)  * @return a new configurations instance (must be of the same type as this instance)  */ ;/**  * Merge configurations from another source of the same type.  * @param other the other {@link Configurations} (must be of the same type as this  * instance)  * @return a new configurations instance (must be of the same type as this instance)  */ protected Configurations merge(Configurations other) {     Set<Class<?>> mergedClasses = new LinkedHashSet<>(getClasses()).     mergedClasses.addAll(other.getClasses()).     return merge(mergedClasses). }
true;protected,abstract;1;1;/**  * Merge configurations.  * @param mergedClasses the merged classes  * @return a new configurations instance (must be of the same type as this instance)  */ ;/**  * Merge configurations.  * @param mergedClasses the merged classes  * @return a new configurations instance (must be of the same type as this instance)  */ protected abstract Configurations merge(Set<Class<?>> mergedClasses).
true;public,static;1;3;/**  * Return the classes from all the specified configurations in the order that they  * would be registered.  * @param configurations the source configuration  * @return configuration classes in registration order  */ ;/**  * Return the classes from all the specified configurations in the order that they  * would be registered.  * @param configurations the source configuration  * @return configuration classes in registration order  */ public static Class<?>[] getClasses(Configurations... configurations) {     return getClasses(Arrays.asList(configurations)). }
true;public,static;1;9;/**  * Return the classes from all the specified configurations in the order that they  * would be registered.  * @param configurations the source configuration  * @return configuration classes in registration order  */ ;/**  * Return the classes from all the specified configurations in the order that they  * would be registered.  * @param configurations the source configuration  * @return configuration classes in registration order  */ public static Class<?>[] getClasses(Collection<Configurations> configurations) {     List<Configurations> ordered = new ArrayList<>(configurations).     ordered.sort(COMPARATOR).     List<Configurations> collated = collate(ordered).     LinkedHashSet<Class<?>> classes = collated.stream().flatMap(Configurations::streamClasses).collect(Collectors.toCollection(LinkedHashSet::new)).     return ClassUtils.toClassArray(classes). }
false;private,static;1;3;;private static Stream<Class<?>> streamClasses(Configurations configurations) {     return configurations.getClasses().stream(). }
false;private,static;1;13;;private static List<Configurations> collate(List<Configurations> orderedConfigurations) {     LinkedList<Configurations> collated = new LinkedList<>().     for (Configurations item : orderedConfigurations) {         if (collated.isEmpty() || collated.getLast().getClass() != item.getClass()) {             collated.add(item).         } else {             collated.set(collated.size() - 1, collated.getLast().merge(item)).         }     }     return collated. }
