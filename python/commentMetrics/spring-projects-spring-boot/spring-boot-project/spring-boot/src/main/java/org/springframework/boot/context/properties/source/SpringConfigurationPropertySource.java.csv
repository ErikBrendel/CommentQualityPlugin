commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public ConfigurationProperty getConfigurationProperty(ConfigurationPropertyName name) {     PropertyMapping[] mappings = getMapper().map(name).     return find(mappings, name). }
false;public;1;5;;@Override public ConfigurationPropertyState containsDescendantOf(ConfigurationPropertyName name) {     return this.containsDescendantOf.apply(name). }
false;public;0;4;;@Override public Object getUnderlyingSource() {     return this.propertySource. }
false;protected,final;2;12;;protected final ConfigurationProperty find(PropertyMapping[] mappings, ConfigurationPropertyName name) {     for (PropertyMapping candidate : mappings) {         if (candidate.isApplicable(name)) {             ConfigurationProperty result = find(candidate).             if (result != null) {                 return result.             }         }     }     return null. }
false;private;1;11;;private ConfigurationProperty find(PropertyMapping mapping) {     String propertySourceName = mapping.getPropertySourceName().     Object value = getPropertySource().getProperty(propertySourceName).     if (value == null) {         return null.     }     ConfigurationPropertyName configurationPropertyName = mapping.getConfigurationPropertyName().     Origin origin = PropertySourceOrigin.get(this.propertySource, propertySourceName).     return ConfigurationProperty.of(configurationPropertyName, value, origin). }
false;protected;0;3;;protected PropertySource<?> getPropertySource() {     return this.propertySource. }
false;protected,final;0;3;;protected final PropertyMapper getMapper() {     return this.mapper. }
false;public;0;4;;@Override public String toString() {     return this.propertySource.toString(). }
true;public,static;1;10;/**  * Create a new {@link SpringConfigurationPropertySource} for the specified  * {@link PropertySource}.  * @param source the source Spring {@link PropertySource}  * @return a {@link SpringConfigurationPropertySource} or  * {@link SpringIterableConfigurationPropertySource} instance  */ ;/**  * Create a new {@link SpringConfigurationPropertySource} for the specified  * {@link PropertySource}.  * @param source the source Spring {@link PropertySource}  * @return a {@link SpringConfigurationPropertySource} or  * {@link SpringIterableConfigurationPropertySource} instance  */ public static SpringConfigurationPropertySource from(PropertySource<?> source) {     Assert.notNull(source, "Source must not be null").     PropertyMapper mapper = getPropertyMapper(source).     if (isFullEnumerable(source)) {         return new SpringIterableConfigurationPropertySource((EnumerablePropertySource<?>) source, mapper).     }     return new SpringConfigurationPropertySource(source, mapper, getContainsDescendantOfForSource(source)). }
false;private,static;1;8;;private static PropertyMapper getPropertyMapper(PropertySource<?> source) {     if (source instanceof SystemEnvironmentPropertySource && hasSystemEnvironmentName(source)) {         return new DelegatingPropertyMapper(SystemEnvironmentPropertyMapper.INSTANCE, DefaultPropertyMapper.INSTANCE).     }     return new DelegatingPropertyMapper(DefaultPropertyMapper.INSTANCE). }
false;private,static;1;6;;private static boolean hasSystemEnvironmentName(PropertySource<?> source) {     String name = source.getName().     return StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME.equals(name) || name.endsWith("-" + StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME). }
false;private,static;1;13;;private static boolean isFullEnumerable(PropertySource<?> source) {     PropertySource<?> rootSource = getRootSource(source).     if (rootSource.getSource() instanceof Map) {         // Check we're not security restricted         try {             ((Map<?, ?>) rootSource.getSource()).size().         } catch (UnsupportedOperationException ex) {             return false.         }     }     return (source instanceof EnumerablePropertySource). }
false;private,static;1;7;;private static PropertySource<?> getRootSource(PropertySource<?> source) {     while (source.getSource() != null && source.getSource() instanceof PropertySource) {         source = (PropertySource<?>) source.getSource().     }     return source. }
false;private,static;1;7;;private static Function<ConfigurationPropertyName, ConfigurationPropertyState> getContainsDescendantOfForSource(PropertySource<?> source) {     if (source.getSource() instanceof Random) {         return SpringConfigurationPropertySource::containsDescendantOfForRandom.     }     return null. }
false;private,static;1;7;;private static ConfigurationPropertyState containsDescendantOfForRandom(ConfigurationPropertyName name) {     if (name.isAncestorOf(RANDOM) || name.equals(RANDOM)) {         return ConfigurationPropertyState.PRESENT.     }     return ConfigurationPropertyState.ABSENT. }
false;public;1;7;;@Override public PropertyMapping[] map(ConfigurationPropertyName configurationPropertyName) {     PropertyMapping[] first = map(this.first, configurationPropertyName).     PropertyMapping[] second = map(this.second, configurationPropertyName).     return merge(first, second). }
false;private;2;9;;private PropertyMapping[] map(PropertyMapper mapper, ConfigurationPropertyName configurationPropertyName) {     try {         return (mapper != null) ? mapper.map(configurationPropertyName) : NONE.     } catch (Exception ex) {         return NONE.     } }
false;public;1;6;;@Override public PropertyMapping[] map(String propertySourceName) {     PropertyMapping[] first = map(this.first, propertySourceName).     PropertyMapping[] second = map(this.second, propertySourceName).     return merge(first, second). }
false;private;2;8;;private PropertyMapping[] map(PropertyMapper mapper, String propertySourceName) {     try {         return (mapper != null) ? mapper.map(propertySourceName) : NONE.     } catch (Exception ex) {         return NONE.     } }
false;private;2;13;;private PropertyMapping[] merge(PropertyMapping[] first, PropertyMapping[] second) {     if (ObjectUtils.isEmpty(second)) {         return first.     }     if (ObjectUtils.isEmpty(first)) {         return second.     }     PropertyMapping[] merged = new PropertyMapping[first.length + second.length].     System.arraycopy(first, 0, merged, 0, first.length).     System.arraycopy(second, 0, merged, first.length, second.length).     return merged. }
