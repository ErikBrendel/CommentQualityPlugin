commented;modifiers;parameterAmount;loc;comment;code
false;private;0;40;;private void initialize() throws WebServerException {     logger.info("Tomcat initialized with port(s): " + getPortsDescription(false)).     synchronized (this.monitor) {         try {             addInstanceIdToEngineName().             Context context = findContext().             context.addLifecycleListener((event) -> {                 if (context.equals(event.getSource()) && Lifecycle.START_EVENT.equals(event.getType())) {                     // Remove service connectors so that protocol binding doesn't                     // happen when the service is started.                     removeServiceConnectors().                 }             }).             // Start the server to trigger initialization listeners             this.tomcat.start().             // We can re-throw failure exception directly in the main thread             rethrowDeferredStartupExceptions().             try {                 ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader()).             } catch (NamingException ex) {             // Naming is not enabled. Continue             }             // Unlike Jetty, all Tomcat threads are daemon threads. We create a             // blocking non-daemon to stop immediate shutdown             startDaemonAwaitThread().         } catch (Exception ex) {             stopSilently().             throw new WebServerException("Unable to start embedded Tomcat", ex).         }     } }
false;private;0;8;;private Context findContext() {     for (Container child : this.tomcat.getHost().findChildren()) {         if (child instanceof Context) {             return (Context) child.         }     }     throw new IllegalStateException("The host does not contain a Context"). }
false;private;0;7;;private void addInstanceIdToEngineName() {     int instanceId = containerCounter.incrementAndGet().     if (instanceId > 0) {         Engine engine = this.tomcat.getEngine().         engine.setName(engine.getName() + "-" + instanceId).     } }
false;private;0;9;;private void removeServiceConnectors() {     for (Service service : this.tomcat.getServer().findServices()) {         Connector[] connectors = service.findConnectors().clone().         this.serviceConnectors.put(service, connectors).         for (Connector connector : connectors) {             service.removeConnector(connector).         }     } }
false;private;0;18;;private void rethrowDeferredStartupExceptions() throws Exception {     Container[] children = this.tomcat.getHost().findChildren().     for (Container container : children) {         if (container instanceof TomcatEmbeddedContext) {             TomcatStarter tomcatStarter = ((TomcatEmbeddedContext) container).getStarter().             if (tomcatStarter != null) {                 Exception exception = tomcatStarter.getStartUpException().                 if (exception != null) {                     throw exception.                 }             }         }         if (!LifecycleState.STARTED.equals(container.getState())) {             throw new IllegalStateException(container + " failed to start").         }     } }
false;public;0;4;;@Override public void run() {     TomcatWebServer.this.tomcat.getServer().await(). }
false;private;0;13;;private void startDaemonAwaitThread() {     Thread awaitThread = new Thread("container-" + (containerCounter.get())) {          @Override         public void run() {             TomcatWebServer.this.tomcat.getServer().await().         }     }.     awaitThread.setContextClassLoader(getClass().getClassLoader()).     awaitThread.setDaemon(false).     awaitThread.start(). }
false;public;0;32;;@Override public void start() throws WebServerException {     synchronized (this.monitor) {         if (this.started) {             return.         }         try {             addPreviouslyRemovedConnectors().             Connector connector = this.tomcat.getConnector().             if (connector != null && this.autoStart) {                 performDeferredLoadOnStartup().             }             checkThatConnectorsHaveStarted().             this.started = true.             logger.info("Tomcat started on port(s): " + getPortsDescription(true) + " with context path '" + getContextPath() + "'").         } catch (ConnectorStartFailedException ex) {             stopSilently().             throw ex.         } catch (Exception ex) {             throw new WebServerException("Unable to start embedded Tomcat server", ex).         } finally {             Context context = findContext().             ContextBindings.unbindClassLoader(context, context.getNamingToken(), getClass().getClassLoader()).         }     } }
false;private;0;6;;private void checkThatConnectorsHaveStarted() {     checkConnectorHasStarted(this.tomcat.getConnector()).     for (Connector connector : this.tomcat.getService().findConnectors()) {         checkConnectorHasStarted(connector).     } }
false;private;1;5;;private void checkConnectorHasStarted(Connector connector) {     if (LifecycleState.FAILED.equals(connector.getState())) {         throw new ConnectorStartFailedException(connector.getPort()).     } }
false;private;0;8;;private void stopSilently() {     try {         stopTomcat().     } catch (LifecycleException ex) {     // Ignore     } }
false;private;0;7;;private void stopTomcat() throws LifecycleException {     if (Thread.currentThread().getContextClassLoader() instanceof TomcatEmbeddedWebappClassLoader) {         Thread.currentThread().setContextClassLoader(getClass().getClassLoader()).     }     this.tomcat.stop(). }
false;private;0;15;;private void addPreviouslyRemovedConnectors() {     Service[] services = this.tomcat.getServer().findServices().     for (Service service : services) {         Connector[] connectors = this.serviceConnectors.get(service).         if (connectors != null) {             for (Connector connector : connectors) {                 service.addConnector(connector).                 if (!this.autoStart) {                     stopProtocolHandler(connector).                 }             }             this.serviceConnectors.remove(service).         }     } }
false;private;1;8;;private void stopProtocolHandler(Connector connector) {     try {         connector.getProtocolHandler().stop().     } catch (Exception ex) {         logger.error("Cannot pause connector: ", ex).     } }
false;private;0;16;;private void performDeferredLoadOnStartup() {     try {         for (Container child : this.tomcat.getHost().findChildren()) {             if (child instanceof TomcatEmbeddedContext) {                 ((TomcatEmbeddedContext) child).deferredLoadOnStartup().             }         }     } catch (Exception ex) {         if (ex instanceof WebServerException) {             throw (WebServerException) ex.         }         throw new WebServerException("Unable to start embedded Tomcat connectors", ex).     } }
false;;0;3;;Map<Service, Connector[]> getServiceConnectors() {     return this.serviceConnectors. }
false;public;0;24;;@Override public void stop() throws WebServerException {     synchronized (this.monitor) {         boolean wasStarted = this.started.         try {             this.started = false.             try {                 stopTomcat().                 this.tomcat.destroy().             } catch (LifecycleException ex) {             // swallow and continue             }         } catch (Exception ex) {             throw new WebServerException("Unable to stop embedded Tomcat", ex).         } finally {             if (wasStarted) {                 containerCounter.decrementAndGet().             }         }     } }
false;private;1;11;;private String getPortsDescription(boolean localPort) {     StringBuilder ports = new StringBuilder().     for (Connector connector : this.tomcat.getService().findConnectors()) {         if (ports.length() != 0) {             ports.append(' ').         }         int port = localPort ? connector.getLocalPort() : connector.getPort().         ports.append(port).append(" (").append(connector.getScheme()).append(')').     }     return ports.toString(). }
false;public;0;8;;@Override public int getPort() {     Connector connector = this.tomcat.getConnector().     if (connector != null) {         return connector.getLocalPort().     }     return 0. }
false;private;0;6;;private String getContextPath() {     return Arrays.stream(this.tomcat.getHost().findChildren()).filter(TomcatEmbeddedContext.class::isInstance).map(TomcatEmbeddedContext.class::cast).map(TomcatEmbeddedContext::getPath).collect(Collectors.joining(" ")). }
true;public;0;3;/**  * Returns access to the underlying Tomcat server.  * @return the Tomcat server  */ ;/**  * Returns access to the underlying Tomcat server.  * @return the Tomcat server  */ public Tomcat getTomcat() {     return this.tomcat. }
