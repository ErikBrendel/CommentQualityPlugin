commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Set<ConvertiblePair> getConvertibleTypes() {     return Collections.singleton(new ConvertiblePair(Collection.class, String.class)). }
false;public;2;12;;@Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {     TypeDescriptor sourceElementType = sourceType.getElementTypeDescriptor().     if (targetType == null || sourceElementType == null) {         return true.     }     if (this.conversionService.canConvert(sourceElementType, targetType) || sourceElementType.getType().isAssignableFrom(targetType.getType())) {         return true.     }     return false. }
false;public;3;9;;@Override public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     if (source == null) {         return null.     }     Collection<?> sourceCollection = (Collection<?>) source.     return convert(sourceCollection, sourceType, targetType). }
false;private;3;9;;private Object convert(Collection<?> source, TypeDescriptor sourceType, TypeDescriptor targetType) {     if (source.isEmpty()) {         return "".     }     return source.stream().map((element) -> convertElement(element, sourceType, targetType)).collect(Collectors.joining(getDelimiter(sourceType))). }
false;private;1;4;;private CharSequence getDelimiter(TypeDescriptor sourceType) {     Delimiter annotation = sourceType.getAnnotation(Delimiter.class).     return (annotation != null) ? annotation.value() : ",". }
false;private;3;5;;private String convertElement(Object element, TypeDescriptor sourceType, TypeDescriptor targetType) {     return String.valueOf(this.conversionService.convert(element, sourceType.elementTypeDescriptor(element), targetType)). }
