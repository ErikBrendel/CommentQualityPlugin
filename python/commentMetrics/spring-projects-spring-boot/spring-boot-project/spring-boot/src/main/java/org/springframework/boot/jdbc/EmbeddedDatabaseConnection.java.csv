commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the driver class name.  * @return the driver class name  */ ;/**  * Returns the driver class name.  * @return the driver class name  */ public String getDriverClassName() {     return this.driverClass. }
true;public;0;3;/**  * Returns the {@link EmbeddedDatabaseType} for the connection.  * @return the database type  */ ;/**  * Returns the {@link EmbeddedDatabaseType} for the connection.  * @return the database type  */ public EmbeddedDatabaseType getType() {     return this.type. }
true;public;1;4;/**  * Returns the URL for the connection using the specified {@code databaseName}.  * @param databaseName the name of the database  * @return the connection URL  */ ;/**  * Returns the URL for the connection using the specified {@code databaseName}.  * @param databaseName the name of the database  * @return the connection URL  */ public String getUrl(String databaseName) {     Assert.hasText(databaseName, "DatabaseName must not be empty").     return (this.url != null) ? String.format(this.url, databaseName) : null. }
true;public,static;1;5;/**  * Convenience method to determine if a given driver class name represents an embedded  * database type.  * @param driverClass the driver class  * @return true if the driver class is one of the embedded types  */ ;/**  * Convenience method to determine if a given driver class name represents an embedded  * database type.  * @param driverClass the driver class  * @return true if the driver class is one of the embedded types  */ public static boolean isEmbedded(String driverClass) {     return driverClass != null && (driverClass.equals(HSQL.driverClass) || driverClass.equals(H2.driverClass) || driverClass.equals(DERBY.driverClass)). }
true;public,static;1;9;/**  * Convenience method to determine if a given data source represents an embedded  * database type.  * @param dataSource the data source to interrogate  * @return true if the data source is one of the embedded types  */ ;/**  * Convenience method to determine if a given data source represents an embedded  * database type.  * @param dataSource the data source to interrogate  * @return true if the data source is one of the embedded types  */ public static boolean isEmbedded(DataSource dataSource) {     try {         return new JdbcTemplate(dataSource).execute(new IsEmbedded()).     } catch (DataAccessException ex) {         // Could not connect, which means it's not embedded         return false.     } }
true;public,static;1;9;/**  * Returns the most suitable {@link EmbeddedDatabaseConnection} for the given class  * loader.  * @param classLoader the class loader used to check for classes  * @return an {@link EmbeddedDatabaseConnection} or {@link #NONE}.  */ ;/**  * Returns the most suitable {@link EmbeddedDatabaseConnection} for the given class  * loader.  * @param classLoader the class loader used to check for classes  * @return an {@link EmbeddedDatabaseConnection} or {@link #NONE}.  */ public static EmbeddedDatabaseConnection get(ClassLoader classLoader) {     for (EmbeddedDatabaseConnection candidate : EmbeddedDatabaseConnection.values()) {         if (candidate != NONE && ClassUtils.isPresent(candidate.getDriverClassName(), classLoader)) {             return candidate.         }     }     return NONE. }
false;public;1;16;;@Override public Boolean doInConnection(Connection connection) throws SQLException, DataAccessException {     String productName = connection.getMetaData().getDatabaseProductName().     if (productName == null) {         return false.     }     productName = productName.toUpperCase(Locale.ENGLISH).     EmbeddedDatabaseConnection[] candidates = EmbeddedDatabaseConnection.values().     for (EmbeddedDatabaseConnection candidate : candidates) {         if (candidate != NONE && productName.contains(candidate.name())) {             return true.         }     }     return false. }
