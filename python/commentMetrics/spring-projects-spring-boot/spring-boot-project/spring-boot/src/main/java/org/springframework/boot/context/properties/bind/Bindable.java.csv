commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the type of the item to bind.  * @return the type being bound  */ ;/**  * Return the type of the item to bind.  * @return the type being bound  */ public ResolvableType getType() {     return this.type. }
true;public;0;3;/**  * Return the boxed type of the item to bind.  * @return the boxed type for the item being bound  */ ;/**  * Return the boxed type of the item to bind.  * @return the boxed type for the item being bound  */ public ResolvableType getBoxedType() {     return this.boxedType. }
true;public;0;3;/**  * Return a supplier that provides the object value or {@code null}.  * @return the value or {@code null}  */ ;/**  * Return a supplier that provides the object value or {@code null}.  * @return the value or {@code null}  */ public Supplier<T> getValue() {     return this.value. }
true;public;0;3;/**  * Return any associated annotations that could affect binding.  * @return the associated annotations  */ ;/**  * Return any associated annotations that could affect binding.  * @return the associated annotations  */ public Annotation[] getAnnotations() {     return this.annotations. }
true;public;1;9;/**  * Return a single associated annotations that could affect binding.  * @param <A> the annotation type  * @param type annotation type  * @return the associated annotation or {@code null}  */ ;/**  * Return a single associated annotations that could affect binding.  * @param <A> the annotation type  * @param type annotation type  * @return the associated annotation or {@code null}  */ @SuppressWarnings("unchecked") public <A extends Annotation> A getAnnotation(Class<A> type) {     for (Annotation annotation : this.annotations) {         if (type.isInstance(annotation)) {             return (A) annotation.         }     }     return null. }
false;public;1;14;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     Bindable<?> other = (Bindable<?>) obj.     boolean result = true.     result = result && nullSafeEquals(this.type.resolve(), other.type.resolve()).     result = result && nullSafeEquals(this.annotations, other.annotations).     return result. }
false;public;0;8;;@Override public int hashCode() {     final int prime = 31.     int result = 1.     result = prime * result + ObjectUtils.nullSafeHashCode(this.type).     result = prime * result + ObjectUtils.nullSafeHashCode(this.annotations).     return result. }
false;public;0;8;;@Override public String toString() {     ToStringCreator creator = new ToStringCreator(this).     creator.append("type", this.type).     creator.append("value", (this.value != null) ? "provided" : "none").     creator.append("annotations", this.annotations).     return creator.toString(). }
false;private;2;3;;private boolean nullSafeEquals(Object o1, Object o2) {     return ObjectUtils.nullSafeEquals(o1, o2). }
true;public;1;4;/**  * Create an updated {@link Bindable} instance with the specified annotations.  * @param annotations the annotations  * @return an updated {@link Bindable}  */ ;/**  * Create an updated {@link Bindable} instance with the specified annotations.  * @param annotations the annotations  * @return an updated {@link Bindable}  */ public Bindable<T> withAnnotations(Annotation... annotations) {     return new Bindable<>(this.type, this.boxedType, this.value, (annotations != null) ? annotations : NO_ANNOTATIONS). }
true;public;1;8;/**  * Create an updated {@link Bindable} instance with an existing value.  * @param existingValue the existing value  * @return an updated {@link Bindable}  */ ;/**  * Create an updated {@link Bindable} instance with an existing value.  * @param existingValue the existing value  * @return an updated {@link Bindable}  */ public Bindable<T> withExistingValue(T existingValue) {     Assert.isTrue(existingValue == null || this.type.isArray() || this.boxedType.resolve().isInstance(existingValue), () -> "ExistingValue must be an instance of " + this.type).     Supplier<T> value = (existingValue != null) ? () -> existingValue : null.     return new Bindable<>(this.type, this.boxedType, value, NO_ANNOTATIONS). }
true;public;1;3;/**  * Create an updated {@link Bindable} instance with a value supplier.  * @param suppliedValue the supplier for the value  * @return an updated {@link Bindable}  */ ;/**  * Create an updated {@link Bindable} instance with a value supplier.  * @param suppliedValue the supplier for the value  * @return an updated {@link Bindable}  */ public Bindable<T> withSuppliedValue(Supplier<T> suppliedValue) {     return new Bindable<>(this.type, this.boxedType, suppliedValue, NO_ANNOTATIONS). }
true;public,static;1;6;/**  * Create a new {@link Bindable} of the type of the specified instance with an  * existing value equal to the instance.  * @param <T> the source type  * @param instance the instance (must not be {@code null})  * @return a {@link Bindable} instance  * @see #of(ResolvableType)  * @see #withExistingValue(Object)  */ ;/**  * Create a new {@link Bindable} of the type of the specified instance with an  * existing value equal to the instance.  * @param <T> the source type  * @param instance the instance (must not be {@code null})  * @return a {@link Bindable} instance  * @see #of(ResolvableType)  * @see #withExistingValue(Object)  */ @SuppressWarnings("unchecked") public static <T> Bindable<T> ofInstance(T instance) {     Assert.notNull(instance, "Instance must not be null").     Class<T> type = (Class<T>) instance.getClass().     return of(type).withExistingValue(instance). }
true;public,static;1;4;/**  * Create a new {@link Bindable} of the specified type.  * @param <T> the source type  * @param type the type (must not be {@code null})  * @return a {@link Bindable} instance  * @see #of(ResolvableType)  */ ;/**  * Create a new {@link Bindable} of the specified type.  * @param <T> the source type  * @param type the type (must not be {@code null})  * @return a {@link Bindable} instance  * @see #of(ResolvableType)  */ public static <T> Bindable<T> of(Class<T> type) {     Assert.notNull(type, "Type must not be null").     return of(ResolvableType.forClass(type)). }
true;public,static;1;3;/**  * Create a new {@link Bindable} {@link List} of the specified element type.  * @param <E> the element type  * @param elementType the list element type  * @return a {@link Bindable} instance  */ ;/**  * Create a new {@link Bindable} {@link List} of the specified element type.  * @param <E> the element type  * @param elementType the list element type  * @return a {@link Bindable} instance  */ public static <E> Bindable<List<E>> listOf(Class<E> elementType) {     return of(ResolvableType.forClassWithGenerics(List.class, elementType)). }
true;public,static;1;3;/**  * Create a new {@link Bindable} {@link Set} of the specified element type.  * @param <E> the element type  * @param elementType the set element type  * @return a {@link Bindable} instance  */ ;/**  * Create a new {@link Bindable} {@link Set} of the specified element type.  * @param <E> the element type  * @param elementType the set element type  * @return a {@link Bindable} instance  */ public static <E> Bindable<Set<E>> setOf(Class<E> elementType) {     return of(ResolvableType.forClassWithGenerics(Set.class, elementType)). }
true;public,static;2;3;/**  * Create a new {@link Bindable} {@link Map} of the specified key and value type.  * @param <K> the key type  * @param <V> the value type  * @param keyType the map key type  * @param valueType the map value type  * @return a {@link Bindable} instance  */ ;/**  * Create a new {@link Bindable} {@link Map} of the specified key and value type.  * @param <K> the key type  * @param <V> the value type  * @param keyType the map key type  * @param valueType the map value type  * @return a {@link Bindable} instance  */ public static <K, V> Bindable<Map<K, V>> mapOf(Class<K> keyType, Class<V> valueType) {     return of(ResolvableType.forClassWithGenerics(Map.class, keyType, valueType)). }
true;public,static;1;5;/**  * Create a new {@link Bindable} of the specified type.  * @param <T> the source type  * @param type the type (must not be {@code null})  * @return a {@link Bindable} instance  * @see #of(Class)  */ ;/**  * Create a new {@link Bindable} of the specified type.  * @param <T> the source type  * @param type the type (must not be {@code null})  * @return a {@link Bindable} instance  * @see #of(Class)  */ public static <T> Bindable<T> of(ResolvableType type) {     Assert.notNull(type, "Type must not be null").     ResolvableType boxedType = box(type).     return new Bindable<>(type, boxedType, null, NO_ANNOTATIONS). }
false;private,static;1;12;;private static ResolvableType box(ResolvableType type) {     Class<?> resolved = type.resolve().     if (resolved != null && resolved.isPrimitive()) {         Object array = Array.newInstance(resolved, 1).         Class<?> wrapperType = Array.get(array, 0).getClass().         return ResolvableType.forClass(wrapperType).     }     if (resolved != null && resolved.isArray()) {         return ResolvableType.forArrayComponent(box(type.getComponentType())).     }     return type. }
