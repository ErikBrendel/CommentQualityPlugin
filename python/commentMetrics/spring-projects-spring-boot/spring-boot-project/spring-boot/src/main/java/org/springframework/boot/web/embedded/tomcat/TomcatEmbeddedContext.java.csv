commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public boolean loadOnStartup(Container[] children) {     // deferred until later (see deferredLoadOnStartup)     return true. }
false;public;1;7;;@Override public void setManager(Manager manager) {     if (manager instanceof ManagerBase) {         ((ManagerBase) manager).setSessionIdGenerator(new LazySessionIdGenerator()).     }     super.setManager(manager). }
false;public;0;4;;public void deferredLoadOnStartup() throws LifecycleException {     doWithThreadContextClassLoader(getLoader().getClassLoader(), () -> getLoadOnStartupWrappers(findChildren()).forEach(this::load)). }
false;private;1;12;;private Stream<Wrapper> getLoadOnStartupWrappers(Container[] children) {     Map<Integer, List<Wrapper>> grouped = new TreeMap<>().     for (Container child : children) {         Wrapper wrapper = (Wrapper) child.         int order = wrapper.getLoadOnStartup().         if (order >= 0) {             grouped.computeIfAbsent(order, ArrayList::new).             grouped.get(order).add(wrapper).         }     }     return grouped.values().stream().flatMap(List::stream). }
false;private;1;13;;private void load(Wrapper wrapper) {     try {         wrapper.load().     } catch (ServletException ex) {         String message = sm.getString("standardContext.loadOnStartup.loadException", getName(), wrapper.getName()).         if (getComputedFailCtxIfServletStartFails()) {             throw new WebServerException(message, ex).         }         getLogger().error(message, StandardWrapper.getRootCause(ex)).     } }
true;private;2;12;/**  * Some older Servlet frameworks (e.g. Struts, BIRT) use the Thread context class  * loader to create servlet instances in this phase. If they do that and then try to  * initialize them later the class loader may have changed, so wrap the call to  * loadOnStartup in what we think its going to be the main webapp classloader at  * runtime.  * @param classLoader the class loader to use  * @param code the code to run  */ ;/**  * Some older Servlet frameworks (e.g. Struts, BIRT) use the Thread context class  * loader to create servlet instances in this phase. If they do that and then try to  * initialize them later the class loader may have changed, so wrap the call to  * loadOnStartup in what we think its going to be the main webapp classloader at  * runtime.  * @param classLoader the class loader to use  * @param code the code to run  */ private void doWithThreadContextClassLoader(ClassLoader classLoader, Runnable code) {     ClassLoader existingLoader = (classLoader != null) ? ClassUtils.overrideThreadContextClassLoader(classLoader) : null.     try {         code.run().     } finally {         if (existingLoader != null) {             ClassUtils.overrideThreadContextClassLoader(existingLoader).         }     } }
false;public;1;3;;public void setStarter(TomcatStarter starter) {     this.starter = starter. }
false;public;0;3;;public TomcatStarter getStarter() {     return this.starter. }
