commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;4;/**  * Determines if the specific {@link PropertySource} is the  * {@link ConfigurationPropertySource} that was {@link #attach(Environment) attached}  * to the {@link Environment}.  * @param propertySource the property source to test  * @return {@code true} if this is the attached {@link ConfigurationPropertySource}  */ ;/**  * Determines if the specific {@link PropertySource} is the  * {@link ConfigurationPropertySource} that was {@link #attach(Environment) attached}  * to the {@link Environment}.  * @param propertySource the property source to test  * @return {@code true} if this is the attached {@link ConfigurationPropertySource}  */ public static boolean isAttachedConfigurationPropertySource(PropertySource<?> propertySource) {     return ATTACHED_PROPERTY_SOURCE_NAME.equals(propertySource.getName()). }
true;public,static;1;15;/**  * Attach a {@link ConfigurationPropertySource} support to the specified  * {@link Environment}. Adapts each {@link PropertySource} managed by the environment  * to a {@link ConfigurationPropertySource} and allows classic  * {@link PropertySourcesPropertyResolver} calls to resolve using  * {@link ConfigurationPropertyName configuration property names}.  * <p>  * The attached resolver will dynamically track any additions or removals from the  * underlying {@link Environment} property sources.  * @param environment the source environment (must be an instance of  * {@link ConfigurableEnvironment})  * @see #get(Environment)  */ ;/**  * Attach a {@link ConfigurationPropertySource} support to the specified  * {@link Environment}. Adapts each {@link PropertySource} managed by the environment  * to a {@link ConfigurationPropertySource} and allows classic  * {@link PropertySourcesPropertyResolver} calls to resolve using  * {@link ConfigurationPropertyName configuration property names}.  * <p>  * The attached resolver will dynamically track any additions or removals from the  * underlying {@link Environment} property sources.  * @param environment the source environment (must be an instance of  * {@link ConfigurableEnvironment})  * @see #get(Environment)  */ public static void attach(Environment environment) {     Assert.isInstanceOf(ConfigurableEnvironment.class, environment).     MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources().     PropertySource<?> attached = sources.get(ATTACHED_PROPERTY_SOURCE_NAME).     if (attached != null && attached.getSource() != sources) {         sources.remove(ATTACHED_PROPERTY_SOURCE_NAME).         attached = null.     }     if (attached == null) {         sources.addFirst(new ConfigurationPropertySourcesPropertySource(ATTACHED_PROPERTY_SOURCE_NAME, new SpringConfigurationPropertySources(sources))).     } }
true;public,static;1;11;/**  * Return a set of {@link ConfigurationPropertySource} instances that have previously  * been {@link #attach(Environment) attached} to the {@link Environment}.  * @param environment the source environment (must be an instance of  * {@link ConfigurableEnvironment})  * @return an iterable set of configuration property sources  * @throws IllegalStateException if not configuration property sources have been  * attached  */ ;/**  * Return a set of {@link ConfigurationPropertySource} instances that have previously  * been {@link #attach(Environment) attached} to the {@link Environment}.  * @param environment the source environment (must be an instance of  * {@link ConfigurableEnvironment})  * @return an iterable set of configuration property sources  * @throws IllegalStateException if not configuration property sources have been  * attached  */ public static Iterable<ConfigurationPropertySource> get(Environment environment) {     Assert.isInstanceOf(ConfigurableEnvironment.class, environment).     MutablePropertySources sources = ((ConfigurableEnvironment) environment).getPropertySources().     ConfigurationPropertySourcesPropertySource attached = (ConfigurationPropertySourcesPropertySource) sources.get(ATTACHED_PROPERTY_SOURCE_NAME).     if (attached == null) {         return from(sources).     }     return attached.getSource(). }
true;public,static;1;3;/**  * Return {@link Iterable} containing a single new {@link ConfigurationPropertySource}  * adapted from the given Spring {@link PropertySource}.  * @param source the Spring property source to adapt  * @return an {@link Iterable} containing a single newly adapted  * {@link SpringConfigurationPropertySource}  */ ;/**  * Return {@link Iterable} containing a single new {@link ConfigurationPropertySource}  * adapted from the given Spring {@link PropertySource}.  * @param source the Spring property source to adapt  * @return an {@link Iterable} containing a single newly adapted  * {@link SpringConfigurationPropertySource}  */ public static Iterable<ConfigurationPropertySource> from(PropertySource<?> source) {     return Collections.singleton(SpringConfigurationPropertySource.from(source)). }
true;public,static;1;4;/**  * Return {@link Iterable} containing new {@link ConfigurationPropertySource}  * instances adapted from the given Spring {@link PropertySource PropertySources}.  * <p>  * This method will flatten any nested property sources and will filter all  * {@link StubPropertySource stub property sources}. Updates to the underlying source,  * identified by changes in the sources returned by its iterator, will be  * automatically tracked. The underlying source should be thread safe, for example a  * {@link MutablePropertySources}  * @param sources the Spring property sources to adapt  * @return an {@link Iterable} containing newly adapted  * {@link SpringConfigurationPropertySource} instances  */ ;/**  * Return {@link Iterable} containing new {@link ConfigurationPropertySource}  * instances adapted from the given Spring {@link PropertySource PropertySources}.  * <p>  * This method will flatten any nested property sources and will filter all  * {@link StubPropertySource stub property sources}. Updates to the underlying source,  * identified by changes in the sources returned by its iterator, will be  * automatically tracked. The underlying source should be thread safe, for example a  * {@link MutablePropertySources}  * @param sources the Spring property sources to adapt  * @return an {@link Iterable} containing newly adapted  * {@link SpringConfigurationPropertySource} instances  */ public static Iterable<ConfigurationPropertySource> from(Iterable<PropertySource<?>> sources) {     return new SpringConfigurationPropertySources(sources). }
false;private,static;1;5;;private static Stream<PropertySource<?>> streamPropertySources(PropertySources sources) {     return sources.stream().flatMap(ConfigurationPropertySources::flatten).filter(ConfigurationPropertySources::isIncluded). }
false;private,static;1;7;;private static Stream<PropertySource<?>> flatten(PropertySource<?> source) {     if (source.getSource() instanceof ConfigurableEnvironment) {         return streamPropertySources(((ConfigurableEnvironment) source.getSource()).getPropertySources()).     }     return Stream.of(source). }
false;private,static;1;4;;private static boolean isIncluded(PropertySource<?> source) {     return !(source instanceof StubPropertySource) && !(source instanceof ConfigurationPropertySourcesPropertySource). }
