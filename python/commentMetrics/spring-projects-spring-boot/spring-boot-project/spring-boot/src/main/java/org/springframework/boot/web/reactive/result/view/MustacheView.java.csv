commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the JMustache compiler to be used by this view. Typically this property is not  * set directly. Instead a single {@link Compiler} is expected in the Spring  * application context which is used to compile Mustache templates.  * @param compiler the Mustache compiler  */ ;/**  * Set the JMustache compiler to be used by this view. Typically this property is not  * set directly. Instead a single {@link Compiler} is expected in the Spring  * application context which is used to compile Mustache templates.  * @param compiler the Mustache compiler  */ public void setCompiler(Compiler compiler) {     this.compiler = compiler. }
true;public;1;3;/**  * Set the charset used for reading Mustache template files.  * @param charset the charset to use for reading template files  */ ;/**  * Set the charset used for reading Mustache template files.  * @param charset the charset to use for reading template files  */ public void setCharset(String charset) {     this.charset = charset. }
false;public;1;4;;@Override public boolean checkResourceExists(Locale locale) throws Exception {     return resolveResource() != null. }
false;protected;3;24;;@Override protected Mono<Void> renderInternal(Map<String, Object> model, MediaType contentType, ServerWebExchange exchange) {     Resource resource = resolveResource().     if (resource == null) {         return Mono.error(new IllegalStateException("Could not find Mustache template with URL [" + getUrl() + "]")).     }     DataBuffer dataBuffer = exchange.getResponse().bufferFactory().allocateBuffer().     try (Reader reader = getReader(resource)) {         Template template = this.compiler.compile(reader).         Charset charset = getCharset(contentType).orElse(getDefaultCharset()).         try (Writer writer = new OutputStreamWriter(dataBuffer.asOutputStream(), charset)) {             template.execute(model, writer).             writer.flush().         }     } catch (Exception ex) {         DataBufferUtils.release(dataBuffer).         return Mono.error(ex).     }     return exchange.getResponse().writeWith(Flux.just(dataBuffer)). }
false;private;0;7;;private Resource resolveResource() {     Resource resource = getApplicationContext().getResource(getUrl()).     if (resource == null || !resource.exists()) {         return null.     }     return resource. }
false;private;1;6;;private Reader getReader(Resource resource) throws IOException {     if (this.charset != null) {         return new InputStreamReader(resource.getInputStream(), this.charset).     }     return new InputStreamReader(resource.getInputStream()). }
false;private;1;3;;private Optional<Charset> getCharset(MediaType mediaType) {     return Optional.ofNullable((mediaType != null) ? mediaType.getCharset() : null). }
