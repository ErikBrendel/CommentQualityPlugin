commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {     return ApplicationEnvironmentPreparedEvent.class.isAssignableFrom(eventType) || ApplicationPreparedEvent.class.isAssignableFrom(eventType). }
false;public;1;10;;@Override public void onApplicationEvent(ApplicationEvent event) {     if (event instanceof ApplicationEnvironmentPreparedEvent) {         onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event).     }     if (event instanceof ApplicationPreparedEvent) {         onApplicationPreparedEvent(event).     } }
false;private;1;10;;private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) {     List<EnvironmentPostProcessor> postProcessors = loadPostProcessors().     postProcessors.add(this).     AnnotationAwareOrderComparator.sort(postProcessors).     for (EnvironmentPostProcessor postProcessor : postProcessors) {         postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication()).     } }
false;;0;4;;List<EnvironmentPostProcessor> loadPostProcessors() {     return SpringFactoriesLoader.loadFactories(EnvironmentPostProcessor.class, getClass().getClassLoader()). }
false;public;2;5;;@Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) {     addPropertySources(environment, application.getResourceLoader()). }
false;private;1;4;;private void onApplicationPreparedEvent(ApplicationEvent event) {     this.logger.switchTo(ConfigFileApplicationListener.class).     addPostProcessors(((ApplicationPreparedEvent) event).getApplicationContext()). }
true;protected;2;5;/**  * Add config file property sources to the specified environment.  * @param environment the environment to add source to  * @param resourceLoader the resource loader  * @see #addPostProcessors(ConfigurableApplicationContext)  */ ;/**  * Add config file property sources to the specified environment.  * @param environment the environment to add source to  * @param resourceLoader the resource loader  * @see #addPostProcessors(ConfigurableApplicationContext)  */ protected void addPropertySources(ConfigurableEnvironment environment, ResourceLoader resourceLoader) {     RandomValuePropertySource.addToEnvironment(environment).     new Loader(environment, resourceLoader).load(). }
true;protected;1;4;/**  * Add appropriate post-processors to post-configure the property-sources.  * @param context the context to configure  */ ;/**  * Add appropriate post-processors to post-configure the property-sources.  * @param context the context to configure  */ protected void addPostProcessors(ConfigurableApplicationContext context) {     context.addBeanFactoryPostProcessor(new PropertySourceOrderingPostProcessor(context)). }
false;public;1;3;;public void setOrder(int order) {     this.order = order. }
false;public;0;4;;@Override public int getOrder() {     return this.order. }
true;public;1;4;/**  * Set the search locations that will be considered as a comma-separated list. Each  * search location should be a directory path (ending in "/") and it will be prefixed  * by the file names constructed from {@link #setSearchNames(String) search names} and  * profiles (if any) plus file extensions supported by the properties loaders.  * Locations are considered in the order specified, with later items taking precedence  * (like a map merge).  * @param locations the search locations  */ ;/**  * Set the search locations that will be considered as a comma-separated list. Each  * search location should be a directory path (ending in "/") and it will be prefixed  * by the file names constructed from {@link #setSearchNames(String) search names} and  * profiles (if any) plus file extensions supported by the properties loaders.  * Locations are considered in the order specified, with later items taking precedence  * (like a map merge).  * @param locations the search locations  */ public void setSearchLocations(String locations) {     Assert.hasLength(locations, "Locations must not be empty").     this.searchLocations = locations. }
true;public;1;4;/**  * Sets the names of the files that should be loaded (excluding file extension) as a  * comma-separated list.  * @param names the names to load  */ ;/**  * Sets the names of the files that should be loaded (excluding file extension) as a  * comma-separated list.  * @param names the names to load  */ public void setSearchNames(String names) {     Assert.hasLength(names, "Names must not be empty").     this.names = names. }
false;public;0;4;;@Override public int getOrder() {     return Ordered.HIGHEST_PRECEDENCE. }
false;public;1;5;;@Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {     reorderSources(this.context.getEnvironment()). }
false;private;1;7;;private void reorderSources(ConfigurableEnvironment environment) {     PropertySource<?> defaultProperties = environment.getPropertySources().remove(DEFAULT_PROPERTIES).     if (defaultProperties != null) {         environment.getPropertySources().addLast(defaultProperties).     } }
false;public;0;20;;public void load() {     this.profiles = new LinkedList<>().     this.processedProfiles = new LinkedList<>().     this.activatedProfiles = false.     this.loaded = new LinkedHashMap<>().     initializeProfiles().     while (!this.profiles.isEmpty()) {         Profile profile = this.profiles.poll().         if (profile != null && !profile.isDefaultProfile()) {             addProfileToEnvironment(profile.getName()).         }         load(profile, this::getPositiveProfileFilter, addToLoaded(MutablePropertySources::addLast, false)).         this.processedProfiles.add(profile).     }     resetEnvironmentProfiles(this.processedProfiles).     load(null, this::getNegativeProfileFilter, addToLoaded(MutablePropertySources::addFirst, true)).     addLoadedPropertySources(). }
true;private;0;22;/**  * Initialize profile information from both the {@link Environment} active  * profiles and any {@code spring.profiles.active}/{@code spring.profiles.include}  * properties that are already set.  */ ;/**  * Initialize profile information from both the {@link Environment} active  * profiles and any {@code spring.profiles.active}/{@code spring.profiles.include}  * properties that are already set.  */ private void initializeProfiles() {     // The default profile for these purposes is represented as null. We add it     // first so that it is processed first and has lowest priority.     this.profiles.add(null).     Set<Profile> activatedViaProperty = getProfilesFromProperty(ACTIVE_PROFILES_PROPERTY).     Set<Profile> includedViaProperty = getProfilesFromProperty(INCLUDE_PROFILES_PROPERTY).     List<Profile> otherActiveProfiles = getOtherActiveProfiles(activatedViaProperty, includedViaProperty).     this.profiles.addAll(otherActiveProfiles).     // Any pre-existing active profiles set via property sources (e.g.     // System properties) take precedence over those added in config files.     this.profiles.addAll(includedViaProperty).     addActiveProfiles(activatedViaProperty).     if (this.profiles.size() == 1) {         // only has null profile         for (String defaultProfileName : this.environment.getDefaultProfiles()) {             Profile defaultProfile = new Profile(defaultProfileName, true).             this.profiles.add(defaultProfile).         }     } }
false;private;1;8;;private Set<Profile> getProfilesFromProperty(String profilesProperty) {     if (!this.environment.containsProperty(profilesProperty)) {         return Collections.emptySet().     }     Binder binder = Binder.get(this.environment).     Set<Profile> profiles = getProfiles(binder, profilesProperty).     return new LinkedHashSet<>(profiles). }
false;private;2;7;;private List<Profile> getOtherActiveProfiles(Set<Profile> activatedViaProperty, Set<Profile> includedViaProperty) {     return Arrays.stream(this.environment.getActiveProfiles()).map(Profile::new).filter((profile) -> !activatedViaProperty.contains(profile) && !includedViaProperty.contains(profile)).collect(Collectors.toList()). }
false;;1;19;;void addActiveProfiles(Set<Profile> profiles) {     if (profiles.isEmpty()) {         return.     }     if (this.activatedProfiles) {         if (this.logger.isDebugEnabled()) {             this.logger.debug("Profiles already activated, '" + profiles + "' will not be applied").         }         return.     }     this.profiles.addAll(profiles).     if (this.logger.isDebugEnabled()) {         this.logger.debug("Activated activeProfiles " + StringUtils.collectionToCommaDelimitedString(profiles)).     }     this.activatedProfiles = true.     removeUnprocessedDefaultProfiles(). }
false;private;0;4;;private void removeUnprocessedDefaultProfiles() {     this.profiles.removeIf((profile) -> (profile != null && profile.isDefaultProfile())). }
false;private;1;11;;private DocumentFilter getPositiveProfileFilter(Profile profile) {     return (Document document) -> {         if (profile == null) {             return ObjectUtils.isEmpty(document.getProfiles()).         }         return ObjectUtils.containsElement(document.getProfiles(), profile.getName()) && this.environment.acceptsProfiles(Profiles.of(document.getProfiles())).     }. }
false;private;1;5;;private DocumentFilter getNegativeProfileFilter(Profile profile) {     return (Document document) -> (profile == null && !ObjectUtils.isEmpty(document.getProfiles()) && this.environment.acceptsProfiles(Profiles.of(document.getProfiles()))). }
false;private;2;16;;private DocumentConsumer addToLoaded(BiConsumer<MutablePropertySources, PropertySource<?>> addMethod, boolean checkForExisting) {     return (profile, document) -> {         if (checkForExisting) {             for (MutablePropertySources merged : this.loaded.values()) {                 if (merged.contains(document.getPropertySource().getName())) {                     return.                 }             }         }         MutablePropertySources merged = this.loaded.computeIfAbsent(profile, (k) -> new MutablePropertySources()).         addMethod.accept(merged, document.getPropertySource()).     }. }
false;private;3;9;;private void load(Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) {     getSearchLocations().forEach((location) -> {         boolean isFolder = location.endsWith("/").         Set<String> names = isFolder ? getSearchNames() : NO_SEARCH_NAMES.         names.forEach((name) -> load(location, name, profile, filterFactory, consumer)).     }). }
false;private;5;21;;private void load(String location, String name, Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) {     if (!StringUtils.hasText(name)) {         for (PropertySourceLoader loader : this.propertySourceLoaders) {             if (canLoadFileExtension(loader, location)) {                 load(loader, location, profile, filterFactory.getDocumentFilter(profile), consumer).                 return.             }         }     }     Set<String> processed = new HashSet<>().     for (PropertySourceLoader loader : this.propertySourceLoaders) {         for (String fileExtension : loader.getFileExtensions()) {             if (processed.add(fileExtension)) {                 loadForFileExtension(loader, location + name, "." + fileExtension, profile, filterFactory, consumer).             }         }     } }
false;private;2;5;;private boolean canLoadFileExtension(PropertySourceLoader loader, String name) {     return Arrays.stream(loader.getFileExtensions()).anyMatch((fileExtension) -> StringUtils.endsWithIgnoreCase(name, fileExtension)). }
false;private;6;22;;private void loadForFileExtension(PropertySourceLoader loader, String prefix, String fileExtension, Profile profile, DocumentFilterFactory filterFactory, DocumentConsumer consumer) {     DocumentFilter defaultFilter = filterFactory.getDocumentFilter(null).     DocumentFilter profileFilter = filterFactory.getDocumentFilter(profile).     if (profile != null) {         // Try profile-specific file & profile section in profile file (gh-340)         String profileSpecificFile = prefix + "-" + profile + fileExtension.         load(loader, profileSpecificFile, profile, defaultFilter, consumer).         load(loader, profileSpecificFile, profile, profileFilter, consumer).         // Try profile specific sections in files we've already processed         for (Profile processedProfile : this.processedProfiles) {             if (processedProfile != null) {                 String previouslyLoaded = prefix + "-" + processedProfile + fileExtension.                 load(loader, previouslyLoaded, profile, profileFilter, consumer).             }         }     }     // Also try the profile-specific section (if any) of the normal file     load(loader, prefix + fileExtension, profile, profileFilter, consumer). }
false;private;5;55;;private void load(PropertySourceLoader loader, String location, Profile profile, DocumentFilter filter, DocumentConsumer consumer) {     try {         Resource resource = this.resourceLoader.getResource(location).         if (resource == null || !resource.exists()) {             if (this.logger.isTraceEnabled()) {                 StringBuilder description = getDescription("Skipped missing config ", location, resource, profile).                 this.logger.trace(description).             }             return.         }         if (!StringUtils.hasText(StringUtils.getFilenameExtension(resource.getFilename()))) {             if (this.logger.isTraceEnabled()) {                 StringBuilder description = getDescription("Skipped empty config extension ", location, resource, profile).                 this.logger.trace(description).             }             return.         }         String name = "applicationConfig: [" + location + "]".         List<Document> documents = loadDocuments(loader, name, resource).         if (CollectionUtils.isEmpty(documents)) {             if (this.logger.isTraceEnabled()) {                 StringBuilder description = getDescription("Skipped unloaded config ", location, resource, profile).                 this.logger.trace(description).             }             return.         }         List<Document> loaded = new ArrayList<>().         for (Document document : documents) {             if (filter.match(document)) {                 addActiveProfiles(document.getActiveProfiles()).                 addIncludedProfiles(document.getIncludeProfiles()).                 loaded.add(document).             }         }         Collections.reverse(loaded).         if (!loaded.isEmpty()) {             loaded.forEach((document) -> consumer.accept(profile, document)).             if (this.logger.isDebugEnabled()) {                 StringBuilder description = getDescription("Loaded config file ", location, resource, profile).                 this.logger.debug(description).             }         }     } catch (Exception ex) {         throw new IllegalStateException("Failed to load property " + "source from location '" + location + "'", ex).     } }
false;private;1;7;;private void addIncludedProfiles(Set<Profile> includeProfiles) {     LinkedList<Profile> existingProfiles = new LinkedList<>(this.profiles).     this.profiles.clear().     this.profiles.addAll(includeProfiles).     this.profiles.removeAll(this.processedProfiles).     this.profiles.addAll(existingProfiles). }
false;private;3;11;;private List<Document> loadDocuments(PropertySourceLoader loader, String name, Resource resource) throws IOException {     DocumentsCacheKey cacheKey = new DocumentsCacheKey(loader, resource).     List<Document> documents = this.loadDocumentsCache.get(cacheKey).     if (documents == null) {         List<PropertySource<?>> loaded = loader.load(name, resource).         documents = asDocuments(loaded).         this.loadDocumentsCache.put(cacheKey, documents).     }     return documents. }
false;private;1;14;;private List<Document> asDocuments(List<PropertySource<?>> loaded) {     if (loaded == null) {         return Collections.emptyList().     }     return loaded.stream().map((propertySource) -> {         Binder binder = new Binder(ConfigurationPropertySources.from(propertySource), this.placeholdersResolver).         return new Document(propertySource, binder.bind("spring.profiles", STRING_ARRAY).orElse(null), getProfiles(binder, ACTIVE_PROFILES_PROPERTY), getProfiles(binder, INCLUDE_PROFILES_PROPERTY)).     }).collect(Collectors.toList()). }
false;private;4;22;;private StringBuilder getDescription(String prefix, String location, Resource resource, Profile profile) {     StringBuilder result = new StringBuilder(prefix).     try {         if (resource != null) {             String uri = resource.getURI().toASCIIString().             result.append("'").             result.append(uri).             result.append("' (").             result.append(location).             result.append(")").         }     } catch (IOException ex) {         result.append(location).     }     if (profile != null) {         result.append(" for profile ").         result.append(profile).     }     return result. }
false;private;2;4;;private Set<Profile> getProfiles(Binder binder, String name) {     return binder.bind(name, STRING_ARRAY).map(this::asProfileSet).orElse(Collections.emptySet()). }
false;private;1;7;;private Set<Profile> asProfileSet(String[] profileNames) {     List<Profile> profiles = new ArrayList<>().     for (String profileName : profileNames) {         profiles.add(new Profile(profileName)).     }     return new LinkedHashSet<>(profiles). }
false;private;1;8;;private void addProfileToEnvironment(String profile) {     for (String activeProfile : this.environment.getActiveProfiles()) {         if (activeProfile.equals(profile)) {             return.         }     }     this.environment.addActiveProfile(profile). }
false;private;0;11;;private Set<String> getSearchLocations() {     if (this.environment.containsProperty(CONFIG_LOCATION_PROPERTY)) {         return getSearchLocations(CONFIG_LOCATION_PROPERTY).     }     Set<String> locations = getSearchLocations(CONFIG_ADDITIONAL_LOCATION_PROPERTY).     locations.addAll(asResolvedSet(ConfigFileApplicationListener.this.searchLocations, DEFAULT_SEARCH_LOCATIONS)).     return locations. }
false;private;1;16;;private Set<String> getSearchLocations(String propertyName) {     Set<String> locations = new LinkedHashSet<>().     if (this.environment.containsProperty(propertyName)) {         for (String path : asResolvedSet(this.environment.getProperty(propertyName), null)) {             if (!path.contains("$")) {                 path = StringUtils.cleanPath(path).                 if (!ResourceUtils.isUrl(path)) {                     path = ResourceUtils.FILE_URL_PREFIX + path.                 }             }             locations.add(path).         }     }     return locations. }
false;private;0;7;;private Set<String> getSearchNames() {     if (this.environment.containsProperty(CONFIG_NAME_PROPERTY)) {         String property = this.environment.getProperty(CONFIG_NAME_PROPERTY).         return asResolvedSet(property, null).     }     return asResolvedSet(ConfigFileApplicationListener.this.names, DEFAULT_NAMES). }
false;private;2;7;;private Set<String> asResolvedSet(String value, String fallback) {     List<String> list = Arrays.asList(StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray((value != null) ? this.environment.resolvePlaceholders(value) : fallback))).     Collections.reverse(list).     return new LinkedHashSet<>(list). }
true;private;1;6;/**  * This ensures that the order of active profiles in the {@link Environment}  * matches the order in which the profiles were processed.  * @param processedProfiles the processed profiles  */ ;/**  * This ensures that the order of active profiles in the {@link Environment}  * matches the order in which the profiles were processed.  * @param processedProfiles the processed profiles  */ private void resetEnvironmentProfiles(List<Profile> processedProfiles) {     String[] names = processedProfiles.stream().filter((profile) -> profile != null && !profile.isDefaultProfile()).map(Profile::getName).toArray(String[]::new).     this.environment.setActiveProfiles(names). }
false;private;0;15;;private void addLoadedPropertySources() {     MutablePropertySources destination = this.environment.getPropertySources().     List<MutablePropertySources> loaded = new ArrayList<>(this.loaded.values()).     Collections.reverse(loaded).     String lastAdded = null.     Set<String> added = new HashSet<>().     for (MutablePropertySources sources : loaded) {         for (PropertySource<?> source : sources) {             if (added.add(source.getName())) {                 addLoadedPropertySource(destination, lastAdded, source).                 lastAdded = source.getName().             }         }     } }
false;private;3;14;;private void addLoadedPropertySource(MutablePropertySources destination, String lastAdded, PropertySource<?> source) {     if (lastAdded == null) {         if (destination.contains(DEFAULT_PROPERTIES)) {             destination.addBefore(DEFAULT_PROPERTIES, source).         } else {             destination.addLast(source).         }     } else {         destination.addAfter(lastAdded, source).     } }
false;public;0;3;;public String getName() {     return this.name. }
false;public;0;3;;public boolean isDefaultProfile() {     return this.defaultProfile. }
false;public;1;10;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     }     if (obj == null || obj.getClass() != getClass()) {         return false.     }     return ((Profile) obj).name.equals(this.name). }
false;public;0;4;;@Override public int hashCode() {     return this.name.hashCode(). }
false;public;0;4;;@Override public String toString() {     return this.name. }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     DocumentsCacheKey other = (DocumentsCacheKey) obj.     return this.loader.equals(other.loader) && this.resource.equals(other.resource). }
false;public;0;4;;@Override public int hashCode() {     return this.loader.hashCode() * 31 + this.resource.hashCode(). }
false;public;0;3;;public PropertySource<?> getPropertySource() {     return this.propertySource. }
false;public;0;3;;public String[] getProfiles() {     return this.profiles. }
false;public;0;3;;public Set<Profile> getActiveProfiles() {     return this.activeProfiles. }
false;public;0;3;;public Set<Profile> getIncludeProfiles() {     return this.includeProfiles. }
false;public;0;4;;@Override public String toString() {     return this.propertySource.toString(). }
true;;1;1;/**  * Create a filter for the given profile.  * @param profile the profile or {@code null}  * @return the filter  */ ;/**  * Create a filter for the given profile.  * @param profile the profile or {@code null}  * @return the filter  */ DocumentFilter getDocumentFilter(Profile profile).
false;;1;1;;boolean match(Document document).
false;;2;1;;void accept(Profile profile, Document document).
