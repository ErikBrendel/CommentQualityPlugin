commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;10;;@Override public final void refresh() throws BeansException, IllegalStateException {     try {         super.refresh().     } catch (RuntimeException ex) {         stopAndReleaseReactiveWebServer().         throw ex.     } }
false;protected;0;11;;@Override protected void onRefresh() {     super.onRefresh().     try {         createWebServer().     } catch (Throwable ex) {         throw new ApplicationContextException("Unable to start reactive web server", ex).     } }
false;private;0;12;;private void createWebServer() {     ServerManager serverManager = this.serverManager.     if (serverManager == null) {         String webServerFactoryBeanName = getWebServerFactoryBeanName().         ReactiveWebServerFactory webServerFactory = getWebServerFactory(webServerFactoryBeanName).         boolean lazyInit = getBeanFactory().getBeanDefinition(webServerFactoryBeanName).isLazyInit().         this.serverManager = ServerManager.get(webServerFactory, lazyInit).     }     initPropertySources(). }
false;protected;0;17;;protected String getWebServerFactoryBeanName() {     // Use bean names so that we don't consider the hierarchy     String[] beanNames = getBeanFactory().getBeanNamesForType(ReactiveWebServerFactory.class).     if (beanNames.length == 0) {         throw new ApplicationContextException("Unable to start ReactiveWebApplicationContext due to missing " + "ReactiveWebServerFactory bean.").     }     if (beanNames.length > 1) {         throw new ApplicationContextException("Unable to start ReactiveWebApplicationContext due to multiple " + "ReactiveWebServerFactory beans : " + StringUtils.arrayToCommaDelimitedString(beanNames)).     }     return beanNames[0]. }
false;protected;1;3;;protected ReactiveWebServerFactory getWebServerFactory(String factoryBeanName) {     return getBeanFactory().getBean(factoryBeanName, ReactiveWebServerFactory.class). }
true;protected;0;4;/**  * Return the {@link ReactiveWebServerFactory} that should be used to create the  * reactive web server. By default this method searches for a suitable bean in the  * context itself.  * @return a {@link ReactiveWebServerFactory} (never {@code null})  * @deprecated since 2.2 in favor of {@link #getWebServerFactoryBeanName()} and  * {@link #getWebServerFactory(String)}  */ ;/**  * Return the {@link ReactiveWebServerFactory} that should be used to create the  * reactive web server. By default this method searches for a suitable bean in the  * context itself.  * @return a {@link ReactiveWebServerFactory} (never {@code null})  * @deprecated since 2.2 in favor of {@link #getWebServerFactoryBeanName()} and  * {@link #getWebServerFactory(String)}  */ @Deprecated protected ReactiveWebServerFactory getWebServerFactory() {     return getWebServerFactory(getWebServerFactoryBeanName()). }
false;protected;0;8;;@Override protected void finishRefresh() {     super.finishRefresh().     WebServer webServer = startReactiveWebServer().     if (webServer != null) {         publishEvent(new ReactiveWebServerInitializedEvent(webServer, this)).     } }
false;private;0;5;;private WebServer startReactiveWebServer() {     ServerManager serverManager = this.serverManager.     ServerManager.start(serverManager, this::getHttpHandler).     return ServerManager.getWebServer(serverManager). }
true;protected;0;14;/**  * Return the {@link HttpHandler} that should be used to process the reactive web  * server. By default this method searches for a suitable bean in the context itself.  * @return a {@link HttpHandler} (never {@code null}  */ ;/**  * Return the {@link HttpHandler} that should be used to process the reactive web  * server. By default this method searches for a suitable bean in the context itself.  * @return a {@link HttpHandler} (never {@code null}  */ protected HttpHandler getHttpHandler() {     // Use bean names so that we don't consider the hierarchy     String[] beanNames = getBeanFactory().getBeanNamesForType(HttpHandler.class).     if (beanNames.length == 0) {         throw new ApplicationContextException("Unable to start ReactiveWebApplicationContext due to missing HttpHandler bean.").     }     if (beanNames.length > 1) {         throw new ApplicationContextException("Unable to start ReactiveWebApplicationContext due to multiple HttpHandler beans : " + StringUtils.arrayToCommaDelimitedString(beanNames)).     }     return getBeanFactory().getBean(beanNames[0], HttpHandler.class). }
false;protected;0;5;;@Override protected void onClose() {     super.onClose().     stopAndReleaseReactiveWebServer(). }
false;private;0;9;;private void stopAndReleaseReactiveWebServer() {     ServerManager serverManager = this.serverManager.     try {         ServerManager.stop(serverManager).     } finally {         this.serverManager = null.     } }
true;public;0;4;/**  * Returns the {@link WebServer} that was created by the context or {@code null} if  * the server has not yet been created.  * @return the web server  */ ;/**  * Returns the {@link WebServer} that was created by the context or {@code null} if  * the server has not yet been created.  * @return the web server  */ @Override public WebServer getWebServer() {     return ServerManager.getWebServer(this.serverManager). }
false;public;0;4;;@Override public String getServerNamespace() {     return this.serverNamespace. }
false;public;1;4;;@Override public void setServerNamespace(String serverNamespace) {     this.serverNamespace = serverNamespace. }
false;public;2;4;;@Override public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {     return this.delegate.flatMap((handler) -> handler.handle(request, response)). }
false;private;2;5;;private Mono<Void> handleUninitialized(ServerHttpRequest request, ServerHttpResponse response) {     throw new IllegalStateException("The HttpHandler has not yet been initialized"). }
false;public;2;4;;@Override public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {     return this.handler.handle(request, response). }
false;public;0;3;;public HttpHandler getHandler() {     return this.handler. }
false;public,static;2;4;;public static ServerManager get(ReactiveWebServerFactory factory, boolean lazyInit) {     return new ServerManager(factory, lazyInit). }
false;public,static;1;3;;public static WebServer getWebServer(ServerManager manager) {     return (manager != null) ? manager.server : null. }
false;public,static;2;9;;public static void start(ServerManager manager, Supplier<HttpHandler> handlerSupplier) {     if (manager != null && manager.server != null) {         manager.handler = manager.lazyInit ? new LazyHttpHandler(Mono.fromSupplier(handlerSupplier)) : handlerSupplier.get().         manager.server.start().     } }
false;public,static;1;10;;public static void stop(ServerManager manager) {     if (manager != null && manager.server != null) {         try {             manager.server.stop().         } catch (Exception ex) {             throw new IllegalStateException(ex).         }     } }
