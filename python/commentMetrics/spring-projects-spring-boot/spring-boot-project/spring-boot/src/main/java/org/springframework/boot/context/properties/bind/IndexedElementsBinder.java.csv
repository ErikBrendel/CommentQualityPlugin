commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected boolean isAllowRecursiveBinding(ConfigurationPropertySource source) {     return source == null || source instanceof IterableConfigurationPropertySource. }
true;protected,final;6;11;/**  * Bind indexed elements to the supplied collection.  * @param name the name of the property to bind  * @param target the target bindable  * @param elementBinder the binder to use for elements  * @param aggregateType the aggregate type, may be a collection or an array  * @param elementType the element type  * @param result the destination for results  */ ;/**  * Bind indexed elements to the supplied collection.  * @param name the name of the property to bind  * @param target the target bindable  * @param elementBinder the binder to use for elements  * @param aggregateType the aggregate type, may be a collection or an array  * @param elementType the element type  * @param result the destination for results  */ protected final void bindIndexed(ConfigurationPropertyName name, Bindable<?> target, AggregateElementBinder elementBinder, ResolvableType aggregateType, ResolvableType elementType, IndexedCollectionSupplier result) {     for (ConfigurationPropertySource source : getContext().getSources()) {         bindIndexed(source, name, target, elementBinder, result, aggregateType, elementType).         if (result.wasSupplied() && result.get() != null) {             return.         }     } }
false;private;7;13;;private void bindIndexed(ConfigurationPropertySource source, ConfigurationPropertyName root, Bindable<?> target, AggregateElementBinder elementBinder, IndexedCollectionSupplier collection, ResolvableType aggregateType, ResolvableType elementType) {     ConfigurationProperty property = source.getConfigurationProperty(root).     if (property != null) {         bindValue(target, collection.get(), aggregateType, elementType, property.getValue()).     } else {         bindIndexed(source, root, elementBinder, collection, elementType).     } }
false;private;5;11;;private void bindValue(Bindable<?> target, Collection<Object> collection, ResolvableType aggregateType, ResolvableType elementType, Object value) {     if (value instanceof String && !StringUtils.hasText((String) value)) {         return.     }     Object aggregate = convert(value, aggregateType, target.getAnnotations()).     ResolvableType collectionType = ResolvableType.forClassWithGenerics(collection.getClass(), elementType).     Collection<Object> elements = convert(aggregate, collectionType).     collection.addAll(elements). }
false;private;5;17;;private void bindIndexed(ConfigurationPropertySource source, ConfigurationPropertyName root, AggregateElementBinder elementBinder, IndexedCollectionSupplier collection, ResolvableType elementType) {     MultiValueMap<String, ConfigurationProperty> knownIndexedChildren = getKnownIndexedChildren(source, root).     for (int i = 0. i < Integer.MAX_VALUE. i++) {         ConfigurationPropertyName name = root.append((i != 0) ? "[" + i + "]" : INDEX_ZERO).         Object value = elementBinder.bind(name, Bindable.of(elementType), source).         if (value == null) {             break.         }         knownIndexedChildren.remove(name.getLastElement(Form.UNIFORM)).         collection.get().add(value).     }     assertNoUnboundChildren(knownIndexedChildren). }
false;private;2;18;;private MultiValueMap<String, ConfigurationProperty> getKnownIndexedChildren(ConfigurationPropertySource source, ConfigurationPropertyName root) {     MultiValueMap<String, ConfigurationProperty> children = new LinkedMultiValueMap<>().     if (!(source instanceof IterableConfigurationPropertySource)) {         return children.     }     for (ConfigurationPropertyName name : (IterableConfigurationPropertySource) source.filter(root::isAncestorOf)) {         ConfigurationPropertyName choppedName = name.chop(root.getNumberOfElements() + 1).         if (choppedName.isLastElementIndexed()) {             String key = choppedName.getLastElement(Form.UNIFORM).             ConfigurationProperty value = source.getConfigurationProperty(name).             children.add(key, value).         }     }     return children. }
false;private;1;8;;private void assertNoUnboundChildren(MultiValueMap<String, ConfigurationProperty> children) {     if (!children.isEmpty()) {         throw new UnboundConfigurationPropertiesException(children.values().stream().flatMap(List::stream).collect(Collectors.toCollection(TreeSet::new))).     } }
false;private;3;4;;private <C> C convert(Object value, ResolvableType type, Annotation... annotations) {     value = getContext().getPlaceholdersResolver().resolvePlaceholders(value).     return getContext().getConverter().convert(value, type, annotations). }
