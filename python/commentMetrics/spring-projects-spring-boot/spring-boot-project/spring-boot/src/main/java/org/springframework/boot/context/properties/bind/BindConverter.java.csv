commented;modifiers;parameterAmount;loc;comment;code
false;private;2;11;;private List<ConversionService> getConversionServices(ConversionService conversionService, Consumer<PropertyEditorRegistry> propertyEditorInitializer) {     List<ConversionService> services = new ArrayList<>().     services.add(new TypeConverterConversionService(propertyEditorInitializer)).     services.add(conversionService).     if (!(conversionService instanceof ApplicationConversionService)) {         services.add(ApplicationConversionService.getSharedInstance()).     }     return services. }
false;public;3;5;;public boolean canConvert(Object value, ResolvableType type, Annotation... annotations) {     return this.conversionService.canConvert(TypeDescriptor.forObject(value), new ResolvableTypeDescriptor(type, annotations)). }
false;public;2;3;;public <T> T convert(Object result, Bindable<T> target) {     return convert(result, target.getType(), target.getAnnotations()). }
false;public;3;8;;@SuppressWarnings("unchecked") public <T> T convert(Object value, ResolvableType type, Annotation... annotations) {     if (value == null) {         return null.     }     return (T) this.conversionService.convert(value, TypeDescriptor.forObject(value), new ResolvableTypeDescriptor(type, annotations)). }
false;static;2;12;;static BindConverter get(ConversionService conversionService, Consumer<PropertyEditorRegistry> propertyEditorInitializer) {     if (conversionService == ApplicationConversionService.getSharedInstance() && propertyEditorInitializer == null) {         if (sharedInstance == null) {             sharedInstance = new BindConverter(conversionService, propertyEditorInitializer).         }         return sharedInstance.     }     return new BindConverter(conversionService, propertyEditorInitializer). }
false;public;2;7;;@Override public boolean canConvert(Class<?> sourceType, Class<?> targetType) {     Assert.notNull(targetType, "Target type to convert to cannot be null").     return canConvert((sourceType != null) ? TypeDescriptor.valueOf(sourceType) : null, TypeDescriptor.valueOf(targetType)). }
false;public;2;9;;@Override public boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {     for (ConversionService service : this.delegates) {         if (service.canConvert(sourceType, targetType)) {             return true.         }     }     return false. }
false;public;2;7;;@Override @SuppressWarnings("unchecked") public <T> T convert(Object source, Class<T> targetType) {     Assert.notNull(targetType, "Target type to convert to cannot be null").     return (T) convert(source, TypeDescriptor.forObject(source), TypeDescriptor.valueOf(targetType)). }
false;public;3;16;;@Override public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     for (int i = 0. i < this.delegates.size() - 1. i++) {         try {             ConversionService delegate = this.delegates.get(i).             if (delegate.canConvert(sourceType, targetType)) {                 return delegate.convert(source, sourceType, targetType).             }         } catch (ConversionException ex) {         }     }     return this.delegates.get(this.delegates.size() - 1).convert(source, sourceType, targetType). }
false;private;1;8;;private SimpleTypeConverter createTypeConverter(Consumer<PropertyEditorRegistry> initializer) {     SimpleTypeConverter typeConverter = new SimpleTypeConverter().     if (initializer != null) {         initializer.accept(typeConverter).     }     return typeConverter. }
false;public;2;9;;@Override public boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {     // Prefer conversion service to handle things like String to char[].     if (targetType.isArray() && targetType.getElementTypeDescriptor().isPrimitive()) {         return false.     }     return super.canConvert(sourceType, targetType). }
false;public;0;4;;@Override public Set<ConvertiblePair> getConvertibleTypes() {     return Collections.singleton(new ConvertiblePair(String.class, Object.class)). }
false;public;2;4;;@Override public boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {     return getPropertyEditor(targetType.getType()) != null. }
false;public;3;6;;@Override public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     SimpleTypeConverter typeConverter = this.typeConverter.     return typeConverter.convertIfNecessary(source, targetType.getType()). }
false;private;1;19;;private PropertyEditor getPropertyEditor(Class<?> type) {     if (type == null || type == Object.class || Collection.class.isAssignableFrom(type) || Map.class.isAssignableFrom(type)) {         return null.     }     SimpleTypeConverter typeConverter = this.typeConverter.     PropertyEditor editor = typeConverter.getDefaultEditor(type).     if (editor == null) {         editor = typeConverter.findCustomEditor(type, null).     }     if (editor == null && String.class != type) {         editor = BeanUtils.findEditorByConvention(type).     }     if (editor == null || EXCLUDED_EDITORS.contains(editor.getClass())) {         return null.     }     return editor. }
