commented;modifiers;parameterAmount;loc;comment;code
false;public;4;12;;@Override public <T> T bind(ConfigurationPropertyName name, Bindable<T> target, Context context, BeanPropertyBinder propertyBinder) {     boolean hasKnownBindableProperties = hasKnownBindableProperties(name, context).     Bean<T> bean = Bean.get(target, hasKnownBindableProperties).     if (bean == null) {         return null.     }     BeanSupplier<T> beanSupplier = bean.getSupplier(target).     boolean bound = bind(propertyBinder, bean, beanSupplier).     return (bound ? beanSupplier.get() : null). }
false;private;2;9;;private boolean hasKnownBindableProperties(ConfigurationPropertyName name, Context context) {     for (ConfigurationPropertySource source : context.getSources()) {         if (source.containsDescendantOf(name) == ConfigurationPropertyState.PRESENT) {             return true.         }     }     return false. }
false;private;3;8;;private <T> boolean bind(BeanPropertyBinder propertyBinder, Bean<T> bean, BeanSupplier<T> beanSupplier) {     boolean bound = false.     for (BeanProperty beanProperty : bean.getProperties().values()) {         bound |= bind(beanSupplier, propertyBinder, beanProperty).     }     return bound. }
false;private;3;20;;private <T> boolean bind(BeanSupplier<T> beanSupplier, BeanPropertyBinder propertyBinder, BeanProperty property) {     String propertyName = property.getName().     ResolvableType type = property.getType().     Supplier<Object> value = property.getValue(beanSupplier).     Annotation[] annotations = property.getAnnotations().     Object bound = propertyBinder.bindProperty(propertyName, Bindable.of(type).withSuppliedValue(value).withAnnotations(annotations)).     if (bound == null) {         return false.     }     if (property.isSettable()) {         property.setValue(beanSupplier, bound).     } else if (value == null || !bound.equals(value.get())) {         throw new IllegalStateException("No setter found for property: " + property.getName()).     }     return true. }
false;private;1;13;;private void putProperties(Class<?> type) {     while (type != null && !Object.class.equals(type)) {         for (Method method : type.getDeclaredMethods()) {             if (isCandidate(method)) {                 addMethod(method).             }         }         for (Field field : type.getDeclaredFields()) {             addField(field).         }         type = type.getSuperclass().     } }
false;private;1;7;;private boolean isCandidate(Method method) {     int modifiers = method.getModifiers().     return Modifier.isPublic(modifiers) && !Modifier.isAbstract(modifiers) && !Modifier.isStatic(modifiers) && !Object.class.equals(method.getDeclaringClass()) && !Class.class.equals(method.getDeclaringClass()). }
false;private;1;5;;private void addMethod(Method method) {     addMethodIfPossible(method, "get", 0, BeanProperty::addGetter).     addMethodIfPossible(method, "is", 0, BeanProperty::addGetter).     addMethodIfPossible(method, "set", 1, BeanProperty::addSetter). }
false;private;4;11;;private void addMethodIfPossible(Method method, String prefix, int parameterCount, BiConsumer<BeanProperty, Method> consumer) {     if (method.getParameterCount() == parameterCount && method.getName().startsWith(prefix) && method.getName().length() > prefix.length()) {         String propertyName = Introspector.decapitalize(method.getName().substring(prefix.length())).         consumer.accept(this.properties.computeIfAbsent(propertyName, this::getBeanProperty), method).     } }
false;private;1;3;;private BeanProperty getBeanProperty(String name) {     return new BeanProperty(name, this.resolvableType). }
false;private;1;6;;private void addField(Field field) {     BeanProperty property = this.properties.get(field.getName()).     if (property != null) {         property.addField(field).     } }
false;public;0;3;;public Class<?> getType() {     return this.type. }
false;public;0;3;;public Map<String, BeanProperty> getProperties() {     return this.properties. }
false;public;1;13;;@SuppressWarnings("unchecked") public BeanSupplier<T> getSupplier(Bindable<T> target) {     return new BeanSupplier<>(() -> {         T instance = null.         if (target.getValue() != null) {             instance = target.getValue().get().         }         if (instance == null) {             instance = (T) BeanUtils.instantiateClass(this.type).         }         return instance.     }). }
false;public,static;2;19;;@SuppressWarnings("unchecked") public static <T> Bean<T> get(Bindable<T> bindable, boolean canCallGetValue) {     Class<?> type = bindable.getType().resolve(Object.class).     Supplier<T> value = bindable.getValue().     T instance = null.     if (canCallGetValue && value != null) {         instance = value.get().         type = (instance != null) ? instance.getClass() : type.     }     if (instance == null && !isInstantiable(type)) {         return null.     }     Bean<?> bean = Bean.cached.     if (bean == null || !type.equals(bean.getType())) {         bean = new Bean<>(bindable.getType(), type).         cached = bean.     }     return (Bean<T>) bean. }
false;private,static;1;12;;private static boolean isInstantiable(Class<?> type) {     if (type.isInterface()) {         return false.     }     try {         type.getDeclaredConstructor().         return true.     } catch (Exception ex) {         return false.     } }
false;public;0;7;;@Override public T get() {     if (this.instance == null) {         this.instance = this.factory.get().     }     return this.instance. }
false;public;1;5;;public void addGetter(Method getter) {     if (this.getter == null) {         this.getter = getter.     } }
false;public;1;5;;public void addSetter(Method setter) {     if (this.setter == null) {         this.setter = setter.     } }
false;public;1;5;;public void addField(Field field) {     if (this.field == null) {         this.field = field.     } }
false;public;0;3;;public String getName() {     return this.name. }
false;public;0;10;;public ResolvableType getType() {     if (this.setter != null) {         MethodParameter methodParameter = new MethodParameter(this.setter, 0).         return ResolvableType.forMethodParameter(methodParameter, this.declaringClassType).     }     MethodParameter methodParameter = new MethodParameter(this.getter, -1).     return ResolvableType.forMethodParameter(methodParameter, this.declaringClassType). }
false;public;0;8;;public Annotation[] getAnnotations() {     try {         return (this.field != null) ? this.field.getDeclaredAnnotations() : null.     } catch (Exception ex) {         return null.     } }
false;public;1;15;;public Supplier<Object> getValue(Supplier<?> instance) {     if (this.getter == null) {         return null.     }     return () -> {         try {             this.getter.setAccessible(true).             return this.getter.invoke(instance.get()).         } catch (Exception ex) {             throw new IllegalStateException("Unable to get value for property " + this.name, ex).         }     }. }
false;public;0;3;;public boolean isSettable() {     return this.setter != null. }
false;public;2;10;;public void setValue(Supplier<?> instance, Object value) {     try {         this.setter.setAccessible(true).         this.setter.invoke(instance.get(), value).     } catch (Exception ex) {         throw new IllegalStateException("Unable to set value for property " + this.name, ex).     } }
