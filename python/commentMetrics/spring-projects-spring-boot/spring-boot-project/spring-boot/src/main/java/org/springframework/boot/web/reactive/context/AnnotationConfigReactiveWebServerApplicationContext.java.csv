commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * {@inheritDoc}  * <p>  * Delegates given environment to underlying {@link AnnotatedBeanDefinitionReader} and  * {@link ClassPathBeanDefinitionScanner} members.  */ ;/**  * {@inheritDoc}  * <p>  * Delegates given environment to underlying {@link AnnotatedBeanDefinitionReader} and  * {@link ClassPathBeanDefinitionScanner} members.  */ @Override public void setEnvironment(ConfigurableEnvironment environment) {     super.setEnvironment(environment).     this.reader.setEnvironment(environment).     this.scanner.setEnvironment(environment). }
true;public;1;7;/**  * Provide a custom {@link BeanNameGenerator} for use with  * {@link AnnotatedBeanDefinitionReader} and/or  * {@link ClassPathBeanDefinitionScanner}, if any.  * <p>  * Default is  * {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}.  * <p>  * Any call to this method must occur prior to calls to {@link #register(Class...)}  * and/or {@link #scan(String...)}.  * @param beanNameGenerator the bean name generator  * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator  * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator  */ ;/**  * Provide a custom {@link BeanNameGenerator} for use with  * {@link AnnotatedBeanDefinitionReader} and/or  * {@link ClassPathBeanDefinitionScanner}, if any.  * <p>  * Default is  * {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}.  * <p>  * Any call to this method must occur prior to calls to {@link #register(Class...)}  * and/or {@link #scan(String...)}.  * @param beanNameGenerator the bean name generator  * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator  * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator  */ public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {     this.reader.setBeanNameGenerator(beanNameGenerator).     this.scanner.setBeanNameGenerator(beanNameGenerator).     this.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator). }
true;public;1;4;/**  * Set the {@link ScopeMetadataResolver} to use for detected bean classes.  * <p>  * The default is an {@link AnnotationScopeMetadataResolver}.  * <p>  * Any call to this method must occur prior to calls to {@link #register(Class...)}  * and/or {@link #scan(String...)}.  * @param scopeMetadataResolver the scope metadata resolver  */ ;/**  * Set the {@link ScopeMetadataResolver} to use for detected bean classes.  * <p>  * The default is an {@link AnnotationScopeMetadataResolver}.  * <p>  * Any call to this method must occur prior to calls to {@link #register(Class...)}  * and/or {@link #scan(String...)}.  * @param scopeMetadataResolver the scope metadata resolver  */ public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) {     this.reader.setScopeMetadataResolver(scopeMetadataResolver).     this.scanner.setScopeMetadataResolver(scopeMetadataResolver). }
true;public,final;1;6;/**  * Register one or more annotated classes to be processed. Note that  * {@link #refresh()} must be called in order for the context to fully process the new  * class.  * <p>  * Calls to {@code #register} are idempotent. adding the same annotated class more  * than once has no additional effect.  * @param annotatedClasses one or more annotated classes, e.g. {@code @Configuration}  * classes  * @see #scan(String...)  * @see #refresh()  */ ;/**  * Register one or more annotated classes to be processed. Note that  * {@link #refresh()} must be called in order for the context to fully process the new  * class.  * <p>  * Calls to {@code #register} are idempotent. adding the same annotated class more  * than once has no additional effect.  * @param annotatedClasses one or more annotated classes, e.g. {@code @Configuration}  * classes  * @see #scan(String...)  * @see #refresh()  */ @Override public final void register(Class<?>... annotatedClasses) {     Assert.notEmpty(annotatedClasses, "At least one annotated class must be specified").     this.annotatedClasses.addAll(Arrays.asList(annotatedClasses)). }
true;public,final;1;5;/**  * Perform a scan within the specified base packages. Note that {@link #refresh()}  * must be called in order for the context to fully process the new class.  * @param basePackages the packages to check for annotated classes  * @see #register(Class...)  * @see #refresh()  */ ;/**  * Perform a scan within the specified base packages. Note that {@link #refresh()}  * must be called in order for the context to fully process the new class.  * @param basePackages the packages to check for annotated classes  * @see #register(Class...)  * @see #refresh()  */ @Override public final void scan(String... basePackages) {     Assert.notEmpty(basePackages, "At least one base package must be specified").     this.basePackages = basePackages. }
false;protected;0;5;;@Override protected void prepareRefresh() {     this.scanner.clearCache().     super.prepareRefresh(). }
false;protected;1;10;;@Override protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {     super.postProcessBeanFactory(beanFactory).     if (!ObjectUtils.isEmpty(this.basePackages)) {         this.scanner.scan(this.basePackages).     }     if (!this.annotatedClasses.isEmpty()) {         this.reader.register(ClassUtils.toClassArray(this.annotatedClasses)).     } }
