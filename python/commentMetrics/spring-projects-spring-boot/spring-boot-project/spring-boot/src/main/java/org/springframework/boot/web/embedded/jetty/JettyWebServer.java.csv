commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;8;;@Override protected void doStart() throws Exception {     for (Connector connector : JettyWebServer.this.connectors) {         Assert.state(connector.isStopped(), () -> "Connector " + connector + " has been started prematurely").     }     JettyWebServer.this.server.setConnectors(null). }
false;private;0;30;;private void initialize() {     synchronized (this.monitor) {         try {             // Cache the connectors and then remove them to prevent requests being             // handled before the application context is ready.             this.connectors = this.server.getConnectors().             this.server.addBean(new AbstractLifeCycle() {                  @Override                 protected void doStart() throws Exception {                     for (Connector connector : JettyWebServer.this.connectors) {                         Assert.state(connector.isStopped(), () -> "Connector " + connector + " has been started prematurely").                     }                     JettyWebServer.this.server.setConnectors(null).                 }             }).             // Start the server so that the ServletContext is available             this.server.start().             this.server.setStopAtShutdown(false).         } catch (Throwable ex) {             // Ensure process isn't left running             stopSilently().             throw new WebServerException("Unable to start embedded Jetty web server", ex).         }     } }
false;private;0;8;;private void stopSilently() {     try {         this.server.stop().     } catch (Exception ex) {     // Ignore     } }
false;public;0;43;;@Override public void start() throws WebServerException {     synchronized (this.monitor) {         if (this.started) {             return.         }         this.server.setConnectors(this.connectors).         if (!this.autoStart) {             return.         }         try {             this.server.start().             for (Handler handler : this.server.getHandlers()) {                 handleDeferredInitialize(handler).             }             Connector[] connectors = this.server.getConnectors().             for (Connector connector : connectors) {                 try {                     connector.start().                 } catch (IOException ex) {                     if (connector instanceof NetworkConnector && findBindException(ex) != null) {                         throw new PortInUseException(((NetworkConnector) connector).getPort()).                     }                     throw ex.                 }             }             this.started = true.             logger.info("Jetty started on port(s) " + getActualPortsDescription() + " with context path '" + getContextPath() + "'").         } catch (WebServerException ex) {             stopSilently().             throw ex.         } catch (Exception ex) {             stopSilently().             throw new WebServerException("Unable to start embedded Jetty server", ex).         }     } }
false;private;1;9;;private BindException findBindException(Throwable ex) {     if (ex == null) {         return null.     }     if (ex instanceof BindException) {         return (BindException) ex.     }     return findBindException(ex.getCause()). }
false;private;0;10;;private String getActualPortsDescription() {     StringBuilder ports = new StringBuilder().     for (Connector connector : this.server.getConnectors()) {         if (ports.length() != 0) {             ports.append(", ").         }         ports.append(getLocalPort(connector)).append(getProtocols(connector)).     }     return ports.toString(). }
false;private;1;12;;private Integer getLocalPort(Connector connector) {     try {         // Jetty 9 internals are different, but the method name is the same         return (Integer) ReflectionUtils.invokeMethod(ReflectionUtils.findMethod(connector.getClass(), "getLocalPort"), connector).     } catch (Exception ex) {         logger.info("could not determine port ( " + ex.getMessage() + ")").         return 0.     } }
false;private;1;4;;private String getProtocols(Connector connector) {     List<String> protocols = connector.getProtocols().     return " (" + StringUtils.collectionToDelimitedString(protocols, ", ") + ")". }
false;private;0;5;;private String getContextPath() {     return Arrays.stream(this.server.getHandlers()).filter(ContextHandler.class::isInstance).map(ContextHandler.class::cast).map(ContextHandler::getContextPath).collect(Collectors.joining(" ")). }
false;private;1;13;;private void handleDeferredInitialize(Handler... handlers) throws Exception {     for (Handler handler : handlers) {         if (handler instanceof JettyEmbeddedWebAppContext) {             ((JettyEmbeddedWebAppContext) handler).deferredInitialize().         } else if (handler instanceof HandlerWrapper) {             handleDeferredInitialize(((HandlerWrapper) handler).getHandler()).         } else if (handler instanceof HandlerCollection) {             handleDeferredInitialize(((HandlerCollection) handler).getHandlers()).         }     } }
false;public;0;15;;@Override public void stop() {     synchronized (this.monitor) {         this.started = false.         try {             this.server.stop().         } catch (InterruptedException ex) {             Thread.currentThread().interrupt().         } catch (Exception ex) {             throw new WebServerException("Unable to stop embedded Jetty server", ex).         }     } }
false;public;0;9;;@Override public int getPort() {     Connector[] connectors = this.server.getConnectors().     for (Connector connector : connectors) {         // Probably only one...         return getLocalPort(connector).     }     return 0. }
true;public;0;3;/**  * Returns access to the underlying Jetty Server.  * @return the Jetty server  */ ;/**  * Returns access to the underlying Jetty Server.  * @return the Jetty server  */ public Server getServer() {     return this.server. }
