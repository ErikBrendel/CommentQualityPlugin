commented;modifiers;parameterAmount;loc;comment;code
true;public;1;5;/**  * Set the bean name generator to be used by the underlying readers and scanner.  * @param beanNameGenerator the bean name generator  */ ;/**  * Set the bean name generator to be used by the underlying readers and scanner.  * @param beanNameGenerator the bean name generator  */ public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {     this.annotatedReader.setBeanNameGenerator(beanNameGenerator).     this.xmlReader.setBeanNameGenerator(beanNameGenerator).     this.scanner.setBeanNameGenerator(beanNameGenerator). }
true;public;1;5;/**  * Set the resource loader to be used by the underlying readers and scanner.  * @param resourceLoader the resource loader  */ ;/**  * Set the resource loader to be used by the underlying readers and scanner.  * @param resourceLoader the resource loader  */ public void setResourceLoader(ResourceLoader resourceLoader) {     this.resourceLoader = resourceLoader.     this.xmlReader.setResourceLoader(resourceLoader).     this.scanner.setResourceLoader(resourceLoader). }
true;public;1;5;/**  * Set the environment to be used by the underlying readers and scanner.  * @param environment the environment  */ ;/**  * Set the environment to be used by the underlying readers and scanner.  * @param environment the environment  */ public void setEnvironment(ConfigurableEnvironment environment) {     this.annotatedReader.setEnvironment(environment).     this.xmlReader.setEnvironment(environment).     this.scanner.setEnvironment(environment). }
true;public;0;7;/**  * Load the sources into the reader.  * @return the number of loaded beans  */ ;/**  * Load the sources into the reader.  * @return the number of loaded beans  */ public int load() {     int count = 0.     for (Object source : this.sources) {         count += load(source).     }     return count. }
false;private;1;16;;private int load(Object source) {     Assert.notNull(source, "Source must not be null").     if (source instanceof Class<?>) {         return load((Class<?>) source).     }     if (source instanceof Resource) {         return load((Resource) source).     }     if (source instanceof Package) {         return load((Package) source).     }     if (source instanceof CharSequence) {         return load((CharSequence) source).     }     throw new IllegalArgumentException("Invalid source type " + source.getClass()). }
false;private;1;14;;private int load(Class<?> source) {     if (isGroovyPresent() && GroovyBeanDefinitionSource.class.isAssignableFrom(source)) {         // Any GroovyLoaders added in beans{} DSL can contribute beans here         GroovyBeanDefinitionSource loader = BeanUtils.instantiateClass(source, GroovyBeanDefinitionSource.class).         load(loader).     }     if (isComponent(source)) {         this.annotatedReader.register(source).         return 1.     }     return 0. }
false;private;1;6;;private int load(GroovyBeanDefinitionSource source) {     int before = this.xmlReader.getRegistry().getBeanDefinitionCount().     ((GroovyBeanDefinitionReader) this.groovyReader).beans(source.getBeans()).     int after = this.xmlReader.getRegistry().getBeanDefinitionCount().     return after - before. }
false;private;1;10;;private int load(Resource source) {     if (source.getFilename().endsWith(".groovy")) {         if (this.groovyReader == null) {             throw new BeanDefinitionStoreException("Cannot load Groovy beans without Groovy on classpath").         }         return this.groovyReader.loadBeanDefinitions(source).     }     return this.xmlReader.loadBeanDefinitions(source). }
false;private;1;3;;private int load(Package source) {     return this.scanner.scan(source.getName()). }
false;private;1;30;;private int load(CharSequence source) {     String resolvedSource = this.xmlReader.getEnvironment().resolvePlaceholders(source.toString()).     // Attempt as a Class     try {         return load(ClassUtils.forName(resolvedSource, null)).     } catch (IllegalArgumentException | ClassNotFoundException ex) {     // swallow exception and continue     }     // Attempt as resources     Resource[] resources = findResources(resolvedSource).     int loadCount = 0.     boolean atLeastOneResourceExists = false.     for (Resource resource : resources) {         if (isLoadCandidate(resource)) {             atLeastOneResourceExists = true.             loadCount += load(resource).         }     }     if (atLeastOneResourceExists) {         return loadCount.     }     // Attempt as package     Package packageResource = findPackage(resolvedSource).     if (packageResource != null) {         return load(packageResource).     }     throw new IllegalArgumentException("Invalid source '" + resolvedSource + "'"). }
false;private;0;3;;private boolean isGroovyPresent() {     return ClassUtils.isPresent("groovy.lang.MetaClass", null). }
false;private;1;13;;private Resource[] findResources(String source) {     ResourceLoader loader = (this.resourceLoader != null) ? this.resourceLoader : new PathMatchingResourcePatternResolver().     try {         if (loader instanceof ResourcePatternResolver) {             return ((ResourcePatternResolver) loader).getResources(source).         }         return new Resource[] { loader.getResource(source) }.     } catch (IOException ex) {         throw new IllegalStateException("Error reading source '" + source + "'").     } }
false;private;1;21;;private boolean isLoadCandidate(Resource resource) {     if (resource == null || !resource.exists()) {         return false.     }     if (resource instanceof ClassPathResource) {         // A simple package without a '.' may accidentally get loaded as an XML         // document if we're not careful. The result of getInputStream() will be         // a file list of the package content. We double check here that it's not         // actually a package.         String path = ((ClassPathResource) resource).getPath().         if (path.indexOf('.') == -1) {             try {                 return Package.getPackage(path) == null.             } catch (Exception ex) {             // Ignore             }         }     }     return true. }
false;private;1;24;;private Package findPackage(CharSequence source) {     Package pkg = Package.getPackage(source.toString()).     if (pkg != null) {         return pkg.     }     try {         // Attempt to find a class in this package         ResourcePatternResolver resolver = new PathMatchingResourcePatternResolver(getClass().getClassLoader()).         Resource[] resources = resolver.getResources(ClassUtils.convertClassNameToResourcePath(source.toString()) + "/*.class").         for (Resource resource : resources) {             String className = StringUtils.stripFilenameExtension(resource.getFilename()).             load(Class.forName(source.toString() + "." + className)).             break.         }     } catch (Exception ex) {     // swallow exception and continue     }     return Package.getPackage(source.toString()). }
false;private;1;14;;private boolean isComponent(Class<?> type) {     // eligible is to make a bean definition out of it and try to instantiate it.     if (AnnotationUtils.findAnnotation(type, Component.class) != null) {         return true.     }     // closures     if (type.getName().matches(".*\\$_.*closure.*") || type.isAnonymousClass() || type.getConstructors() == null || type.getConstructors().length == 0) {         return false.     }     return true. }
false;protected;1;4;;@Override protected boolean matchClassName(String className) {     return this.classNames.contains(className). }
false;;0;1;;Closure<?> getBeans().
