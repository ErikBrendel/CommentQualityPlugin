commented;modifiers;parameterAmount;loc;comment;code
true;protected;1;7;/**  * Register ServletContextAwareProcessor.  * @see ServletContextAwareProcessor  */ ;/**  * Register ServletContextAwareProcessor.  * @see ServletContextAwareProcessor  */ @Override protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {     beanFactory.addBeanPostProcessor(new WebApplicationContextServletContextAwareProcessor(this)).     beanFactory.ignoreDependencyInterface(ServletContextAware.class).     registerWebApplicationScopes(). }
false;public,final;0;10;;@Override public final void refresh() throws BeansException, IllegalStateException {     try {         super.refresh().     } catch (RuntimeException ex) {         stopAndReleaseWebServer().         throw ex.     } }
false;protected;0;10;;@Override protected void onRefresh() {     super.onRefresh().     try {         createWebServer().     } catch (Throwable ex) {         throw new ApplicationContextException("Unable to start web server", ex).     } }
false;protected;0;8;;@Override protected void finishRefresh() {     super.finishRefresh().     WebServer webServer = startWebServer().     if (webServer != null) {         publishEvent(new ServletWebServerInitializedEvent(webServer, this)).     } }
false;protected;0;5;;@Override protected void onClose() {     super.onClose().     stopAndReleaseWebServer(). }
false;private;0;18;;private void createWebServer() {     WebServer webServer = this.webServer.     ServletContext servletContext = getServletContext().     if (webServer == null && servletContext == null) {         ServletWebServerFactory factory = getWebServerFactory().         this.webServer = factory.getWebServer(getSelfInitializer()).     } else if (servletContext != null) {         try {             getSelfInitializer().onStartup(servletContext).         } catch (ServletException ex) {             throw new ApplicationContextException("Cannot initialize servlet context", ex).         }     }     initPropertySources(). }
true;protected;0;17;/**  * Returns the {@link ServletWebServerFactory} that should be used to create the  * embedded {@link WebServer}. By default this method searches for a suitable bean in  * the context itself.  * @return a {@link ServletWebServerFactory} (never {@code null})  */ ;/**  * Returns the {@link ServletWebServerFactory} that should be used to create the  * embedded {@link WebServer}. By default this method searches for a suitable bean in  * the context itself.  * @return a {@link ServletWebServerFactory} (never {@code null})  */ protected ServletWebServerFactory getWebServerFactory() {     // Use bean names so that we don't consider the hierarchy     String[] beanNames = getBeanFactory().getBeanNamesForType(ServletWebServerFactory.class).     if (beanNames.length == 0) {         throw new ApplicationContextException("Unable to start ServletWebServerApplicationContext due to missing " + "ServletWebServerFactory bean.").     }     if (beanNames.length > 1) {         throw new ApplicationContextException("Unable to start ServletWebServerApplicationContext due to multiple " + "ServletWebServerFactory beans : " + StringUtils.arrayToCommaDelimitedString(beanNames)).     }     return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class). }
true;private;0;3;/**  * Returns the {@link ServletContextInitializer} that will be used to complete the  * setup of this {@link WebApplicationContext}.  * @return the self initializer  * @see #prepareWebApplicationContext(ServletContext)  */ ;/**  * Returns the {@link ServletContextInitializer} that will be used to complete the  * setup of this {@link WebApplicationContext}.  * @return the self initializer  * @see #prepareWebApplicationContext(ServletContext)  */ private org.springframework.boot.web.servlet.ServletContextInitializer getSelfInitializer() {     return this::selfInitialize. }
false;private;1;9;;private void selfInitialize(ServletContext servletContext) throws ServletException {     prepareWebApplicationContext(servletContext).     registerApplicationScope(servletContext).     WebApplicationContextUtils.registerEnvironmentBeans(getBeanFactory(), servletContext).     for (ServletContextInitializer beans : getServletContextInitializerBeans()) {         beans.onStartup(servletContext).     } }
false;private;1;6;;private void registerApplicationScope(ServletContext servletContext) {     ServletContextScope appScope = new ServletContextScope(servletContext).     getBeanFactory().registerScope(WebApplicationContext.SCOPE_APPLICATION, appScope).     // Register as ServletContext attribute, for ContextCleanupListener to detect it.     servletContext.setAttribute(ServletContextScope.class.getName(), appScope). }
false;private;0;6;;private void registerWebApplicationScopes() {     ExistingWebApplicationScopes existingScopes = new ExistingWebApplicationScopes(getBeanFactory()).     WebApplicationContextUtils.registerWebApplicationScopes(getBeanFactory()).     existingScopes.restore(). }
true;protected;0;3;/**  * Returns {@link ServletContextInitializer}s that should be used with the embedded  * web server. By default this method will first attempt to find  * {@link ServletContextInitializer}, {@link Servlet}, {@link Filter} and certain  * {@link EventListener} beans.  * @return the servlet initializer beans  */ ;/**  * Returns {@link ServletContextInitializer}s that should be used with the embedded  * web server. By default this method will first attempt to find  * {@link ServletContextInitializer}, {@link Servlet}, {@link Filter} and certain  * {@link EventListener} beans.  * @return the servlet initializer beans  */ protected Collection<ServletContextInitializer> getServletContextInitializerBeans() {     return new ServletContextInitializerBeans(getBeanFactory()). }
true;protected;1;36;/**  * Prepare the {@link WebApplicationContext} with the given fully loaded  * {@link ServletContext}. This method is usually called from  * {@link ServletContextInitializer#onStartup(ServletContext)} and is similar to the  * functionality usually provided by a {@link ContextLoaderListener}.  * @param servletContext the operational servlet context  */ ;/**  * Prepare the {@link WebApplicationContext} with the given fully loaded  * {@link ServletContext}. This method is usually called from  * {@link ServletContextInitializer#onStartup(ServletContext)} and is similar to the  * functionality usually provided by a {@link ContextLoaderListener}.  * @param servletContext the operational servlet context  */ protected void prepareWebApplicationContext(ServletContext servletContext) {     Object rootContext = servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE).     if (rootContext != null) {         if (rootContext == this) {             throw new IllegalStateException("Cannot initialize context because there is already a root application context present - " + "check whether you have multiple ServletContextInitializers!").         }         return.     }     Log logger = LogFactory.getLog(ContextLoader.class).     servletContext.log("Initializing Spring embedded WebApplicationContext").     try {         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, this).         if (logger.isDebugEnabled()) {             logger.debug("Published root WebApplicationContext as ServletContext attribute with name [" + WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE + "]").         }         setServletContext(servletContext).         if (logger.isInfoEnabled()) {             long elapsedTime = System.currentTimeMillis() - getStartupDate().             logger.info("Root WebApplicationContext: initialization completed in " + elapsedTime + " ms").         }     } catch (RuntimeException | Error ex) {         logger.error("Context initialization failed", ex).         servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex).         throw ex.     } }
false;private;0;7;;private WebServer startWebServer() {     WebServer webServer = this.webServer.     if (webServer != null) {         webServer.start().     }     return webServer. }
false;private;0;12;;private void stopAndReleaseWebServer() {     WebServer webServer = this.webServer.     if (webServer != null) {         try {             webServer.stop().             this.webServer = null.         } catch (Exception ex) {             throw new IllegalStateException(ex).         }     } }
false;protected;1;7;;@Override protected Resource getResourceByPath(String path) {     if (getServletContext() == null) {         return new ClassPathContextResource(path, getClassLoader()).     }     return new ServletContextResource(getServletContext(), path). }
false;public;0;4;;@Override public String getServerNamespace() {     return this.serverNamespace. }
false;public;1;4;;@Override public void setServerNamespace(String serverNamespace) {     this.serverNamespace = serverNamespace. }
false;public;1;4;;@Override public void setServletConfig(ServletConfig servletConfig) {     this.servletConfig = servletConfig. }
false;public;0;4;;@Override public ServletConfig getServletConfig() {     return this.servletConfig. }
true;public;0;4;/**  * Returns the {@link WebServer} that was created by the context or {@code null} if  * the server has not yet been created.  * @return the embedded web server  */ ;/**  * Returns the {@link WebServer} that was created by the context or {@code null} if  * the server has not yet been created.  * @return the embedded web server  */ @Override public WebServer getWebServer() {     return this.webServer. }
false;public;0;8;;public void restore() {     this.scopes.forEach((key, value) -> {         if (logger.isInfoEnabled()) {             logger.info("Restoring user defined scope " + key).         }         this.beanFactory.registerScope(key, value).     }). }
