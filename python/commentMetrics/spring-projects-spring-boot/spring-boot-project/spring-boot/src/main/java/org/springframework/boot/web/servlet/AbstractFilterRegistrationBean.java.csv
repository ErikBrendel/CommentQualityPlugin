commented;modifiers;parameterAmount;loc;comment;code
true;public;1;6;/**  * Set {@link ServletRegistrationBean}s that the filter will be registered against.  * @param servletRegistrationBeans the Servlet registration beans  */ ;/**  * Set {@link ServletRegistrationBean}s that the filter will be registered against.  * @param servletRegistrationBeans the Servlet registration beans  */ public void setServletRegistrationBeans(Collection<? extends ServletRegistrationBean<?>> servletRegistrationBeans) {     Assert.notNull(servletRegistrationBeans, "ServletRegistrationBeans must not be null").     this.servletRegistrationBeans = new LinkedHashSet<>(servletRegistrationBeans). }
true;public;0;3;/**  * Return a mutable collection of the {@link ServletRegistrationBean} that the filter  * will be registered against. {@link ServletRegistrationBean}s.  * @return the Servlet registration beans  * @see #setServletNames  * @see #setUrlPatterns  */ ;/**  * Return a mutable collection of the {@link ServletRegistrationBean} that the filter  * will be registered against. {@link ServletRegistrationBean}s.  * @return the Servlet registration beans  * @see #setServletNames  * @see #setUrlPatterns  */ public Collection<ServletRegistrationBean<?>> getServletRegistrationBeans() {     return this.servletRegistrationBeans. }
true;public;1;6;/**  * Add {@link ServletRegistrationBean}s for the filter.  * @param servletRegistrationBeans the servlet registration beans to add  * @see #setServletRegistrationBeans  */ ;/**  * Add {@link ServletRegistrationBean}s for the filter.  * @param servletRegistrationBeans the servlet registration beans to add  * @see #setServletRegistrationBeans  */ public void addServletRegistrationBeans(ServletRegistrationBean<?>... servletRegistrationBeans) {     Assert.notNull(servletRegistrationBeans, "ServletRegistrationBeans must not be null").     Collections.addAll(this.servletRegistrationBeans, servletRegistrationBeans). }
true;public;1;4;/**  * Set servlet names that the filter will be registered against. This will replace any  * previously specified servlet names.  * @param servletNames the servlet names  * @see #setServletRegistrationBeans  * @see #setUrlPatterns  */ ;/**  * Set servlet names that the filter will be registered against. This will replace any  * previously specified servlet names.  * @param servletNames the servlet names  * @see #setServletRegistrationBeans  * @see #setUrlPatterns  */ public void setServletNames(Collection<String> servletNames) {     Assert.notNull(servletNames, "ServletNames must not be null").     this.servletNames = new LinkedHashSet<>(servletNames). }
true;public;0;3;/**  * Return a mutable collection of servlet names that the filter will be registered  * against.  * @return the servlet names  */ ;/**  * Return a mutable collection of servlet names that the filter will be registered  * against.  * @return the servlet names  */ public Collection<String> getServletNames() {     return this.servletNames. }
true;public;1;4;/**  * Add servlet names for the filter.  * @param servletNames the servlet names to add  */ ;/**  * Add servlet names for the filter.  * @param servletNames the servlet names to add  */ public void addServletNames(String... servletNames) {     Assert.notNull(servletNames, "ServletNames must not be null").     this.servletNames.addAll(Arrays.asList(servletNames)). }
true;public;1;4;/**  * Set the URL patterns that the filter will be registered against. This will replace  * any previously specified URL patterns.  * @param urlPatterns the URL patterns  * @see #setServletRegistrationBeans  * @see #setServletNames  */ ;/**  * Set the URL patterns that the filter will be registered against. This will replace  * any previously specified URL patterns.  * @param urlPatterns the URL patterns  * @see #setServletRegistrationBeans  * @see #setServletNames  */ public void setUrlPatterns(Collection<String> urlPatterns) {     Assert.notNull(urlPatterns, "UrlPatterns must not be null").     this.urlPatterns = new LinkedHashSet<>(urlPatterns). }
true;public;0;3;/**  * Return a mutable collection of URL patterns, as defined in the Servlet  * specification, that the filter will be registered against.  * @return the URL patterns  */ ;/**  * Return a mutable collection of URL patterns, as defined in the Servlet  * specification, that the filter will be registered against.  * @return the URL patterns  */ public Collection<String> getUrlPatterns() {     return this.urlPatterns. }
true;public;1;4;/**  * Add URL patterns, as defined in the Servlet specification, that the filter will be  * registered against.  * @param urlPatterns the URL patterns  */ ;/**  * Add URL patterns, as defined in the Servlet specification, that the filter will be  * registered against.  * @param urlPatterns the URL patterns  */ public void addUrlPatterns(String... urlPatterns) {     Assert.notNull(urlPatterns, "UrlPatterns must not be null").     Collections.addAll(this.urlPatterns, urlPatterns). }
true;public;2;3;/**  * Convenience method to {@link #setDispatcherTypes(EnumSet) set dispatcher types}  * using the specified elements.  * @param first the first dispatcher type  * @param rest additional dispatcher types  */ ;/**  * Convenience method to {@link #setDispatcherTypes(EnumSet) set dispatcher types}  * using the specified elements.  * @param first the first dispatcher type  * @param rest additional dispatcher types  */ public void setDispatcherTypes(DispatcherType first, DispatcherType... rest) {     this.dispatcherTypes = EnumSet.of(first, rest). }
true;public;1;3;/**  * Sets the dispatcher types that should be used with the registration. If not  * specified the types will be deduced based on the value of  * {@link #isAsyncSupported()}.  * @param dispatcherTypes the dispatcher types  */ ;/**  * Sets the dispatcher types that should be used with the registration. If not  * specified the types will be deduced based on the value of  * {@link #isAsyncSupported()}.  * @param dispatcherTypes the dispatcher types  */ public void setDispatcherTypes(EnumSet<DispatcherType> dispatcherTypes) {     this.dispatcherTypes = dispatcherTypes. }
true;public;1;3;/**  * Set if the filter mappings should be matched after any declared filter mappings of  * the ServletContext. Defaults to {@code false} indicating the filters are supposed  * to be matched before any declared filter mappings of the ServletContext.  * @param matchAfter if filter mappings are matched after  */ ;/**  * Set if the filter mappings should be matched after any declared filter mappings of  * the ServletContext. Defaults to {@code false} indicating the filters are supposed  * to be matched before any declared filter mappings of the ServletContext.  * @param matchAfter if filter mappings are matched after  */ public void setMatchAfter(boolean matchAfter) {     this.matchAfter = matchAfter. }
true;public;0;3;/**  * Return if filter mappings should be matched after any declared Filter mappings of  * the ServletContext.  * @return if filter mappings are matched after  */ ;/**  * Return if filter mappings should be matched after any declared Filter mappings of  * the ServletContext.  * @return if filter mappings are matched after  */ public boolean isMatchAfter() {     return this.matchAfter. }
false;protected;0;6;;@Override protected String getDescription() {     Filter filter = getFilter().     Assert.notNull(filter, "Filter must not be null").     return "filter " + getOrDeduceName(filter). }
false;protected;2;5;;@Override protected Dynamic addRegistration(String description, ServletContext servletContext) {     Filter filter = getFilter().     return servletContext.addFilter(getOrDeduceName(filter), filter). }
true;protected;1;27;/**  * Configure registration settings. Subclasses can override this method to perform  * additional configuration if required.  * @param registration the registration  */ ;/**  * Configure registration settings. Subclasses can override this method to perform  * additional configuration if required.  * @param registration the registration  */ @Override protected void configure(FilterRegistration.Dynamic registration) {     super.configure(registration).     EnumSet<DispatcherType> dispatcherTypes = this.dispatcherTypes.     if (dispatcherTypes == null) {         dispatcherTypes = EnumSet.of(DispatcherType.REQUEST).     }     Set<String> servletNames = new LinkedHashSet<>().     for (ServletRegistrationBean<?> servletRegistrationBean : this.servletRegistrationBeans) {         servletNames.add(servletRegistrationBean.getServletName()).     }     servletNames.addAll(this.servletNames).     if (servletNames.isEmpty() && this.urlPatterns.isEmpty()) {         registration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter, DEFAULT_URL_MAPPINGS).     } else {         if (!servletNames.isEmpty()) {             registration.addMappingForServletNames(dispatcherTypes, this.matchAfter, StringUtils.toStringArray(servletNames)).         }         if (!this.urlPatterns.isEmpty()) {             registration.addMappingForUrlPatterns(dispatcherTypes, this.matchAfter, StringUtils.toStringArray(this.urlPatterns)).         }     } }
true;public,abstract;0;1;/**  * Return the {@link Filter} to be registered.  * @return the filter  */ ;/**  * Return the {@link Filter} to be registered.  * @return the filter  */ public abstract T getFilter().
false;public;0;16;;@Override public String toString() {     StringBuilder builder = new StringBuilder(getOrDeduceName(this)).     if (this.servletNames.isEmpty() && this.urlPatterns.isEmpty()) {         builder.append(" urls=").append(Arrays.toString(DEFAULT_URL_MAPPINGS)).     } else {         if (!this.servletNames.isEmpty()) {             builder.append(" servlets=").append(this.servletNames).         }         if (!this.urlPatterns.isEmpty()) {             builder.append(" urls=").append(this.urlPatterns).         }     }     return builder.toString(). }
