commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected boolean isAllowRecursiveBinding(ConfigurationPropertySource source) {     return true. }
false;protected;3;20;;@Override protected Object bindAggregate(ConfigurationPropertyName name, Bindable<?> target, AggregateElementBinder elementBinder) {     Map<Object, Object> map = CollectionFactory.createMap((target.getValue() != null) ? Map.class : target.getType().resolve(Object.class), 0).     Bindable<?> resolvedTarget = resolveTarget(target).     boolean hasDescendants = hasDescendants(name).     for (ConfigurationPropertySource source : getContext().getSources()) {         if (!ConfigurationPropertyName.EMPTY.equals(name)) {             ConfigurationProperty property = source.getConfigurationProperty(name).             if (property != null && !hasDescendants) {                 return getContext().getConverter().convert(property.getValue(), target).             }             source = source.filter(name::isAncestorOf).         }         new EntryBinder(name, resolvedTarget, elementBinder).bindEntries(source, map).     }     return map.isEmpty() ? null : map. }
false;private;1;8;;private boolean hasDescendants(ConfigurationPropertyName name) {     for (ConfigurationPropertySource source : getContext().getSources()) {         if (source.containsDescendantOf(name) == ConfigurationPropertyState.PRESENT) {             return true.         }     }     return false. }
false;private;1;7;;private Bindable<?> resolveTarget(Bindable<?> target) {     Class<?> type = target.getType().resolve(Object.class).     if (Properties.class.isAssignableFrom(type)) {         return STRING_STRING_MAP.     }     return target. }
false;protected;2;17;;@Override protected Map<Object, Object> merge(Supplier<Map<Object, Object>> existing, Map<Object, Object> additional) {     Map<Object, Object> existingMap = getExistingIfPossible(existing).     if (existingMap == null) {         return additional.     }     try {         existingMap.putAll(additional).         return copyIfPossible(existingMap).     } catch (UnsupportedOperationException ex) {         Map<Object, Object> result = createNewMap(additional.getClass(), existingMap).         result.putAll(additional).         return result.     } }
false;private;1;9;;private Map<Object, Object> getExistingIfPossible(Supplier<Map<Object, Object>> existing) {     try {         return existing.get().     } catch (Exception ex) {         return null.     } }
false;private;1;8;;private Map<Object, Object> copyIfPossible(Map<Object, Object> map) {     try {         return createNewMap(map.getClass(), map).     } catch (Exception ex) {         return map.     } }
false;private;2;5;;private Map<Object, Object> createNewMap(Class<?> mapClass, Map<Object, Object> map) {     Map<Object, Object> result = CollectionFactory.createMap(mapClass, map.size()).     result.putAll(map).     return result. }
false;public;2;13;;public void bindEntries(ConfigurationPropertySource source, Map<Object, Object> map) {     if (source instanceof IterableConfigurationPropertySource) {         for (ConfigurationPropertyName name : (IterableConfigurationPropertySource) source) {             Bindable<?> valueBindable = getValueBindable(name).             ConfigurationPropertyName entryName = getEntryName(source, name).             Object key = getContext().getConverter().convert(getKeyName(entryName), this.keyType).             map.computeIfAbsent(key, (k) -> this.elementBinder.bind(entryName, valueBindable)).         }     } }
false;private;1;6;;private Bindable<?> getValueBindable(ConfigurationPropertyName name) {     if (!this.root.isParentOf(name) && isValueTreatedAsNestedMap()) {         return Bindable.of(this.mapType).     }     return Bindable.of(this.valueType). }
false;private;2;12;;private ConfigurationPropertyName getEntryName(ConfigurationPropertySource source, ConfigurationPropertyName name) {     Class<?> resolved = this.valueType.resolve(Object.class).     if (Collection.class.isAssignableFrom(resolved) || this.valueType.isArray()) {         return chopNameAtNumericIndex(name).     }     if (!this.root.isParentOf(name) && (isValueTreatedAsNestedMap() || !isScalarValue(source, name))) {         return name.chop(this.root.getNumberOfElements() + 1).     }     return name. }
false;private;1;11;;private ConfigurationPropertyName chopNameAtNumericIndex(ConfigurationPropertyName name) {     int start = this.root.getNumberOfElements() + 1.     int size = name.getNumberOfElements().     for (int i = start. i < size. i++) {         if (name.isNumericIndex(i)) {             return name.chop(i).         }     }     return name. }
false;private;0;3;;private boolean isValueTreatedAsNestedMap() {     return Object.class.equals(this.valueType.resolve(Object.class)). }
false;private;2;14;;private boolean isScalarValue(ConfigurationPropertySource source, ConfigurationPropertyName name) {     Class<?> resolved = this.valueType.resolve(Object.class).     if (!resolved.getName().startsWith("java.lang") && !resolved.isEnum()) {         return false.     }     ConfigurationProperty property = source.getConfigurationProperty(name).     if (property == null) {         return false.     }     Object value = property.getValue().     value = getContext().getPlaceholdersResolver().resolvePlaceholders(value).     return getContext().getConverter().canConvert(value, this.valueType). }
false;private;1;11;;private String getKeyName(ConfigurationPropertyName name) {     StringBuilder result = new StringBuilder().     for (int i = this.root.getNumberOfElements(). i < name.getNumberOfElements(). i++) {         if (result.length() != 0) {             result.append('.').         }         result.append(name.getElement(i, Form.ORIGINAL)).     }     return result.toString(). }
