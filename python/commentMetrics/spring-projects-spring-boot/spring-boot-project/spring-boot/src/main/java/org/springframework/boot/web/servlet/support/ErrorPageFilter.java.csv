commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;6;;@Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException {     ErrorPageFilter.this.doFilter(request, response, chain). }
false;protected;0;4;;@Override protected boolean shouldNotFilterAsyncDispatch() {     return false. }
false;public;1;4;;@Override public void init(FilterConfig filterConfig) throws ServletException {     this.delegate.init(filterConfig). }
false;public;3;5;;@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {     this.delegate.doFilter(request, response, chain). }
false;private;3;23;;private void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {     ErrorWrapperResponse wrapped = new ErrorWrapperResponse(response).     try {         chain.doFilter(request, wrapped).         if (wrapped.hasErrorToSend()) {             handleErrorStatus(request, response, wrapped.getStatus(), wrapped.getMessage()).             response.flushBuffer().         } else if (!request.isAsyncStarted() && !response.isCommitted()) {             response.flushBuffer().         }     } catch (Throwable ex) {         Throwable exceptionToHandle = ex.         if (ex instanceof NestedServletException) {             exceptionToHandle = ((NestedServletException) ex).getRootCause().         }         handleException(request, response, wrapped, exceptionToHandle).         response.flushBuffer().     } }
false;private;4;16;;private void handleErrorStatus(HttpServletRequest request, HttpServletResponse response, int status, String message) throws ServletException, IOException {     if (response.isCommitted()) {         handleCommittedResponse(request, null).         return.     }     String errorPath = getErrorPath(this.statuses, status).     if (errorPath == null) {         response.sendError(status, message).         return.     }     response.setStatus(status).     setErrorAttributes(request, status, message).     request.getRequestDispatcher(errorPath).forward(request, response). }
false;private;4;15;;private void handleException(HttpServletRequest request, HttpServletResponse response, ErrorWrapperResponse wrapped, Throwable ex) throws IOException, ServletException {     Class<?> type = ex.getClass().     String errorPath = getErrorPath(type).     if (errorPath == null) {         rethrow(ex).         return.     }     if (response.isCommitted()) {         handleCommittedResponse(request, ex).         return.     }     forwardToErrorPage(errorPath, request, wrapped, ex). }
false;private;4;18;;private void forwardToErrorPage(String path, HttpServletRequest request, HttpServletResponse response, Throwable ex) throws ServletException, IOException {     if (logger.isErrorEnabled()) {         String message = "Forwarding to error page from request " + getDescription(request) + " due to exception [" + ex.getMessage() + "]".         logger.error(message, ex).     }     setErrorAttributes(request, 500, ex.getMessage()).     request.setAttribute(ERROR_EXCEPTION, ex).     request.setAttribute(ERROR_EXCEPTION_TYPE, ex.getClass()).     response.reset().     response.setStatus(500).     request.getRequestDispatcher(path).forward(request, response).     request.removeAttribute(ERROR_EXCEPTION).     request.removeAttribute(ERROR_EXCEPTION_TYPE). }
true;protected;1;4;/**  * Return the description for the given request. By default this method will return a  * description based on the request {@code servletPath} and {@code pathInfo}.  * @param request the source request  * @return the description  * @since 1.5.0  */ ;/**  * Return the description for the given request. By default this method will return a  * description based on the request {@code servletPath} and {@code pathInfo}.  * @param request the source request  * @return the description  * @since 1.5.0  */ protected String getDescription(HttpServletRequest request) {     String pathInfo = (request.getPathInfo() != null) ? request.getPathInfo() : "".     return "[" + request.getServletPath() + pathInfo + "]". }
false;private;2;19;;private void handleCommittedResponse(HttpServletRequest request, Throwable ex) {     if (isClientAbortException(ex)) {         return.     }     String message = "Cannot forward to error page for request " + getDescription(request) + " as the response has already been" + " committed. As a result, the response may have the wrong status" + " code. If your application is running on WebSphere Application" + " Server you may be able to resolve this problem by setting" + " com.ibm.ws.webcontainer.invokeFlushAfterService to false".     if (ex == null) {         logger.error(message).     } else {         // User might see the error page without all the data here but throwing the         // exception isn't going to help anyone (we'll log it to be on the safe side)         logger.error(message, ex).     } }
false;private;1;11;;private boolean isClientAbortException(Throwable ex) {     if (ex == null) {         return false.     }     for (Class<?> candidate : CLIENT_ABORT_EXCEPTIONS) {         if (candidate.isInstance(ex)) {             return true.         }     }     return isClientAbortException(ex.getCause()). }
false;private;2;6;;private String getErrorPath(Map<Integer, String> map, Integer status) {     if (map.containsKey(status)) {         return map.get(status).     }     return this.global. }
false;private;1;10;;private String getErrorPath(Class<?> type) {     while (type != Object.class) {         String path = this.exceptions.get(type).         if (path != null) {             return path.         }         type = type.getSuperclass().     }     return this.global. }
false;private;3;6;;private void setErrorAttributes(HttpServletRequest request, int status, String message) {     request.setAttribute(ERROR_STATUS_CODE, status).     request.setAttribute(ERROR_MESSAGE, message).     request.setAttribute(ERROR_REQUEST_URI, request.getRequestURI()). }
false;private;1;15;;private void rethrow(Throwable ex) throws IOException, ServletException {     if (ex instanceof RuntimeException) {         throw (RuntimeException) ex.     }     if (ex instanceof Error) {         throw (Error) ex.     }     if (ex instanceof IOException) {         throw (IOException) ex.     }     if (ex instanceof ServletException) {         throw (ServletException) ex.     }     throw new IllegalStateException(ex). }
false;public;1;14;;@Override public void addErrorPages(ErrorPage... errorPages) {     for (ErrorPage errorPage : errorPages) {         if (errorPage.isGlobal()) {             this.global = errorPage.getPath().         } else if (errorPage.getStatus() != null) {             this.statuses.put(errorPage.getStatus().value(), errorPage.getPath()).         } else {             this.exceptions.put(errorPage.getException(), errorPage.getPath()).         }     } }
false;public;0;3;;@Override public void destroy() { }
false;private,static;2;8;;private static void addClassIfPresent(Collection<Class<?>> collection, String className) {     try {         collection.add(ClassUtils.forName(className, null)).     } catch (Throwable ex) {     } }
false;public;1;4;;@Override public void sendError(int status) throws IOException {     sendError(status, null). }
false;public;2;8;;@Override public void sendError(int status, String message) throws IOException {     this.status = status.     this.message = message.     this.hasErrorToSend = true. // Do not call super because the container may prevent us from handling the // error ourselves }
false;public;0;8;;@Override public int getStatus() {     if (this.hasErrorToSend) {         return this.status.     }     // If there was no error we need to trust the wrapped response     return super.getStatus(). }
false;public;0;5;;@Override public void flushBuffer() throws IOException {     sendErrorIfNecessary().     super.flushBuffer(). }
false;private;0;6;;private void sendErrorIfNecessary() throws IOException {     if (this.hasErrorToSend && !isCommitted()) {         ((HttpServletResponse) getResponse()).sendError(this.status, this.message).     } }
false;public;0;3;;public String getMessage() {     return this.message. }
false;public;0;3;;public boolean hasErrorToSend() {     return this.hasErrorToSend. }
false;public;0;6;;@Override public PrintWriter getWriter() throws IOException {     sendErrorIfNecessary().     return super.getWriter(). }
false;public;0;5;;@Override public ServletOutputStream getOutputStream() throws IOException {     sendErrorIfNecessary().     return super.getOutputStream(). }
