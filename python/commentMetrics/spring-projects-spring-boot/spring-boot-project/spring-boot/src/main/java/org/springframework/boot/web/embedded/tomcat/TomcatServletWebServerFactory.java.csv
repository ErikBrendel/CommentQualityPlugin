commented;modifiers;parameterAmount;loc;comment;code
false;public;1;18;;@Override public WebServer getWebServer(ServletContextInitializer... initializers) {     Tomcat tomcat = new Tomcat().     File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir("tomcat").     tomcat.setBaseDir(baseDir.getAbsolutePath()).     Connector connector = new Connector(this.protocol).     tomcat.getService().addConnector(connector).     customizeConnector(connector).     tomcat.setConnector(connector).     tomcat.getHost().setAutoDeploy(false).     configureEngine(tomcat.getEngine()).     for (Connector additionalConnector : this.additionalTomcatConnectors) {         tomcat.getService().addConnector(additionalConnector).     }     prepareContext(tomcat.getHost(), initializers).     return getTomcatWebServer(tomcat). }
false;private;1;6;;private void configureEngine(Engine engine) {     engine.setBackgroundProcessorDelay(this.backgroundProcessorDelay).     for (Valve valve : this.engineValves) {         engine.getPipeline().addValve(valve).     } }
false;protected;2;37;;protected void prepareContext(Host host, ServletContextInitializer[] initializers) {     File documentRoot = getValidDocumentRoot().     TomcatEmbeddedContext context = new TomcatEmbeddedContext().     if (documentRoot != null) {         context.setResources(new LoaderHidingResourceRoot(context)).     }     context.setName(getContextPath()).     context.setDisplayName(getDisplayName()).     context.setPath(getContextPath()).     File docBase = (documentRoot != null) ? documentRoot : createTempDir("tomcat-docbase").     context.setDocBase(docBase.getAbsolutePath()).     context.addLifecycleListener(new FixContextListener()).     context.setParentClassLoader((this.resourceLoader != null) ? this.resourceLoader.getClassLoader() : ClassUtils.getDefaultClassLoader()).     resetDefaultLocaleMapping(context).     addLocaleMappings(context).     context.setUseRelativeRedirects(false).     configureTldSkipPatterns(context).     WebappLoader loader = new WebappLoader(context.getParentClassLoader()).     loader.setLoaderClass(TomcatEmbeddedWebappClassLoader.class.getName()).     loader.setDelegate(true).     context.setLoader(loader).     if (isRegisterDefaultServlet()) {         addDefaultServlet(context).     }     if (shouldRegisterJspServlet()) {         addJspServlet(context).         addJasperInitializer(context).     }     context.addLifecycleListener(new StaticResourceConfigurer(context)).     ServletContextInitializer[] initializersToUse = mergeInitializers(initializers).     host.addChild(context).     configureContext(context, initializersToUse).     postProcessContext(context). }
true;private;1;6;/**  * Override Tomcat's default locale mappings to align with other servers. See  * {@code org.apache.catalina.util.CharsetMapperDefault.properties}.  * @param context the context to reset  */ ;/**  * Override Tomcat's default locale mappings to align with other servers. See  * {@code org.apache.catalina.util.CharsetMapperDefault.properties}.  * @param context the context to reset  */ private void resetDefaultLocaleMapping(TomcatEmbeddedContext context) {     context.addLocaleEncodingMappingParameter(Locale.ENGLISH.toString(), DEFAULT_CHARSET.displayName()).     context.addLocaleEncodingMappingParameter(Locale.FRENCH.toString(), DEFAULT_CHARSET.displayName()). }
false;private;1;5;;private void addLocaleMappings(TomcatEmbeddedContext context) {     getLocaleCharsetMappings().forEach((locale, charset) -> context.addLocaleEncodingMappingParameter(locale.toString(), charset.toString())). }
false;private;1;6;;private void configureTldSkipPatterns(TomcatEmbeddedContext context) {     StandardJarScanFilter filter = new StandardJarScanFilter().     filter.setTldSkip(StringUtils.collectionToCommaDelimitedString(this.tldSkipPatterns)).     context.getJarScanner().setJarScanFilter(filter). }
false;private;1;12;;private void addDefaultServlet(Context context) {     Wrapper defaultServlet = context.createWrapper().     defaultServlet.setName("default").     defaultServlet.setServletClass("org.apache.catalina.servlets.DefaultServlet").     defaultServlet.addInitParameter("debug", "0").     defaultServlet.addInitParameter("listings", "false").     defaultServlet.setLoadOnStartup(1).     // Otherwise the default location of a Spring DispatcherServlet cannot be set     defaultServlet.setOverridable(true).     context.addChild(defaultServlet).     context.addServletMappingDecoded("/", "default"). }
false;private;1;11;;private void addJspServlet(Context context) {     Wrapper jspServlet = context.createWrapper().     jspServlet.setName("jsp").     jspServlet.setServletClass(getJsp().getClassName()).     jspServlet.addInitParameter("fork", "false").     getJsp().getInitParameters().forEach(jspServlet::addInitParameter).     jspServlet.setLoadOnStartup(3).     context.addChild(jspServlet).     context.addServletMappingDecoded("*.jsp", "jsp").     context.addServletMappingDecoded("*.jspx", "jsp"). }
false;private;1;11;;private void addJasperInitializer(TomcatEmbeddedContext context) {     try {         ServletContainerInitializer initializer = (ServletContainerInitializer) ClassUtils.forName("org.apache.jasper.servlet.JasperInitializer", null).newInstance().         context.addServletContainerInitializer(initializer, null).     } catch (Exception ex) {     // Probably not Tomcat 8     } }
true;protected;1;24;// Needs to be protected so it can be used by subclasses ;// Needs to be protected so it can be used by subclasses protected void customizeConnector(Connector connector) {     int port = (getPort() >= 0) ? getPort() : 0.     connector.setPort(port).     if (StringUtils.hasText(this.getServerHeader())) {         connector.setAttribute("server", this.getServerHeader()).     }     if (connector.getProtocolHandler() instanceof AbstractProtocol) {         customizeProtocol((AbstractProtocol<?>) connector.getProtocolHandler()).     }     if (getUriEncoding() != null) {         connector.setURIEncoding(getUriEncoding().name()).     }     // Don't bind to the socket prematurely if ApplicationContext is slow to start     connector.setProperty("bindOnInit", "false").     if (getSsl() != null && getSsl().isEnabled()) {         customizeSsl(connector).     }     TomcatConnectorCustomizer compression = new CompressionConnectorCustomizer(getCompression()).     compression.customize(connector).     for (TomcatConnectorCustomizer customizer : this.tomcatConnectorCustomizers) {         customizer.customize(connector).     } }
false;private;1;5;;private void customizeProtocol(AbstractProtocol<?> protocol) {     if (getAddress() != null) {         protocol.setAddress(getAddress()).     } }
false;private;1;6;;private void customizeSsl(Connector connector) {     new SslConnectorCustomizer(getSsl(), getSslStoreProvider()).customize(connector).     if (getHttp2() != null && getHttp2().isEnabled()) {         connector.addUpgradeProtocol(new Http2Protocol()).     } }
true;protected;2;27;/**  * Configure the Tomcat {@link Context}.  * @param context the Tomcat context  * @param initializers initializers to apply  */ ;/**  * Configure the Tomcat {@link Context}.  * @param context the Tomcat context  * @param initializers initializers to apply  */ protected void configureContext(Context context, ServletContextInitializer[] initializers) {     TomcatStarter starter = new TomcatStarter(initializers).     if (context instanceof TomcatEmbeddedContext) {         TomcatEmbeddedContext embeddedContext = (TomcatEmbeddedContext) context.         embeddedContext.setStarter(starter).         embeddedContext.setFailCtxIfServletStartFails(true).     }     context.addServletContainerInitializer(starter, NO_CLASSES).     for (LifecycleListener lifecycleListener : this.contextLifecycleListeners) {         context.addLifecycleListener(lifecycleListener).     }     for (Valve valve : this.contextValves) {         context.getPipeline().addValve(valve).     }     for (ErrorPage errorPage : getErrorPages()) {         new TomcatErrorPage(errorPage).addToContext(context).     }     for (MimeMappings.Mapping mapping : getMimeMappings()) {         context.addMimeMapping(mapping.getExtension(), mapping.getMimeType()).     }     configureSession(context).     new DisableReferenceClearingContextCustomizer().customize(context).     for (TomcatContextCustomizer customizer : this.tomcatContextCustomizers) {         customizer.customize(context).     } }
false;private;1;19;;private void configureSession(Context context) {     long sessionTimeout = getSessionTimeoutInMinutes().     context.setSessionTimeout((int) sessionTimeout).     Boolean httpOnly = getSession().getCookie().getHttpOnly().     if (httpOnly != null) {         context.setUseHttpOnly(httpOnly).     }     if (getSession().isPersistent()) {         Manager manager = context.getManager().         if (manager == null) {             manager = new StandardManager().             context.setManager(manager).         }         configurePersistSession(manager).     } else {         context.addLifecycleListener(new DisablePersistSessionListener()).     } }
false;private;1;8;;private void configurePersistSession(Manager manager) {     Assert.state(manager instanceof StandardManager, () -> "Unable to persist HTTP session state using manager type " + manager.getClass().getName()).     File dir = getValidSessionStoreDir().     File file = new File(dir, "SESSIONS.ser").     ((StandardManager) manager).setPathname(file.getAbsolutePath()). }
false;private;0;7;;private long getSessionTimeoutInMinutes() {     Duration sessionTimeout = getSession().getTimeout().     if (isZeroOrLess(sessionTimeout)) {         return 0.     }     return Math.max(sessionTimeout.toMinutes(), 1). }
false;private;1;4;;private boolean isZeroOrLess(Duration sessionTimeout) {     return sessionTimeout == null || sessionTimeout.isNegative() || sessionTimeout.isZero(). }
true;protected;1;2;/**  * Post process the Tomcat {@link Context} before it's used with the Tomcat Server.  * Subclasses can override this method to apply additional processing to the  * {@link Context}.  * @param context the Tomcat {@link Context}  */ ;/**  * Post process the Tomcat {@link Context} before it's used with the Tomcat Server.  * Subclasses can override this method to apply additional processing to the  * {@link Context}.  * @param context the Tomcat {@link Context}  */ protected void postProcessContext(Context context) { }
true;protected;1;3;/**  * Factory method called to create the {@link TomcatWebServer}. Subclasses can  * override this method to return a different {@link TomcatWebServer} or apply  * additional processing to the Tomcat server.  * @param tomcat the Tomcat server.  * @return a new {@link TomcatWebServer} instance  */ ;/**  * Factory method called to create the {@link TomcatWebServer}. Subclasses can  * override this method to return a different {@link TomcatWebServer} or apply  * additional processing to the Tomcat server.  * @param tomcat the Tomcat server.  * @return a new {@link TomcatWebServer} instance  */ protected TomcatWebServer getTomcatWebServer(Tomcat tomcat) {     return new TomcatWebServer(tomcat, getPort() >= 0). }
false;public;1;4;;@Override public void setResourceLoader(ResourceLoader resourceLoader) {     this.resourceLoader = resourceLoader. }
false;public;1;4;;@Override public void setBaseDirectory(File baseDirectory) {     this.baseDirectory = baseDirectory. }
true;public;0;3;/**  * Returns a mutable set of the patterns that match jars to ignore for TLD scanning.  * @return the list of jars to ignore for TLD scanning  */ ;/**  * Returns a mutable set of the patterns that match jars to ignore for TLD scanning.  * @return the list of jars to ignore for TLD scanning  */ public Set<String> getTldSkipPatterns() {     return this.tldSkipPatterns. }
true;public;1;4;/**  * Set the patterns that match jars to ignore for TLD scanning. See Tomcat's  * catalina.properties for typical values. Defaults to a list drawn from that source.  * @param patterns the jar patterns to skip when scanning for TLDs etc  */ ;/**  * Set the patterns that match jars to ignore for TLD scanning. See Tomcat's  * catalina.properties for typical values. Defaults to a list drawn from that source.  * @param patterns the jar patterns to skip when scanning for TLDs etc  */ public void setTldSkipPatterns(Collection<String> patterns) {     Assert.notNull(patterns, "Patterns must not be null").     this.tldSkipPatterns = new LinkedHashSet<>(patterns). }
true;public;1;4;/**  * Add patterns that match jars to ignore for TLD scanning. See Tomcat's  * catalina.properties for typical values.  * @param patterns the additional jar patterns to skip when scanning for TLDs etc  */ ;/**  * Add patterns that match jars to ignore for TLD scanning. See Tomcat's  * catalina.properties for typical values.  * @param patterns the additional jar patterns to skip when scanning for TLDs etc  */ public void addTldSkipPatterns(String... patterns) {     Assert.notNull(patterns, "Patterns must not be null").     this.tldSkipPatterns.addAll(Arrays.asList(patterns)). }
true;public;1;4;/**  * The Tomcat protocol to use when create the {@link Connector}.  * @param protocol the protocol  * @see Connector#Connector(String)  */ ;/**  * The Tomcat protocol to use when create the {@link Connector}.  * @param protocol the protocol  * @see Connector#Connector(String)  */ public void setProtocol(String protocol) {     Assert.hasLength(protocol, "Protocol must not be empty").     this.protocol = protocol. }
true;public;1;4;/**  * Set {@link Valve}s that should be applied to the Tomcat {@link Engine}. Calling  * this method will replace any existing valves.  * @param engineValves the valves to set  */ ;/**  * Set {@link Valve}s that should be applied to the Tomcat {@link Engine}. Calling  * this method will replace any existing valves.  * @param engineValves the valves to set  */ public void setEngineValves(Collection<? extends Valve> engineValves) {     Assert.notNull(engineValves, "Valves must not be null").     this.engineValves = new ArrayList<>(engineValves). }
true;public;0;3;/**  * Returns a mutable collection of the {@link Valve}s that will be applied to the  * Tomcat {@link Engine}.  * @return the engine valves that will be applied  */ ;/**  * Returns a mutable collection of the {@link Valve}s that will be applied to the  * Tomcat {@link Engine}.  * @return the engine valves that will be applied  */ public Collection<Valve> getEngineValves() {     return this.engineValves. }
false;public;1;5;;@Override public void addEngineValves(Valve... engineValves) {     Assert.notNull(engineValves, "Valves must not be null").     this.engineValves.addAll(Arrays.asList(engineValves)). }
true;public;1;4;/**  * Set {@link Valve}s that should be applied to the Tomcat {@link Context}. Calling  * this method will replace any existing valves.  * @param contextValves the valves to set  */ ;/**  * Set {@link Valve}s that should be applied to the Tomcat {@link Context}. Calling  * this method will replace any existing valves.  * @param contextValves the valves to set  */ public void setContextValves(Collection<? extends Valve> contextValves) {     Assert.notNull(contextValves, "Valves must not be null").     this.contextValves = new ArrayList<>(contextValves). }
true;public;0;3;/**  * Returns a mutable collection of the {@link Valve}s that will be applied to the  * Tomcat {@link Context}.  * @return the context valves that will be applied  * @see #getEngineValves()  */ ;/**  * Returns a mutable collection of the {@link Valve}s that will be applied to the  * Tomcat {@link Context}.  * @return the context valves that will be applied  * @see #getEngineValves()  */ public Collection<Valve> getContextValves() {     return this.contextValves. }
true;public;1;4;/**  * Add {@link Valve}s that should be applied to the Tomcat {@link Context}.  * @param contextValves the valves to add  */ ;/**  * Add {@link Valve}s that should be applied to the Tomcat {@link Context}.  * @param contextValves the valves to add  */ public void addContextValves(Valve... contextValves) {     Assert.notNull(contextValves, "Valves must not be null").     this.contextValves.addAll(Arrays.asList(contextValves)). }
true;public;1;6;/**  * Set {@link LifecycleListener}s that should be applied to the Tomcat  * {@link Context}. Calling this method will replace any existing listeners.  * @param contextLifecycleListeners the listeners to set  */ ;/**  * Set {@link LifecycleListener}s that should be applied to the Tomcat  * {@link Context}. Calling this method will replace any existing listeners.  * @param contextLifecycleListeners the listeners to set  */ public void setContextLifecycleListeners(Collection<? extends LifecycleListener> contextLifecycleListeners) {     Assert.notNull(contextLifecycleListeners, "ContextLifecycleListeners must not be null").     this.contextLifecycleListeners = new ArrayList<>(contextLifecycleListeners). }
true;public;0;3;/**  * Returns a mutable collection of the {@link LifecycleListener}s that will be applied  * to the Tomcat {@link Context}.  * @return the context lifecycle listeners that will be applied  */ ;/**  * Returns a mutable collection of the {@link LifecycleListener}s that will be applied  * to the Tomcat {@link Context}.  * @return the context lifecycle listeners that will be applied  */ public Collection<LifecycleListener> getContextLifecycleListeners() {     return this.contextLifecycleListeners. }
true;public;1;6;/**  * Add {@link LifecycleListener}s that should be added to the Tomcat {@link Context}.  * @param contextLifecycleListeners the listeners to add  */ ;/**  * Add {@link LifecycleListener}s that should be added to the Tomcat {@link Context}.  * @param contextLifecycleListeners the listeners to add  */ public void addContextLifecycleListeners(LifecycleListener... contextLifecycleListeners) {     Assert.notNull(contextLifecycleListeners, "ContextLifecycleListeners must not be null").     this.contextLifecycleListeners.addAll(Arrays.asList(contextLifecycleListeners)). }
true;public;1;6;/**  * Set {@link TomcatContextCustomizer}s that should be applied to the Tomcat  * {@link Context}. Calling this method will replace any existing customizers.  * @param tomcatContextCustomizers the customizers to set  */ ;/**  * Set {@link TomcatContextCustomizer}s that should be applied to the Tomcat  * {@link Context}. Calling this method will replace any existing customizers.  * @param tomcatContextCustomizers the customizers to set  */ public void setTomcatContextCustomizers(Collection<? extends TomcatContextCustomizer> tomcatContextCustomizers) {     Assert.notNull(tomcatContextCustomizers, "TomcatContextCustomizers must not be null").     this.tomcatContextCustomizers = new ArrayList<>(tomcatContextCustomizers). }
true;public;0;3;/**  * Returns a mutable collection of the {@link TomcatContextCustomizer}s that will be  * applied to the Tomcat {@link Context}.  * @return the listeners that will be applied  */ ;/**  * Returns a mutable collection of the {@link TomcatContextCustomizer}s that will be  * applied to the Tomcat {@link Context}.  * @return the listeners that will be applied  */ public Collection<TomcatContextCustomizer> getTomcatContextCustomizers() {     return this.tomcatContextCustomizers. }
false;public;1;7;;@Override public void addContextCustomizers(TomcatContextCustomizer... tomcatContextCustomizers) {     Assert.notNull(tomcatContextCustomizers, "TomcatContextCustomizers must not be null").     this.tomcatContextCustomizers.addAll(Arrays.asList(tomcatContextCustomizers)). }
true;public;1;6;/**  * Set {@link TomcatConnectorCustomizer}s that should be applied to the Tomcat  * {@link Connector}. Calling this method will replace any existing customizers.  * @param tomcatConnectorCustomizers the customizers to set  */ ;/**  * Set {@link TomcatConnectorCustomizer}s that should be applied to the Tomcat  * {@link Connector}. Calling this method will replace any existing customizers.  * @param tomcatConnectorCustomizers the customizers to set  */ public void setTomcatConnectorCustomizers(Collection<? extends TomcatConnectorCustomizer> tomcatConnectorCustomizers) {     Assert.notNull(tomcatConnectorCustomizers, "TomcatConnectorCustomizers must not be null").     this.tomcatConnectorCustomizers = new ArrayList<>(tomcatConnectorCustomizers). }
false;public;1;7;;@Override public void addConnectorCustomizers(TomcatConnectorCustomizer... tomcatConnectorCustomizers) {     Assert.notNull(tomcatConnectorCustomizers, "TomcatConnectorCustomizers must not be null").     this.tomcatConnectorCustomizers.addAll(Arrays.asList(tomcatConnectorCustomizers)). }
true;public;0;3;/**  * Returns a mutable collection of the {@link TomcatConnectorCustomizer}s that will be  * applied to the Tomcat {@link Connector}.  * @return the customizers that will be applied  */ ;/**  * Returns a mutable collection of the {@link TomcatConnectorCustomizer}s that will be  * applied to the Tomcat {@link Connector}.  * @return the customizers that will be applied  */ public Collection<TomcatConnectorCustomizer> getTomcatConnectorCustomizers() {     return this.tomcatConnectorCustomizers. }
true;public;1;4;/**  * Add {@link Connector}s in addition to the default connector, e.g. for SSL or AJP  * @param connectors the connectors to add  */ ;/**  * Add {@link Connector}s in addition to the default connector, e.g. for SSL or AJP  * @param connectors the connectors to add  */ public void addAdditionalTomcatConnectors(Connector... connectors) {     Assert.notNull(connectors, "Connectors must not be null").     this.additionalTomcatConnectors.addAll(Arrays.asList(connectors)). }
true;public;0;3;/**  * Returns a mutable collection of the {@link Connector}s that will be added to the  * Tomcat.  * @return the additionalTomcatConnectors  */ ;/**  * Returns a mutable collection of the {@link Connector}s that will be added to the  * Tomcat.  * @return the additionalTomcatConnectors  */ public List<Connector> getAdditionalTomcatConnectors() {     return this.additionalTomcatConnectors. }
false;public;1;4;;@Override public void setUriEncoding(Charset uriEncoding) {     this.uriEncoding = uriEncoding. }
true;public;0;3;/**  * Returns the character encoding to use for URL decoding.  * @return the URI encoding  */ ;/**  * Returns the character encoding to use for URL decoding.  * @return the URI encoding  */ public Charset getUriEncoding() {     return this.uriEncoding. }
false;public;1;4;;@Override public void setBackgroundProcessorDelay(int delay) {     this.backgroundProcessorDelay = delay. }
false;public;1;10;;@Override public void lifecycleEvent(LifecycleEvent event) {     if (event.getType().equals(Lifecycle.START_EVENT)) {         Context context = (Context) event.getLifecycle().         Manager manager = context.getManager().         if (manager != null && manager instanceof StandardManager) {             ((StandardManager) manager).setPathname(null).         }     } }
false;public;1;6;;@Override public void lifecycleEvent(LifecycleEvent event) {     if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) {         addResourceJars(getUrlsOfJarsWithMetaInfResources()).     } }
false;private;1;16;;private void addResourceJars(List<URL> resourceJarUrls) {     for (URL url : resourceJarUrls) {         String path = url.getPath().         if (path.endsWith(".jar") || path.endsWith(".jar!/")) {             String jar = url.toString().             if (!jar.startsWith("jar:")) {                 // A jar file in the file system. Convert to Jar URL.                 jar = "jar:" + jar + "!/".             }             addResourceSet(jar).         } else {             addResourceSet(url.toString()).         }     } }
false;private;1;17;;private void addResourceSet(String resource) {     try {         if (isInsideNestedJar(resource)) {             // It's a nested jar but we now don't want the suffix because Tomcat             // is going to try and locate it as a root URL (not the resource             // inside it)             resource = resource.substring(0, resource.length() - 2).         }         URL url = new URL(resource).         String path = "/META-INF/resources".         this.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, "/", url, path).     } catch (Exception ex) {     // Ignore (probably not a directory)     } }
false;private;1;3;;private boolean isInsideNestedJar(String dir) {     return dir.indexOf("!/") < dir.lastIndexOf("!/"). }
false;protected;0;4;;@Override protected WebResourceSet createMainResourceSet() {     return new LoaderHidingWebResourceSet(super.createMainResourceSet()). }
false;public;1;7;;@Override public WebResource getResource(String path) {     if (path.startsWith("/org/springframework/boot")) {         return new EmptyResource(getRoot(), path).     }     return this.delegate.getResource(path). }
false;public;1;4;;@Override public String[] list(String path) {     return this.delegate.list(path). }
false;public;1;4;;@Override public Set<String> listWebAppPaths(String path) {     return this.delegate.listWebAppPaths(path). }
false;public;1;4;;@Override public boolean mkdir(String path) {     return this.delegate.mkdir(path). }
false;public;3;4;;@Override public boolean write(String path, InputStream is, boolean overwrite) {     return this.delegate.write(path, is, overwrite). }
false;public;0;4;;@Override public URL getBaseUrl() {     return this.delegate.getBaseUrl(). }
false;public;1;4;;@Override public void setReadOnly(boolean readOnly) {     this.delegate.setReadOnly(readOnly). }
false;public;0;4;;@Override public boolean isReadOnly() {     return this.delegate.isReadOnly(). }
false;public;0;4;;@Override public void gc() {     this.delegate.gc(). }
false;protected;0;11;;@Override protected void initInternal() throws LifecycleException {     if (this.delegate instanceof LifecycleBase) {         try {             ReflectionUtils.invokeMethod(this.initInternal, this.delegate).         } catch (Exception ex) {             throw new LifecycleException(ex).         }     } }
