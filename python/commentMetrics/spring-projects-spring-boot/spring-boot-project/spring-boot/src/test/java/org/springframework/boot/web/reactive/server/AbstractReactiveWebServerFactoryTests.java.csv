commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@After public void tearDown() {     if (this.webServer != null) {         try {             this.webServer.stop().         } catch (Exception ex) {         // Ignore         }     } }
false;protected,abstract;0;1;;protected abstract AbstractReactiveWebServerFactory getFactory().
false;public;0;14;;@Test public void specificPort() {     AbstractReactiveWebServerFactory factory = getFactory().     int specificPort = SocketUtils.findAvailableTcpPort(41000).     factory.setPort(specificPort).     this.webServer = factory.getWebServer(new EchoHandler()).     this.webServer.start().     Mono<String> result = getWebClient().build().post().uri("/test").contentType(MediaType.TEXT_PLAIN).body(BodyInserters.fromObject("Hello World")).exchange().flatMap((response) -> response.bodyToMono(String.class)).     assertThat(result.block(Duration.ofSeconds(30))).isEqualTo("Hello World").     assertThat(this.webServer.getPort()).isEqualTo(specificPort). }
false;public;0;4;;@Test public void basicSslFromClassPath() {     testBasicSslWithKeyStore("classpath:test.jks", "password"). }
false;public;0;4;;@Test public void basicSslFromFileSystem() {     testBasicSslWithKeyStore("src/test/resources/test.jks", "password"). }
false;protected,final;2;17;;protected final void testBasicSslWithKeyStore(String keyStore, String keyPassword) {     AbstractReactiveWebServerFactory factory = getFactory().     Ssl ssl = new Ssl().     ssl.setKeyStore(keyStore).     ssl.setKeyPassword(keyPassword).     factory.setSsl(ssl).     this.webServer = factory.getWebServer(new EchoHandler()).     this.webServer.start().     ReactorClientHttpConnector connector = buildTrustAllSslConnector().     WebClient client = WebClient.builder().baseUrl("https://localhost:" + this.webServer.getPort()).clientConnector(connector).build().     Mono<String> result = client.post().uri("/test").contentType(MediaType.TEXT_PLAIN).body(BodyInserters.fromObject("Hello World")).exchange().flatMap((response) -> response.bodyToMono(String.class)).     assertThat(result.block(Duration.ofSeconds(30))).isEqualTo("Hello World"). }
false;protected;0;8;;protected ReactorClientHttpConnector buildTrustAllSslConnector() {     SslContextBuilder builder = SslContextBuilder.forClient().sslProvider(SslProvider.JDK).trustManager(InsecureTrustManagerFactory.INSTANCE).     HttpClient client = HttpClient.create().wiretap(true).secure((sslContextSpec) -> sslContextSpec.sslContext(builder)).     return new ReactorClientHttpConnector(client). }
false;public;0;10;;@Test public void sslWantsClientAuthenticationSucceedsWithClientCertificate() throws Exception {     Ssl ssl = new Ssl().     ssl.setClientAuth(Ssl.ClientAuth.WANT).     ssl.setKeyStore("classpath:test.jks").     ssl.setKeyPassword("password").     ssl.setTrustStore("classpath:test.jks").     testClientAuthSuccess(ssl, buildTrustAllSslWithClientKeyConnector()). }
false;public;0;9;;@Test public void sslWantsClientAuthenticationSucceedsWithoutClientCertificate() {     Ssl ssl = new Ssl().     ssl.setClientAuth(Ssl.ClientAuth.WANT).     ssl.setKeyStore("classpath:test.jks").     ssl.setKeyPassword("password").     ssl.setTrustStore("classpath:test.jks").     testClientAuthSuccess(ssl, buildTrustAllSslConnector()). }
false;protected;0;16;;protected ReactorClientHttpConnector buildTrustAllSslWithClientKeyConnector() throws Exception {     KeyStore clientKeyStore = KeyStore.getInstance(KeyStore.getDefaultType()).     clientKeyStore.load(new FileInputStream(new File("src/test/resources/test.jks")), "secret".toCharArray()).     KeyManagerFactory clientKeyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()).     clientKeyManagerFactory.init(clientKeyStore, "password".toCharArray()).     SslContextBuilder builder = SslContextBuilder.forClient().sslProvider(SslProvider.JDK).trustManager(InsecureTrustManagerFactory.INSTANCE).keyManager(clientKeyManagerFactory).     HttpClient client = HttpClient.create().wiretap(true).secure((sslContextSpec) -> sslContextSpec.sslContext(builder)).     return new ReactorClientHttpConnector(client). }
false;protected;2;14;;protected void testClientAuthSuccess(Ssl sslConfiguration, ReactorClientHttpConnector clientConnector) {     AbstractReactiveWebServerFactory factory = getFactory().     factory.setSsl(sslConfiguration).     this.webServer = factory.getWebServer(new EchoHandler()).     this.webServer.start().     WebClient client = WebClient.builder().baseUrl("https://localhost:" + this.webServer.getPort()).clientConnector(clientConnector).build().     Mono<String> result = client.post().uri("/test").contentType(MediaType.TEXT_PLAIN).body(BodyInserters.fromObject("Hello World")).exchange().flatMap((response) -> response.bodyToMono(String.class)).     assertThat(result.block(Duration.ofSeconds(30))).isEqualTo("Hello World"). }
false;public;0;10;;@Test public void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception {     Ssl ssl = new Ssl().     ssl.setClientAuth(Ssl.ClientAuth.NEED).     ssl.setKeyStore("classpath:test.jks").     ssl.setKeyPassword("password").     ssl.setTrustStore("classpath:test.jks").     testClientAuthSuccess(ssl, buildTrustAllSslWithClientKeyConnector()). }
false;public;0;9;;@Test public void sslNeedsClientAuthenticationFailsWithoutClientCertificate() {     Ssl ssl = new Ssl().     ssl.setClientAuth(Ssl.ClientAuth.NEED).     ssl.setKeyStore("classpath:test.jks").     ssl.setKeyPassword("password").     ssl.setTrustStore("classpath:test.jks").     testClientAuthFailure(ssl, buildTrustAllSslConnector()). }
false;protected;2;15;;protected void testClientAuthFailure(Ssl sslConfiguration, ReactorClientHttpConnector clientConnector) {     AbstractReactiveWebServerFactory factory = getFactory().     factory.setSsl(sslConfiguration).     this.webServer = factory.getWebServer(new EchoHandler()).     this.webServer.start().     WebClient client = WebClient.builder().baseUrl("https://localhost:" + this.webServer.getPort()).clientConnector(clientConnector).build().     Mono<String> result = client.post().uri("/test").contentType(MediaType.TEXT_PLAIN).body(BodyInserters.fromObject("Hello World")).exchange().flatMap((response) -> response.bodyToMono(String.class)).     StepVerifier.create(result).expectError(SSLException.class).verify(Duration.ofSeconds(10)). }
false;protected;0;3;;protected WebClient.Builder getWebClient() {     return getWebClient(HttpClient.create().wiretap(true)). }
false;protected;1;6;;protected WebClient.Builder getWebClient(HttpClient client) {     InetSocketAddress address = new InetSocketAddress(this.webServer.getPort()).     String baseUrl = "http://" + address.getHostString() + ":" + address.getPort().     return WebClient.builder().clientConnector(new ReactorClientHttpConnector(client)).baseUrl(baseUrl). }
false;public;0;7;;@Test public void compressionOfResponseToGetRequest() {     WebClient client = prepareCompressionTest().     ResponseEntity<Void> response = client.get().exchange().flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30)).     assertResponseIsCompressed(response). }
false;public;0;7;;@Test public void compressionOfResponseToPostRequest() {     WebClient client = prepareCompressionTest().     ResponseEntity<Void> response = client.post().exchange().flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30)).     assertResponseIsCompressed(response). }
false;public;0;10;;@Test public void noCompressionForSmallResponse() {     Compression compression = new Compression().     compression.setEnabled(true).     compression.setMinResponseSize(DataSize.ofBytes(3001)).     WebClient client = prepareCompressionTest(compression).     ResponseEntity<Void> response = client.get().exchange().flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30)).     assertResponseIsNotCompressed(response). }
false;public;0;9;;@Test public void noCompressionForMimeType() {     Compression compression = new Compression().     compression.setMimeTypes(new String[] { "application/json" }).     WebClient client = prepareCompressionTest(compression).     ResponseEntity<Void> response = client.get().exchange().flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30)).     assertResponseIsNotCompressed(response). }
false;public;0;11;;@Test public void noCompressionForUserAgent() {     Compression compression = new Compression().     compression.setEnabled(true).     compression.setExcludedUserAgents(new String[] { "testUserAgent" }).     WebClient client = prepareCompressionTest(compression).     ResponseEntity<Void> response = client.get().header("User-Agent", "testUserAgent").exchange().flatMap((res) -> res.toEntity(Void.class)).block(Duration.ofSeconds(30)).     assertResponseIsNotCompressed(response). }
false;public;0;5;;@Test public void whenSslIsEnabledAndNoKeyStoreIsConfiguredThenServerFailsToStart() {     assertThatThrownBy(() -> testBasicSslWithKeyStore(null, null)).hasMessageContaining("Could not load key store 'null'"). }
false;protected;0;6;;protected WebClient prepareCompressionTest() {     Compression compression = new Compression().     compression.setEnabled(true).     return prepareCompressionTest(compression). }
false;protected;1;14;;protected WebClient prepareCompressionTest(Compression compression) {     AbstractReactiveWebServerFactory factory = getFactory().     factory.setCompression(compression).     this.webServer = factory.getWebServer(new CharsHandler(3000, MediaType.TEXT_PLAIN)).     this.webServer.start().     HttpClient client = HttpClient.create().wiretap(true).compress(true).tcpConfiguration((tcpClient) -> tcpClient.doOnConnected((connection) -> connection.channel().pipeline().addBefore(NettyPipeline.HttpDecompressor, "CompressionTest", new CompressionDetectionHandler()))).     return getWebClient(client).build(). }
false;protected;1;3;;protected void assertResponseIsCompressed(ResponseEntity<Void> response) {     assertThat(response.getHeaders().getFirst("X-Test-Compressed")).isEqualTo("true"). }
false;protected;1;3;;protected void assertResponseIsNotCompressed(ResponseEntity<Void> response) {     assertThat(response.getHeaders().keySet()).doesNotContain("X-Test-Compressed"). }
false;protected;1;7;;protected void assertForwardHeaderIsUsed(AbstractReactiveWebServerFactory factory) {     this.webServer = factory.getWebServer(new XForwardedHandler()).     this.webServer.start().     String body = getWebClient().build().get().header("X-Forwarded-Proto", "https").retrieve().bodyToMono(String.class).block(Duration.ofSeconds(30)).     assertThat(body).isEqualTo("https"). }
false;public;2;5;;@Override public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {     response.setStatusCode(HttpStatus.OK).     return response.writeWith(request.getBody()). }
false;public;2;12;;@Override public void channelRead(ChannelHandlerContext ctx, Object msg) {     if (msg instanceof HttpResponse) {         HttpResponse response = (HttpResponse) msg.         boolean compressed = response.headers().contains(HttpHeaderNames.CONTENT_ENCODING, "gzip", true).         if (compressed) {             response.headers().set("X-Test-Compressed", "true").         }     }     ctx.fireChannelRead(msg). }
false;public;2;7;;@Override public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {     response.setStatusCode(HttpStatus.OK).     response.getHeaders().setContentType(this.mediaType).     response.getHeaders().setContentLength(this.bytes.readableByteCount()).     return response.writeWith(Mono.just(this.bytes)). }
false;public;2;8;;@Override public Mono<Void> handle(ServerHttpRequest request, ServerHttpResponse response) {     String scheme = request.getURI().getScheme().     DataBufferFactory bufferFactory = new DefaultDataBufferFactory().     DataBuffer buffer = bufferFactory.wrap(scheme.getBytes(StandardCharsets.UTF_8)).     return response.writeWith(Mono.just(buffer)). }
