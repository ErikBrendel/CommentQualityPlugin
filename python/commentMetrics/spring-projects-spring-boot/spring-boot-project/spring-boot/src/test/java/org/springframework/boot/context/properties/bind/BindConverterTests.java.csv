commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void setup() {     MockitoAnnotations.initMocks(this). }
false;public;0;6;;@Test public void createWhenConversionServiceIsNullShouldThrowException() {     assertThatIllegalArgumentException().isThrownBy(() -> BindConverter.get(null, null)).withMessageContaining("ConversionService must not be null"). }
false;public;0;4;;@Test public void createWhenPropertyEditorInitializerIsNullShouldCreate() {     BindConverter.get(ApplicationConversionService.getSharedInstance(), null). }
false;public;0;6;;@Test public void createWhenPropertyEditorInitializerIsNotNullShouldUseToInitialize() {     BindConverter.get(ApplicationConversionService.getSharedInstance(), this.propertyEditorInitializer).     verify(this.propertyEditorInitializer).accept(any(PropertyEditorRegistry.class)). }
false;public;0;6;;@Test public void canConvertWhenHasDefaultEditorShouldReturnTrue() {     BindConverter bindConverter = getPropertyEditorOnlyBindConverter(null).     assertThat(bindConverter.canConvert("java.lang.RuntimeException", ResolvableType.forClass(Class.class))).isTrue(). }
false;public;0;7;;@Test public void canConvertWhenHasCustomEditorShouldReturnTrue() {     BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor).     assertThat(bindConverter.canConvert("test", ResolvableType.forClass(SampleType.class))).isTrue(). }
false;public;0;6;;@Test public void canConvertWhenHasEditorByConventionShouldReturnTrue() {     BindConverter bindConverter = getPropertyEditorOnlyBindConverter(null).     assertThat(bindConverter.canConvert("test", ResolvableType.forClass(ConventionType.class))).isTrue(). }
false;public;0;8;;@Test public void canConvertWhenHasEditorForCollectionElementShouldReturnTrue() {     BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor).     assertThat(bindConverter.canConvert("test", ResolvableType.forClassWithGenerics(List.class, SampleType.class))).isTrue(). }
false;public;0;7;;@Test public void canConvertWhenHasEditorForArrayElementShouldReturnTrue() {     BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor).     assertThat(bindConverter.canConvert("test", ResolvableType.forClass(SampleType[].class))).isTrue(). }
false;public;0;6;;@Test public void canConvertWhenConversionServiceCanConvertShouldReturnTrue() {     BindConverter bindConverter = getBindConverter(new SampleTypeConverter()).     assertThat(bindConverter.canConvert("test", ResolvableType.forClass(SampleType.class))).isTrue(). }
false;public;0;7;;@Test public void canConvertWhenNotPropertyEditorAndConversionServiceCannotConvertShouldReturnFalse() {     BindConverter bindConverter = BindConverter.get(ApplicationConversionService.getSharedInstance(), null).     assertThat(bindConverter.canConvert("test", ResolvableType.forClass(SampleType.class))).isFalse(). }
false;public;0;7;;@Test public void convertWhenHasDefaultEditorShouldConvert() {     BindConverter bindConverter = getPropertyEditorOnlyBindConverter(null).     Class<?> converted = bindConverter.convert("java.lang.RuntimeException", ResolvableType.forClass(Class.class)).     assertThat(converted).isEqualTo(RuntimeException.class). }
false;public;0;8;;@Test public void convertWhenHasCustomEditorShouldConvert() {     BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor).     SampleType converted = bindConverter.convert("test", ResolvableType.forClass(SampleType.class)).     assertThat(converted.getText()).isEqualTo("test"). }
false;public;0;7;;@Test public void convertWhenHasEditorByConventionShouldConvert() {     BindConverter bindConverter = getPropertyEditorOnlyBindConverter(null).     ConventionType converted = bindConverter.convert("test", ResolvableType.forClass(ConventionType.class)).     assertThat(converted.getText()).isEqualTo("test"). }
false;public;0;9;;@Test public void convertWhenHasEditorForCollectionElementShouldConvert() {     BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor).     List<SampleType> converted = bindConverter.convert("test", ResolvableType.forClassWithGenerics(List.class, SampleType.class)).     assertThat(converted).hasSize(1).     assertThat(converted.get(0).getText()).isEqualTo("test"). }
false;public;0;9;;@Test public void convertWhenHasEditorForArrayElementShouldConvert() {     BindConverter bindConverter = getPropertyEditorOnlyBindConverter(this::registerSampleTypeEditor).     SampleType[] converted = bindConverter.convert("test", ResolvableType.forClass(SampleType[].class)).     assertThat(converted).isNotEmpty().     assertThat(converted[0].getText()).isEqualTo("test"). }
false;public;0;7;;@Test public void convertWhenConversionServiceCanConvertShouldConvert() {     BindConverter bindConverter = getBindConverter(new SampleTypeConverter()).     SampleType converted = bindConverter.convert("test", ResolvableType.forClass(SampleType.class)).     assertThat(converted.getText()).isEqualTo("test"). }
false;public;0;8;;@Test public void convertWhenNotPropertyEditorAndConversionServiceCannotConvertShouldThrowException() {     BindConverter bindConverter = BindConverter.get(ApplicationConversionService.getSharedInstance(), null).     assertThatExceptionOfType(ConverterNotFoundException.class).isThrownBy(() -> bindConverter.convert("test", ResolvableType.forClass(SampleType.class))). }
false;public;0;9;;@Test public void convertWhenConvertingToFileShouldExcludeFileEditor() {     // For back compatibility we want true file conversion and not an accidental     // classpath resource reference. See gh-12163     BindConverter bindConverter = BindConverter.get(new GenericConversionService(), null).     File result = bindConverter.convert(".", ResolvableType.forClass(File.class)).     assertThat(result.getPath()).isEqualTo("."). }
false;public;0;8;;@Test public void fallsBackToApplicationConversionService() {     BindConverter bindConverter = BindConverter.get(new GenericConversionService(), null).     Duration result = bindConverter.convert("10s", ResolvableType.forClass(Duration.class)).     assertThat(result.getSeconds()).isEqualTo(10). }
false;private;1;5;;private BindConverter getPropertyEditorOnlyBindConverter(Consumer<PropertyEditorRegistry> propertyEditorInitializer) {     return BindConverter.get(new ThrowingConversionService(), propertyEditorInitializer). }
false;private;1;5;;private BindConverter getBindConverter(Converter<?, ?> converter) {     GenericConversionService conversionService = new GenericConversionService().     conversionService.addConverter(converter).     return BindConverter.get(conversionService, null). }
false;private;1;3;;private void registerSampleTypeEditor(PropertyEditorRegistry registry) {     registry.registerCustomEditor(SampleType.class, new SampleTypePropertyEditor()). }
false;public;0;3;;public String getText() {     return this.text. }
false;public;1;6;;@Override public void setAsText(String text) throws IllegalArgumentException {     SampleType value = new SampleType().     value.text = text.     setValue(value). }
false;public;1;6;;@Override public SampleType convert(String source) {     SampleType result = new SampleType().     result.text = source.     return result. }
false;public;0;3;;public String getText() {     return this.text. }
false;public;1;6;;@Override public void setAsText(String text) throws IllegalArgumentException {     ConventionType value = new ConventionType().     value.text = text.     setValue(value). }
false;public;2;4;;@Override public boolean canConvert(Class<?> sourceType, Class<?> targetType) {     throw new AssertionError("Should not call conversion service"). }
false;public;2;4;;@Override public boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {     throw new AssertionError("Should not call conversion service"). }
false;public;2;4;;@Override public <T> T convert(Object source, Class<T> targetType) {     throw new AssertionError("Should not call conversion service"). }
false;public;3;5;;@Override public Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {     throw new AssertionError("Should not call conversion service"). }
