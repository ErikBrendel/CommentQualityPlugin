commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Test public void callbackWhenCallbackTypeIsNullShouldThrowException() {     assertThatIllegalArgumentException().isThrownBy(() -> LambdaSafe.callback(null, new Object(), null)).withMessageContaining("CallbackType must not be null"). }
false;public;0;6;;@Test public void callbackWhenCallbackInstanceIsNullShouldThrowException() {     assertThatIllegalArgumentException().isThrownBy(() -> LambdaSafe.callback(Object.class, null, null)).withMessageContaining("CallbackInstance must not be null"). }
false;public;0;8;;@Test public void callbackInvokeWhenNoGenericShouldInvokeCallback() {     NonGenericCallback callbackInstance = mock(NonGenericCallback.class).     String argument = "foo".     LambdaSafe.callback(NonGenericCallback.class, callbackInstance, argument).invoke((c) -> c.handle(argument)).     verify(callbackInstance).handle(argument). }
false;public;0;9;;@Test @SuppressWarnings("unchecked") public void callbackInvokeWhenHasGenericShouldInvokeCallback() {     StringCallback callbackInstance = mock(StringCallback.class).     String argument = "foo".     LambdaSafe.callback(GenericCallback.class, callbackInstance, argument).invoke((c) -> c.handle(argument)).     verify(callbackInstance).handle(argument). }
false;public;0;9;;@Test @SuppressWarnings("unchecked") public void callbackInvokeWhenHasResolvableGenericMatchShouldInvokeCallback() {     StringBuilderCallback callbackInstance = mock(StringBuilderCallback.class).     StringBuilder argument = new StringBuilder("foo").     LambdaSafe.callback(GenericCallback.class, callbackInstance, argument).invoke((c) -> c.handle(argument)).     verify(callbackInstance).handle(argument). }
false;public;0;9;;@Test @SuppressWarnings("unchecked") public void callbackInvokeWhenHasResolvableGenericNonMatchShouldNotInvokeCallback() {     GenericCallback<?> callbackInstance = mock(StringBuilderCallback.class).     String argument = "foo".     LambdaSafe.callback(GenericCallback.class, callbackInstance, argument).invoke((c) -> c.handle(argument)).     verifyZeroInteractions(callbackInstance). }
false;public;0;9;;@Test @SuppressWarnings("unchecked") public void callbackInvokeWhenLambdaMismatchShouldSwallowException() {     GenericCallback<StringBuilder> callbackInstance = (s) -> fail("Should not get here").     String argument = "foo".     LambdaSafe.callback(GenericCallback.class, callbackInstance, argument).invoke((c) -> c.handle(argument)). }
false;public;0;9;;@Test @SuppressWarnings("unchecked") public void callbackInvokeWhenLambdaMismatchOnDifferentArgumentShouldSwallowException() {     GenericMultiArgCallback<StringBuilder> callbackInstance = (n, s, b) -> fail("Should not get here").     String argument = "foo".     LambdaSafe.callback(GenericMultiArgCallback.class, callbackInstance, argument).invoke((c) -> c.handle(1, argument, false)). }
false;public;0;11;;@Test public void callbackInvokeAndWhenNoGenericShouldReturnResult() {     NonGenericFactory callbackInstance = mock(NonGenericFactory.class).     String argument = "foo".     given(callbackInstance.handle("foo")).willReturn(123).     InvocationResult<Integer> result = LambdaSafe.callback(NonGenericFactory.class, callbackInstance, argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result.hasResult()).isTrue().     assertThat(result.get()).isEqualTo(123). }
false;public;0;12;;@Test @SuppressWarnings("unchecked") public void callbackInvokeAndWhenHasGenericShouldReturnResult() {     StringFactory callbackInstance = mock(StringFactory.class).     String argument = "foo".     given(callbackInstance.handle("foo")).willReturn(123).     InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result.hasResult()).isTrue().     assertThat(result.get()).isEqualTo(123). }
false;public;0;12;;@Test @SuppressWarnings("unchecked") public void callbackInvokeAndWhenReturnNullShouldReturnResult() {     StringFactory callbackInstance = mock(StringFactory.class).     String argument = "foo".     given(callbackInstance.handle("foo")).willReturn(null).     InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result.hasResult()).isTrue().     assertThat(result.get()).isNull(). }
false;public;0;13;;@Test @SuppressWarnings("unchecked") public void callbackInvokeAndWhenHasResolvableGenericMatchShouldReturnResult() {     StringBuilderFactory callbackInstance = mock(StringBuilderFactory.class).     StringBuilder argument = new StringBuilder("foo").     given(callbackInstance.handle(any(StringBuilder.class))).willReturn(123).     InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument).invokeAnd((c) -> c.handle(argument)).     verify(callbackInstance).handle(argument).     assertThat(result.hasResult()).isTrue().     assertThat(result.get()).isEqualTo(123). }
false;public;0;11;;@Test @SuppressWarnings("unchecked") public void callbackInvokeAndWhenHasResolvableGenericNonMatchShouldReturnNoResult() {     GenericFactory<?> callbackInstance = mock(StringBuilderFactory.class).     String argument = "foo".     InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result.hasResult()).isFalse().     verifyZeroInteractions(callbackInstance). }
false;public;0;13;;@Test @SuppressWarnings("unchecked") public void callbackInvokeAndWhenLambdaMismatchShouldSwallowException() {     GenericFactory<StringBuilder> callbackInstance = (s) -> {         fail("Should not get here").         return 123.     }.     String argument = "foo".     InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result.hasResult()).isFalse(). }
false;public;0;13;;@Test @SuppressWarnings("unchecked") public void callbackInvokeAndWhenLambdaMismatchOnDifferentArgumentShouldSwallowException() {     GenericMultiArgFactory<StringBuilder> callbackInstance = (n, s, b) -> {         fail("Should not get here").         return 123.     }.     String argument = "foo".     InvocationResult<Integer> result = LambdaSafe.callback(GenericMultiArgFactory.class, callbackInstance, argument).invokeAnd((c) -> c.handle(1, argument, false)).     assertThat(result.hasResult()).isFalse(). }
false;public;0;10;;@Test public void callbacksInvokeWhenNoGenericShouldInvokeCallbacks() {     NonGenericCallback callbackInstance = mock(NonGenericCallback.class).     String argument = "foo".     LambdaSafe.callbacks(NonGenericCallback.class, Collections.singleton(callbackInstance), argument).invoke((c) -> c.handle(argument)).     verify(callbackInstance).handle(argument). }
false;public;0;10;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeWhenHasGenericShouldInvokeCallback() {     StringCallback callbackInstance = mock(StringCallback.class).     String argument = "foo".     LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument).invoke((c) -> c.handle(argument)).     verify(callbackInstance).handle(argument). }
false;public;0;10;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeWhenHasResolvableGenericMatchShouldInvokeCallback() {     StringBuilderCallback callbackInstance = mock(StringBuilderCallback.class).     StringBuilder argument = new StringBuilder("foo").     LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument).invoke((c) -> c.handle(argument)).     verify(callbackInstance).handle(argument). }
false;public;0;10;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeWhenHasResolvableGenericNonMatchShouldNotInvokeCallback() {     GenericCallback<?> callbackInstance = mock(StringBuilderCallback.class).     String argument = "foo".     LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument).invoke((c) -> c.handle(null)).     verifyZeroInteractions(callbackInstance). }
false;public;0;10;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeWhenLambdaMismatchShouldSwallowException() {     GenericCallback<StringBuilder> callbackInstance = (s) -> fail("Should not get here").     String argument = "foo".     LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument).invoke((c) -> c.handle(argument)). }
false;public;0;11;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeWhenLambdaMismatchOnDifferentArgumentShouldSwallowException() {     GenericMultiArgCallback<StringBuilder> callbackInstance = (n, s, b) -> fail("Should not get here").     String argument = "foo".     LambdaSafe.callbacks(GenericMultiArgCallback.class, Collections.singleton(callbackInstance), argument).invoke((c) -> c.handle(1, argument, false)). }
false;public;0;11;;@Test public void callbacksInvokeAndWhenNoGenericShouldReturnResult() {     NonGenericFactory callbackInstance = mock(NonGenericFactory.class).     String argument = "foo".     given(callbackInstance.handle("foo")).willReturn(123).     Stream<Integer> result = LambdaSafe.callbacks(NonGenericFactory.class, Collections.singleton(callbackInstance), argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result).containsExactly(123). }
false;public;0;11;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeAndWhenHasGenericShouldReturnResult() {     StringFactory callbackInstance = mock(StringFactory.class).     String argument = "foo".     given(callbackInstance.handle("foo")).willReturn(123).     Stream<Integer> result = LambdaSafe.callbacks(GenericFactory.class, Collections.singleton(callbackInstance), argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result).containsExactly(123). }
false;public;0;11;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeAndWhenReturnNullShouldReturnResult() {     StringFactory callbackInstance = mock(StringFactory.class).     String argument = "foo".     given(callbackInstance.handle("foo")).willReturn(null).     Stream<Integer> result = LambdaSafe.callbacks(GenericFactory.class, Collections.singleton(callbackInstance), argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result).containsExactly((Integer) null). }
false;public;0;11;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeAndWhenHasResolvableGenericMatchShouldReturnResult() {     StringBuilderFactory callbackInstance = mock(StringBuilderFactory.class).     StringBuilder argument = new StringBuilder("foo").     given(callbackInstance.handle(any(StringBuilder.class))).willReturn(123).     Stream<Integer> result = LambdaSafe.callbacks(GenericFactory.class, Collections.singleton(callbackInstance), argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result).containsExactly(123). }
false;public;0;10;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeAndWhenHasResolvableGenericNonMatchShouldReturnNoResult() {     GenericFactory<?> callbackInstance = mock(StringBuilderFactory.class).     String argument = "foo".     Stream<Integer> result = LambdaSafe.callbacks(GenericFactory.class, Collections.singleton(callbackInstance), argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result).isEmpty(). }
false;public;0;13;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeAndWhenLambdaMismatchShouldSwallowException() {     GenericFactory<StringBuilder> callbackInstance = (s) -> {         fail("Should not get here").         return 123.     }.     String argument = "foo".     Stream<Integer> result = LambdaSafe.callbacks(GenericFactory.class, Collections.singleton(callbackInstance), argument).invokeAnd((c) -> (c).handle(argument)).     assertThat(result).isEmpty(). }
false;public;0;14;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeAndWhenLambdaMismatchOnDifferentArgumentShouldSwallowException() {     GenericMultiArgFactory<StringBuilder> callbackInstance = (n, s, b) -> {         fail("Should not get here").         return 123.     }.     String argument = "foo".     Stream<Integer> result = LambdaSafe.callbacks(GenericMultiArgFactory.class, Collections.singleton(callbackInstance), argument).invokeAnd((c) -> c.handle(1, argument, false)).     assertThat(result).isEmpty(). }
false;public;0;22;;@Test @SuppressWarnings("unchecked") public void callbacksInvokeWhenMultipleShouldInvokeSuitable() {     List<GenericFactory<?>> callbackInstances = new ArrayList<>().     GenericFactory<String> callback1 = (s) -> 1.     GenericFactory<CharSequence> callback2 = (s) -> 2.     GenericFactory<StringBuilder> callback3 = (s) -> 3.     StringFactory callback4 = mock(StringFactory.class).     given(callback4.handle(any(String.class))).willReturn(4).     StringBuilderFactory callback5 = mock(StringBuilderFactory.class).     given(callback5.handle(any(StringBuilder.class))).willReturn(5).     callbackInstances.add(callback1).     callbackInstances.add(callback2).     callbackInstances.add(callback3).     callbackInstances.add(callback4).     callbackInstances.add(callback5).     String argument = "foo".     Stream<Integer> result = LambdaSafe.callbacks(GenericFactory.class, callbackInstances, argument).invokeAnd((c) -> c.handle(argument)).     assertThat(result).containsExactly(1, 2, 4). }
false;public;0;9;;@Test @SuppressWarnings("unchecked") public void callbackWithFilterShouldUseFilter() {     GenericCallback<?> callbackInstance = mock(StringBuilderCallback.class).     String argument = "foo".     LambdaSafe.callback(GenericCallback.class, callbackInstance, argument).withFilter(Filter.allowAll()).invoke((c) -> c.handle(null)).     verify(callbackInstance).handle(null). }
false;public;0;13;;@Test @SuppressWarnings("unchecked") public void callbackWithLoggerShouldUseLogger() {     Log logger = mock(Log.class).     given(logger.isDebugEnabled()).willReturn(true).     GenericCallback<StringBuilder> callbackInstance = (s) -> fail("Should not get here").     String argument = "foo".     LambdaSafe.callback(GenericCallback.class, callbackInstance, argument).withLogger(logger).invoke((c) -> c.handle(argument)).     verify(logger).debug(contains("Non-matching CharSequence type for callback " + "LambdaSafeTests.GenericCallback"), any(Throwable.class)). }
false;;1;1;;void handle(String argument).
false;;1;1;;void handle(T argument).
false;;3;1;;void handle(Integer number, T argument, Boolean bool).
false;;1;1;;Integer handle(String argument).
false;;1;1;;Integer handle(T argument).
false;;3;1;;Integer handle(Integer number, T argument, Boolean bool).
