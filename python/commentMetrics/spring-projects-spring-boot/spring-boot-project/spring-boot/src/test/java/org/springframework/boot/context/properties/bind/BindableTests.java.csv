commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Test public void ofClassWhenTypeIsNullShouldThrowException() {     assertThatIllegalArgumentException().isThrownBy(() -> Bindable.of((Class<?>) null)).withMessageContaining("Type must not be null"). }
false;public;0;6;;@Test public void ofTypeWhenTypeIsNullShouldThrowException() {     assertThatIllegalArgumentException().isThrownBy(() -> Bindable.of((ResolvableType) null)).withMessageContaining("Type must not be null"). }
false;public;0;5;;@Test public void ofClassShouldSetType() {     assertThat(Bindable.of(String.class).getType()).isEqualTo(ResolvableType.forClass(String.class)). }
false;public;0;5;;@Test public void ofTypeShouldSetType() {     ResolvableType type = ResolvableType.forClass(String.class).     assertThat(Bindable.of(type).getType()).isEqualTo(type). }
false;public;0;7;;@Test public void ofInstanceShouldSetTypeAndExistingValue() {     String instance = "foo".     ResolvableType type = ResolvableType.forClass(String.class).     assertThat(Bindable.ofInstance(instance).getType()).isEqualTo(type).     assertThat(Bindable.ofInstance(instance).getValue().get()).isEqualTo("foo"). }
false;public;0;5;;@Test public void ofClassWithExistingValueShouldSetTypeAndExistingValue() {     assertThat(Bindable.of(String.class).withExistingValue("foo").getValue().get()).isEqualTo("foo"). }
false;public;0;5;;@Test public void ofTypeWithExistingValueShouldSetTypeAndExistingValue() {     assertThat(Bindable.of(ResolvableType.forClass(String.class)).withExistingValue("foo").getValue().get()).isEqualTo("foo"). }
false;public;0;8;;@Test public void ofTypeWhenExistingValueIsNotInstanceOfTypeShouldThrowException() {     assertThatIllegalArgumentException().isThrownBy(() -> Bindable.of(ResolvableType.forClass(String.class)).withExistingValue(123)).withMessageContaining("ExistingValue must be an instance of " + String.class.getName()). }
false;public;0;7;;@Test public void ofTypeWhenPrimitiveWithExistingValueWrapperShouldNotThrowException() {     Bindable<Integer> bindable = Bindable.<Integer>of(ResolvableType.forClass(int.class)).withExistingValue(123).     assertThat(bindable.getType().resolve()).isEqualTo(int.class).     assertThat(bindable.getValue().get()).isEqualTo(123). }
false;public;0;6;;@Test public void getBoxedTypeWhenNotBoxedShouldReturnType() {     Bindable<String> bindable = Bindable.of(String.class).     assertThat(bindable.getBoxedType()).isEqualTo(ResolvableType.forClass(String.class)). }
false;public;0;7;;@Test public void getBoxedTypeWhenPrimitiveShouldReturnBoxedType() {     Bindable<Integer> bindable = Bindable.of(int.class).     assertThat(bindable.getType()).isEqualTo(ResolvableType.forClass(int.class)).     assertThat(bindable.getBoxedType()).isEqualTo(ResolvableType.forClass(Integer.class)). }
false;public;0;9;;@Test public void getBoxedTypeWhenPrimitiveArrayShouldReturnBoxedType() {     Bindable<int[]> bindable = Bindable.of(int[].class).     assertThat(bindable.getType().getComponentType()).isEqualTo(ResolvableType.forClass(int.class)).     assertThat(bindable.getBoxedType().isArray()).isTrue().     assertThat(bindable.getBoxedType().getComponentType()).isEqualTo(ResolvableType.forClass(Integer.class)). }
false;public;0;4;;@Test public void getAnnotationsShouldReturnEmptyArray() {     assertThat(Bindable.of(String.class).getAnnotations()).isEmpty(). }
false;public;0;6;;@Test public void withAnnotationsShouldSetAnnotations() {     Annotation annotation = mock(Annotation.class).     assertThat(Bindable.of(String.class).withAnnotations(annotation).getAnnotations()).containsExactly(annotation). }
false;public;0;6;;@Test public void getAnnotationWhenMatchShouldReturnAnnotation() {     Test annotation = AnnotationUtils.synthesizeAnnotation(Test.class).     assertThat(Bindable.of(String.class).withAnnotations(annotation).getAnnotation(Test.class)).isSameAs(annotation). }
false;public;0;6;;@Test public void getAnnotationWhenNoMatchShouldReturnNull() {     Test annotation = AnnotationUtils.synthesizeAnnotation(Test.class).     assertThat(Bindable.of(String.class).withAnnotations(annotation).getAnnotation(Bean.class)).isNull(). }
false;public;0;12;;@Test public void toStringShouldShowDetails() {     Annotation annotation = AnnotationUtils.synthesizeAnnotation(TestAnnotation.class).     Bindable<String> bindable = Bindable.of(String.class).withExistingValue("foo").withAnnotations(annotation).     System.out.println(bindable.toString()).     assertThat(bindable.toString()).contains("type = java.lang.String, " + "value = 'provided', annotations = array<Annotation>[" + "@org.springframework.boot.context.properties.bind." + "BindableTests$TestAnnotation()]"). }
false;public;0;14;;@Test public void equalsAndHashCode() {     Annotation annotation = AnnotationUtils.synthesizeAnnotation(TestAnnotation.class).     Bindable<String> bindable1 = Bindable.of(String.class).withExistingValue("foo").withAnnotations(annotation).     Bindable<String> bindable2 = Bindable.of(String.class).withExistingValue("foo").withAnnotations(annotation).     Bindable<String> bindable3 = Bindable.of(String.class).withExistingValue("fof").withAnnotations(annotation).     assertThat(bindable1.hashCode()).isEqualTo(bindable2.hashCode()).     assertThat(bindable1).isEqualTo(bindable1).isEqualTo(bindable2).     assertThat(bindable1).isEqualTo(bindable3). }
false;public;0;3;;public String getFoo() {     return this.foo. }
false;public;1;3;;public void setFoo(String foo) {     this.foo = foo. }
false;public;0;3;;public String getFoo() {     return this.foo. }
false;public;1;3;;public void setFoo(String foo) {     this.foo = foo. }
