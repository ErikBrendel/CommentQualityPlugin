commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Test public void notAnError() throws Exception {     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.chain.getRequest()).isEqualTo(this.request).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response).     assertThat(this.response.isCommitted()).isTrue().     assertThat(this.response.getForwardedUrl()).isNull(). }
false;public;0;14;;@Test public void notAnErrorButNotOK() throws Exception {     this.chain = new TestFilterChain((request, response, chain) -> {         response.setStatus(201).         chain.call().         response.flushBuffer().     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(((HttpServletResponse) this.chain.getResponse()).getStatus()).isEqualTo(201).     assertThat(((HttpServletResponse) ((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).getStatus()).isEqualTo(201).     assertThat(this.response.isCommitted()).isTrue(). }
false;public;0;16;;@Test public void unauthorizedWithErrorPath() throws Exception {     this.filter.addErrorPages(new ErrorPage("/error")).     this.chain = new TestFilterChain((request, response, chain) -> response.sendError(401, "UNAUTHORIZED")).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.chain.getRequest()).isEqualTo(this.request).     HttpServletResponseWrapper wrapper = (HttpServletResponseWrapper) this.chain.getResponse().     assertThat(wrapper.getResponse()).isEqualTo(this.response).     assertThat(this.response.isCommitted()).isTrue().     assertThat(wrapper.getStatus()).isEqualTo(401).     // The real response has to be 401 as well...     assertThat(this.response.getStatus()).isEqualTo(401).     assertThat(this.response.getForwardedUrl()).isEqualTo("/error"). }
false;public;0;15;;@Test public void responseCommitted() throws Exception {     this.filter.addErrorPages(new ErrorPage("/error")).     this.response.setCommitted(true).     this.chain = new TestFilterChain((request, response, chain) -> response.sendError(400, "BAD")).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.chain.getRequest()).isEqualTo(this.request).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(400).     assertThat(this.response.getForwardedUrl()).isNull().     assertThat(this.response.isCommitted()).isTrue(). }
false;public;0;12;;@Test public void responseCommittedWhenFromClientAbortException() throws Exception {     this.filter.addErrorPages(new ErrorPage("/error")).     this.response.setCommitted(true).     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         throw new ClientAbortException().     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.response.isCommitted()).isTrue().     assertThat(this.output.toString()).doesNotContain("Cannot forward"). }
false;public;0;13;;@Test public void responseUncommittedWithoutErrorPage() throws Exception {     this.chain = new TestFilterChain((request, response, chain) -> response.sendError(400, "BAD")).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.chain.getRequest()).isEqualTo(this.request).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(400).     assertThat(this.response.getForwardedUrl()).isNull().     assertThat(this.response.isCommitted()).isTrue(). }
false;public;0;9;;@Test public void oncePerRequest() throws Exception {     this.chain = new TestFilterChain((request, response, chain) -> {         response.sendError(400, "BAD").         assertThat(request.getAttribute("FILTER.FILTERED")).isNotNull().     }).     this.filter.init(new MockFilterConfig("FILTER")).     this.filter.doFilter(this.request, this.response, this.chain). }
false;public;0;17;;@Test public void globalError() throws Exception {     this.filter.addErrorPages(new ErrorPage("/error")).     this.chain = new TestFilterChain((request, response, chain) -> response.sendError(400, "BAD")).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(400).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(400).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).isEqualTo("BAD").     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo("/test/path").     assertThat(this.response.isCommitted()).isTrue().     assertThat(this.response.getForwardedUrl()).isEqualTo("/error"). }
false;public;0;17;;@Test public void statusError() throws Exception {     this.filter.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400")).     this.chain = new TestFilterChain((request, response, chain) -> response.sendError(400, "BAD")).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(400).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(400).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).isEqualTo("BAD").     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo("/test/path").     assertThat(this.response.isCommitted()).isTrue().     assertThat(this.response.getForwardedUrl()).isEqualTo("/400"). }
false;public;0;13;;@Test public void statusErrorWithCommittedResponse() throws Exception {     this.filter.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400")).     this.chain = new TestFilterChain((request, response, chain) -> {         response.sendError(400, "BAD").         response.flushBuffer().     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(400).     assertThat(this.response.isCommitted()).isTrue().     assertThat(this.response.getForwardedUrl()).isNull(). }
false;public;0;27;;@Test public void exceptionError() throws Exception {     this.filter.addErrorPages(new ErrorPage(RuntimeException.class, "/500")).     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         throw new RuntimeException("BAD").     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(500).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(500).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).isEqualTo("BAD").     Map<String, Object> requestAttributes = getAttributesForDispatch("/500").     assertThat(requestAttributes.get(RequestDispatcher.ERROR_EXCEPTION_TYPE)).isEqualTo(RuntimeException.class).     assertThat(requestAttributes.get(RequestDispatcher.ERROR_EXCEPTION)).isInstanceOf(RuntimeException.class).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE)).isNull().     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION)).isNull().     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo("/test/path").     assertThat(this.response.isCommitted()).isTrue().     assertThat(this.response.getForwardedUrl()).isEqualTo("/500"). }
false;public;0;11;;@Test public void exceptionErrorWithCommittedResponse() throws Exception {     this.filter.addErrorPages(new ErrorPage(RuntimeException.class, "/500")).     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         response.flushBuffer().         throw new RuntimeException("BAD").     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.response.getForwardedUrl()).isNull(). }
false;public;0;8;;@Test public void statusCode() throws Exception {     this.chain = new TestFilterChain((request, response, chain) -> assertThat(response.getStatus()).isEqualTo(200)).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(200). }
false;public;0;26;;@Test public void subClassExceptionError() throws Exception {     this.filter.addErrorPages(new ErrorPage(RuntimeException.class, "/500")).     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         throw new IllegalStateException("BAD").     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(500).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(500).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).isEqualTo("BAD").     Map<String, Object> requestAttributes = getAttributesForDispatch("/500").     assertThat(requestAttributes.get(RequestDispatcher.ERROR_EXCEPTION_TYPE)).isEqualTo(IllegalStateException.class).     assertThat(requestAttributes.get(RequestDispatcher.ERROR_EXCEPTION)).isInstanceOf(IllegalStateException.class).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE)).isNull().     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION)).isNull().     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo("/test/path").     assertThat(this.response.isCommitted()).isTrue(). }
false;public;0;9;;@Test public void responseIsNotCommittedWhenRequestIsAsync() throws Exception {     this.request.setAsyncStarted(true).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.chain.getRequest()).isEqualTo(this.request).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response).     assertThat(this.response.isCommitted()).isFalse(). }
false;public;0;15;;@Test public void responseIsCommittedWhenRequestIsAsyncAndExceptionIsThrown() throws Exception {     this.filter.addErrorPages(new ErrorPage("/error")).     this.request.setAsyncStarted(true).     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         throw new RuntimeException("BAD").     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.chain.getRequest()).isEqualTo(this.request).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response).     assertThat(this.response.isCommitted()).isTrue(). }
false;public;0;15;;@Test public void responseIsCommittedWhenRequestIsAsyncAndStatusIs400Plus() throws Exception {     this.filter.addErrorPages(new ErrorPage("/error")).     this.request.setAsyncStarted(true).     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         response.sendError(400, "BAD").     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.chain.getRequest()).isEqualTo(this.request).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response).     assertThat(this.response.isCommitted()).isTrue(). }
false;public;0;9;;@Test public void responseIsNotCommittedDuringAsyncDispatch() throws Exception {     setUpAsyncDispatch().     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.chain.getRequest()).isEqualTo(this.request).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response).     assertThat(this.response.isCommitted()).isFalse(). }
false;public;0;15;;@Test public void responseIsCommittedWhenExceptionIsThrownDuringAsyncDispatch() throws Exception {     this.filter.addErrorPages(new ErrorPage("/error")).     setUpAsyncDispatch().     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         throw new RuntimeException("BAD").     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.chain.getRequest()).isEqualTo(this.request).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response).     assertThat(this.response.isCommitted()).isTrue(). }
false;public;0;15;;@Test public void responseIsCommittedWhenStatusIs400PlusDuringAsyncDispatch() throws Exception {     this.filter.addErrorPages(new ErrorPage("/error")).     setUpAsyncDispatch().     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         response.sendError(400, "BAD").     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.chain.getRequest()).isEqualTo(this.request).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()).isEqualTo(this.response).     assertThat(this.response.isCommitted()).isTrue(). }
false;public;0;9;;@Test public void responseIsNotFlushedIfStatusIsLessThan400AndItHasAlreadyBeenCommitted() throws Exception {     HttpServletResponse committedResponse = mock(HttpServletResponse.class).     given(committedResponse.isCommitted()).willReturn(true).     given(committedResponse.getStatus()).willReturn(200).     this.filter.doFilter(this.request, committedResponse, this.chain).     verify(committedResponse, never()).flushBuffer(). }
false;public;0;12;;@Test public void errorMessageForRequestWithoutPathInfo() throws IOException, ServletException {     this.request.setServletPath("/test").     this.filter.addErrorPages(new ErrorPage("/error")).     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         throw new RuntimeException().     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.output.toString()).contains("request [/test]"). }
false;public;0;13;;@Test public void errorMessageForRequestWithPathInfo() throws IOException, ServletException {     this.request.setServletPath("/test").     this.request.setPathInfo("/alpha").     this.filter.addErrorPages(new ErrorPage("/error")).     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         throw new RuntimeException().     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.output.toString()).contains("request [/test/alpha]"). }
false;public;0;27;;@Test public void nestedServletExceptionIsUnwrapped() throws Exception {     this.filter.addErrorPages(new ErrorPage(RuntimeException.class, "/500")).     this.chain = new TestFilterChain((request, response, chain) -> {         chain.call().         throw new NestedServletException("Wrapper", new RuntimeException("BAD")).     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus()).isEqualTo(500).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE)).isEqualTo(500).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_MESSAGE)).isEqualTo("BAD").     Map<String, Object> requestAttributes = getAttributesForDispatch("/500").     assertThat(requestAttributes.get(RequestDispatcher.ERROR_EXCEPTION_TYPE)).isEqualTo(RuntimeException.class).     assertThat(requestAttributes.get(RequestDispatcher.ERROR_EXCEPTION)).isInstanceOf(RuntimeException.class).     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE)).isNull().     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_EXCEPTION)).isNull().     assertThat(this.request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI)).isEqualTo("/test/path").     assertThat(this.response.isCommitted()).isTrue().     assertThat(this.response.getForwardedUrl()).isEqualTo("/500"). }
false;public;0;10;;@Test public void whenErrorIsSentAndWriterIsFlushedErrorIsSentToTheClient() throws Exception {     this.chain = new TestFilterChain((request, response, chain) -> {         response.sendError(400).         response.getWriter().flush().     }).     this.filter.doFilter(this.request, this.response, this.chain).     assertThat(this.response.getStatus()).isEqualTo(400). }
false;private;0;9;;private void setUpAsyncDispatch() throws Exception {     this.request.setAsyncSupported(true).     this.request.setAsyncStarted(true).     DeferredResult<String> result = new DeferredResult<>().     WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(this.request).     asyncManager.setAsyncWebRequest(new StandardServletAsyncWebRequest(this.request, this.response)).     asyncManager.startDeferredResultProcessing(result). }
false;private;1;3;;private Map<String, Object> getAttributesForDispatch(String path) {     return this.request.getDispatcher(path).getRequestAttributes(). }
false;public;2;13;;@Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {     AtomicBoolean called = new AtomicBoolean().     Chain chain = () -> {         if (called.compareAndSet(false, true)) {             super.doFilter(request, response).         }     }.     this.handler.handle((HttpServletRequest) request, (HttpServletResponse) response, chain).     chain.call(). }
false;;3;2;;void handle(HttpServletRequest request, HttpServletResponse response, Chain chain) throws IOException, ServletException.
false;;0;1;;void call() throws IOException, ServletException.
false;public;1;7;;@Override public RequestDispatcher getRequestDispatcher(String path) {     AttributeCapturingRequestDispatcher dispatcher = new AttributeCapturingRequestDispatcher(path).     this.dispatchers.put(path, dispatcher).     return dispatcher. }
false;private;1;3;;private AttributeCapturingRequestDispatcher getDispatcher(String path) {     return this.dispatchers.get(path). }
false;public;2;5;;@Override public void forward(ServletRequest request, ServletResponse response) {     captureAttributes(request).     super.forward(request, response). }
false;private;1;7;;private void captureAttributes(ServletRequest request) {     Enumeration<String> names = request.getAttributeNames().     while (names.hasMoreElements()) {         String name = names.nextElement().         this.requestAttributes.put(name, request.getAttribute(name)).     } }
false;private;0;3;;private Map<String, Object> getRequestAttributes() {     return this.requestAttributes. }
