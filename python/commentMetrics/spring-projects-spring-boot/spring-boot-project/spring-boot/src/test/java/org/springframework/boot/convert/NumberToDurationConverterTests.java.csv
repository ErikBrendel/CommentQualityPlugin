commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Test public void convertWhenSimpleWithoutSuffixShouldReturnDuration() {     assertThat(convert(10)).isEqualTo(Duration.ofMillis(10)).     assertThat(convert(+10)).isEqualTo(Duration.ofMillis(10)).     assertThat(convert(-10)).isEqualTo(Duration.ofMillis(-10)). }
false;public;0;6;;@Test public void convertWhenSimpleWithoutSuffixButWithAnnotationShouldReturnDuration() {     assertThat(convert(10, ChronoUnit.SECONDS)).isEqualTo(Duration.ofSeconds(10)).     assertThat(convert(+10, ChronoUnit.SECONDS)).isEqualTo(Duration.ofSeconds(10)).     assertThat(convert(-10, ChronoUnit.SECONDS)).isEqualTo(Duration.ofSeconds(-10)). }
false;private;1;3;;private Duration convert(Integer source) {     return this.conversionService.convert(source, Duration.class). }
false;private;2;14;;@SuppressWarnings({ "rawtypes", "unchecked" }) private Duration convert(Integer source, ChronoUnit defaultUnit) {     TypeDescriptor targetType = mock(TypeDescriptor.class).     if (defaultUnit != null) {         DurationUnit unitAnnotation = AnnotationUtils.synthesizeAnnotation(Collections.singletonMap("value", defaultUnit), DurationUnit.class, null).         given(targetType.getAnnotation(DurationUnit.class)).willReturn(unitAnnotation).     }     given(targetType.getType()).willReturn((Class) Duration.class).     return (Duration) this.conversionService.convert(source, TypeDescriptor.forObject(source), targetType). }
false;public,static;0;4;;@Parameters(name = "{0}") public static Iterable<Object[]> conversionServices() {     return new ConversionServiceParameters(new NumberToDurationConverter()). }
