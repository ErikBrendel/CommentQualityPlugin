commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Test public void createWhenPropertySourceIsNullShouldThrowException() {     assertThatIllegalArgumentException().isThrownBy(() -> new SpringConfigurationPropertySource(null, mock(PropertyMapper.class), null)).withMessageContaining("PropertySource must not be null"). }
false;public;0;7;;@Test public void createWhenMapperIsNullShouldThrowException() {     assertThatIllegalArgumentException().isThrownBy(() -> new SpringConfigurationPropertySource(mock(PropertySource.class), null, null)).withMessageContaining("Mapper must not be null"). }
false;public;0;14;;@Test public void getValueShouldUseDirectMapping() {     Map<String, Object> source = new LinkedHashMap<>().     source.put("key1", "value1").     source.put("key2", "value2").     source.put("key3", "value3").     PropertySource<?> propertySource = new MapPropertySource("test", source).     TestPropertyMapper mapper = new TestPropertyMapper().     ConfigurationPropertyName name = ConfigurationPropertyName.of("my.key").     mapper.addFromConfigurationProperty(name, "key2").     SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource, mapper, null).     assertThat(adapter.getConfigurationProperty(name).getValue()).isEqualTo("value2"). }
false;public;0;13;;@Test public void getValueOrigin() {     Map<String, Object> source = new LinkedHashMap<>().     source.put("key", "value").     PropertySource<?> propertySource = new MapPropertySource("test", source).     TestPropertyMapper mapper = new TestPropertyMapper().     ConfigurationPropertyName name = ConfigurationPropertyName.of("my.key").     mapper.addFromConfigurationProperty(name, "key").     SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource, mapper, null).     assertThat(adapter.getConfigurationProperty(name).getOrigin().toString()).isEqualTo("\"key\" from property source \"test\""). }
false;public;0;14;;@Test public void getValueWhenOriginCapableShouldIncludeSourceOrigin() {     Map<String, Object> source = new LinkedHashMap<>().     source.put("key", "value").     PropertySource<?> propertySource = new OriginCapablePropertySource<>(new MapPropertySource("test", source)).     TestPropertyMapper mapper = new TestPropertyMapper().     ConfigurationPropertyName name = ConfigurationPropertyName.of("my.key").     mapper.addFromConfigurationProperty(name, "key").     SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource, mapper, null).     assertThat(adapter.getConfigurationProperty(name).getOrigin().toString()).isEqualTo("TestOrigin key"). }
false;public;0;10;;@Test public void containsDescendantOfShouldReturnEmpty() {     Map<String, Object> source = new LinkedHashMap<>().     source.put("foo.bar", "value").     PropertySource<?> propertySource = new MapPropertySource("test", source).     SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource, DefaultPropertyMapper.INSTANCE, null).     assertThat(adapter.containsDescendantOf(ConfigurationPropertyName.of("foo"))).isEqualTo(ConfigurationPropertyState.UNKNOWN). }
false;public;0;6;;@Test public void fromWhenPropertySourceIsNullShouldThrowException() {     assertThatIllegalArgumentException().isThrownBy(() -> SpringConfigurationPropertySource.from(null)).withMessageContaining("Source must not be null"). }
false;public;1;4;;@Override public Object getProperty(String name) {     return null. }
false;public;0;15;;@Test public void fromWhenNonEnumerableShouldReturnNonIterable() {     PropertySource<?> propertySource = new PropertySource<Object>("test", new Object()) {          @Override         public Object getProperty(String name) {             return null.         }     }.     assertThat(SpringConfigurationPropertySource.from(propertySource)).isNotInstanceOf(IterableConfigurationPropertySource.class). }
false;public;0;4;;@Override public int size() {     throw new UnsupportedOperationException("Same as security restricted"). }
false;public;0;14;;@Test public void fromWhenEnumerableButRestrictedShouldReturnNonIterable() {     Map<String, Object> source = new LinkedHashMap<String, Object>() {          @Override         public int size() {             throw new UnsupportedOperationException("Same as security restricted").         }     }.     PropertySource<?> propertySource = new MapPropertySource("test", source).     assertThat(SpringConfigurationPropertySource.from(propertySource)).isNotInstanceOf(IterableConfigurationPropertySource.class). }
false;public;0;9;;@Test public void getWhenEnumerableShouldBeIterable() {     Map<String, Object> source = new LinkedHashMap<>().     source.put("fooBar", "Spring ${barBaz} ${bar-baz}").     source.put("barBaz", "Boot").     PropertySource<?> propertySource = new MapPropertySource("test", source).     assertThat(SpringConfigurationPropertySource.from(propertySource)).isInstanceOf(IterableConfigurationPropertySource.class). }
false;public;1;4;;@Override public Object getProperty(String name) {     return this.propertySource.getProperty(name). }
false;public;0;4;;@Override public String toString() {     return "TestOrigin " + name. }
false;public;1;11;;@Override public Origin getOrigin(String name) {     return new Origin() {          @Override         public String toString() {             return "TestOrigin " + name.         }     }. }
