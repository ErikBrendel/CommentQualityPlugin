commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Test public void canConvertFromStringToArrayShouldReturnTrue() {     assertThat(this.conversionService.canConvert(String.class, String[].class)).isTrue(). }
false;public;0;8;;@Test public void matchesWhenTargetIsNotAnnotatedShouldReturnTrue() {     TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class).     TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, "noAnnotation"), 0).     assertThat(new DelimitedStringToArrayConverter(this.conversionService).matches(sourceType, targetType)).isTrue(). }
false;public;0;10;;@Test public void matchesWhenHasAnnotationAndConvertibleElementTypeShouldReturnTrue() {     if (this.conversionService instanceof ApplicationConversionService) {         TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class).         TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, "convertibleElementType"), 0).         assertThat(new DelimitedStringToArrayConverter(this.conversionService).matches(sourceType, targetType)).isTrue().     } }
false;public;0;8;;@Test public void matchesWhenHasAnnotationAndNonConvertibleElementTypeShouldReturnFalse() {     TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class).     TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, "nonConvertibleElementType"), 0).     assertThat(new DelimitedStringToArrayConverter(this.conversionService).matches(sourceType, targetType)).isFalse(). }
false;public;0;11;;@Test public void convertWhenHasConvertibleElementTypeShouldReturnConvertedType() {     if (this.conversionService instanceof ApplicationConversionService) {         TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class).         TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, "convertibleElementType"), 0).         Integer[] converted = (Integer[]) this.conversionService.convert(" 1 |  2| 3  ", sourceType, targetType).         assertThat(converted).containsExactly(1, 2, 3).     } }
false;public;0;9;;@Test public void convertWhenHasDelimiterOfNoneShouldReturnWholeString() {     TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class).     TypeDescriptor targetType = TypeDescriptor.nested(ReflectionUtils.findField(Values.class, "delimiterNone"), 0).     String[] converted = (String[]) this.conversionService.convert("a,b,c", sourceType, targetType).     assertThat(converted).containsExactly("a,b,c"). }
false;public,static;0;5;;@Parameters(name = "{0}") public static Iterable<Object[]> conversionServices() {     return new ConversionServiceParameters(DelimitedStringToArrayConverterTests::addConverter). }
false;private,static;1;3;;private static void addConverter(FormattingConversionService service) {     service.addConverter(new DelimitedStringToArrayConverter(service)). }
