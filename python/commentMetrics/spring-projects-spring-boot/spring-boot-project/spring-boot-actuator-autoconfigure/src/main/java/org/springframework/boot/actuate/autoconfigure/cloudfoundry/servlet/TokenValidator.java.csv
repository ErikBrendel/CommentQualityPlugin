commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;public void validate(Token token) {     validateAlgorithm(token).     validateKeyIdAndSignature(token).     validateExpiry(token).     validateIssuer(token).     validateAudience(token). }
false;private;1;12;;private void validateAlgorithm(Token token) {     String algorithm = token.getSignatureAlgorithm().     if (algorithm == null) {         throw new CloudFoundryAuthorizationException(Reason.INVALID_SIGNATURE, "Signing algorithm cannot be null").     }     if (!algorithm.equals("RS256")) {         throw new CloudFoundryAuthorizationException(Reason.UNSUPPORTED_TOKEN_SIGNING_ALGORITHM, "Signing algorithm " + algorithm + " not supported").     } }
false;private;1;15;;private void validateKeyIdAndSignature(Token token) {     String keyId = token.getKeyId().     if (this.tokenKeys == null || !hasValidKeyId(keyId)) {         this.tokenKeys = this.securityService.fetchTokenKeys().         if (!hasValidKeyId(keyId)) {             throw new CloudFoundryAuthorizationException(Reason.INVALID_KEY_ID, "Key Id present in token header does not match").         }     }     if (!hasValidSignature(token, this.tokenKeys.get(keyId))) {         throw new CloudFoundryAuthorizationException(Reason.INVALID_SIGNATURE, "RSA Signature did not match content").     } }
false;private;1;3;;private boolean hasValidKeyId(String tokenKey) {     return this.tokenKeys.containsKey(tokenKey). }
false;private;2;12;;private boolean hasValidSignature(Token token, String key) {     try {         PublicKey publicKey = getPublicKey(key).         Signature signature = Signature.getInstance("SHA256withRSA").         signature.initVerify(publicKey).         signature.update(token.getContent()).         return signature.verify(token.getSignature()).     } catch (GeneralSecurityException ex) {         return false.     } }
false;private;1;9;;private PublicKey getPublicKey(String key) throws NoSuchAlgorithmException, InvalidKeySpecException {     key = key.replace("-----BEGIN PUBLIC KEY-----\n", "").     key = key.replace("-----END PUBLIC KEY-----", "").     key = key.trim().replace("\n", "").     byte[] bytes = Base64Utils.decodeFromString(key).     X509EncodedKeySpec keySpec = new X509EncodedKeySpec(bytes).     return KeyFactory.getInstance("RSA").generatePublic(keySpec). }
false;private;1;7;;private void validateExpiry(Token token) {     long currentTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis()).     if (currentTime > token.getExpiry()) {         throw new CloudFoundryAuthorizationException(Reason.TOKEN_EXPIRED, "Token expired").     } }
false;private;1;8;;private void validateIssuer(Token token) {     String uaaUrl = this.securityService.getUaaUrl().     String issuerUri = String.format("%s/oauth/token", uaaUrl).     if (!issuerUri.equals(token.getIssuer())) {         throw new CloudFoundryAuthorizationException(Reason.INVALID_ISSUER, "Token issuer does not match " + uaaUrl + "/oauth/token").     } }
false;private;1;7;;private void validateAudience(Token token) {     if (!token.getScope().contains("actuator.read")) {         throw new CloudFoundryAuthorizationException(Reason.INVALID_AUDIENCE, "Token does not have audience actuator").     } }
