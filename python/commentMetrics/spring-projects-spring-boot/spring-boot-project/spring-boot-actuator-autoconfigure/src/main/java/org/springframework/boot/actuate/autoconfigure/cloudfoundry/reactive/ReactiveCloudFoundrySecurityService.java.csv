commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;protected ReactorClientHttpConnector buildTrustAllSslConnector() {     HttpClient client = HttpClient.create().secure((sslContextSpec) -> sslContextSpec.sslContext(createSslContext())).     return new ReactorClientHttpConnector(client). }
false;private;0;4;;private SslContextBuilder createSslContext() {     return SslContextBuilder.forClient().sslProvider(SslProvider.JDK).trustManager(InsecureTrustManagerFactory.INSTANCE). }
true;public;2;7;/**  * Return a Mono of the access level that should be granted to the given token.  * @param token the token  * @param applicationId the cloud foundry application ID  * @return a Mono of the access level that should be granted  * @throws CloudFoundryAuthorizationException if the token is not authorized  */ ;/**  * Return a Mono of the access level that should be granted to the given token.  * @param token the token  * @param applicationId the cloud foundry application ID  * @return a Mono of the access level that should be granted  * @throws CloudFoundryAuthorizationException if the token is not authorized  */ public Mono<AccessLevel> getAccessLevel(String token, String applicationId) throws CloudFoundryAuthorizationException {     String uri = getPermissionsUri(applicationId).     return this.webClient.get().uri(uri).header("Authorization", "bearer " + token).retrieve().bodyToMono(Map.class).map(this::getAccessLevel).onErrorMap(this::mapError). }
false;private;1;16;;private Throwable mapError(Throwable throwable) {     if (throwable instanceof WebClientResponseException) {         HttpStatus statusCode = ((WebClientResponseException) throwable).getStatusCode().         if (statusCode.equals(HttpStatus.FORBIDDEN)) {             return new CloudFoundryAuthorizationException(Reason.ACCESS_DENIED, "Access denied").         }         if (statusCode.is4xxClientError()) {             return new CloudFoundryAuthorizationException(Reason.INVALID_TOKEN, "Invalid token", throwable).         }     }     return new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, "Cloud controller not reachable"). }
false;private;1;6;;private AccessLevel getAccessLevel(Map<?, ?> body) {     if (Boolean.TRUE.equals(body.get("read_sensitive_data"))) {         return AccessLevel.FULL.     }     return AccessLevel.RESTRICTED. }
false;private;1;3;;private String getPermissionsUri(String applicationId) {     return this.cloudControllerUrl + "/v2/apps/" + applicationId + "/permissions". }
true;public;0;3;/**  * Return a Mono of all token keys known by the UAA.  * @return a Mono of token keys  */ ;/**  * Return a Mono of all token keys known by the UAA.  * @return a Mono of token keys  */ public Mono<Map<String, String>> fetchTokenKeys() {     return getUaaUrl().flatMap(this::fetchTokenKeys). }
false;private;1;6;;private Mono<? extends Map<String, String>> fetchTokenKeys(String url) {     RequestHeadersSpec<?> uri = this.webClient.get().uri(url + "/token_keys").     return uri.retrieve().bodyToMono(STRING_OBJECT_MAP).map(this::extractTokenKeys).onErrorMap(((ex) -> new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, ex.getMessage()))). }
false;private;1;8;;private Map<String, String> extractTokenKeys(Map<String, Object> response) {     Map<String, String> tokenKeys = new HashMap<>().     for (Object key : (List<?>) response.get("keys")) {         Map<?, ?> tokenKey = (Map<?, ?>) key.         tokenKeys.put((String) tokenKey.get("kid"), (String) tokenKey.get("value")).     }     return tokenKeys. }
true;public;0;9;/**  * Return a Mono of URL of the UAA.  * @return the UAA url Mono  */ ;/**  * Return a Mono of URL of the UAA.  * @return the UAA url Mono  */ public Mono<String> getUaaUrl() {     this.uaaUrl = this.webClient.get().uri(this.cloudControllerUrl + "/info").retrieve().bodyToMono(Map.class).map((response) -> (String) response.get("token_endpoint")).cache().onErrorMap((ex) -> new CloudFoundryAuthorizationException(Reason.SERVICE_UNAVAILABLE, "Unable to fetch token keys from UAA.")).     return this.uaaUrl. }
