commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;6;;@Override protected ReactiveWebOperation wrapReactiveWebOperation(ExposableWebEndpoint endpoint, WebOperation operation, ReactiveWebOperation reactiveWebOperation) {     return new SecureReactiveWebOperation(reactiveWebOperation, this.securityInterceptor, endpoint.getEndpointId()). }
false;protected;0;4;;@Override protected LinksHandler getLinksHandler() {     return new CloudFoundryLinksHandler(). }
false;public;1;18;;@Override public Publisher<ResponseEntity<Object>> links(ServerWebExchange exchange) {     ServerHttpRequest request = exchange.getRequest().     return CloudFoundryWebFluxEndpointHandlerMapping.this.securityInterceptor.preHandle(exchange, "").map((securityResponse) -> {         if (!securityResponse.getStatus().equals(HttpStatus.OK)) {             return new ResponseEntity<>(securityResponse.getStatus()).         }         AccessLevel accessLevel = exchange.getAttribute(AccessLevel.REQUEST_ATTRIBUTE).         Map<String, Link> links = CloudFoundryWebFluxEndpointHandlerMapping.this.linksResolver.resolveLinks(request.getURI().toString()).         return new ResponseEntity<>(Collections.singletonMap("_links", getAccessibleLinks(accessLevel, links)), HttpStatus.OK).     }). }
false;private;2;10;;private Map<String, Link> getAccessibleLinks(AccessLevel accessLevel, Map<String, Link> links) {     if (accessLevel == null) {         return new LinkedHashMap<>().     }     return links.entrySet().stream().filter((entry) -> entry.getKey().equals("self") || accessLevel.isAccessAllowed(entry.getKey())).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)). }
false;public;0;4;;@Override public String toString() {     return "Actuator root web endpoint". }
false;public;2;8;;@Override public Mono<ResponseEntity<Object>> handle(ServerWebExchange exchange, Map<String, String> body) {     return this.securityInterceptor.preHandle(exchange, this.endpointId.toLowerCaseString()).flatMap((securityResponse) -> flatMapResponse(exchange, body, securityResponse)). }
false;private;3;7;;private Mono<ResponseEntity<Object>> flatMapResponse(ServerWebExchange exchange, Map<String, String> body, SecurityResponse securityResponse) {     if (!securityResponse.getStatus().equals(HttpStatus.OK)) {         return Mono.just(new ResponseEntity<>(securityResponse.getStatus())).     }     return this.delegate.handle(exchange, body). }
