commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;public Mono<Void> validate(Token token) {     return validateAlgorithm(token).then(validateKeyIdAndSignature(token)).then(validateExpiry(token)).then(validateIssuer(token)).then(validateAudience(token)). }
false;private;1;13;;private Mono<Void> validateAlgorithm(Token token) {     String algorithm = token.getSignatureAlgorithm().     if (algorithm == null) {         return Mono.error(new CloudFoundryAuthorizationException(Reason.INVALID_SIGNATURE, "Signing algorithm cannot be null")).     }     if (!algorithm.equals("RS256")) {         return Mono.error(new CloudFoundryAuthorizationException(Reason.UNSUPPORTED_TOKEN_SIGNING_ALGORITHM, "Signing algorithm " + algorithm + " not supported")).     }     return Mono.empty(). }
false;private;1;6;;private Mono<Void> validateKeyIdAndSignature(Token token) {     return getTokenKey(token).filter((tokenKey) -> hasValidSignature(token, tokenKey)).switchIfEmpty(Mono.error(new CloudFoundryAuthorizationException(Reason.INVALID_SIGNATURE, "RSA Signature did not match content"))).then(). }
false;private;1;13;;private Mono<String> getTokenKey(Token token) {     String keyId = token.getKeyId().     String cached = this.cachedTokenKeys.get(keyId).     if (cached != null) {         return Mono.just(cached).     }     return this.securityService.fetchTokenKeys().doOnSuccess(this::cacheTokenKeys).filter((tokenKeys) -> tokenKeys.containsKey(keyId)).map((tokenKeys) -> tokenKeys.get(keyId)).switchIfEmpty(Mono.error(new CloudFoundryAuthorizationException(Reason.INVALID_KEY_ID, "Key Id present in token header does not match"))). }
false;private;1;3;;private void cacheTokenKeys(Map<String, String> tokenKeys) {     this.cachedTokenKeys = new ConcurrentHashMap<>(tokenKeys). }
false;private;2;12;;private boolean hasValidSignature(Token token, String key) {     try {         PublicKey publicKey = getPublicKey(key).         Signature signature = Signature.getInstance("SHA256withRSA").         signature.initVerify(publicKey).         signature.update(token.getContent()).         return signature.verify(token.getSignature()).     } catch (GeneralSecurityException ex) {         return false.     } }
false;private;1;9;;private PublicKey getPublicKey(String key) throws NoSuchAlgorithmException, InvalidKeySpecException {     key = key.replace("-----BEGIN PUBLIC KEY-----\n", "").     key = key.replace("-----END PUBLIC KEY-----", "").     key = key.trim().replace("\n", "").     byte[] bytes = Base64Utils.decodeFromString(key).     X509EncodedKeySpec keySpec = new X509EncodedKeySpec(bytes).     return KeyFactory.getInstance("RSA").generatePublic(keySpec). }
false;private;1;8;;private Mono<Void> validateExpiry(Token token) {     long currentTime = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis()).     if (currentTime > token.getExpiry()) {         return Mono.error(new CloudFoundryAuthorizationException(Reason.TOKEN_EXPIRED, "Token expired")).     }     return Mono.empty(). }
false;private;1;8;;private Mono<Void> validateIssuer(Token token) {     return this.securityService.getUaaUrl().map((uaaUrl) -> String.format("%s/oauth/token", uaaUrl)).filter((issuerUri) -> issuerUri.equals(token.getIssuer())).switchIfEmpty(Mono.error(new CloudFoundryAuthorizationException(Reason.INVALID_ISSUER, "Token issuer does not match"))).then(). }
false;private;1;7;;private Mono<Void> validateAudience(Token token) {     if (!token.getScope().contains("actuator.read")) {         return Mono.error(new CloudFoundryAuthorizationException(Reason.INVALID_AUDIENCE, "Token does not have audience actuator")).     }     return Mono.empty(). }
