commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void setup() {     MockitoAnnotations.initMocks(this).     this.url = "http://localhost:12345".     this.incomingData = new ByteArrayOutputStream().     this.incomingChannel = Channels.newChannel(this.incomingData). }
false;public;0;6;;@Test public void urlMustNotBeNull() {     assertThatIllegalArgumentException().isThrownBy(() -> new HttpTunnelConnection(null, this.requestFactory)).withMessageContaining("URL must not be empty"). }
false;public;0;6;;@Test public void urlMustNotBeEmpty() {     assertThatIllegalArgumentException().isThrownBy(() -> new HttpTunnelConnection("", this.requestFactory)).withMessageContaining("URL must not be empty"). }
false;public;0;6;;@Test public void urlMustNotBeMalformed() {     assertThatIllegalArgumentException().isThrownBy(() -> new HttpTunnelConnection("htttttp:///ttest", this.requestFactory)).withMessageContaining("Malformed URL 'htttttp:///ttest'"). }
false;public;0;6;;@Test public void requestFactoryMustNotBeNull() {     assertThatIllegalArgumentException().isThrownBy(() -> new HttpTunnelConnection(this.url, null)).withMessageContaining("RequestFactory must not be null"). }
false;public;0;8;;@Test public void closeTunnelChangesIsOpen() throws Exception {     this.requestFactory.willRespondAfterDelay(1000, HttpStatus.GONE).     WritableByteChannel channel = openTunnel(false).     assertThat(channel.isOpen()).isTrue().     channel.close().     assertThat(channel.isOpen()).isFalse(). }
false;public;0;9;;@Test public void closeTunnelCallsCloseableOnce() throws Exception {     this.requestFactory.willRespondAfterDelay(1000, HttpStatus.GONE).     WritableByteChannel channel = openTunnel(false).     verify(this.closeable, never()).close().     channel.close().     channel.close().     verify(this.closeable, times(1)).close(). }
false;public;0;9;;@Test public void typicalTraffic() throws Exception {     this.requestFactory.willRespond("hi", "=2", "=3").     TunnelChannel channel = openTunnel(true).     write(channel, "hello").     write(channel, "1+1").     write(channel, "1+2").     assertThat(this.incomingData.toString()).isEqualTo("hi=2=3"). }
false;public;0;11;;@Test public void trafficWithLongPollTimeouts() throws Exception {     for (int i = 0. i < 10. i++) {         this.requestFactory.willRespond(HttpStatus.NO_CONTENT).     }     this.requestFactory.willRespond("hi").     TunnelChannel channel = openTunnel(true).     write(channel, "hello").     assertThat(this.incomingData.toString()).isEqualTo("hi").     assertThat(this.requestFactory.getExecutedRequests().size()).isGreaterThan(10). }
false;public;0;8;;@Test public void connectFailureLogsWarning() throws Exception {     this.requestFactory.willRespond(new ConnectException()).     TunnelChannel tunnel = openTunnel(true).     assertThat(tunnel.isOpen()).isFalse().     this.outputCapture.expect(containsString("Failed to connect to remote application at http://localhost:12345")). }
false;private;2;3;;private void write(TunnelChannel channel, String string) throws IOException {     channel.write(ByteBuffer.wrap(string.getBytes())). }
false;private;1;5;;private TunnelChannel openTunnel(boolean singleThreaded) throws Exception {     HttpTunnelConnection connection = new HttpTunnelConnection(this.url, this.requestFactory, singleThreaded ? new CurrentThreadExecutor() : null).     return connection.open(this.incomingChannel, this.closeable). }
false;public;1;4;;@Override public void execute(Runnable command) {     command.run(). }
