commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Test public void listenPortMustNotBeNegative() {     assertThatIllegalArgumentException().isThrownBy(() -> new TunnelClient(-5, this.tunnelConnection)).withMessageContaining("ListenPort must be greater than or equal to 0"). }
false;public;0;5;;@Test public void tunnelConnectionMustNotBeNull() {     assertThatIllegalArgumentException().isThrownBy(() -> new TunnelClient(1, null)).withMessageContaining("TunnelConnection must not be null"). }
false;public;0;12;;@Test public void typicalTraffic() throws Exception {     TunnelClient client = new TunnelClient(0, this.tunnelConnection).     int port = client.start().     SocketChannel channel = SocketChannel.open(new InetSocketAddress(port)).     channel.write(ByteBuffer.wrap("hello".getBytes())).     ByteBuffer buffer = ByteBuffer.allocate(5).     channel.read(buffer).     channel.close().     this.tunnelConnection.verifyWritten("hello").     assertThat(new String(buffer.array())).isEqualTo("olleh"). }
false;public;0;12;;@Test public void socketChannelClosedTriggersTunnelClose() throws Exception {     TunnelClient client = new TunnelClient(0, this.tunnelConnection).     int port = client.start().     SocketChannel channel = SocketChannel.open(new InetSocketAddress(port)).     Thread.sleep(200).     channel.close().     client.getServerThread().stopAcceptingConnections().     client.getServerThread().join(2000).     assertThat(this.tunnelConnection.getOpenedTimes()).isEqualTo(1).     assertThat(this.tunnelConnection.isOpen()).isFalse(). }
false;public;0;11;;@Test public void stopTriggersTunnelClose() throws Exception {     TunnelClient client = new TunnelClient(0, this.tunnelConnection).     int port = client.start().     SocketChannel channel = SocketChannel.open(new InetSocketAddress(port)).     Thread.sleep(200).     client.stop().     assertThat(this.tunnelConnection.getOpenedTimes()).isEqualTo(1).     assertThat(this.tunnelConnection.isOpen()).isFalse().     assertThat(channel.read(ByteBuffer.allocate(1))).isEqualTo(-1). }
false;public;0;14;;@Test public void addListener() throws Exception {     TunnelClient client = new TunnelClient(0, this.tunnelConnection).     TunnelClientListener listener = mock(TunnelClientListener.class).     client.addListener(listener).     int port = client.start().     SocketChannel channel = SocketChannel.open(new InetSocketAddress(port)).     Thread.sleep(200).     channel.close().     client.getServerThread().stopAcceptingConnections().     client.getServerThread().join(2000).     verify(listener).onOpen(any(SocketChannel.class)).     verify(listener).onClose(any(SocketChannel.class)). }
false;public;2;7;;@Override public WritableByteChannel open(WritableByteChannel incomingChannel, Closeable closeable) {     this.openedTimes++.     this.open = true.     return new TunnelChannel(incomingChannel, closeable). }
false;public;1;3;;public void verifyWritten(String expected) {     verifyWritten(expected.getBytes()). }
false;public;1;6;;public void verifyWritten(byte[] expected) {     synchronized (this.written) {         assertThat(this.written.toByteArray()).isEqualTo(expected).         this.written.reset().     } }
false;public;0;3;;public boolean isOpen() {     return this.open. }
false;public;0;3;;public int getOpenedTimes() {     return this.openedTimes. }
false;public;0;4;;@Override public boolean isOpen() {     return MockTunnelConnection.this.open. }
false;public;0;5;;@Override public void close() throws IOException {     MockTunnelConnection.this.open = false.     this.closeable.close(). }
false;public;1;16;;@Override public int write(ByteBuffer src) throws IOException {     int remaining = src.remaining().     ByteArrayOutputStream stream = new ByteArrayOutputStream().     Channels.newChannel(stream).write(src).     byte[] bytes = stream.toByteArray().     synchronized (MockTunnelConnection.this.written) {         MockTunnelConnection.this.written.write(bytes).     }     byte[] reversed = new byte[bytes.length].     for (int i = 0. i < reversed.length. i++) {         reversed[i] = bytes[bytes.length - 1 - i].     }     this.incomingChannel.write(ByteBuffer.wrap(reversed)).     return remaining. }
