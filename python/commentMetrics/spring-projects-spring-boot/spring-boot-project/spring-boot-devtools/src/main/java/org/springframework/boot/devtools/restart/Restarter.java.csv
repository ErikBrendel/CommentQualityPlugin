commented;modifiers;parameterAmount;loc;comment;code
false;private;1;8;;private String getMainClassName(Thread thread) {     try {         return new MainMethod(thread).getDeclaringClassName().     } catch (Exception ex) {         return null.     } }
false;protected;1;10;;protected void initialize(boolean restartOnInitialize) {     preInitializeLeakyClasses().     if (this.initialUrls != null) {         this.urls.addAll(Arrays.asList(this.initialUrls)).         if (restartOnInitialize) {             this.logger.debug("Immediately restarting application").             immediateRestart().         }     } }
false;private;0;13;;private void immediateRestart() {     try {         getLeakSafeThread().callAndWait(() -> {             start(FailureHandler.NONE).             cleanupCaches().             return null.         }).     } catch (Exception ex) {         this.logger.warn("Unable to initialize restarter", ex).     }     SilentExitExceptionHandler.exitCurrentThread(). }
true;private;0;11;/**  * CGLIB has a private exception field which needs to initialized early to ensure that  * the stacktrace doesn't retain a reference to the RestartClassLoader.  */ ;/**  * CGLIB has a private exception field which needs to initialized early to ensure that  * the stacktrace doesn't retain a reference to the RestartClassLoader.  */ private void preInitializeLeakyClasses() {     try {         Class<?> readerClass = ClassNameReader.class.         Field field = readerClass.getDeclaredField("EARLY_EXIT").         field.setAccessible(true).         ((Throwable) field.get(null)).fillInStackTrace().     } catch (Exception ex) {         this.logger.warn("Unable to pre-initialize classes", ex).     } }
true;private;1;3;/**  * Set if restart support is enabled.  * @param enabled if restart support is enabled  */ ;/**  * Set if restart support is enabled.  * @param enabled if restart support is enabled  */ private void setEnabled(boolean enabled) {     this.enabled = enabled. }
true;public;1;4;/**  * Add additional URLs to be includes in the next restart.  * @param urls the urls to add  */ ;/**  * Add additional URLs to be includes in the next restart.  * @param urls the urls to add  */ public void addUrls(Collection<URL> urls) {     Assert.notNull(urls, "Urls must not be null").     this.urls.addAll(urls). }
true;public;1;4;/**  * Add additional {@link ClassLoaderFiles} to be included in the next restart.  * @param classLoaderFiles the files to add  */ ;/**  * Add additional {@link ClassLoaderFiles} to be included in the next restart.  * @param classLoaderFiles the files to add  */ public void addClassLoaderFiles(ClassLoaderFiles classLoaderFiles) {     Assert.notNull(classLoaderFiles, "ClassLoaderFiles must not be null").     this.classLoaderFiles.addAll(classLoaderFiles). }
true;public;0;3;/**  * Return a {@link ThreadFactory} that can be used to create leak safe threads.  * @return a leak safe thread factory  */ ;/**  * Return a {@link ThreadFactory} that can be used to create leak safe threads.  * @return a leak safe thread factory  */ public ThreadFactory getThreadFactory() {     return new LeakSafeThreadFactory(). }
true;public;0;3;/**  * Restart the running application.  */ ;/**  * Restart the running application.  */ public void restart() {     restart(FailureHandler.NONE). }
true;public;1;12;/**  * Restart the running application.  * @param failureHandler a failure handler to deal with application that doesn't start  */ ;/**  * Restart the running application.  * @param failureHandler a failure handler to deal with application that doesn't start  */ public void restart(FailureHandler failureHandler) {     if (!this.enabled) {         this.logger.debug("Application restart is disabled").         return.     }     this.logger.debug("Restarting application").     getLeakSafeThread().call(() -> {         Restarter.this.stop().         Restarter.this.start(failureHandler).         return null.     }). }
true;protected;1;12;/**  * Start the application.  * @param failureHandler a failure handler for application that won't start  * @throws Exception in case of errors  */ ;/**  * Start the application.  * @param failureHandler a failure handler for application that won't start  * @throws Exception in case of errors  */ protected void start(FailureHandler failureHandler) throws Exception {     do {         Throwable error = doStart().         if (error == null) {             return.         }         if (failureHandler.handle(error) == Outcome.ABORT) {             return.         }     } while (true). }
false;private;0;12;;private Throwable doStart() throws Exception {     Assert.notNull(this.mainClassName, "Unable to find the main class to restart").     URL[] urls = this.urls.toArray(new URL[0]).     ClassLoaderFiles updatedFiles = new ClassLoaderFiles(this.classLoaderFiles).     ClassLoader classLoader = new RestartClassLoader(this.applicationClassLoader, urls, updatedFiles, this.logger).     if (this.logger.isDebugEnabled()) {         this.logger.debug("Starting application " + this.mainClassName + " with URLs " + Arrays.asList(urls)).     }     return relaunch(classLoader). }
true;protected;1;7;/**  * Relaunch the application using the specified classloader.  * @param classLoader the classloader to use  * @return any exception that caused the launch to fail or {@code null}  * @throws Exception in case of errors  */ ;/**  * Relaunch the application using the specified classloader.  * @param classLoader the classloader to use  * @return any exception that caused the launch to fail or {@code null}  * @throws Exception in case of errors  */ protected Throwable relaunch(ClassLoader classLoader) throws Exception {     RestartLauncher launcher = new RestartLauncher(classLoader, this.mainClassName, this.args, this.exceptionHandler).     launcher.start().     launcher.join().     return launcher.getError(). }
true;protected;0;19;/**  * Stop the application.  * @throws Exception in case of errors  */ ;/**  * Stop the application.  * @throws Exception in case of errors  */ protected void stop() throws Exception {     this.logger.debug("Stopping application").     this.stopLock.lock().     try {         for (ConfigurableApplicationContext context : this.rootContexts) {             context.close().             this.rootContexts.remove(context).         }         cleanupCaches().         if (this.forceReferenceCleanup) {             forceReferenceCleanup().         }     } finally {         this.stopLock.unlock().     }     System.gc().     System.runFinalization(). }
false;private;0;4;;private void cleanupCaches() throws Exception {     Introspector.flushCaches().     cleanupKnownCaches(). }
false;private;0;11;;private void cleanupKnownCaches() throws Exception {     // Whilst not strictly necessary it helps to cleanup soft reference caches     // early rather than waiting for memory limits to be reached     ResolvableType.clearCache().     cleanCachedIntrospectionResultsCache().     ReflectionUtils.clearCache().     clearAnnotationUtilsCache().     if (!JavaVersion.getJavaVersion().isEqualOrNewerThan(JavaVersion.NINE)) {         clear("com.sun.naming.internal.ResourceManager", "propertiesCache").     } }
false;private;0;5;;private void cleanCachedIntrospectionResultsCache() throws Exception {     clear(CachedIntrospectionResults.class, "acceptedClassLoaders").     clear(CachedIntrospectionResults.class, "strongClassCache").     clear(CachedIntrospectionResults.class, "softClassCache"). }
false;private;0;9;;private void clearAnnotationUtilsCache() throws Exception {     try {         AnnotationUtils.clearCache().     } catch (Throwable ex) {         clear(AnnotationUtils.class, "findAnnotationCache").         clear(AnnotationUtils.class, "annotatedInterfaceCache").     } }
false;private;2;11;;private void clear(String className, String fieldName) {     try {         clear(Class.forName(className), fieldName).     } catch (Exception ex) {         if (this.logger.isDebugEnabled()) {             this.logger.debug("Unable to clear field " + className + " " + fieldName, ex).         }     } }
false;private;2;18;;private void clear(Class<?> type, String fieldName) throws Exception {     try {         Field field = type.getDeclaredField(fieldName).         field.setAccessible(true).         Object instance = field.get(null).         if (instance instanceof Set) {             ((Set<?>) instance).clear().         }         if (instance instanceof Map) {             ((Map<?, ?>) instance).keySet().removeIf(this::isFromRestartClassLoader).         }     } catch (Exception ex) {         if (this.logger.isDebugEnabled()) {             this.logger.debug("Unable to clear field " + type + " " + fieldName, ex).         }     } }
false;private;1;4;;private boolean isFromRestartClassLoader(Object object) {     return (object instanceof Class && ((Class<?>) object).getClassLoader() instanceof RestartClassLoader). }
true;private;0;11;/**  * Cleanup any soft/weak references by forcing an {@link OutOfMemoryError} error.  */ ;/**  * Cleanup any soft/weak references by forcing an {@link OutOfMemoryError} error.  */ private void forceReferenceCleanup() {     try {         final List<long[]> memory = new LinkedList<>().         while (true) {             memory.add(new long[102400]).         }     } catch (OutOfMemoryError ex) {     // Expected     } }
true;;0;9;/**  * Called to finish {@link Restarter} initialization when application logging is  * available.  */ ;/**  * Called to finish {@link Restarter} initialization when application logging is  * available.  */ void finish() {     synchronized (this.monitor) {         if (!isFinished()) {             this.logger = DeferredLog.replay(this.logger, LogFactory.getLog(getClass())).             this.finished = true.         }     } }
false;;0;5;;boolean isFinished() {     synchronized (this.monitor) {         return this.finished.     } }
false;;1;9;;void prepare(ConfigurableApplicationContext applicationContext) {     if (applicationContext != null && applicationContext.getParent() != null) {         return.     }     if (applicationContext instanceof GenericApplicationContext) {         prepare((GenericApplicationContext) applicationContext).     }     this.rootContexts.add(applicationContext). }
false;;1;5;;void remove(ConfigurableApplicationContext applicationContext) {     if (applicationContext != null) {         this.rootContexts.remove(applicationContext).     } }
false;private;1;5;;private void prepare(GenericApplicationContext applicationContext) {     ResourceLoader resourceLoader = new ClassLoaderFilesResourcePatternResolver(applicationContext, this.classLoaderFiles).     applicationContext.setResourceLoader(resourceLoader). }
false;private;0;9;;private LeakSafeThread getLeakSafeThread() {     try {         return this.leakSafeThreads.takeFirst().     } catch (InterruptedException ex) {         Thread.currentThread().interrupt().         throw new IllegalStateException(ex).     } }
false;public;2;8;;public Object getOrAddAttribute(String name, final ObjectFactory<?> objectFactory) {     synchronized (this.attributes) {         if (!this.attributes.containsKey(name)) {             this.attributes.put(name, objectFactory.getObject()).         }         return this.attributes.get(name).     } }
false;public;1;5;;public Object removeAttribute(String name) {     synchronized (this.attributes) {         return this.attributes.remove(name).     } }
true;public;0;3;/**  * Return the initial set of URLs as configured by the {@link RestartInitializer}.  * @return the initial URLs or {@code null}  */ ;/**  * Return the initial set of URLs as configured by the {@link RestartInitializer}.  * @return the initial URLs or {@code null}  */ public URL[] getInitialUrls() {     return this.initialUrls. }
true;public,static;0;4;/**  * Initialize and disable restart support.  */ ;/**  * Initialize and disable restart support.  */ public static void disable() {     initialize(NO_ARGS, false, RestartInitializer.NONE).     getInstance().setEnabled(false). }
true;public,static;1;3;/**  * Initialize restart support. See  * {@link #initialize(String[], boolean, RestartInitializer)} for details.  * @param args main application arguments  * @see #initialize(String[], boolean, RestartInitializer)  */ ;/**  * Initialize restart support. See  * {@link #initialize(String[], boolean, RestartInitializer)} for details.  * @param args main application arguments  * @see #initialize(String[], boolean, RestartInitializer)  */ public static void initialize(String[] args) {     initialize(args, false, new DefaultRestartInitializer()). }
true;public,static;2;3;/**  * Initialize restart support. See  * {@link #initialize(String[], boolean, RestartInitializer)} for details.  * @param args main application arguments  * @param initializer the restart initializer  * @see #initialize(String[], boolean, RestartInitializer)  */ ;/**  * Initialize restart support. See  * {@link #initialize(String[], boolean, RestartInitializer)} for details.  * @param args main application arguments  * @param initializer the restart initializer  * @see #initialize(String[], boolean, RestartInitializer)  */ public static void initialize(String[] args, RestartInitializer initializer) {     initialize(args, false, initializer, true). }
true;public,static;2;3;/**  * Initialize restart support. See  * {@link #initialize(String[], boolean, RestartInitializer)} for details.  * @param args main application arguments  * @param forceReferenceCleanup if forcing of soft/weak reference should happen on  * @see #initialize(String[], boolean, RestartInitializer)  */ ;/**  * Initialize restart support. See  * {@link #initialize(String[], boolean, RestartInitializer)} for details.  * @param args main application arguments  * @param forceReferenceCleanup if forcing of soft/weak reference should happen on  * @see #initialize(String[], boolean, RestartInitializer)  */ public static void initialize(String[] args, boolean forceReferenceCleanup) {     initialize(args, forceReferenceCleanup, new DefaultRestartInitializer()). }
true;public,static;3;4;/**  * Initialize restart support. See  * {@link #initialize(String[], boolean, RestartInitializer, boolean)} for details.  * @param args main application arguments  * @param forceReferenceCleanup if forcing of soft/weak reference should happen on  * @param initializer the restart initializer  * @see #initialize(String[], boolean, RestartInitializer)  */ ;/**  * Initialize restart support. See  * {@link #initialize(String[], boolean, RestartInitializer, boolean)} for details.  * @param args main application arguments  * @param forceReferenceCleanup if forcing of soft/weak reference should happen on  * @param initializer the restart initializer  * @see #initialize(String[], boolean, RestartInitializer)  */ public static void initialize(String[] args, boolean forceReferenceCleanup, RestartInitializer initializer) {     initialize(args, forceReferenceCleanup, initializer, true). }
true;public,static;4;14;/**  * Initialize restart support for the current application. Called automatically by  * {@link RestartApplicationListener} but can also be called directly if main  * application arguments are not the same as those passed to the  * {@link SpringApplication}.  * @param args main application arguments  * @param forceReferenceCleanup if forcing of soft/weak reference should happen on  * each restart. This will slow down restarts and is intended primarily for testing  * @param initializer the restart initializer  * @param restartOnInitialize if the restarter should be restarted immediately when  * the {@link RestartInitializer} returns non {@code null} results  */ ;/**  * Initialize restart support for the current application. Called automatically by  * {@link RestartApplicationListener} but can also be called directly if main  * application arguments are not the same as those passed to the  * {@link SpringApplication}.  * @param args main application arguments  * @param forceReferenceCleanup if forcing of soft/weak reference should happen on  * each restart. This will slow down restarts and is intended primarily for testing  * @param initializer the restart initializer  * @param restartOnInitialize if the restarter should be restarted immediately when  * the {@link RestartInitializer} returns non {@code null} results  */ public static void initialize(String[] args, boolean forceReferenceCleanup, RestartInitializer initializer, boolean restartOnInitialize) {     Restarter localInstance = null.     synchronized (INSTANCE_MONITOR) {         if (instance == null) {             localInstance = new Restarter(Thread.currentThread(), args, forceReferenceCleanup, initializer).             instance = localInstance.         }     }     if (localInstance != null) {         localInstance.initialize(restartOnInitialize).     } }
true;public,static;0;6;/**  * Return the active {@link Restarter} instance. Cannot be called before  * {@link #initialize(String[]) initialization}.  * @return the restarter  */ ;/**  * Return the active {@link Restarter} instance. Cannot be called before  * {@link #initialize(String[]) initialization}.  * @return the restarter  */ public static Restarter getInstance() {     synchronized (INSTANCE_MONITOR) {         Assert.state(instance != null, "Restarter has not been initialized").         return instance.     } }
true;static;1;5;/**  * Set the restarter instance (useful for testing).  * @param instance the instance to set  */ ;/**  * Set the restarter instance (useful for testing).  * @param instance the instance to set  */ static void setInstance(Restarter instance) {     synchronized (INSTANCE_MONITOR) {         Restarter.instance = instance.     } }
true;public,static;0;5;/**  * Clear the instance. Primarily provided for tests and not usually used in  * application code.  */ ;/**  * Clear the instance. Primarily provided for tests and not usually used in  * application code.  */ public static void clearInstance() {     synchronized (INSTANCE_MONITOR) {         instance = null.     } }
false;public;1;4;;public void call(Callable<?> callable) {     this.callable = callable.     start(). }
false;public;1;13;;@SuppressWarnings("unchecked") public <V> V callAndWait(Callable<V> callable) {     this.callable = callable.     start().     try {         join().         return (V) this.result.     } catch (InterruptedException ex) {         Thread.currentThread().interrupt().         throw new IllegalStateException(ex).     } }
false;public;0;14;;@Override public void run() {     // RestartClassLoader     try {         Restarter.this.leakSafeThreads.put(new LeakSafeThread()).         this.result = this.callable.call().     } catch (Exception ex) {         ex.printStackTrace().         System.exit(1).     } }
false;public;1;8;;@Override public Thread newThread(Runnable runnable) {     return getLeakSafeThread().callAndWait(() -> {         Thread thread = new Thread(runnable).         thread.setContextClassLoader(Restarter.this.applicationClassLoader).         return thread.     }). }
