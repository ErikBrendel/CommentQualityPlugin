commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Override public void afterSingletonsInstantiated() {     synchronized (this.monitor) {         if (this.serverThread == null) {             try {                 start().             } catch (IOException ex) {                 throw new IllegalStateException(ex).             }         }     } }
true;public;0;12;/**  * Start the client and accept incoming connections.  * @return the port on which the client is listening  * @throws IOException in case of I/O errors  */ ;/**  * Start the client and accept incoming connections.  * @return the port on which the client is listening  * @throws IOException in case of I/O errors  */ public int start() throws IOException {     synchronized (this.monitor) {         Assert.state(this.serverThread == null, "Server already started").         ServerSocketChannel serverSocketChannel = ServerSocketChannel.open().         serverSocketChannel.socket().bind(new InetSocketAddress(this.listenPort)).         int port = serverSocketChannel.socket().getLocalPort().         logger.trace("Listening for TCP traffic to tunnel on port " + port).         this.serverThread = new ServerThread(serverSocketChannel).         this.serverThread.start().         return port.     } }
true;public;0;14;/**  * Stop the client, disconnecting any servers.  * @throws IOException in case of I/O errors  */ ;/**  * Stop the client, disconnecting any servers.  * @throws IOException in case of I/O errors  */ public void stop() throws IOException {     synchronized (this.monitor) {         if (this.serverThread != null) {             this.serverThread.close().             try {                 this.serverThread.join(2000).             } catch (InterruptedException ex) {                 Thread.currentThread().interrupt().             }             this.serverThread = null.         }     } }
false;protected,final;0;5;;protected final ServerThread getServerThread() {     synchronized (this.monitor) {         return this.serverThread.     } }
false;public;1;3;;public void addListener(TunnelClientListener listener) {     this.listeners.addListener(listener). }
false;public;1;3;;public void removeListener(TunnelClientListener listener) {     this.listeners.removeListener(listener). }
false;public;0;7;;public void close() throws IOException {     logger.trace("Closing tunnel client on port " + this.serverSocketChannel.socket().getLocalPort()).     this.serverSocketChannel.close().     this.acceptConnections = false.     interrupt(). }
false;public;0;16;;@Override public void run() {     try {         while (this.acceptConnections) {             try (SocketChannel socket = this.serverSocketChannel.accept()) {                 handleConnection(socket).             } catch (AsynchronousCloseException ex) {             // Connection has been closed. Keep the server running             }         }     } catch (Exception ex) {         logger.trace("Unexpected exception from tunnel client", ex).     } }
false;private;1;20;;private void handleConnection(SocketChannel socketChannel) throws Exception {     Closeable closeable = new SocketCloseable(socketChannel).     TunnelClient.this.listeners.fireOpenEvent(socketChannel).     try (WritableByteChannel outputChannel = TunnelClient.this.tunnelConnection.open(socketChannel, closeable)) {         logger.trace("Accepted connection to tunnel client from " + socketChannel.socket().getRemoteSocketAddress()).         while (true) {             ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE).             int amountRead = socketChannel.read(buffer).             if (amountRead == -1) {                 return.             }             if (amountRead > 0) {                 buffer.flip().                 outputChannel.write(buffer).             }         }     } }
false;protected;0;3;;protected void stopAcceptingConnections() {     this.acceptConnections = false. }
false;public;0;8;;@Override public void close() throws IOException {     if (!this.closed) {         this.socketChannel.close().         TunnelClient.this.listeners.fireCloseEvent(this.socketChannel).         this.closed = true.     } }
