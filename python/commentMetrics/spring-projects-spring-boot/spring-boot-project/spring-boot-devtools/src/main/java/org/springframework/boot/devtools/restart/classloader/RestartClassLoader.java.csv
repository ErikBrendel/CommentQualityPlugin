commented;modifiers;parameterAmount;loc;comment;code
false;public;1;16;;@Override public Enumeration<URL> getResources(String name) throws IOException {     // Use the parent since we're shadowing resource and we don't want duplicates     Enumeration<URL> resources = getParent().getResources(name).     ClassLoaderFile file = this.updatedFiles.getFile(name).     if (file != null) {         // Assume that we're replacing just the first item         if (resources.hasMoreElements()) {             resources.nextElement().         }         if (file.getKind() != Kind.DELETED) {             return new CompoundEnumeration<>(createFileUrl(name, file), resources).         }     }     return resources. }
false;public;1;12;;@Override public URL getResource(String name) {     ClassLoaderFile file = this.updatedFiles.getFile(name).     if (file != null && file.getKind() == Kind.DELETED) {         return null.     }     URL resource = findResource(name).     if (resource != null) {         return resource.     }     return getParent().getResource(name). }
false;public;1;12;;@Override public URL findResource(String name) {     final ClassLoaderFile file = this.updatedFiles.getFile(name).     if (file == null) {         return super.findResource(name).     }     if (file.getKind() == Kind.DELETED) {         return null.     }     return AccessController.doPrivileged((PrivilegedAction<URL>) () -> createFileUrl(name, file)). }
false;public;2;24;;@Override public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {     String path = name.replace('.', '/').concat(".class").     ClassLoaderFile file = this.updatedFiles.getFile(path).     if (file != null && file.getKind() == Kind.DELETED) {         throw new ClassNotFoundException(name).     }     synchronized (getClassLoadingLock(name)) {         Class<?> loadedClass = findLoadedClass(name).         if (loadedClass == null) {             try {                 loadedClass = findClass(name).             } catch (ClassNotFoundException ex) {                 loadedClass = getParent().loadClass(name).             }         }         if (resolve) {             resolveClass(loadedClass).         }         return loadedClass.     } }
false;protected;1;15;;@Override protected Class<?> findClass(String name) throws ClassNotFoundException {     String path = name.replace('.', '/').concat(".class").     final ClassLoaderFile file = this.updatedFiles.getFile(path).     if (file == null) {         return super.findClass(name).     }     if (file.getKind() == Kind.DELETED) {         throw new ClassNotFoundException(name).     }     return AccessController.doPrivileged((PrivilegedAction<Class<?>>) () -> {         byte[] bytes = file.getContents().         return defineClass(name, bytes, 0, bytes.length).     }). }
false;private;2;9;;private URL createFileUrl(String name, ClassLoaderFile file) {     try {         return new URL("reloaded", null, -1, "/" + name, new ClassLoaderFileURLStreamHandler(file)).     } catch (MalformedURLException ex) {         throw new IllegalStateException(ex).     } }
false;protected;0;7;;@Override protected void finalize() throws Throwable {     if (this.logger.isDebugEnabled()) {         this.logger.debug("Finalized classloader " + toString()).     }     super.finalize(). }
false;public;1;4;;@Override public boolean isClassReloadable(Class<?> classType) {     return (classType.getClassLoader() instanceof RestartClassLoader). }
false;public;0;4;;@Override public boolean hasMoreElements() {     return (this.firstElement != null || this.enumeration.hasMoreElements()). }
false;public;0;9;;@Override public E nextElement() {     if (this.firstElement == null) {         return this.enumeration.nextElement().     }     E element = this.firstElement.     this.firstElement = null.     return element. }
