commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Type getType() {     return this.type. }
false;public;0;3;;public byte[] getPayload() {     return this.payload. }
false;public;0;4;;@Override public String toString() {     return new String(this.payload). }
false;public;1;13;;public void write(OutputStream outputStream) throws IOException {     outputStream.write(0x80 | this.type.code).     if (this.payload.length < 126) {         outputStream.write(0x00 | (this.payload.length & 0x7F)).     } else {         outputStream.write(0x7E).         outputStream.write(this.payload.length >> 8 & 0xFF).         outputStream.write(this.payload.length >> 0 & 0xFF).     }     outputStream.write(this.payload).     outputStream.flush(). }
false;public,static;1;23;;public static Frame read(ConnectionInputStream inputStream) throws IOException {     int firstByte = inputStream.checkedRead().     Assert.state((firstByte & 0x80) != 0, "Fragmented frames are not supported").     int maskAndLength = inputStream.checkedRead().     boolean hasMask = (maskAndLength & 0x80) != 0.     int length = (maskAndLength & 0x7F).     Assert.state(length != 127, "Large frames are not supported").     if (length == 126) {         length = ((inputStream.checkedRead()) << 8 | inputStream.checkedRead()).     }     byte[] mask = new byte[4].     if (hasMask) {         inputStream.readFully(mask, 0, mask.length).     }     byte[] payload = new byte[length].     inputStream.readFully(payload, 0, length).     if (hasMask) {         for (int i = 0. i < payload.length. i++) {             payload[i] ^= mask[i % 4].         }     }     return new Frame(Type.forCode(firstByte & 0x0F), payload). }
false;public,static;1;8;;public static Type forCode(int code) {     for (Type type : values()) {         if (type.code == code) {             return type.         }     }     throw new IllegalStateException("Unknown code " + code). }
