commented;modifiers;parameterAmount;loc;comment;code
false;public;2;6;;@Override public TunnelChannel open(WritableByteChannel incomingChannel, Closeable closeable) throws Exception {     logger.trace("Opening HTTP tunnel to " + this.uri).     return new TunnelChannel(incomingChannel, closeable). }
false;protected,final;1;5;;protected final ClientHttpRequest createRequest(boolean hasPayload) throws IOException {     HttpMethod method = hasPayload ? HttpMethod.POST : HttpMethod.GET.     return this.requestFactory.createRequest(this.uri, method). }
false;public;0;4;;@Override public boolean isOpen() {     return this.open. }
false;public;0;7;;@Override public void close() throws IOException {     if (this.open) {         this.open = false.         this.closeable.close().     } }
false;public;1;9;;@Override public int write(ByteBuffer src) throws IOException {     int size = src.remaining().     if (size > 0) {         openNewConnection(new HttpTunnelPayload(this.requestSeq.incrementAndGet(), src)).     }     return size. }
false;public;0;16;;@Override public void run() {     try {         sendAndReceive(payload).     } catch (IOException ex) {         if (ex instanceof ConnectException) {             logger.warn("Failed to connect to remote application at " + HttpTunnelConnection.this.uri).         } else {             logger.trace("Unexpected connection error", ex).         }         closeQuietly().     } }
false;private;0;8;;private void closeQuietly() {     try {         close().     } catch (IOException ex) {     // Ignore     } }
false;private;1;31;;private void openNewConnection(HttpTunnelPayload payload) {     HttpTunnelConnection.this.executor.execute(new Runnable() {          @Override         public void run() {             try {                 sendAndReceive(payload).             } catch (IOException ex) {                 if (ex instanceof ConnectException) {                     logger.warn("Failed to connect to remote application at " + HttpTunnelConnection.this.uri).                 } else {                     logger.trace("Unexpected connection error", ex).                 }                 closeQuietly().             }         }          private void closeQuietly() {             try {                 close().             } catch (IOException ex) {             // Ignore             }         }     }). }
false;private;1;8;;private void sendAndReceive(HttpTunnelPayload payload) throws IOException {     ClientHttpRequest request = createRequest(payload != null).     if (payload != null) {         payload.logIncoming().         payload.assignTo(request).     }     handleResponse(request.execute()). }
false;private;1;15;;private void handleResponse(ClientHttpResponse response) throws IOException {     if (response.getStatusCode() == HttpStatus.GONE) {         close().         return.     }     if (response.getStatusCode() == HttpStatus.OK) {         HttpTunnelPayload payload = HttpTunnelPayload.get(response).         if (payload != null) {             this.forwarder.forward(payload).         }     }     if (response.getStatusCode() != HttpStatus.TOO_MANY_REQUESTS) {         openNewConnection(null).     } }
false;public;1;6;;@Override public Thread newThread(Runnable runnable) {     Thread thread = new Thread(runnable, "HTTP Tunnel Connection").     thread.setDaemon(true).     return thread. }
