commented;modifiers;parameterAmount;loc;comment;code
true;public;0;10;/**  * Run the connection.  * @throws Exception in case of errors  */ ;/**  * Run the connection.  * @throws Exception in case of errors  */ public void run() throws Exception {     if (this.header.contains("Upgrade: websocket") && this.header.contains("Sec-WebSocket-Version: 13")) {         runWebSocket().     }     if (this.header.contains("GET /livereload.js")) {         this.outputStream.writeHttp(getClass().getResourceAsStream("livereload.js"), "text/javascript").     } }
false;private;0;14;;private void runWebSocket() throws Exception {     String accept = getWebsocketAcceptResponse().     this.outputStream.writeHeaders("HTTP/1.1 101 Switching Protocols", "Upgrade: websocket", "Connection: Upgrade", "Sec-WebSocket-Accept: " + accept).     new Frame("{\"command\":\"hello\",\"protocols\":" + "[\"http://livereload.com/protocols/official-7\"]," + "\"serverName\":\"spring-boot\"}").write(this.outputStream).     Thread.sleep(100).     this.webSocket = true.     while (this.running) {         readWebSocketFrame().     } }
false;private;0;24;;private void readWebSocketFrame() throws IOException {     try {         Frame frame = Frame.read(this.inputStream).         if (frame.getType() == Frame.Type.PING) {             writeWebSocketFrame(new Frame(Frame.Type.PONG)).         } else if (frame.getType() == Frame.Type.CLOSE) {             throw new ConnectionClosedException().         } else if (frame.getType() == Frame.Type.TEXT) {             logger.debug("Received LiveReload text frame " + frame).         } else {             throw new IOException("Unexpected Frame Type " + frame.getType()).         }     } catch (SocketTimeoutException ex) {         writeWebSocketFrame(new Frame(Frame.Type.PING)).         Frame frame = Frame.read(this.inputStream).         if (frame.getType() != Frame.Type.PONG) {             throw new IllegalStateException("No Pong").         }     } }
true;public;0;6;/**  * Trigger livereload for the client using this connection.  * @throws IOException in case of I/O errors  */ ;/**  * Trigger livereload for the client using this connection.  * @throws IOException in case of I/O errors  */ public void triggerReload() throws IOException {     if (this.webSocket) {         logger.debug("Triggering LiveReload").         writeWebSocketFrame(new Frame("{\"command\":\"reload\",\"path\":\"/\"}")).     } }
false;private;1;3;;private void writeWebSocketFrame(Frame frame) throws IOException {     frame.write(this.outputStream). }
false;private;0;10;;private String getWebsocketAcceptResponse() throws NoSuchAlgorithmException {     Matcher matcher = WEBSOCKET_KEY_PATTERN.matcher(this.header).     if (!matcher.find()) {         throw new IllegalStateException("No Sec-WebSocket-Key").     }     String response = matcher.group(1).trim() + WEBSOCKET_GUID.     MessageDigest messageDigest = MessageDigest.getInstance("SHA-1").     messageDigest.update(response.getBytes(), 0, response.length()).     return Base64Utils.encodeToString(messageDigest.digest()). }
true;public;0;4;/**  * Close the connection.  * @throws IOException in case of I/O errors  */ ;/**  * Close the connection.  * @throws IOException in case of I/O errors  */ public void close() throws IOException {     this.running = false.     this.socket.close(). }
