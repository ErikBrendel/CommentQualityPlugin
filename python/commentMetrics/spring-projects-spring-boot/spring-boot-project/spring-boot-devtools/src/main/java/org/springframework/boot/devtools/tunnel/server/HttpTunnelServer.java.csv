commented;modifiers;parameterAmount;loc;comment;code
true;public;2;4;/**  * Handle an incoming HTTP connection.  * @param request the HTTP request  * @param response the HTTP response  * @throws IOException in case of I/O errors  */ ;/**  * Handle an incoming HTTP connection.  * @param request the HTTP request  * @param response the HTTP response  * @throws IOException in case of I/O errors  */ public void handle(ServerHttpRequest request, ServerHttpResponse response) throws IOException {     handle(new HttpConnection(request, response)). }
true;protected;1;9;/**  * Handle an incoming HTTP connection.  * @param httpConnection the HTTP connection  * @throws IOException in case of I/O errors  */ ;/**  * Handle an incoming HTTP connection.  * @param httpConnection the HTTP connection  * @throws IOException in case of I/O errors  */ protected void handle(HttpConnection httpConnection) throws IOException {     try {         getServerThread().handleIncomingHttp(httpConnection).         httpConnection.waitForResponse().     } catch (ConnectException ex) {         httpConnection.respond(HttpStatus.GONE).     } }
true;protected;0;10;/**  * Returns the active server thread, creating and starting it if necessary.  * @return the {@code ServerThread} (never {@code null})  * @throws IOException in case of I/O errors  */ ;/**  * Returns the active server thread, creating and starting it if necessary.  * @return the {@code ServerThread} (never {@code null})  * @throws IOException in case of I/O errors  */ protected ServerThread getServerThread() throws IOException {     synchronized (this) {         if (this.serverThread == null) {             ByteChannel channel = this.serverConnection.open(this.longPollTimeout).             this.serverThread = new ServerThread(channel).             this.serverThread.start().         }         return this.serverThread.     } }
true;;0;5;/**  * Called when the server thread exits.  */ ;/**  * Called when the server thread exits.  */ void clearServerThread() {     synchronized (this) {         this.serverThread = null.     } }
true;public;1;4;/**  * Set the long poll timeout for the server.  * @param longPollTimeout the long poll timeout in milliseconds  */ ;/**  * Set the long poll timeout for the server.  * @param longPollTimeout the long poll timeout in milliseconds  */ public void setLongPollTimeout(int longPollTimeout) {     Assert.isTrue(longPollTimeout > 0, "LongPollTimeout must be a positive value").     this.longPollTimeout = longPollTimeout. }
true;public;1;5;/**  * Set the maximum amount of time to wait for a client before closing the connection.  * @param disconnectTimeout the disconnect timeout in milliseconds  */ ;/**  * Set the maximum amount of time to wait for a client before closing the connection.  * @param disconnectTimeout the disconnect timeout in milliseconds  */ public void setDisconnectTimeout(long disconnectTimeout) {     Assert.isTrue(disconnectTimeout > 0, "DisconnectTimeout must be a positive value").     this.disconnectTimeout = disconnectTimeout. }
false;public;0;17;;@Override public void run() {     try {         try {             readAndForwardTargetServerData().         } catch (Exception ex) {             logger.trace("Unexpected exception from tunnel server", ex).         }     } finally {         this.closed = true.         closeHttpConnections().         closeTargetServer().         HttpTunnelServer.this.clearServerThread().     } }
false;private;0;15;;private void readAndForwardTargetServerData() throws IOException {     while (this.targetServer.isOpen()) {         closeStaleHttpConnections().         ByteBuffer data = HttpTunnelPayload.getPayloadData(this.targetServer).         synchronized (this.httpConnections) {             if (data != null) {                 HttpTunnelPayload payload = new HttpTunnelPayload(this.responseSeq.incrementAndGet(), data).                 payload.logIncoming().                 HttpConnection connection = getOrWaitForHttpConnection().                 connection.respond(payload).             }         }     } }
false;private;0;16;;private HttpConnection getOrWaitForHttpConnection() {     synchronized (this.httpConnections) {         HttpConnection httpConnection = this.httpConnections.pollFirst().         while (httpConnection == null) {             try {                 this.httpConnections.wait(HttpTunnelServer.this.longPollTimeout).             } catch (InterruptedException ex) {                 Thread.currentThread().interrupt().                 closeHttpConnections().             }             httpConnection = this.httpConnections.pollFirst().         }         return httpConnection.     } }
false;private;0;14;;private void closeStaleHttpConnections() throws IOException {     synchronized (this.httpConnections) {         checkNotDisconnected().         Iterator<HttpConnection> iterator = this.httpConnections.iterator().         while (iterator.hasNext()) {             HttpConnection httpConnection = iterator.next().             if (httpConnection.isOlderThan(HttpTunnelServer.this.longPollTimeout)) {                 httpConnection.respond(HttpStatus.NO_CONTENT).                 iterator.remove().             }         }     } }
false;private;0;8;;private void checkNotDisconnected() {     if (this.lastHttpRequestTime > 0) {         long timeout = HttpTunnelServer.this.disconnectTimeout.         long duration = System.currentTimeMillis() - this.lastHttpRequestTime.         Assert.state(duration < timeout, () -> "Disconnect timeout: " + timeout + " " + duration).     } }
false;private;0;12;;private void closeHttpConnections() {     synchronized (this.httpConnections) {         while (!this.httpConnections.isEmpty()) {             try {                 this.httpConnections.removeFirst().respond(HttpStatus.GONE).             } catch (Exception ex) {                 logger.trace("Unable to close remote HTTP connection").             }         }     } }
false;private;0;8;;private void closeTargetServer() {     try {         this.targetServer.close().     } catch (IOException ex) {         logger.trace("Unable to target server connection").     } }
true;public;1;15;/**  * Handle an incoming {@link HttpConnection}.  * @param httpConnection the connection to handle.  * @throws IOException in case of I/O errors  */ ;/**  * Handle an incoming {@link HttpConnection}.  * @param httpConnection the connection to handle.  * @throws IOException in case of I/O errors  */ public void handleIncomingHttp(HttpConnection httpConnection) throws IOException {     if (this.closed) {         httpConnection.respond(HttpStatus.GONE).     }     synchronized (this.httpConnections) {         while (this.httpConnections.size() > 1) {             this.httpConnections.removeFirst().respond(HttpStatus.TOO_MANY_REQUESTS).         }         this.lastHttpRequestTime = System.currentTimeMillis().         this.httpConnections.addLast(httpConnection).         this.httpConnections.notify().     }     forwardToTargetServer(httpConnection). }
false;private;1;12;;private void forwardToTargetServer(HttpConnection httpConnection) throws IOException {     if (httpConnection.isDisconnectRequest()) {         this.targetServer.close().         interrupt().     }     ServerHttpRequest request = httpConnection.getRequest().     HttpTunnelPayload payload = HttpTunnelPayload.get(request).     if (payload != null) {         this.payloadForwarder.forward(payload).     } }
true;protected;0;12;/**  * Start asynchronous support or if unavailable return {@code null} to cause  * {@link #waitForResponse()} to block.  * @return the async request control  */ ;/**  * Start asynchronous support or if unavailable return {@code null} to cause  * {@link #waitForResponse()} to block.  * @return the async request control  */ protected ServerHttpAsyncRequestControl startAsync() {     try {         // Try to use async to save blocking         ServerHttpAsyncRequestControl async = this.request.getAsyncRequestControl(this.response).         async.start().         return async.     } catch (Exception ex) {         return null.     } }
true;public,final;0;3;/**  * Return the underlying request.  * @return the request  */ ;/**  * Return the underlying request.  * @return the request  */ public final ServerHttpRequest getRequest() {     return this.request. }
true;protected,final;0;3;/**  * Return the underlying response.  * @return the response  */ ;/**  * Return the underlying response.  * @return the response  */ protected final ServerHttpResponse getResponse() {     return this.response. }
true;public;1;4;/**  * Determine if a connection is older than the specified time.  * @param time the time to check  * @return {@code true} if the request is older than the time  */ ;/**  * Determine if a connection is older than the specified time.  * @param time the time to check  * @return {@code true} if the request is older than the time  */ public boolean isOlderThan(int time) {     long runningTime = System.currentTimeMillis() - this.createTime.     return (runningTime > time). }
true;public;0;14;/**  * Cause the request to block or use asynchronous methods to wait until a response  * is available.  */ ;/**  * Cause the request to block or use asynchronous methods to wait until a response  * is available.  */ public void waitForResponse() {     if (this.async == null) {         while (!this.complete) {             try {                 synchronized (this) {                     wait(1000).                 }             } catch (InterruptedException ex) {                 Thread.currentThread().interrupt().             }         }     } }
true;public;0;4;/**  * Detect if the request is actually a signal to disconnect.  * @return if the request is a signal to disconnect  */ ;/**  * Detect if the request is actually a signal to disconnect.  * @return if the request is a signal to disconnect  */ public boolean isDisconnectRequest() {     return DISCONNECT_MEDIA_TYPE.equals(this.request.getHeaders().getContentType()). }
true;public;1;5;/**  * Send a HTTP status response.  * @param status the status to send  * @throws IOException in case of I/O errors  */ ;/**  * Send a HTTP status response.  * @param status the status to send  * @throws IOException in case of I/O errors  */ public void respond(HttpStatus status) throws IOException {     Assert.notNull(status, "Status must not be null").     this.response.setStatusCode(status).     complete(). }
true;public;1;6;/**  * Send a payload response.  * @param payload the payload to send  * @throws IOException in case of I/O errors  */ ;/**  * Send a payload response.  * @param payload the payload to send  * @throws IOException in case of I/O errors  */ public void respond(HttpTunnelPayload payload) throws IOException {     Assert.notNull(payload, "Payload must not be null").     this.response.setStatusCode(HttpStatus.OK).     payload.assignTo(this.response).     complete(). }
true;protected;0;11;/**  * Called when a request is complete.  */ ;/**  * Called when a request is complete.  */ protected void complete() {     if (this.async != null) {         this.async.complete().     } else {         synchronized (this) {             this.complete = true.             notifyAll().         }     } }
