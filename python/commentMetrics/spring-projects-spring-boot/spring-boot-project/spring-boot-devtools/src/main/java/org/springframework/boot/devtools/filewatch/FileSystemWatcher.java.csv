commented;modifiers;parameterAmount;loc;comment;code
true;public;1;7;/**  * Add listener for file change events. Cannot be called after the watcher has been  * {@link #start() started}.  * @param fileChangeListener the listener to add  */ ;/**  * Add listener for file change events. Cannot be called after the watcher has been  * {@link #start() started}.  * @param fileChangeListener the listener to add  */ public void addListener(FileChangeListener fileChangeListener) {     Assert.notNull(fileChangeListener, "FileChangeListener must not be null").     synchronized (this.monitor) {         checkNotStarted().         this.listeners.add(fileChangeListener).     } }
true;public;1;8;/**  * Add source folders to monitor. Cannot be called after the watcher has been  * {@link #start() started}.  * @param folders the folders to monitor  */ ;/**  * Add source folders to monitor. Cannot be called after the watcher has been  * {@link #start() started}.  * @param folders the folders to monitor  */ public void addSourceFolders(Iterable<File> folders) {     Assert.notNull(folders, "Folders must not be null").     synchronized (this.monitor) {         for (File folder : folders) {             addSourceFolder(folder).         }     } }
true;public;1;8;/**  * Add a source folder to monitor. Cannot be called after the watcher has been  * {@link #start() started}.  * @param folder the folder to monitor  */ ;/**  * Add a source folder to monitor. Cannot be called after the watcher has been  * {@link #start() started}.  * @param folder the folder to monitor  */ public void addSourceFolder(File folder) {     Assert.notNull(folder, "Folder must not be null").     Assert.isTrue(!folder.isFile(), "Folder '" + folder + "' must not be a file").     synchronized (this.monitor) {         checkNotStarted().         this.folders.put(folder, null).     } }
true;public;1;5;/**  * Set an optional {@link FileFilter} used to limit the files that trigger a change.  * @param triggerFilter a trigger filter or null  */ ;/**  * Set an optional {@link FileFilter} used to limit the files that trigger a change.  * @param triggerFilter a trigger filter or null  */ public void setTriggerFilter(FileFilter triggerFilter) {     synchronized (this.monitor) {         this.triggerFilter = triggerFilter.     } }
false;private;0;5;;private void checkNotStarted() {     synchronized (this.monitor) {         Assert.state(this.watchThread == null, "FileSystemWatcher already started").     } }
true;public;0;15;/**  * Start monitoring the source folder for changes.  */ ;/**  * Start monitoring the source folder for changes.  */ public void start() {     synchronized (this.monitor) {         saveInitialSnapshots().         if (this.watchThread == null) {             Map<File, FolderSnapshot> localFolders = new HashMap<>().             localFolders.putAll(this.folders).             this.watchThread = new Thread(new Watcher(this.remainingScans, new ArrayList<>(this.listeners), this.triggerFilter, this.pollInterval, this.quietPeriod, localFolders)).             this.watchThread.setName("File Watcher").             this.watchThread.setDaemon(this.daemon).             this.watchThread.start().         }     } }
false;private;0;5;;private void saveInitialSnapshots() {     for (File folder : this.folders.keySet()) {         this.folders.put(folder, new FolderSnapshot(folder)).     } }
true;public;0;3;/**  * Stop monitoring the source folders.  */ ;/**  * Stop monitoring the source folders.  */ public void stop() {     stopAfter(0). }
true;;1;21;/**  * Stop monitoring the source folders.  * @param remainingScans the number of remaining scans  */ ;/**  * Stop monitoring the source folders.  * @param remainingScans the number of remaining scans  */ void stopAfter(int remainingScans) {     Thread thread.     synchronized (this.monitor) {         thread = this.watchThread.         if (thread != null) {             this.remainingScans.set(remainingScans).             if (remainingScans <= 0) {                 thread.interrupt().             }         }         this.watchThread = null.     }     if (thread != null && Thread.currentThread() != thread) {         try {             thread.join().         } catch (InterruptedException ex) {             Thread.currentThread().interrupt().         }     } }
false;public;0;16;;@Override public void run() {     int remainingScans = this.remainingScans.get().     while (remainingScans > 0 || remainingScans == -1) {         try {             if (remainingScans > 0) {                 this.remainingScans.decrementAndGet().             }             scan().         } catch (InterruptedException ex) {             Thread.currentThread().interrupt().         }         remainingScans = this.remainingScans.get().     } }
false;private;0;14;;private void scan() throws InterruptedException {     Thread.sleep(this.pollInterval - this.quietPeriod).     Map<File, FolderSnapshot> previous.     Map<File, FolderSnapshot> current = this.folders.     do {         previous = current.         current = getCurrentSnapshots().         Thread.sleep(this.quietPeriod).     } while (isDifferent(previous, current)).     if (isDifferent(this.folders, current)) {         updateSnapshots(current.values()).     } }
false;private;2;14;;private boolean isDifferent(Map<File, FolderSnapshot> previous, Map<File, FolderSnapshot> current) {     if (!previous.keySet().equals(current.keySet())) {         return true.     }     for (Map.Entry<File, FolderSnapshot> entry : previous.entrySet()) {         FolderSnapshot previousFolder = entry.getValue().         FolderSnapshot currentFolder = current.get(entry.getKey()).         if (!previousFolder.equals(currentFolder, this.triggerFilter)) {             return true.         }     }     return false. }
false;private;0;7;;private Map<File, FolderSnapshot> getCurrentSnapshots() {     Map<File, FolderSnapshot> snapshots = new LinkedHashMap<>().     for (File folder : this.folders.keySet()) {         snapshots.put(folder, new FolderSnapshot(folder)).     }     return snapshots. }
false;private;1;17;;private void updateSnapshots(Collection<FolderSnapshot> snapshots) {     Map<File, FolderSnapshot> updated = new LinkedHashMap<>().     Set<ChangedFiles> changeSet = new LinkedHashSet<>().     for (FolderSnapshot snapshot : snapshots) {         FolderSnapshot previous = this.folders.get(snapshot.getFolder()).         updated.put(snapshot.getFolder(), snapshot).         ChangedFiles changedFiles = previous.getChangedFiles(snapshot, this.triggerFilter).         if (!changedFiles.getFiles().isEmpty()) {             changeSet.add(changedFiles).         }     }     if (!changeSet.isEmpty()) {         fireListeners(Collections.unmodifiableSet(changeSet)).     }     this.folders = updated. }
false;private;1;5;;private void fireListeners(Set<ChangedFiles> changeSet) {     for (FileChangeListener listener : this.listeners) {         listener.onChange(changeSet).     } }
