commented;modifiers;parameterAmount;loc;comment;code
true;public;0;13;/**  * Start the livereload server and accept incoming connections.  * @return the port on which the server is listening  * @throws IOException in case of I/O errors  */ ;/**  * Start the livereload server and accept incoming connections.  * @return the port on which the server is listening  * @throws IOException in case of I/O errors  */ public int start() throws IOException {     synchronized (this.monitor) {         Assert.state(!isStarted(), "Server already started").         logger.debug("Starting live reload server on port " + this.port).         this.serverSocket = new ServerSocket(this.port).         int localPort = this.serverSocket.getLocalPort().         this.listenThread = this.threadFactory.newThread(this::acceptConnections).         this.listenThread.setDaemon(true).         this.listenThread.setName("Live Reload Server").         this.listenThread.start().         return localPort.     } }
true;public;0;5;/**  * Return if the server has been started.  * @return {@code true} if the server is running  */ ;/**  * Return if the server has been started.  * @return {@code true} if the server is running  */ public boolean isStarted() {     synchronized (this.monitor) {         return this.listenThread != null.     } }
true;public;0;3;/**  * Return the port that the server is listening on.  * @return the server port  */ ;/**  * Return the port that the server is listening on.  * @return the server port  */ public int getPort() {     return this.port. }
false;private;0;18;;private void acceptConnections() {     do {         try {             Socket socket = this.serverSocket.accept().             socket.setSoTimeout(READ_TIMEOUT).             this.executor.execute(new ConnectionHandler(socket)).         } catch (SocketTimeoutException ex) {         // Ignore         } catch (Exception ex) {             if (logger.isDebugEnabled()) {                 logger.debug("LiveReload server error", ex).             }         }     } while (!this.serverSocket.isClosed()). }
true;public;0;23;/**  * Gracefully stop the livereload server.  * @throws IOException in case of I/O errors  */ ;/**  * Gracefully stop the livereload server.  * @throws IOException in case of I/O errors  */ public void stop() throws IOException {     synchronized (this.monitor) {         if (this.listenThread != null) {             closeAllConnections().             try {                 this.executor.shutdown().                 this.executor.awaitTermination(1, TimeUnit.MINUTES).             } catch (InterruptedException ex) {                 Thread.currentThread().interrupt().             }             this.serverSocket.close().             try {                 this.listenThread.join().             } catch (InterruptedException ex) {                 Thread.currentThread().interrupt().             }             this.listenThread = null.             this.serverSocket = null.         }     } }
false;private;0;7;;private void closeAllConnections() throws IOException {     synchronized (this.connections) {         for (Connection connection : this.connections) {             connection.close().         }     } }
true;public;0;14;/**  * Trigger livereload of all connected clients.  */ ;/**  * Trigger livereload of all connected clients.  */ public void triggerReload() {     synchronized (this.monitor) {         synchronized (this.connections) {             for (Connection connection : this.connections) {                 try {                     connection.triggerReload().                 } catch (Exception ex) {                     logger.debug("Unable to send reload message", ex).                 }             }         }     } }
false;private;1;5;;private void addConnection(Connection connection) {     synchronized (this.connections) {         this.connections.add(connection).     } }
false;private;1;5;;private void removeConnection(Connection connection) {     synchronized (this.connections) {         this.connections.remove(connection).     } }
true;protected;3;4;/**  * Factory method used to create the {@link Connection}.  * @param socket the source socket  * @param inputStream the socket input stream  * @param outputStream the socket output stream  * @return a connection  * @throws IOException in case of I/O errors  */ ;/**  * Factory method used to create the {@link Connection}.  * @param socket the source socket  * @param inputStream the socket input stream  * @param outputStream the socket output stream  * @return a connection  * @throws IOException in case of I/O errors  */ protected Connection createConnection(Socket socket, InputStream inputStream, OutputStream outputStream) throws IOException {     return new Connection(socket, inputStream, outputStream). }
false;public;0;14;;@Override public void run() {     try {         handle().     } catch (ConnectionClosedException ex) {         logger.debug("LiveReload connection closed").     } catch (Exception ex) {         if (logger.isDebugEnabled()) {             logger.debug("LiveReload error", ex).         }     } }
false;private;0;15;;private void handle() throws Exception {     try {         try (OutputStream outputStream = this.socket.getOutputStream()) {             Connection connection = createConnection(this.socket, this.inputStream, outputStream).             runConnection(connection).         } finally {             this.inputStream.close().         }     } finally {         this.socket.close().     } }
false;private;1;9;;private void runConnection(Connection connection) throws IOException, Exception {     try {         addConnection(connection).         connection.run().     } finally {         removeConnection(connection).     } }
false;public;1;7;;@Override public Thread newThread(Runnable r) {     Thread thread = new Thread(r).     thread.setDaemon(true).     thread.setName("Live Reload #" + this.threadNumber.getAndIncrement()).     return thread. }
