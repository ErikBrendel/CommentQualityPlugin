commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private boolean isFolderUrl(String urlString) {     return urlString.startsWith("file:") && urlString.endsWith("/"). }
false;public;0;4;;@Override public Iterator<URL> iterator() {     return this.urls.iterator(). }
false;public;0;3;;public int size() {     return this.urls.size(). }
false;public;0;3;;public URL[] toArray() {     return this.urls.toArray(new URL[0]). }
false;public;0;3;;public List<URL> toList() {     return Collections.unmodifiableList(this.urls). }
false;public;0;4;;@Override public String toString() {     return this.urls.toString(). }
false;public,static;1;8;;public static ChangeableUrls fromClassLoader(ClassLoader classLoader) {     List<URL> urls = new ArrayList<>().     for (URL url : urlsFromClassLoader(classLoader)) {         urls.add(url).         urls.addAll(getUrlsFromClassPathOfJarManifestIfPossible(url)).     }     return fromUrls(urls). }
false;private,static;1;9;;private static URL[] urlsFromClassLoader(ClassLoader classLoader) {     if (classLoader instanceof URLClassLoader) {         return ((URLClassLoader) classLoader).getURLs().     }     return Stream.of(ManagementFactory.getRuntimeMXBean().getClassPath().split(File.pathSeparator)).map(ChangeableUrls::toURL).toArray(URL[]::new). }
false;private,static;1;9;;private static URL toURL(String classPathEntry) {     try {         return new File(classPathEntry).toURI().toURL().     } catch (MalformedURLException ex) {         throw new IllegalArgumentException("URL could not be created from '" + classPathEntry + "'", ex).     } }
false;private,static;1;14;;private static List<URL> getUrlsFromClassPathOfJarManifestIfPossible(URL url) {     JarFile jarFile = getJarFileIfPossible(url).     if (jarFile == null) {         return Collections.emptyList().     }     try {         return getUrlsFromManifestClassPathAttribute(url, jarFile).     } catch (IOException ex) {         throw new IllegalStateException("Failed to read Class-Path attribute from manifest of jar " + url, ex).     } }
false;private,static;1;12;;private static JarFile getJarFileIfPossible(URL url) {     try {         File file = new File(url.toURI()).         if (file.isFile()) {             return new JarFile(file).         }     } catch (Exception ex) {     // Assume it's not a jar and continue     }     return null. }
false;private,static;2;36;;private static List<URL> getUrlsFromManifestClassPathAttribute(URL jarUrl, JarFile jarFile) throws IOException {     Manifest manifest = jarFile.getManifest().     if (manifest == null) {         return Collections.emptyList().     }     String classPath = manifest.getMainAttributes().getValue(Attributes.Name.CLASS_PATH).     if (!StringUtils.hasText(classPath)) {         return Collections.emptyList().     }     String[] entries = StringUtils.delimitedListToStringArray(classPath, " ").     List<URL> urls = new ArrayList<>(entries.length).     List<URL> nonExistentEntries = new ArrayList<>().     for (String entry : entries) {         try {             URL referenced = new URL(jarUrl, entry).             if (new File(referenced.getFile()).exists()) {                 urls.add(referenced).             } else {                 nonExistentEntries.add(referenced).             }         } catch (MalformedURLException ex) {             throw new IllegalStateException("Class-Path attribute contains malformed URL", ex).         }     }     if (!nonExistentEntries.isEmpty()) {         System.out.println("The Class-Path manifest attribute in " + jarFile.getName() + " referenced one or more files that do not exist: " + StringUtils.collectionToCommaDelimitedString(nonExistentEntries)).     }     return urls. }
false;public,static;1;3;;public static ChangeableUrls fromUrls(Collection<URL> urls) {     return fromUrls(new ArrayList<>(urls).toArray(new URL[urls.size()])). }
false;public,static;1;3;;public static ChangeableUrls fromUrls(URL... urls) {     return new ChangeableUrls(urls). }
