commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return the sequence number of the payload.  * @return the sequence  */ ;/**  * Return the sequence number of the payload.  * @return the sequence  */ public long getSequence() {     return this.sequence. }
true;public;1;12;/**  * Assign this payload to the given {@link HttpOutputMessage}.  * @param message the message to assign this payload to  * @throws IOException in case of I/O errors  */ ;/**  * Assign this payload to the given {@link HttpOutputMessage}.  * @param message the message to assign this payload to  * @throws IOException in case of I/O errors  */ public void assignTo(HttpOutputMessage message) throws IOException {     Assert.notNull(message, "Message must not be null").     HttpHeaders headers = message.getHeaders().     headers.setContentLength(this.data.remaining()).     headers.add(SEQ_HEADER, Long.toString(getSequence())).     headers.setContentType(MediaType.APPLICATION_OCTET_STREAM).     WritableByteChannel body = Channels.newChannel(message.getBody()).     while (this.data.hasRemaining()) {         body.write(this.data).     }     body.close(). }
true;public;1;6;/**  * Write the content of this payload to the given target channel.  * @param channel the channel to write to  * @throws IOException in case of I/O errors  */ ;/**  * Write the content of this payload to the given target channel.  * @param channel the channel to write to  * @throws IOException in case of I/O errors  */ public void writeTo(WritableByteChannel channel) throws IOException {     Assert.notNull(channel, "Channel must not be null").     while (this.data.hasRemaining()) {         channel.write(this.data).     } }
true;public,static;1;16;/**  * Return the {@link HttpTunnelPayload} for the given message or {@code null} if there  * is no payload.  * @param message the HTTP message  * @return the payload or {@code null}  * @throws IOException in case of I/O errors  */ ;/**  * Return the {@link HttpTunnelPayload} for the given message or {@code null} if there  * is no payload.  * @param message the HTTP message  * @return the payload or {@code null}  * @throws IOException in case of I/O errors  */ public static HttpTunnelPayload get(HttpInputMessage message) throws IOException {     long length = message.getHeaders().getContentLength().     if (length <= 0) {         return null.     }     String seqHeader = message.getHeaders().getFirst(SEQ_HEADER).     Assert.state(StringUtils.hasLength(seqHeader), "Missing sequence header").     ReadableByteChannel body = Channels.newChannel(message.getBody()).     ByteBuffer payload = ByteBuffer.allocate((int) length).     while (payload.hasRemaining()) {         body.read(payload).     }     body.close().     payload.flip().     return new HttpTunnelPayload(Long.valueOf(seqHeader), payload). }
true;public,static;1;13;/**  * Return the payload data for the given source {@link ReadableByteChannel} or null if  * the channel timed out whilst reading.  * @param channel the source channel  * @return payload data or {@code null}  * @throws IOException in case of I/O errors  */ ;/**  * Return the payload data for the given source {@link ReadableByteChannel} or null if  * the channel timed out whilst reading.  * @param channel the source channel  * @return payload data or {@code null}  * @throws IOException in case of I/O errors  */ public static ByteBuffer getPayloadData(ReadableByteChannel channel) throws IOException {     ByteBuffer buffer = ByteBuffer.allocate(BUFFER_SIZE).     try {         int amountRead = channel.read(buffer).         Assert.state(amountRead != -1, "Target server connection closed").         buffer.flip().         return buffer.     } catch (InterruptedIOException ex) {         return null.     } }
true;public;0;3;/**  * Log incoming payload information at trace level to aid diagnostics.  */ ;/**  * Log incoming payload information at trace level to aid diagnostics.  */ public void logIncoming() {     log("< "). }
true;public;0;3;/**  * Log incoming payload information at trace level to aid diagnostics.  */ ;/**  * Log incoming payload information at trace level to aid diagnostics.  */ public void logOutgoing() {     log("> "). }
false;private;1;5;;private void log(String prefix) {     if (logger.isTraceEnabled()) {         logger.trace(prefix + toHexString()).     } }
true;public;0;10;/**  * Return the payload as a hexadecimal string.  * @return the payload as a hex string  */ ;/**  * Return the payload as a hexadecimal string.  * @return the payload as a hex string  */ public String toHexString() {     byte[] bytes = this.data.array().     char[] hex = new char[this.data.remaining() * 2].     for (int i = this.data.position(). i < this.data.remaining(). i++) {         int b = bytes[i] & 0xFF.         hex[i * 2] = HEX_CHARS[b >>> 4].         hex[i * 2 + 1] = HEX_CHARS[b & 0x0F].     }     return new String(hex). }
