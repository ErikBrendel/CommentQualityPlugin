commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@After public void close() {     Thread.currentThread().setContextClassLoader(this.loader).     System.clearProperty("debug"). }
false;protected;0;5;;@Override protected void showUsage() {     CommandRunnerTests.this.calls.add(Call.SHOW_USAGE).     super.showUsage(). }
false;protected;1;5;;@Override protected boolean errorMessage(String message) {     CommandRunnerTests.this.calls.add(Call.ERROR_MESSAGE).     return super.errorMessage(message). }
false;protected;1;5;;@Override protected void printStackTrace(Exception ex) {     CommandRunnerTests.this.calls.add(Call.PRINT_STACK_TRACE).     super.printStackTrace(ex). }
false;public;0;31;;@Before public void setup() {     this.loader = Thread.currentThread().getContextClassLoader().     MockitoAnnotations.initMocks(this).     this.commandRunner = new CommandRunner("spring") {          @Override         protected void showUsage() {             CommandRunnerTests.this.calls.add(Call.SHOW_USAGE).             super.showUsage().         }          @Override         protected boolean errorMessage(String message) {             CommandRunnerTests.this.calls.add(Call.ERROR_MESSAGE).             return super.errorMessage(message).         }          @Override         protected void printStackTrace(Exception ex) {             CommandRunnerTests.this.calls.add(Call.PRINT_STACK_TRACE).             super.printStackTrace(ex).         }     }.     given(this.anotherCommand.getName()).willReturn("another").     given(this.regularCommand.getName()).willReturn("command").     given(this.regularCommand.getDescription()).willReturn("A regular command").     this.commandRunner.addCommand(this.regularCommand).     this.commandRunner.addCommand(new HelpCommand(this.commandRunner)).     this.commandRunner.addCommand(new HintCommand(this.commandRunner)). }
false;public;0;5;;@Test public void runWithoutArguments() throws Exception {     assertThatExceptionOfType(NoArgumentsException.class).isThrownBy(this.commandRunner::run). }
false;public;0;5;;@Test public void runCommand() throws Exception {     this.commandRunner.run("command", "--arg1", "arg2").     verify(this.regularCommand).run("--arg1", "arg2"). }
false;public;0;5;;@Test public void missingCommand() throws Exception {     assertThatExceptionOfType(NoSuchCommandException.class).isThrownBy(() -> this.commandRunner.run("missing")). }
false;public;0;8;;@Test public void appArguments() throws Exception {     this.commandRunner.runAndHandleErrors("command", "--", "--debug", "bar").     verify(this.regularCommand).run("--", "--debug", "bar").     // When handled by the command itself it shouldn't cause the system property to be     // set     assertThat(System.getProperty("debug")).isNull(). }
false;public;0;6;;@Test public void handlesSuccess() {     int status = this.commandRunner.runAndHandleErrors("command").     assertThat(status).isEqualTo(0).     assertThat(this.calls).isEmpty(). }
false;public;0;6;;@Test public void handlesNoSuchCommand() {     int status = this.commandRunner.runAndHandleErrors("missing").     assertThat(status).isEqualTo(1).     assertThat(this.calls).containsOnly(Call.ERROR_MESSAGE). }
false;public;0;7;;@Test public void handlesRegularExceptionWithMessage() throws Exception {     willThrow(new RuntimeException("With Message")).given(this.regularCommand).run().     int status = this.commandRunner.runAndHandleErrors("command").     assertThat(status).isEqualTo(1).     assertThat(this.calls).containsOnly(Call.ERROR_MESSAGE). }
false;public;0;7;;@Test public void handlesRegularExceptionWithoutMessage() throws Exception {     willThrow(new NullPointerException()).given(this.regularCommand).run().     int status = this.commandRunner.runAndHandleErrors("command").     assertThat(status).isEqualTo(1).     assertThat(this.calls).containsOnly(Call.ERROR_MESSAGE, Call.PRINT_STACK_TRACE). }
false;public;0;8;;@Test public void handlesExceptionWithDashD() throws Exception {     willThrow(new RuntimeException()).given(this.regularCommand).run().     int status = this.commandRunner.runAndHandleErrors("command", "-d").     assertThat(System.getProperty("debug")).isEqualTo("true").     assertThat(status).isEqualTo(1).     assertThat(this.calls).containsOnly(Call.ERROR_MESSAGE, Call.PRINT_STACK_TRACE). }
false;public;0;8;;@Test public void handlesExceptionWithDashDashDebug() throws Exception {     willThrow(new RuntimeException()).given(this.regularCommand).run().     int status = this.commandRunner.runAndHandleErrors("command", "--debug").     assertThat(System.getProperty("debug")).isEqualTo("true").     assertThat(status).isEqualTo(1).     assertThat(this.calls).containsOnly(Call.ERROR_MESSAGE, Call.PRINT_STACK_TRACE). }
false;public;0;5;;@Test public void exceptionMessages() {     assertThat(new NoSuchCommandException("name").getMessage()).isEqualTo("'name' is not a valid command. See 'help'."). }
false;public;0;5;;@Test public void help() throws Exception {     this.commandRunner.run("help", "command").     verify(this.regularCommand).getHelp(). }
false;public;0;5;;@Test public void helpNoCommand() throws Exception {     assertThatExceptionOfType(NoHelpCommandArgumentsException.class).isThrownBy(() -> this.commandRunner.run("help")). }
false;public;0;5;;@Test public void helpUnknownCommand() throws Exception {     assertThatExceptionOfType(NoSuchCommandException.class).isThrownBy(() -> this.commandRunner.run("help", "missing")). }
