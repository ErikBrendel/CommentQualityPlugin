commented;modifiers;parameterAmount;loc;comment;code
false;public;2;3;;public OptionSpecBuilder option(String name, String description) {     return getParser().accepts(name, description). }
false;public;2;3;;public OptionSpecBuilder option(List<String> aliases, String description) {     return getParser().acceptsAll(aliases, description). }
false;public;0;7;;public OptionParser getParser() {     if (this.parser == null) {         this.parser = new OptionParser().         options().     }     return this.parser. }
false;protected;0;2;;protected void options() { }
false;public,final;1;10;;public final ExitStatus run(String... args) throws Exception {     String[] argsToUse = args.clone().     for (int i = 0. i < argsToUse.length. i++) {         if ("-cp".equals(argsToUse[i])) {             argsToUse[i] = "--cp".         }     }     OptionSet options = getParser().parse(argsToUse).     return run(options). }
true;protected;1;3;/**  * Run the command using the specified parsed {@link OptionSet}.  * @param options the parsed option set  * @return an ExitStatus  * @throws Exception in case of errors  */ ;/**  * Run the command using the specified parsed {@link OptionSet}.  * @param options the parsed option set  * @return an ExitStatus  * @throws Exception in case of errors  */ protected ExitStatus run(OptionSet options) throws Exception {     return ExitStatus.OK. }
false;public;0;14;;public String getHelp() {     if (this.help == null) {         getParser().formatHelpWith(new BuiltinHelpFormatter(80, 2)).         OutputStream out = new ByteArrayOutputStream().         try {             getParser().printHelpOn(out).         } catch (IOException ex) {             return "Help not available".         }         this.help = out.toString().replace(" --cp ", " -cp  ").     }     return this.help. }
false;public;0;14;;public Collection<OptionHelp> getOptionsHelp() {     if (this.optionHelp == null) {         OptionHelpFormatter formatter = new OptionHelpFormatter().         getParser().formatHelpWith(formatter).         try {             getParser().printHelpOn(new ByteArrayOutputStream()).         } catch (Exception ex) {         // Ignore and provide no hints         }         this.optionHelp = formatter.getOptionHelp().     }     return this.optionHelp. }
false;public;1;13;;@Override public String format(Map<String, ? extends OptionDescriptor> options) {     Comparator<OptionDescriptor> comparator = Comparator.comparing((optionDescriptor) -> optionDescriptor.options().iterator().next()).     Set<OptionDescriptor> sorted = new TreeSet<>(comparator).     sorted.addAll(options.values()).     for (OptionDescriptor descriptor : sorted) {         if (!descriptor.representsNonOptions()) {             this.help.add(new OptionHelpAdapter(descriptor)).         }     }     return "". }
false;public;0;3;;public Collection<OptionHelp> getOptionHelp() {     return Collections.unmodifiableList(this.help). }
false;public;0;4;;@Override public Set<String> getOptions() {     return this.options. }
false;public;0;4;;@Override public String getUsageHelp() {     return this.description. }
