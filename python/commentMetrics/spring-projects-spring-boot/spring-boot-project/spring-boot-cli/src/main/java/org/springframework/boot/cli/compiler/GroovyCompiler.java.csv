commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Return a mutable list of the {@link ASTTransformation}s to be applied during  * {@link #compile(String...)}.  * @return the AST transformations to apply  */ ;/**  * Return a mutable list of the {@link ASTTransformation}s to be applied during  * {@link #compile(String...)}.  * @return the AST transformations to apply  */ public List<ASTTransformation> getAstTransformations() {     return this.transformations. }
false;public;0;3;;public ExtendedGroovyClassLoader getLoader() {     return this.loader. }
false;private;1;16;;private ExtendedGroovyClassLoader createLoader(GroovyCompilerConfiguration configuration) {     ExtendedGroovyClassLoader loader = new ExtendedGroovyClassLoader(configuration.getScope()).     for (URL url : getExistingUrls()) {         loader.addURL(url).     }     for (String classpath : configuration.getClasspath()) {         loader.addClasspath(classpath).     }     return loader. }
false;private;0;9;;private URL[] getExistingUrls() {     ClassLoader tccl = Thread.currentThread().getContextClassLoader().     if (tccl instanceof ExtendedGroovyClassLoader) {         return ((ExtendedGroovyClassLoader) tccl).getURLs().     } else {         return new URL[0].     } }
false;public;1;3;;public void addCompilationCustomizers(CompilationCustomizer... customizers) {     this.loader.getConfiguration().addCompilationCustomizers(customizers). }
true;public;1;41;/**  * Compile the specified Groovy sources, applying any  * {@link CompilerAutoConfiguration}s. All classes defined in the sources will be  * returned from this method.  * @param sources the sources to compile  * @return compiled classes  * @throws CompilationFailedException in case of compilation failures  * @throws IOException in case of I/O errors  * @throws CompilationFailedException in case of compilation errors  */ ;/**  * Compile the specified Groovy sources, applying any  * {@link CompilerAutoConfiguration}s. All classes defined in the sources will be  * returned from this method.  * @param sources the sources to compile  * @return compiled classes  * @throws CompilationFailedException in case of compilation failures  * @throws IOException in case of I/O errors  * @throws CompilationFailedException in case of compilation errors  */ public Class<?>[] compile(String... sources) throws CompilationFailedException, IOException {     this.loader.clearCache().     List<Class<?>> classes = new ArrayList<>().     CompilerConfiguration configuration = this.loader.getConfiguration().     CompilationUnit compilationUnit = new CompilationUnit(configuration, null, this.loader).     ClassCollector collector = this.loader.createCollector(compilationUnit, null).     compilationUnit.setClassgenCallback(collector).     for (String source : sources) {         List<String> paths = ResourceUtils.getUrls(source, this.loader).         for (String path : paths) {             compilationUnit.addSource(new URL(path)).         }     }     addAstTransformations(compilationUnit).     compilationUnit.compile(Phases.CLASS_GENERATION).     for (Object loadedClass : collector.getLoadedClasses()) {         classes.add((Class<?>) loadedClass).     }     ClassNode mainClassNode = MainClass.get(compilationUnit).     Class<?> mainClass = null.     for (Class<?> loadedClass : classes) {         if (mainClassNode.getName().equals(loadedClass.getName())) {             mainClass = loadedClass.         }     }     if (mainClass != null) {         classes.remove(mainClass).         classes.add(0, mainClass).     }     return ClassUtils.toClassArray(classes). }
false;private;1;5;;@SuppressWarnings("rawtypes") private void addAstTransformations(CompilationUnit compilationUnit) {     LinkedList[] phaseOperations = getPhaseOperations(compilationUnit).     processConversionOperations(phaseOperations[Phases.CONVERSION]). }
false;private;1;12;;@SuppressWarnings("rawtypes") private LinkedList[] getPhaseOperations(CompilationUnit compilationUnit) {     try {         Field field = CompilationUnit.class.getDeclaredField("phaseOperations").         field.setAccessible(true).         return (LinkedList[]) field.get(compilationUnit).     } catch (Exception ex) {         throw new IllegalStateException("Phase operations not available from compilation unit").     } }
false;public;1;7;;@Override public void call(SourceUnit source) throws CompilationFailedException {     ASTNode[] nodes = new ASTNode[] { source.getAST() }.     for (ASTTransformation transformation : GroovyCompiler.this.transformations) {         transformation.visit(nodes, source).     } }
false;private;1;13;;@SuppressWarnings({ "rawtypes", "unchecked" }) private void processConversionOperations(LinkedList conversionOperations) {     int index = getIndexOfASTTransformationVisitor(conversionOperations).     conversionOperations.add(index, new CompilationUnit.SourceUnitOperation() {          @Override         public void call(SourceUnit source) throws CompilationFailedException {             ASTNode[] nodes = new ASTNode[] { source.getAST() }.             for (ASTTransformation transformation : GroovyCompiler.this.transformations) {                 transformation.visit(nodes, source).             }         }     }). }
false;private;1;9;;private int getIndexOfASTTransformationVisitor(List<?> conversionOperations) {     for (int index = 0. index < conversionOperations.size(). index++) {         if (conversionOperations.get(index).getClass().getName().startsWith(ASTTransformationVisitor.class.getName())) {             return index.         }     }     return conversionOperations.size(). }
false;public;3;26;;@Override public void call(SourceUnit source, GeneratorContext context, ClassNode classNode) throws CompilationFailedException {     ImportCustomizer importCustomizer = new SmartImportCustomizer(source).     ClassNode mainClassNode = MainClass.get(source.getAST().getClasses()).     // Additional auto configuration     for (CompilerAutoConfiguration autoConfiguration : GroovyCompiler.this.compilerAutoConfigurations) {         if (autoConfiguration.matches(classNode)) {             if (GroovyCompiler.this.configuration.isGuessImports()) {                 autoConfiguration.applyImports(importCustomizer).                 importCustomizer.call(source, context, classNode).             }             if (classNode.equals(mainClassNode)) {                 autoConfiguration.applyToMainClass(GroovyCompiler.this.loader, GroovyCompiler.this.configuration, context, source, classNode).             }             autoConfiguration.apply(GroovyCompiler.this.loader, GroovyCompiler.this.configuration, context, source, classNode).         }     }     importCustomizer.call(source, context, classNode). }
false;public,static;1;3;;public static ClassNode get(CompilationUnit source) {     return get(source.getAST().getClasses()). }
false;public,static;1;12;;public static ClassNode get(List<ClassNode> classes) {     for (ClassNode node : classes) {         if (AstUtils.hasAtLeastOneAnnotation(node, "Enable*AutoConfiguration")) {             // No need to enhance this             return null.         }         if (AstUtils.hasAtLeastOneAnnotation(node, "*Controller", "Configuration", "Component", "*Service", "Repository", "Enable*")) {             return node.         }     }     return classes.isEmpty() ? null : classes.get(0). }
