commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getUsageHelp() {     return "[options] <" + getName() + "-name> <files>". }
false;protected;0;3;;protected Layout getLayout() {     return this.layout. }
false;protected;0;11;;@Override protected void doOptions() {     this.includeOption = option("include", "Pattern applied to directories on the classpath to find files to " + "include in the resulting ").withRequiredArg().withValuesSeparatedBy(",").defaultsTo("").     this.excludeOption = option("exclude", "Pattern applied to directories on the classpath to find files to " + "exclude from the resulting " + this.type).withRequiredArg().withValuesSeparatedBy(",").defaultsTo(""). }
false;protected;1;31;;@Override protected ExitStatus run(OptionSet options) throws Exception {     List<?> nonOptionArguments = new ArrayList<Object>(options.nonOptionArguments()).     Assert.isTrue(nonOptionArguments.size() >= 2, () -> "The name of the " + "resulting " + this.type + " and at least one source file must be " + "specified").     File output = new File((String) nonOptionArguments.remove(0)).     Assert.isTrue(output.getName().toLowerCase(Locale.ENGLISH).endsWith("." + this.type), () -> "The output '" + output + "' is not a " + this.type.toUpperCase(Locale.ENGLISH) + " file.").     deleteIfExists(output).     GroovyCompiler compiler = createCompiler(options).     List<URL> classpath = getClassPathUrls(compiler).     List<MatchedResource> classpathEntries = findMatchingClasspathEntries(classpath, options).     String[] sources = new SourceOptions(nonOptionArguments).getSourcesArray().     Class<?>[] compiledClasses = compiler.compile(sources).     List<URL> dependencies = getClassPathUrls(compiler).     dependencies.removeAll(classpath).     writeJar(output, compiledClasses, classpathEntries, dependencies).     return ExitStatus.OK. }
false;private;1;6;;private void deleteIfExists(File file) {     if (file.exists() && !file.delete()) {         throw new IllegalStateException("Failed to delete existing file " + file.getPath()).     } }
false;private;1;9;;private GroovyCompiler createCompiler(OptionSet options) {     List<RepositoryConfiguration> repositoryConfiguration = RepositoryConfigurationFactory.createDefaultRepositoryConfiguration().     GroovyCompilerConfiguration configuration = new OptionSetGroovyCompilerConfiguration(options, this, repositoryConfiguration).     GroovyCompiler groovyCompiler = new GroovyCompiler(configuration).     groovyCompiler.getAstTransformations().add(0, new GrabAnnotationTransform()).     return groovyCompiler. }
false;private;1;3;;private List<URL> getClassPathUrls(GroovyCompiler compiler) {     return new ArrayList<>(Arrays.asList(compiler.getLoader().getURLs())). }
false;private;2;11;;private List<MatchedResource> findMatchingClasspathEntries(List<URL> classpath, OptionSet options) throws IOException {     ResourceMatcher matcher = new ResourceMatcher(options.valuesOf(this.includeOption), options.valuesOf(this.excludeOption)).     List<File> roots = new ArrayList<>().     for (URL classpathEntry : classpath) {         roots.add(new File(URI.create(classpathEntry.toString()))).     }     return matcher.find(roots). }
false;private;4;21;;private void writeJar(File file, Class<?>[] compiledClasses, List<MatchedResource> classpathEntries, List<URL> dependencies) throws FileNotFoundException, IOException, URISyntaxException {     final List<Library> libraries.     try (JarWriter writer = new JarWriter(file)) {         addManifest(writer, compiledClasses).         addCliClasses(writer).         for (Class<?> compiledClass : compiledClasses) {             addClass(writer, compiledClass).         }         libraries = addClasspathEntries(writer, classpathEntries).     }     libraries.addAll(createLibraries(dependencies)).     Repackager repackager = new Repackager(file).     repackager.setMainClass(PackagedSpringApplicationLauncher.class.getName()).     repackager.repackage((callback) -> {         for (Library library : libraries) {             callback.library(library).         }     }). }
false;private;1;9;;private List<Library> createLibraries(List<URL> dependencies) throws URISyntaxException {     List<Library> libraries = new ArrayList<>().     for (URL dependency : dependencies) {         File file = new File(dependency.toURI()).         libraries.add(new Library(file, getLibraryScope(file))).     }     return libraries. }
false;private;2;9;;private void addManifest(JarWriter writer, Class<?>[] compiledClasses) throws IOException {     Manifest manifest = new Manifest().     manifest.getMainAttributes().putValue("Manifest-Version", "1.0").     manifest.getMainAttributes().putValue(PackagedSpringApplicationLauncher.SOURCE_ENTRY, commaDelimitedClassNames(compiledClasses)).     writer.writeManifest(manifest). }
false;private;1;10;;private String commaDelimitedClassNames(Class<?>[] classes) {     StringBuilder builder = new StringBuilder().     for (int i = 0. i < classes.length. i++) {         if (i != 0) {             builder.append(',').         }         builder.append(classes[i].getName()).     }     return builder.toString(). }
false;protected;1;11;;protected void addCliClasses(JarWriter writer) throws IOException {     addClass(writer, PackagedSpringApplicationLauncher.class).     addClass(writer, SpringApplicationLauncher.class).     Resource[] resources = new PathMatchingResourcePatternResolver().getResources("org/springframework/boot/groovy/**").     for (Resource resource : resources) {         String url = resource.getURL().toString().         addResource(writer, resource, url.substring(url.indexOf("org/springframework/boot/groovy/"))).     } }
false;protected,final;2;4;;protected final void addClass(JarWriter writer, Class<?> sourceClass) throws IOException {     addClass(writer, sourceClass.getClassLoader(), sourceClass.getName()). }
false;protected,final;3;9;;protected final void addClass(JarWriter writer, ClassLoader classLoader, String sourceClass) throws IOException {     if (classLoader == null) {         classLoader = Thread.currentThread().getContextClassLoader().     }     String name = sourceClass.replace('.', '/') + ".class".     InputStream stream = classLoader.getResourceAsStream(name).     writer.writeEntry(this.layout.getClassesLocation() + name, stream). }
false;private;3;5;;private void addResource(JarWriter writer, Resource resource, String name) throws IOException {     InputStream stream = resource.getInputStream().     writer.writeEntry(name, stream). }
false;private;2;13;;private List<Library> addClasspathEntries(JarWriter writer, List<MatchedResource> entries) throws IOException {     List<Library> libraries = new ArrayList<>().     for (MatchedResource entry : entries) {         if (entry.isRoot()) {             libraries.add(new Library(entry.getFile(), LibraryScope.COMPILE)).         } else {             writeClasspathEntry(writer, entry).         }     }     return libraries. }
false;protected;2;4;;protected void writeClasspathEntry(JarWriter writer, MatchedResource entry) throws IOException {     writer.writeEntry(entry.getName(), new FileInputStream(entry.getFile())). }
false;protected,abstract;1;1;;protected abstract LibraryScope getLibraryScope(File file).
false;public;2;8;;@Override public void visit(ASTNode[] nodes, SourceUnit source) {     for (ASTNode node : nodes) {         if (node instanceof ModuleNode) {             visitModule((ModuleNode) node).         }     } }
false;private;1;13;;private void visitModule(ModuleNode module) {     for (ClassNode classNode : module.getClasses()) {         AnnotationNode annotation = new AnnotationNode(new ClassNode(Grab.class)).         annotation.addMember("value", new ConstantExpression("groovy")).         classNode.addAnnotation(annotation).         // We only need to do it at most once         break.     }     // Disable the addition of a static initializer that calls Grape.addResolver     // because all the dependencies are local now     disableGrabResolvers(module.getClasses()).     disableGrabResolvers(module.getImports()). }
false;private;1;11;;private void disableGrabResolvers(List<? extends AnnotatedNode> nodes) {     for (AnnotatedNode classNode : nodes) {         List<AnnotationNode> annotations = classNode.getAnnotations().         for (AnnotationNode node : new ArrayList<>(annotations)) {             if (node.getClassNode().getNameWithoutPackage().equals("GrabResolver")) {                 node.setMember("initClass", new ConstantExpression(false)).             }         }     } }
