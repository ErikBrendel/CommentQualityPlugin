commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public String getVersion(String artifactId) {     return getVersion(artifactId, ""). }
false;public;2;8;;public String getVersion(String artifactId, String defaultVersion) {     String version = this.dependencyResolutionContext.getArtifactCoordinatesResolver().getVersion(artifactId).     if (version == null) {         version = defaultVersion.     }     return version. }
false;protected;0;12;;@Override protected boolean canAdd() {     for (String className : classNames) {         try {             DependencyCustomizer.this.loader.loadClass(className).         } catch (Exception ex) {             return true.         }     }     return false. }
true;public;1;16;/**  * Create a nested {@link DependencyCustomizer} that only applies if any of the  * specified class names are not on the class path.  * @param classNames the class names to test  * @return a nested {@link DependencyCustomizer}  */ ;/**  * Create a nested {@link DependencyCustomizer} that only applies if any of the  * specified class names are not on the class path.  * @param classNames the class names to test  * @return a nested {@link DependencyCustomizer}  */ public DependencyCustomizer ifAnyMissingClasses(String... classNames) {     return new DependencyCustomizer(this) {          @Override         protected boolean canAdd() {             for (String className : classNames) {                 try {                     DependencyCustomizer.this.loader.loadClass(className).                 } catch (Exception ex) {                     return true.                 }             }             return false.         }     }. }
false;protected;0;13;;@Override protected boolean canAdd() {     for (String className : classNames) {         try {             DependencyCustomizer.this.loader.loadClass(className).             return false.         } catch (Exception ex) {         // swallow exception and continue         }     }     return DependencyCustomizer.this.canAdd(). }
true;public;1;17;/**  * Create a nested {@link DependencyCustomizer} that only applies if all of the  * specified class names are not on the class path.  * @param classNames the class names to test  * @return a nested {@link DependencyCustomizer}  */ ;/**  * Create a nested {@link DependencyCustomizer} that only applies if all of the  * specified class names are not on the class path.  * @param classNames the class names to test  * @return a nested {@link DependencyCustomizer}  */ public DependencyCustomizer ifAllMissingClasses(String... classNames) {     return new DependencyCustomizer(this) {          @Override         protected boolean canAdd() {             for (String className : classNames) {                 try {                     DependencyCustomizer.this.loader.loadClass(className).                     return false.                 } catch (Exception ex) {                 // swallow exception and continue                 }             }             return DependencyCustomizer.this.canAdd().         }     }. }
false;protected;0;15;;@Override protected boolean canAdd() {     for (String path : paths) {         try {             if (DependencyCustomizer.this.loader.getResource(path) == null) {                 return false.             }             return true.         } catch (Exception ex) {         // swallow exception and continue         }     }     return DependencyCustomizer.this.canAdd(). }
true;public;1;19;/**  * Create a nested {@link DependencyCustomizer} that only applies if the specified  * paths are on the class path.  * @param paths the paths to test  * @return a nested {@link DependencyCustomizer}  */ ;/**  * Create a nested {@link DependencyCustomizer} that only applies if the specified  * paths are on the class path.  * @param paths the paths to test  * @return a nested {@link DependencyCustomizer}  */ public DependencyCustomizer ifAllResourcesPresent(String... paths) {     return new DependencyCustomizer(this) {          @Override         protected boolean canAdd() {             for (String path : paths) {                 try {                     if (DependencyCustomizer.this.loader.getResource(path) == null) {                         return false.                     }                     return true.                 } catch (Exception ex) {                 // swallow exception and continue                 }             }             return DependencyCustomizer.this.canAdd().         }     }. }
false;protected;0;15;;@Override protected boolean canAdd() {     for (String path : paths) {         try {             if (DependencyCustomizer.this.loader.getResource(path) != null) {                 return true.             }             return false.         } catch (Exception ex) {         // swallow exception and continue         }     }     return DependencyCustomizer.this.canAdd(). }
true;public;1;19;/**  * Create a nested {@link DependencyCustomizer} that only applies at least one of the  * specified paths is on the class path.  * @param paths the paths to test  * @return a nested {@link DependencyCustomizer}  */ ;/**  * Create a nested {@link DependencyCustomizer} that only applies at least one of the  * specified paths is on the class path.  * @param paths the paths to test  * @return a nested {@link DependencyCustomizer}  */ public DependencyCustomizer ifAnyResourcesPresent(String... paths) {     return new DependencyCustomizer(this) {          @Override         protected boolean canAdd() {             for (String path : paths) {                 try {                     if (DependencyCustomizer.this.loader.getResource(path) != null) {                         return true.                     }                     return false.                 } catch (Exception ex) {                 // swallow exception and continue                 }             }             return DependencyCustomizer.this.canAdd().         }     }. }
true;public;1;6;/**  * Add dependencies and all of their dependencies. The group ID and version of the  * dependencies are resolved from the modules using the customizer's  * {@link ArtifactCoordinatesResolver}.  * @param modules the module IDs  * @return this {@link DependencyCustomizer} for continued use  */ ;/**  * Add dependencies and all of their dependencies. The group ID and version of the  * dependencies are resolved from the modules using the customizer's  * {@link ArtifactCoordinatesResolver}.  * @param modules the module IDs  * @return this {@link DependencyCustomizer} for continued use  */ public DependencyCustomizer add(String... modules) {     for (String module : modules) {         add(module, null, null, true).     }     return this. }
true;public;2;3;/**  * Add a single dependency and, optionally, all of its dependencies. The group ID and  * version of the dependency are resolved from the module using the customizer's  * {@link ArtifactCoordinatesResolver}.  * @param module the module ID  * @param transitive {@code true} if the transitive dependencies should also be added,  * otherwise {@code false}  * @return this {@link DependencyCustomizer} for continued use  */ ;/**  * Add a single dependency and, optionally, all of its dependencies. The group ID and  * version of the dependency are resolved from the module using the customizer's  * {@link ArtifactCoordinatesResolver}.  * @param module the module ID  * @param transitive {@code true} if the transitive dependencies should also be added,  * otherwise {@code false}  * @return this {@link DependencyCustomizer} for continued use  */ public DependencyCustomizer add(String module, boolean transitive) {     return add(module, null, null, transitive). }
true;public;4;13;/**  * Add a single dependency with the specified classifier and type and, optionally, all  * of its dependencies. The group ID and version of the dependency are resolved from  * the module by using the customizer's {@link ArtifactCoordinatesResolver}.  * @param module the module ID  * @param classifier the classifier, may be {@code null}  * @param type the type, may be {@code null}  * @param transitive {@code true} if the transitive dependencies should also be added,  * otherwise {@code false}  * @return this {@link DependencyCustomizer} for continued use  */ ;/**  * Add a single dependency with the specified classifier and type and, optionally, all  * of its dependencies. The group ID and version of the dependency are resolved from  * the module by using the customizer's {@link ArtifactCoordinatesResolver}.  * @param module the module ID  * @param classifier the classifier, may be {@code null}  * @param type the type, may be {@code null}  * @param transitive {@code true} if the transitive dependencies should also be added,  * otherwise {@code false}  * @return this {@link DependencyCustomizer} for continued use  */ public DependencyCustomizer add(String module, String classifier, String type, boolean transitive) {     if (canAdd()) {         ArtifactCoordinatesResolver artifactCoordinatesResolver = this.dependencyResolutionContext.getArtifactCoordinatesResolver().         this.classNode.addAnnotation(createGrabAnnotation(artifactCoordinatesResolver.getGroupId(module), artifactCoordinatesResolver.getArtifactId(module), artifactCoordinatesResolver.getVersion(module), classifier, type, transitive)).     }     return this. }
false;private;6;16;;private AnnotationNode createGrabAnnotation(String group, String module, String version, String classifier, String type, boolean transitive) {     AnnotationNode annotationNode = new AnnotationNode(new ClassNode(Grab.class)).     annotationNode.addMember("group", new ConstantExpression(group)).     annotationNode.addMember("module", new ConstantExpression(module)).     annotationNode.addMember("version", new ConstantExpression(version)).     if (classifier != null) {         annotationNode.addMember("classifier", new ConstantExpression(classifier)).     }     if (type != null) {         annotationNode.addMember("type", new ConstantExpression(type)).     }     annotationNode.addMember("transitive", new ConstantExpression(transitive)).     annotationNode.addMember("initClass", new ConstantExpression(false)).     return annotationNode. }
true;protected;0;3;/**  * Strategy called to test if dependencies can be added. Subclasses override as  * required. Returns {@code true} by default.  * @return {@code true} if dependencies can be added, otherwise {@code false}  */ ;/**  * Strategy called to test if dependencies can be added. Subclasses override as  * required. Returns {@code true} by default.  * @return {@code true} if dependencies can be added, otherwise {@code false}  */ protected boolean canAdd() {     return true. }
true;public;0;3;/**  * Returns the {@link DependencyResolutionContext}.  * @return the dependency resolution context  */ ;/**  * Returns the {@link DependencyResolutionContext}.  * @return the dependency resolution context  */ public DependencyResolutionContext getDependencyResolutionContext() {     return this.dependencyResolutionContext. }
