commented;modifiers;parameterAmount;loc;comment;code
true;public;0;21;/**  * Compile and run the application.  * @throws Exception on error  */ ;/**  * Compile and run the application.  * @throws Exception on error  */ public void compileAndRun() throws Exception {     synchronized (this.monitor) {         try {             stop().             Class<?>[] compiledSources = compile().             monitorForChanges().             // Run in new thread to ensure that the context classloader is setup             this.runThread = new RunThread(compiledSources).             this.runThread.start().             this.runThread.join().         } catch (Exception ex) {             if (this.fileWatchThread == null) {                 throw ex.             } else {                 ex.printStackTrace().             }         }     } }
false;public;0;8;;public void stop() {     synchronized (this.monitor) {         if (this.runThread != null) {             this.runThread.shutdown().             this.runThread = null.         }     } }
false;private;0;8;;private Class<?>[] compile() throws IOException {     Class<?>[] compiledSources = this.compiler.compile(this.sources).     if (compiledSources.length == 0) {         throw new RuntimeException("No classes found in '" + Arrays.toString(this.sources) + "'").     }     return compiledSources. }
false;private;0;6;;private void monitorForChanges() {     if (this.fileWatchThread == null && this.configuration.isWatchForFileChanges()) {         this.fileWatchThread = new FileWatchThread().         this.fileWatchThread.start().     } }
false;public;0;13;;@Override public void run() {     synchronized (this.monitor) {         try {             this.applicationContext = new SpringApplicationLauncher(getContextClassLoader()).launch(this.compiledSources, SpringApplicationRunner.this.args).         } catch (Exception ex) {             ex.printStackTrace().         }     } }
true;public;0;20;/**  * Shutdown the thread, closing any previously opened application context.  */ ;/**  * Shutdown the thread, closing any previously opened application context.  */ public void shutdown() {     synchronized (this.monitor) {         if (this.applicationContext != null) {             try {                 Method method = this.applicationContext.getClass().getMethod("close").                 method.invoke(this.applicationContext).             } catch (NoSuchMethodException ex) {             // Not an application context that we can close             } catch (Exception ex) {                 ex.printStackTrace().             } finally {                 this.applicationContext = null.             }         }     } }
false;private;0;19;;private List<File> getSourceFiles() {     List<File> sources = new ArrayList<>().     for (String source : SpringApplicationRunner.this.sources) {         List<String> paths = ResourceUtils.getUrls(source, SpringApplicationRunner.this.compiler.getLoader()).         for (String path : paths) {             try {                 URL url = new URL(path).                 if ("file".equals(url.getProtocol())) {                     sources.add(new File(url.getFile())).                 }             } catch (MalformedURLException ex) {             // Ignore             }         }     }     return sources. }
false;public;0;23;;@Override public void run() {     while (true) {         try {             Thread.sleep(TimeUnit.SECONDS.toMillis(1)).             for (File file : this.sources) {                 if (file.exists()) {                     long current = file.lastModified().                     if (this.previous < current) {                         this.previous = current.                         compileAndRun().                     }                 }             }         } catch (InterruptedException ex) {             Thread.currentThread().interrupt().         } catch (Exception ex) {         // Swallow, will be reported by compileAndRun         }     } }
