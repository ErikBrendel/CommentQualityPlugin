commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Test public void contextFailsIfMultipleStoresAreAvailable() {     this.contextRunner.run((context) -> {         assertThat(context).hasFailed().         assertThat(context).getFailure().hasCauseInstanceOf(NonUniqueSessionRepositoryException.class).         assertThat(context).getFailure().hasMessageContaining("Multiple session repository candidates are available").     }). }
false;public;0;13;;@Test public void contextFailsIfStoreTypeNotAvailable() {     this.contextRunner.withPropertyValues("spring.session.store-type=jdbc").run((context) -> {         assertThat(context).hasFailed().         assertThat(context).getFailure().hasCauseInstanceOf(SessionRepositoryUnavailableException.class).         assertThat(context).getFailure().hasMessageContaining("No session repository could be auto-configured").         assertThat(context).getFailure().hasMessageContaining("session store type is 'jdbc'").     }). }
false;public;0;6;;@Test public void autoConfigurationDisabledIfStoreTypeSetToNone() {     this.contextRunner.withPropertyValues("spring.session.store-type=none").run((context) -> assertThat(context).doesNotHaveBean(SessionRepository.class)). }
false;public;0;10;;@Test public void backOffIfSessionRepositoryIsPresent() {     this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class).withPropertyValues("spring.session.store-type=redis").run((context) -> {         MapSessionRepository repository = validateSessionRepository(context, MapSessionRepository.class).         assertThat(context).getBean("mySessionRepository").isSameAs(repository).     }). }
false;public;0;11;;@Test public void autoConfigWhenSpringSessionTimeoutIsSetShouldUseThat() {     this.contextRunner.withUserConfiguration(ServerPropertiesConfiguration.class, SessionRepositoryConfiguration.class).withPropertyValues("server.servlet.session.timeout=1", "spring.session.timeout=3").run((context) -> assertThat(context.getBean(SessionProperties.class).getTimeout()).isEqualTo(Duration.ofSeconds(3))). }
false;public;0;10;;@Test public void autoConfigWhenSpringSessionTimeoutIsNotSetShouldUseServerSessionTimeout() {     this.contextRunner.withUserConfiguration(ServerPropertiesConfiguration.class, SessionRepositoryConfiguration.class).withPropertyValues("server.servlet.session.timeout=3").run((context) -> assertThat(context.getBean(SessionProperties.class).getTimeout()).isEqualTo(Duration.ofSeconds(3))). }
false;public;0;15;;@SuppressWarnings("unchecked") @Test public void filterIsRegisteredWithAsyncErrorAndRequestDispatcherTypes() {     this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class).run((context) -> {         FilterRegistrationBean<?> registration = context.getBean(FilterRegistrationBean.class).         assertThat(registration.getFilter()).isSameAs(context.getBean(SessionRepositoryFilter.class)).         assertThat((EnumSet<DispatcherType>) ReflectionTestUtils.getField(registration, "dispatcherTypes")).containsOnly(DispatcherType.ASYNC, DispatcherType.ERROR, DispatcherType.REQUEST).     }). }
false;public;0;10;;@Test public void filterOrderCanBeCustomizedWithCustomStore() {     this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class).withPropertyValues("spring.session.servlet.filter-order=123").run((context) -> {         FilterRegistrationBean<?> registration = context.getBean(FilterRegistrationBean.class).         assertThat(registration.getOrder()).isEqualTo(123).     }). }
false;public;0;14;;@SuppressWarnings("unchecked") @Test public void filterDispatcherTypesCanBeCustomized() {     this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class).withPropertyValues("spring.session.servlet.filter-dispatcher-types=error, request").run((context) -> {         FilterRegistrationBean<?> registration = context.getBean(FilterRegistrationBean.class).         assertThat((EnumSet<DispatcherType>) ReflectionTestUtils.getField(registration, "dispatcherTypes")).containsOnly(DispatcherType.ERROR, DispatcherType.REQUEST).     }). }
false;public;0;26;;@Test public void sessionCookieConfigurationIsAppliedToAutoConfiguredCookieSerializer() {     this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class).withPropertyValues("server.servlet.session.cookie.name=sid", "server.servlet.session.cookie.domain=spring", "server.servlet.session.cookie.path=/test", "server.servlet.session.cookie.httpOnly=false", "server.servlet.session.cookie.secure=false", "server.servlet.session.cookie.maxAge=10s").run((context) -> {         DefaultCookieSerializer cookieSerializer = context.getBean(DefaultCookieSerializer.class).         assertThat(cookieSerializer).hasFieldOrPropertyWithValue("cookieName", "sid").         assertThat(cookieSerializer).hasFieldOrPropertyWithValue("domainName", "spring").         assertThat(cookieSerializer).hasFieldOrPropertyWithValue("cookiePath", "/test").         assertThat(cookieSerializer).hasFieldOrPropertyWithValue("useHttpOnlyCookie", false).         assertThat(cookieSerializer).hasFieldOrPropertyWithValue("useSecureCookie", false).         assertThat(cookieSerializer).hasFieldOrPropertyWithValue("cookieMaxAge", 10).     }). }
false;public;0;14;;@Test public void autoConfiguredCookieSerializerIsUsedBySessionRepositoryFilter() {     this.contextRunner.withUserConfiguration(SessionRepositoryConfiguration.class).withPropertyValues("server.port=0").run((context) -> {         SessionRepositoryFilter<?> filter = context.getBean(SessionRepositoryFilter.class).         CookieHttpSessionIdResolver sessionIdResolver = (CookieHttpSessionIdResolver) ReflectionTestUtils.getField(filter, "httpSessionIdResolver").         DefaultCookieSerializer cookieSerializer = (DefaultCookieSerializer) ReflectionTestUtils.getField(sessionIdResolver, "cookieSerializer").         assertThat(cookieSerializer).isSameAs(context.getBean(DefaultCookieSerializer.class)).     }). }
false;public;0;9;;@Test public void autoConfiguredCookieSerializerBacksOffWhenUserConfiguresACookieSerializer() {     this.contextRunner.withUserConfiguration(UserProvidedCookieSerializerConfiguration.class).run((context) -> {         assertThat(context).hasSingleBean(DefaultCookieSerializer.class).         assertThat(context).hasBean("myCookieSerializer").     }). }
false;public;0;9;;@Test public void cookiesSerializerIsAutoConfiguredWhenUserConfiguresCookieHttpSessionIdResolver() {     this.contextRunner.withUserConfiguration(UserProvidedCookieHttpSessionStrategyConfiguration.class).run((context) -> assertThat(context.getBeansOfType(DefaultCookieSerializer.class)).isNotEmpty()). }
false;public;0;8;;@Test public void autoConfiguredCookieSerializerBacksOffWhenUserConfiguresHeaderHttpSessionIdResolver() {     this.contextRunner.withUserConfiguration(UserProvidedHeaderHttpSessionStrategyConfiguration.class).run((context) -> assertThat(context.getBeansOfType(DefaultCookieSerializer.class)).isEmpty()). }
false;public;0;8;;@Test public void autoConfiguredCookieSerializerBacksOffWhenUserConfiguresCustomHttpSessionIdResolver() {     this.contextRunner.withUserConfiguration(UserProvidedCustomHttpSessionStrategyConfiguration.class).run((context) -> assertThat(context.getBeansOfType(DefaultCookieSerializer.class)).isEmpty()). }
false;public;0;4;;@Bean public MapSessionRepository mySessionRepository() {     return new MapSessionRepository(Collections.emptyMap()). }
false;public;0;4;;@Bean public DefaultCookieSerializer myCookieSerializer() {     return new DefaultCookieSerializer(). }
false;public;0;4;;@Bean public CookieHttpSessionIdResolver httpSessionStrategy() {     return new CookieHttpSessionIdResolver(). }
false;public;0;4;;@Bean public HeaderHttpSessionIdResolver httpSessionStrategy() {     return HeaderHttpSessionIdResolver.xAuthToken(). }
false;public;0;4;;@Bean public HttpSessionIdResolver httpSessionStrategy() {     return mock(HttpSessionIdResolver.class). }
