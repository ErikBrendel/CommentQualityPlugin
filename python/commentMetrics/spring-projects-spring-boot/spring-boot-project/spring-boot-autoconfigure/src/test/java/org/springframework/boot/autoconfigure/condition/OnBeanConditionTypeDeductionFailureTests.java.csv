commented;modifiers;parameterAmount;loc;comment;code
false;public;0;17;;@Test public void conditionalOnMissingBeanWithDeducedTypeThatIsPartiallyMissingFromClassPath() {     assertThatExceptionOfType(Exception.class).isThrownBy(() -> new AnnotationConfigApplicationContext(ImportingConfiguration.class).close()).satisfies((ex) -> {         Throwable beanTypeDeductionException = findNestedCause(ex, BeanTypeDeductionException.class).         assertThat(beanTypeDeductionException).hasMessage("Failed to deduce bean type for " + OnMissingBeanConfiguration.class.getName() + ".objectMapper").         assertThat(findNestedCause(beanTypeDeductionException, NoClassDefFoundError.class)).isNotNull().     }). }
false;private;2;10;;private Throwable findNestedCause(Throwable ex, Class<? extends Throwable> target) {     Throwable candidate = ex.     while (candidate != null) {         if (target.isInstance(candidate)) {             return candidate.         }         candidate = candidate.getCause().     }     return null. }
false;public;0;5;;@Bean @ConditionalOnMissingBean public ObjectMapper objectMapper() {     return new ObjectMapper(). }
false;public;1;4;;@Override public String[] selectImports(AnnotationMetadata importingClassMetadata) {     return new String[] { OnMissingBeanConfiguration.class.getName() }. }
