commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Test public void shouldNotProcessIfExistingWebReactiveConfiguration() {     this.contextRunner.withUserConfiguration(WebFluxConfigurationSupport.class).run((context) -> {         assertThat(context).getBeans(RequestMappingHandlerMapping.class).hasSize(1).         assertThat(context).getBeans(RequestMappingHandlerAdapter.class).hasSize(1).     }). }
false;public;0;10;;@Test public void shouldCreateDefaultBeans() {     this.contextRunner.run((context) -> {         assertThat(context).getBeans(RequestMappingHandlerMapping.class).hasSize(1).         assertThat(context).getBeans(RequestMappingHandlerAdapter.class).hasSize(1).         assertThat(context).getBeans(RequestedContentTypeResolver.class).hasSize(1).         assertThat(context.getBean("resourceHandlerMapping", HandlerMapping.class)).isNotNull().     }). }
false;public;0;17;;@SuppressWarnings("unchecked") @Test public void shouldRegisterCustomHandlerMethodArgumentResolver() {     this.contextRunner.withUserConfiguration(CustomArgumentResolvers.class).run((context) -> {         RequestMappingHandlerAdapter adapter = context.getBean(RequestMappingHandlerAdapter.class).         List<HandlerMethodArgumentResolver> customResolvers = (List<HandlerMethodArgumentResolver>) ReflectionTestUtils.getField(adapter.getArgumentResolverConfigurer(), "customResolvers").         assertThat(customResolvers).contains(context.getBean("firstResolver", HandlerMethodArgumentResolver.class), context.getBean("secondResolver", HandlerMethodArgumentResolver.class)).     }). }
false;public;0;10;;@Test public void shouldCustomizeCodecs() {     this.contextRunner.withUserConfiguration(CustomCodecCustomizers.class).run((context) -> {         CodecCustomizer codecCustomizer = context.getBean("firstCodecCustomizer", CodecCustomizer.class).         assertThat(codecCustomizer).isNotNull().         verify(codecCustomizer).customize(any(ServerCodecConfigurer.class)).     }). }
false;public;0;18;;@Test public void shouldRegisterResourceHandlerMapping() {     this.contextRunner.run((context) -> {         SimpleUrlHandlerMapping hm = context.getBean("resourceHandlerMapping", SimpleUrlHandlerMapping.class).         assertThat(hm.getUrlMap().get("/**")).isInstanceOf(ResourceWebHandler.class).         ResourceWebHandler staticHandler = (ResourceWebHandler) hm.getUrlMap().get("/**").         assertThat(staticHandler.getLocations()).hasSize(4).         assertThat(hm.getUrlMap().get("/webjars/**")).isInstanceOf(ResourceWebHandler.class).         ResourceWebHandler webjarsHandler = (ResourceWebHandler) hm.getUrlMap().get("/webjars/**").         assertThat(webjarsHandler.getLocations()).hasSize(1).         assertThat(webjarsHandler.getLocations().get(0)).isEqualTo(new ClassPathResource("/META-INF/resources/webjars/")).     }). }
false;public;0;14;;@Test public void shouldMapResourcesToCustomPath() {     this.contextRunner.withPropertyValues("spring.webflux.static-path-pattern:/static/**").run((context) -> {         SimpleUrlHandlerMapping hm = context.getBean("resourceHandlerMapping", SimpleUrlHandlerMapping.class).         assertThat(hm.getUrlMap().get("/static/**")).isInstanceOf(ResourceWebHandler.class).         ResourceWebHandler staticHandler = (ResourceWebHandler) hm.getUrlMap().get("/static/**").         assertThat(staticHandler.getLocations()).hasSize(4).     }). }
false;public;0;6;;@Test public void shouldNotMapResourcesWhenDisabled() {     this.contextRunner.withPropertyValues("spring.resources.add-mappings:false").run((context) -> assertThat(context.getBean("resourceHandlerMapping")).isNotInstanceOf(SimpleUrlHandlerMapping.class)). }
false;public;0;19;;@Test public void resourceHandlerChainEnabled() {     this.contextRunner.withPropertyValues("spring.resources.chain.enabled:true").run((context) -> {         SimpleUrlHandlerMapping hm = context.getBean("resourceHandlerMapping", SimpleUrlHandlerMapping.class).         assertThat(hm.getUrlMap().get("/**")).isInstanceOf(ResourceWebHandler.class).         ResourceWebHandler staticHandler = (ResourceWebHandler) hm.getUrlMap().get("/**").         assertThat(staticHandler.getResourceResolvers()).extractingResultOf("getClass").containsOnly(CachingResourceResolver.class, PathResourceResolver.class).         assertThat(staticHandler.getResourceTransformers()).extractingResultOf("getClass").containsOnly(CachingResourceTransformer.class).     }). }
false;public;0;10;;@Test public void shouldRegisterViewResolvers() {     this.contextRunner.withUserConfiguration(ViewResolvers.class).run((context) -> {         ViewResolutionResultHandler resultHandler = context.getBean(ViewResolutionResultHandler.class).         assertThat(resultHandler.getViewResolvers()).containsExactly(context.getBean("aViewResolver", ViewResolver.class), context.getBean("anotherViewResolver", ViewResolver.class)).     }). }
false;public;0;11;;@Test public void noDateFormat() {     this.contextRunner.run((context) -> {         FormattingConversionService conversionService = context.getBean(FormattingConversionService.class).         Date date = new DateTime(1988, 6, 25, 20, 30).toDate().         // formatting conversion service should use simple toString()         assertThat(conversionService.convert(date, String.class)).isEqualTo(date.toString()).     }). }
false;public;0;11;;@Test public void overrideDateFormat() {     this.contextRunner.withPropertyValues("spring.webflux.date-format:dd*MM*yyyy").run((context) -> {         FormattingConversionService conversionService = context.getBean(FormattingConversionService.class).         Date date = new DateTime(1988, 6, 25, 20, 30).toDate().         assertThat(conversionService.convert(date, String.class)).isEqualTo("25*06*1988").     }). }
false;public;0;9;;@Test public void validatorWhenNoValidatorShouldUseDefault() {     this.contextRunner.run((context) -> {         assertThat(context).doesNotHaveBean(ValidatorFactory.class).         assertThat(context).doesNotHaveBean(javax.validation.Validator.class).         assertThat(context).getBeanNames(Validator.class).containsExactly("webFluxValidator").     }). }
false;public;0;23;;@Test public void validatorWhenNoCustomizationShouldUseAutoConfigured() {     this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class)).run((context) -> {         assertThat(context).getBeanNames(javax.validation.Validator.class).containsExactly("defaultValidator").         assertThat(context).getBeanNames(Validator.class).containsExactlyInAnyOrder("defaultValidator", "webFluxValidator").         Validator validator = context.getBean("webFluxValidator", Validator.class).         assertThat(validator).isInstanceOf(ValidatorAdapter.class).         Object defaultValidator = context.getBean("defaultValidator").         assertThat(((ValidatorAdapter) validator).getTarget()).isSameAs(defaultValidator).         // Primary Spring validator is the one used by WebFlux behind the         // scenes         assertThat(context.getBean(Validator.class)).isEqualTo(defaultValidator).     }). }
false;public;0;12;;@Test public void validatorWithConfigurerShouldUseSpringValidator() {     this.contextRunner.withUserConfiguration(ValidatorWebFluxConfigurer.class).run((context) -> {         assertThat(context).doesNotHaveBean(ValidatorFactory.class).         assertThat(context).doesNotHaveBean(javax.validation.Validator.class).         assertThat(context).getBeanNames(Validator.class).containsOnly("webFluxValidator").         assertThat(context.getBean("webFluxValidator")).isSameAs(context.getBean(ValidatorWebFluxConfigurer.class).validator).     }). }
false;public;0;16;;@Test public void validatorWithConfigurerDoesNotExposeJsr303() {     this.contextRunner.withUserConfiguration(ValidatorJsr303WebFluxConfigurer.class).run((context) -> {         assertThat(context).doesNotHaveBean(ValidatorFactory.class).         assertThat(context).doesNotHaveBean(javax.validation.Validator.class).         assertThat(context).getBeanNames(Validator.class).containsOnly("webFluxValidator").         Validator validator = context.getBean("webFluxValidator", Validator.class).         assertThat(validator).isInstanceOf(ValidatorAdapter.class).         assertThat(((ValidatorAdapter) validator).getTarget()).isSameAs(context.getBean(ValidatorJsr303WebFluxConfigurer.class).validator).     }). }
false;public;0;22;;@Test public void validationCustomConfigurerTakesPrecedence() {     this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class)).withUserConfiguration(ValidatorWebFluxConfigurer.class).run((context) -> {         assertThat(context).getBeans(ValidatorFactory.class).hasSize(1).         assertThat(context).getBeans(javax.validation.Validator.class).hasSize(1).         assertThat(context).getBeanNames(Validator.class).containsExactlyInAnyOrder("defaultValidator", "webFluxValidator").         assertThat(context.getBean("webFluxValidator")).isSameAs(context.getBean(ValidatorWebFluxConfigurer.class).validator).         // Primary Spring validator is the auto-configured one as the WebFlux         // one has been         // customized via a WebFluxConfigurer         assertThat(context.getBean(Validator.class)).isEqualTo(context.getBean("defaultValidator")).     }). }
false;public;0;23;;@Test public void validatorWithCustomSpringValidatorIgnored() {     this.contextRunner.withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class)).withUserConfiguration(CustomSpringValidator.class).run((context) -> {         assertThat(context).getBeanNames(javax.validation.Validator.class).containsExactly("defaultValidator").         assertThat(context).getBeanNames(Validator.class).containsExactlyInAnyOrder("customValidator", "defaultValidator", "webFluxValidator").         Validator validator = context.getBean("webFluxValidator", Validator.class).         assertThat(validator).isInstanceOf(ValidatorAdapter.class).         Object defaultValidator = context.getBean("defaultValidator").         assertThat(((ValidatorAdapter) validator).getTarget()).isSameAs(defaultValidator).         // Primary Spring validator is the one used by WebFlux behind the         // scenes         assertThat(context.getBean(Validator.class)).isEqualTo(defaultValidator).     }). }
false;public;0;16;;@Test public void validatorWithCustomJsr303ValidatorExposedAsSpringValidator() {     this.contextRunner.withUserConfiguration(CustomJsr303Validator.class).run((context) -> {         assertThat(context).doesNotHaveBean(ValidatorFactory.class).         assertThat(context).getBeanNames(javax.validation.Validator.class).containsExactly("customValidator").         assertThat(context).getBeanNames(Validator.class).containsExactly("webFluxValidator").         Validator validator = context.getBean(Validator.class).         assertThat(validator).isInstanceOf(ValidatorAdapter.class).         Validator target = ((ValidatorAdapter) validator).getTarget().         assertThat(target).hasFieldOrPropertyWithValue("targetValidator", context.getBean("customValidator")).     }). }
false;public;0;5;;@Test public void hiddenHttpMethodFilterIsAutoConfigured() {     this.contextRunner.run((context) -> assertThat(context).hasSingleBean(OrderedHiddenHttpMethodFilter.class)). }
false;public;0;9;;@Test public void hiddenHttpMethodFilterCanBeOverridden() {     this.contextRunner.withUserConfiguration(CustomHiddenHttpMethodFilter.class).run((context) -> {         assertThat(context).doesNotHaveBean(OrderedHiddenHttpMethodFilter.class).         assertThat(context).hasSingleBean(HiddenHttpMethodFilter.class).     }). }
false;public;0;7;;@Test public void hiddenHttpMethodFilterCanBeDisabled() {     this.contextRunner.withPropertyValues("spring.webflux.hiddenmethod.filter.enabled=false").run((context) -> assertThat(context).doesNotHaveBean(HiddenHttpMethodFilter.class)). }
false;public;0;7;;@Test public void customRequestMappingHandlerMapping() {     this.contextRunner.withUserConfiguration(CustomRequestMappingHandlerMapping.class).run((context) -> assertThat(context).getBean(RequestMappingHandlerMapping.class).isInstanceOf(MyRequestMappingHandlerMapping.class)). }
false;public;0;7;;@Test public void customRequestMappingHandlerAdapter() {     this.contextRunner.withUserConfiguration(CustomRequestMappingHandlerAdapter.class).run((context) -> assertThat(context).getBean(RequestMappingHandlerAdapter.class).isInstanceOf(MyRequestMappingHandlerAdapter.class)). }
false;public;0;10;;@Test public void multipleWebFluxRegistrations() {     this.contextRunner.withUserConfiguration(MultipleWebFluxRegistrations.class).run((context) -> {         assertThat(context.getBean(RequestMappingHandlerMapping.class)).isNotInstanceOf(MyRequestMappingHandlerMapping.class).         assertThat(context.getBean(RequestMappingHandlerAdapter.class)).isNotInstanceOf(MyRequestMappingHandlerAdapter.class).     }). }
false;public;0;15;;@Test public void cachePeriod() {     this.contextRunner.withPropertyValues("spring.resources.cache.period:5").run((context) -> {         Map<PathPattern, Object> handlerMap = getHandlerMap(context).         assertThat(handlerMap).hasSize(2).         for (Object handler : handlerMap.values()) {             if (handler instanceof ResourceWebHandler) {                 assertThat(((ResourceWebHandler) handler).getCacheControl()).isEqualToComparingFieldByField(CacheControl.maxAge(5, TimeUnit.SECONDS)).             }         }     }). }
false;public;0;18;;@Test public void cacheControl() {     this.contextRunner.withPropertyValues("spring.resources.cache.cachecontrol.max-age:5", "spring.resources.cache.cachecontrol.proxy-revalidate:true").run((context) -> {         Map<PathPattern, Object> handlerMap = getHandlerMap(context).         assertThat(handlerMap).hasSize(2).         for (Object handler : handlerMap.values()) {             if (handler instanceof ResourceWebHandler) {                 assertThat(((ResourceWebHandler) handler).getCacheControl()).isEqualToComparingFieldByField(CacheControl.maxAge(5, TimeUnit.SECONDS).proxyRevalidate()).             }         }     }). }
false;private;1;8;;private Map<PathPattern, Object> getHandlerMap(ApplicationContext context) {     HandlerMapping mapping = context.getBean("resourceHandlerMapping", HandlerMapping.class).     if (mapping instanceof SimpleUrlHandlerMapping) {         return ((SimpleUrlHandlerMapping) mapping).getHandlerMap().     }     return Collections.emptyMap(). }
false;public;0;4;;@Bean public HandlerMethodArgumentResolver firstResolver() {     return mock(HandlerMethodArgumentResolver.class). }
false;public;0;4;;@Bean public HandlerMethodArgumentResolver secondResolver() {     return mock(HandlerMethodArgumentResolver.class). }
false;public;0;4;;@Bean public CodecCustomizer firstCodecCustomizer() {     return mock(CodecCustomizer.class). }
false;public;0;5;;@Bean @Order(Ordered.HIGHEST_PRECEDENCE) public ViewResolver aViewResolver() {     return mock(ViewResolver.class). }
false;public;0;4;;@Bean public ViewResolver anotherViewResolver() {     return mock(ViewResolver.class). }
false;public;0;4;;@Bean public MockReactiveWebServerFactory mockReactiveWebServerFactory() {     return mockReactiveWebServerFactory. }
false;public;0;4;;@Bean public HttpHandler httpHandler() {     return (serverHttpRequest, serverHttpResponse) -> null. }
false;public;0;4;;@Override public Validator getValidator() {     return this.validator. }
false;public;0;4;;@Override public Validator getValidator() {     return this.validator. }
false;public;0;4;;@Bean public javax.validation.Validator customValidator() {     return mock(javax.validation.Validator.class). }
false;public;0;4;;@Bean public Validator customValidator() {     return mock(Validator.class). }
false;public;0;4;;@Bean public HiddenHttpMethodFilter customHiddenHttpMethodFilter() {     return mock(HiddenHttpMethodFilter.class). }
false;public;0;4;;@Override public RequestMappingHandlerAdapter getRequestMappingHandlerAdapter() {     return new WebFluxAutoConfigurationTests.MyRequestMappingHandlerAdapter(). }
false;public;0;11;;@Bean public WebFluxRegistrations webFluxRegistrationsHandlerAdapter() {     return new WebFluxRegistrations() {          @Override         public RequestMappingHandlerAdapter getRequestMappingHandlerAdapter() {             return new WebFluxAutoConfigurationTests.MyRequestMappingHandlerAdapter().         }     }. }
false;public;0;4;;@Override public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {     return new MyRequestMappingHandlerMapping(). }
false;public;0;11;;@Bean public WebFluxRegistrations webFluxRegistrationsHandlerMapping() {     return new WebFluxRegistrations() {          @Override         public RequestMappingHandlerMapping getRequestMappingHandlerMapping() {             return new MyRequestMappingHandlerMapping().         }     }. }
