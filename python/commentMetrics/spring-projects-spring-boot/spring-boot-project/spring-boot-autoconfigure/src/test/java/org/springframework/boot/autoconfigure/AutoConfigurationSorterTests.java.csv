commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void setup() {     this.sorter = new AutoConfigurationSorter(new SkipCycleMetadataReaderFactory(), this.autoConfigurationMetadata). }
false;public;0;6;;@Test public void byOrderAnnotation() {     List<String> actual = this.sorter.getInPriorityOrder(Arrays.asList(LOWEST, HIGHEST, DEFAULT)).     assertThat(actual).containsExactly(HIGHEST, DEFAULT, LOWEST). }
false;public;0;5;;@Test public void byAutoConfigureAfter() {     List<String> actual = this.sorter.getInPriorityOrder(Arrays.asList(A, B, C)).     assertThat(actual).containsExactly(C, B, A). }
false;public;0;5;;@Test public void byAutoConfigureBefore() {     List<String> actual = this.sorter.getInPriorityOrder(Arrays.asList(X, Y, Z)).     assertThat(actual).containsExactly(Z, Y, X). }
false;public;0;5;;@Test public void byAutoConfigureAfterDoubles() {     List<String> actual = this.sorter.getInPriorityOrder(Arrays.asList(A, B, C, E)).     assertThat(actual).containsExactly(C, E, B, A). }
false;public;0;6;;@Test public void byAutoConfigureMixedBeforeAndAfter() {     List<String> actual = this.sorter.getInPriorityOrder(Arrays.asList(A, B, C, W, X)).     assertThat(actual).containsExactly(C, W, B, A, X). }
false;public;0;6;;@Test public void byAutoConfigureMixedBeforeAndAfterWithClassNames() {     List<String> actual = this.sorter.getInPriorityOrder(Arrays.asList(A2, B, C, W2, X)).     assertThat(actual).containsExactly(C, W2, B, A2, X). }
false;public;0;6;;@Test public void byAutoConfigureMixedBeforeAndAfterWithDifferentInputOrder() {     List<String> actual = this.sorter.getInPriorityOrder(Arrays.asList(W, X, A, B, C)).     assertThat(actual).containsExactly(C, W, B, A, X). }
false;public;0;5;;@Test public void byAutoConfigureAfterWithMissing() {     List<String> actual = this.sorter.getInPriorityOrder(Arrays.asList(A, B)).     assertThat(actual).containsExactly(B, A). }
false;public;0;9;;@Test public void byAutoConfigureAfterWithCycle() {     this.sorter = new AutoConfigurationSorter(new CachingMetadataReaderFactory(), this.autoConfigurationMetadata).     assertThatIllegalStateException().isThrownBy(() -> this.sorter.getInPriorityOrder(Arrays.asList(A, B, C, D))).withMessageContaining("AutoConfigure cycle detected"). }
false;public;0;10;;@Test public void usesAnnotationPropertiesWhenPossible() throws Exception {     MetadataReaderFactory readerFactory = new SkipCycleMetadataReaderFactory().     this.autoConfigurationMetadata = getAutoConfigurationMetadata(A2, B, C, W2, X).     this.sorter = new AutoConfigurationSorter(readerFactory, this.autoConfigurationMetadata).     List<String> actual = this.sorter.getInPriorityOrder(Arrays.asList(A2, B, C, W2, X)).     assertThat(actual).containsExactly(C, W2, B, A2, X). }
false;public;0;9;;@Test public void useAnnotationWithNoDirectLink() throws Exception {     MetadataReaderFactory readerFactory = new SkipCycleMetadataReaderFactory().     this.autoConfigurationMetadata = getAutoConfigurationMetadata(A, B, E).     this.sorter = new AutoConfigurationSorter(readerFactory, this.autoConfigurationMetadata).     List<String> actual = this.sorter.getInPriorityOrder(Arrays.asList(A, E)).     assertThat(actual).containsExactly(E, A). }
false;public;0;10;;@Test public void useAnnotationWithNoDirectLinkAndCycle() throws Exception {     MetadataReaderFactory readerFactory = new CachingMetadataReaderFactory().     this.autoConfigurationMetadata = getAutoConfigurationMetadata(A, B, D).     this.sorter = new AutoConfigurationSorter(readerFactory, this.autoConfigurationMetadata).     assertThatIllegalStateException().isThrownBy(() -> this.sorter.getInPriorityOrder(Arrays.asList(D, B))).withMessageContaining("AutoConfigure cycle detected"). }
false;private;1;27;;private AutoConfigurationMetadata getAutoConfigurationMetadata(String... classNames) throws Exception {     Properties properties = new Properties().     for (String className : classNames) {         Class<?> type = ClassUtils.forName(className, null).         properties.put(type.getName(), "").         AutoConfigureOrder order = type.getDeclaredAnnotation(AutoConfigureOrder.class).         if (order != null) {             properties.put(className + ".AutoConfigureOrder", String.valueOf(order.value())).         }         AutoConfigureBefore autoConfigureBefore = type.getDeclaredAnnotation(AutoConfigureBefore.class).         if (autoConfigureBefore != null) {             properties.put(className + ".AutoConfigureBefore", merge(autoConfigureBefore.value(), autoConfigureBefore.name())).         }         AutoConfigureAfter autoConfigureAfter = type.getDeclaredAnnotation(AutoConfigureAfter.class).         if (autoConfigureAfter != null) {             properties.put(className + ".AutoConfigureAfter", merge(autoConfigureAfter.value(), autoConfigureAfter.name())).         }     }     return AutoConfigurationMetadataLoader.loadMetadata(properties). }
false;private;2;10;;private String merge(Class<?>[] value, String[] name) {     Set<String> items = new LinkedHashSet<>().     for (Class<?> type : value) {         items.add(type.getName()).     }     for (String type : name) {         items.add(type).     }     return StringUtils.collectionToCommaDelimitedString(items). }
false;public;1;7;;@Override public MetadataReader getMetadataReader(String className) throws IOException {     if (className.equals(D)) {         throw new IOException().     }     return super.getMetadataReader(className). }
