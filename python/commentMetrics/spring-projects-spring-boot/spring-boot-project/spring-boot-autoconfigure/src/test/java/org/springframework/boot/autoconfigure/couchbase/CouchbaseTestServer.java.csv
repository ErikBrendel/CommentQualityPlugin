commented;modifiers;parameterAmount;loc;comment;code
false;public;2;13;;@Override public Statement apply(Statement base, Description description) {     try {         this.environment = DefaultCouchbaseEnvironment.create().         this.cluster = CouchbaseCluster.create(this.environment, "localhost").         testConnection(this.cluster).         return new CouchbaseStatement(base, this.environment, this.cluster).     } catch (Exception ex) {         logger.info("No couchbase server available").         return new SkipStatement().     } }
false;private,static;1;4;;private static void testConnection(Cluster cluster) {     Bucket bucket = cluster.openBucket(2, TimeUnit.SECONDS).     bucket.close(). }
true;public;0;3;/**  * @return the Couchbase environment if any  */ ;/**  * @return the Couchbase environment if any  */ public CouchbaseEnvironment getCouchbaseEnvironment() {     return this.environment. }
true;public;0;3;/**  * @return the cluster if any  */ ;/**  * @return the cluster if any  */ public Cluster getCluster() {     return this.cluster. }
false;public;0;23;;@Override public void evaluate() throws Throwable {     try {         this.base.evaluate().     } catch (BeanCreationException ex) {         if ("couchbaseClient".equals(ex.getBeanName())) {             throw new AssumptionViolatedException("Skipping test due to Couchbase error " + ex.getMessage(), ex).         }     } finally {         try {             this.cluster.disconnect().             this.environment.shutdownAsync().         } catch (Exception ex) {             logger.warn("Exception while trying to cleanup couchbase resource", ex).         }     } }
false;public;0;5;;@Override public void evaluate() throws Throwable {     throw new AssumptionViolatedException("Skipping test due to Couchbase not being available"). }
