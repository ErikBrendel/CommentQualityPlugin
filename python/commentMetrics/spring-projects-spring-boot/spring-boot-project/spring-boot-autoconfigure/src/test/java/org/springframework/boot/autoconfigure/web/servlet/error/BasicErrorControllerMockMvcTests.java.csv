commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void setup() {     this.mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build(). }
false;public;0;7;;@Test public void testDirectAccessForMachineClient() throws Exception {     MvcResult response = this.mockMvc.perform(get("/error")).andExpect(status().is5xxServerError()).andReturn().     String content = response.getResponse().getContentAsString().     assertThat(content).contains("999"). }
false;public;0;9;;@Test public void testErrorWithResponseStatus() throws Exception {     MvcResult result = this.mockMvc.perform(get("/bang")).andExpect(status().isNotFound()).andReturn().     MvcResult response = this.mockMvc.perform(new ErrorDispatcher(result, "/error")).andReturn().     String content = response.getResponse().getContentAsString().     assertThat(content).contains("Expected!"). }
false;public;0;14;;@Test public void testBindingExceptionForMachineClient() throws Exception {     // In a real server the response is carried over into the error dispatcher, but     // in the mock a new one is created so we have to assert the status at this     // intermediate point     MvcResult result = this.mockMvc.perform(get("/bind")).andExpect(status().is4xxClientError()).andReturn().     MvcResult response = this.mockMvc.perform(new ErrorDispatcher(result, "/error")).andReturn().     // And the rendered status code is always wrong (but would be 400 in a real     // system)     String content = response.getResponse().getContentAsString().     assertThat(content).contains("Error count: 1"). }
false;public;0;8;;@Test public void testDirectAccessForBrowserClient() throws Exception {     MvcResult response = this.mockMvc.perform(get("/error").accept(MediaType.TEXT_HTML)).andExpect(status().is5xxServerError()).andReturn().     String content = response.getResponse().getContentAsString().     assertThat(content).contains("ERROR_BEAN"). }
true;public,static;1;3;// For manual testing ;// For manual testing public static void main(String[] args) {     SpringApplication.run(TestConfiguration.class, args). }
false;protected;3;6;;@Override protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {     response.getWriter().write("ERROR_BEAN"). }
false;public;0;11;;@Bean public View error() {     return new AbstractView() {          @Override         protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {             response.getWriter().write("ERROR_BEAN").         }     }. }
false;public;0;3;;public String getFoo() {     return "foo". }
false;public;0;4;;@RequestMapping("/") public String home() {     throw new IllegalStateException("Expected!"). }
false;public;0;4;;@RequestMapping("/bang") public String bang() {     throw new NotFoundException("Expected!"). }
false;public;0;6;;@RequestMapping("/bind") public String bind() throws Exception {     BindException error = new BindException(this, "test").     error.rejectValue("foo", "bar.error").     throw error. }
false;public;1;7;;@Override public MockHttpServletRequest buildRequest(ServletContext servletContext) {     MockHttpServletRequest request = this.result.getRequest().     request.setDispatcherType(DispatcherType.ERROR).     request.setRequestURI(this.path).     return request. }
