commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Configure HTTP message writers to serialize the response body with.  * @param messageWriters the {@link HttpMessageWriter}s to use  */ ;/**  * Configure HTTP message writers to serialize the response body with.  * @param messageWriters the {@link HttpMessageWriter}s to use  */ public void setMessageWriters(List<HttpMessageWriter<?>> messageWriters) {     Assert.notNull(messageWriters, "'messageWriters' must not be null").     this.messageWriters = messageWriters. }
true;public;1;4;/**  * Configure HTTP message readers to deserialize the request body with.  * @param messageReaders the {@link HttpMessageReader}s to use  */ ;/**  * Configure HTTP message readers to deserialize the request body with.  * @param messageReaders the {@link HttpMessageReader}s to use  */ public void setMessageReaders(List<HttpMessageReader<?>> messageReaders) {     Assert.notNull(messageReaders, "'messageReaders' must not be null").     this.messageReaders = messageReaders. }
true;public;1;3;/**  * Configure the {@link ViewResolver} to use for rendering views.  * @param viewResolvers the list of {@link ViewResolver}s to use  */ ;/**  * Configure the {@link ViewResolver} to use for rendering views.  * @param viewResolvers the list of {@link ViewResolver}s to use  */ public void setViewResolvers(List<ViewResolver> viewResolvers) {     this.viewResolvers = viewResolvers. }
true;protected;2;4;/**  * Extract the error attributes from the current request, to be used to populate error  * views or JSON payloads.  * @param request the source request  * @param includeStackTrace whether to include the error stacktrace information  * @return the error attributes as a Map.  */ ;/**  * Extract the error attributes from the current request, to be used to populate error  * views or JSON payloads.  * @param request the source request  * @param includeStackTrace whether to include the error stacktrace information  * @return the error attributes as a Map.  */ protected Map<String, Object> getErrorAttributes(ServerRequest request, boolean includeStackTrace) {     return this.errorAttributes.getErrorAttributes(request, includeStackTrace). }
true;protected;1;3;/**  * Extract the original error from the current request.  * @param request the source request  * @return the error  */ ;/**  * Extract the original error from the current request.  * @param request the source request  * @return the error  */ protected Throwable getError(ServerRequest request) {     return this.errorAttributes.getError(request). }
true;protected;1;4;/**  * Check whether the trace attribute has been set on the given request.  * @param request the source request  * @return {@code true} if the error trace has been requested, {@code false} otherwise  */ ;/**  * Check whether the trace attribute has been set on the given request.  * @param request the source request  * @return {@code true} if the error trace has been requested, {@code false} otherwise  */ protected boolean isTraceEnabled(ServerRequest request) {     String parameter = request.queryParam("trace").orElse("false").     return !"false".equalsIgnoreCase(parameter). }
true;protected;3;11;/**  * Render the given error data as a view, using a template view if available or a  * static HTML file if available otherwise. This will return an empty  * {@code Publisher} if none of the above are available.  * @param viewName the view name  * @param responseBody the error response being built  * @param error the error data as a map  * @return a Publisher of the {@link ServerResponse}  */ ;/**  * Render the given error data as a view, using a template view if available or a  * static HTML file if available otherwise. This will return an empty  * {@code Publisher} if none of the above are available.  * @param viewName the view name  * @param responseBody the error response being built  * @param error the error data as a map  * @return a Publisher of the {@link ServerResponse}  */ protected Mono<ServerResponse> renderErrorView(String viewName, ServerResponse.BodyBuilder responseBody, Map<String, Object> error) {     if (isTemplateAvailable(viewName)) {         return responseBody.render(viewName, error).     }     Resource resource = resolveResource(viewName).     if (resource != null) {         return responseBody.body(BodyInserters.fromResource(resource)).     }     return Mono.empty(). }
false;private;1;4;;private boolean isTemplateAvailable(String viewName) {     return this.templateAvailabilityProviders.getProvider(viewName, this.applicationContext) != null. }
false;private;1;15;;private Resource resolveResource(String viewName) {     for (String location : this.resourceProperties.getStaticLocations()) {         try {             Resource resource = this.applicationContext.getResource(location).             resource = resource.createRelative(viewName + ".html").             if (resource.exists()) {                 return resource.             }         } catch (Exception ex) {         // Ignore         }     }     return null. }
true;protected;2;22;/**  * Render a default HTML "Whitelabel Error Page".  * <p>  * Useful when no other error view is available in the application.  * @param responseBody the error response being built  * @param error the error data as a map  * @return a Publisher of the {@link ServerResponse}  */ ;/**  * Render a default HTML "Whitelabel Error Page".  * <p>  * Useful when no other error view is available in the application.  * @param responseBody the error response being built  * @param error the error data as a map  * @return a Publisher of the {@link ServerResponse}  */ protected Mono<ServerResponse> renderDefaultErrorView(ServerResponse.BodyBuilder responseBody, Map<String, Object> error) {     StringBuilder builder = new StringBuilder().     Date timestamp = (Date) error.get("timestamp").     Object message = error.get("message").     Object trace = error.get("trace").     builder.append("<html><body><h1>Whitelabel Error Page</h1>").append("<p>This application has no configured error view, so you are seeing this as a fallback.</p>").append("<div id='created'>").append(timestamp).append("</div>").append("<div>There was an unexpected error (type=").append(htmlEscape(error.get("error"))).append(", status=").append(htmlEscape(error.get("status"))).append(").</div>").     if (message != null) {         builder.append("<div>").append(htmlEscape(message)).append("</div>").     }     if (trace != null) {         builder.append("<div style='white-space:pre-wrap.'>").append(htmlEscape(trace)).append("</div>").     }     builder.append("</body></html>").     return responseBody.syncBody(builder.toString()). }
false;private;1;3;;private String htmlEscape(Object input) {     return (input != null) ? HtmlUtils.htmlEscape(input.toString()) : null. }
false;public;0;6;;@Override public void afterPropertiesSet() throws Exception {     if (CollectionUtils.isEmpty(this.messageWriters)) {         throw new IllegalArgumentException("Property 'messageWriters' is required").     } }
true;protected,abstract;1;2;/**  * Create a {@link RouterFunction} that can route and handle errors as JSON responses  * or HTML views.  * <p>  * If the returned {@link RouterFunction} doesn't route to a {@code HandlerFunction},  * the original exception is propagated in the pipeline and can be processed by other  * {@link org.springframework.web.server.WebExceptionHandler}s.  * @param errorAttributes the {@code ErrorAttributes} instance to use to extract error  * information  * @return a {@link RouterFunction} that routes and handles errors  */ ;/**  * Create a {@link RouterFunction} that can route and handle errors as JSON responses  * or HTML views.  * <p>  * If the returned {@link RouterFunction} doesn't route to a {@code HandlerFunction},  * the original exception is propagated in the pipeline and can be processed by other  * {@link org.springframework.web.server.WebExceptionHandler}s.  * @param errorAttributes the {@code ErrorAttributes} instance to use to extract error  * information  * @return a {@link RouterFunction} that routes and handles errors  */ protected abstract RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes).
false;public;2;14;;@Override public Mono<Void> handle(ServerWebExchange exchange, Throwable throwable) {     if (exchange.getResponse().isCommitted() || isDisconnectedClientError(throwable)) {         return Mono.error(throwable).     }     this.errorAttributes.storeErrorInformation(throwable, exchange).     ServerRequest request = ServerRequest.create(exchange, this.messageReaders).     return getRoutingFunction(this.errorAttributes).route(request).switchIfEmpty(Mono.error(throwable)).flatMap((handler) -> handler.handle(request)).doOnNext((response) -> logError(request, response, throwable)).flatMap((response) -> write(exchange, response)). }
false;private;1;7;;private boolean isDisconnectedClientError(Throwable ex) {     String message = NestedExceptionUtils.getMostSpecificCause(ex).getMessage().     if (message != null && message.toLowerCase().contains("broken pipe")) {         return true.     }     return DISCONNECTED_CLIENT_EXCEPTIONS.contains(ex.getClass().getSimpleName()). }
false;private;3;11;;private void logError(ServerRequest request, ServerResponse response, Throwable throwable) {     if (logger.isDebugEnabled()) {         logger.debug(request.exchange().getLogPrefix() + formatError(throwable, request)).     }     if (response.statusCode().equals(HttpStatus.INTERNAL_SERVER_ERROR)) {         logger.error(request.exchange().getLogPrefix() + "500 Server Error for " + formatRequest(request), throwable).     } }
false;private;2;5;;private String formatError(Throwable ex, ServerRequest request) {     String reason = ex.getClass().getSimpleName() + ": " + ex.getMessage().     return "Resolved [" + reason + "] for HTTP " + request.methodName() + " " + request.path(). }
false;private;1;5;;private String formatRequest(ServerRequest request) {     String rawQuery = request.uri().getRawQuery().     String query = StringUtils.hasText(rawQuery) ? "?" + rawQuery : "".     return "HTTP " + request.methodName() + " \"" + request.path() + query + "\"". }
false;private;2;7;;private Mono<? extends Void> write(ServerWebExchange exchange, ServerResponse response) {     // force content-type since writeTo won't overwrite response header values     exchange.getResponse().getHeaders().setContentType(response.headers().getContentType()).     return response.writeTo(exchange, new ResponseContext()). }
false;public;0;4;;@Override public List<HttpMessageWriter<?>> messageWriters() {     return AbstractErrorWebExceptionHandler.this.messageWriters. }
false;public;0;4;;@Override public List<ViewResolver> viewResolvers() {     return AbstractErrorWebExceptionHandler.this.viewResolvers. }
