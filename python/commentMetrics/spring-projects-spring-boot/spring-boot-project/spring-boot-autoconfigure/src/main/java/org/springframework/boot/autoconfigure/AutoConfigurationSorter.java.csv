commented;modifiers;parameterAmount;loc;comment;code
false;public;1;16;;public List<String> getInPriorityOrder(Collection<String> classNames) {     AutoConfigurationClasses classes = new AutoConfigurationClasses(this.metadataReaderFactory, this.autoConfigurationMetadata, classNames).     List<String> orderedClassNames = new ArrayList<>(classNames).     // Initially sort alphabetically     Collections.sort(orderedClassNames).     // Then sort by order     orderedClassNames.sort((o1, o2) -> {         int i1 = classes.get(o1).getOrder().         int i2 = classes.get(o2).getOrder().         return Integer.compare(i1, i2).     }).     // Then respect @AutoConfigureBefore @AutoConfigureAfter     orderedClassNames = sortByAnnotation(classes, orderedClassNames).     return orderedClassNames. }
false;private;2;12;;private List<String> sortByAnnotation(AutoConfigurationClasses classes, List<String> classNames) {     List<String> toSort = new ArrayList<>(classNames).     toSort.addAll(classes.getAllNames()).     Set<String> sorted = new LinkedHashSet<>().     Set<String> processing = new LinkedHashSet<>().     while (!toSort.isEmpty()) {         doSortByAfterAnnotation(classes, toSort, sorted, processing, null).     }     sorted.retainAll(classNames).     return new ArrayList<>(sorted). }
false;private;5;17;;private void doSortByAfterAnnotation(AutoConfigurationClasses classes, List<String> toSort, Set<String> sorted, Set<String> processing, String current) {     if (current == null) {         current = toSort.remove(0).     }     processing.add(current).     for (String after : classes.getClassesRequestedAfter(current)) {         Assert.state(!processing.contains(after), "AutoConfigure cycle detected between " + current + " and " + after).         if (!sorted.contains(after) && toSort.contains(after)) {             doSortByAfterAnnotation(classes, toSort, sorted, processing, after).         }     }     processing.remove(current).     sorted.add(current). }
false;public;0;3;;public Set<String> getAllNames() {     return this.classes.keySet(). }
false;private;4;20;;private void addToClasses(MetadataReaderFactory metadataReaderFactory, AutoConfigurationMetadata autoConfigurationMetadata, Collection<String> classNames, boolean required) {     for (String className : classNames) {         if (!this.classes.containsKey(className)) {             AutoConfigurationClass autoConfigurationClass = new AutoConfigurationClass(className, metadataReaderFactory, autoConfigurationMetadata).             boolean available = autoConfigurationClass.isAvailable().             if (required || available) {                 this.classes.put(className, autoConfigurationClass).             }             if (available) {                 addToClasses(metadataReaderFactory, autoConfigurationMetadata, autoConfigurationClass.getBefore(), false).                 addToClasses(metadataReaderFactory, autoConfigurationMetadata, autoConfigurationClass.getAfter(), false).             }         }     } }
false;public;1;3;;public AutoConfigurationClass get(String className) {     return this.classes.get(className). }
false;public;1;10;;public Set<String> getClassesRequestedAfter(String className) {     Set<String> classesRequestedAfter = new LinkedHashSet<>().     classesRequestedAfter.addAll(get(className).getAfter()).     this.classes.forEach((name, autoConfigurationClass) -> {         if (autoConfigurationClass.getBefore().contains(className)) {             classesRequestedAfter.add(name).         }     }).     return classesRequestedAfter. }
false;public;0;11;;public boolean isAvailable() {     try {         if (!wasProcessed()) {             getAnnotationMetadata().         }         return true.     } catch (Exception ex) {         return false.     } }
false;public;0;9;;public Set<String> getBefore() {     if (this.before == null) {         this.before = (wasProcessed() ? this.autoConfigurationMetadata.getSet(this.className, "AutoConfigureBefore", Collections.emptySet()) : getAnnotationValue(AutoConfigureBefore.class)).     }     return this.before. }
false;public;0;9;;public Set<String> getAfter() {     if (this.after == null) {         this.after = (wasProcessed() ? this.autoConfigurationMetadata.getSet(this.className, "AutoConfigureAfter", Collections.emptySet()) : getAnnotationValue(AutoConfigureAfter.class)).     }     return this.after. }
false;private;0;10;;private int getOrder() {     if (wasProcessed()) {         return this.autoConfigurationMetadata.getInteger(this.className, "AutoConfigureOrder", AutoConfigureOrder.DEFAULT_ORDER).     }     Map<String, Object> attributes = getAnnotationMetadata().getAnnotationAttributes(AutoConfigureOrder.class.getName()).     return (attributes != null) ? (Integer) attributes.get("value") : AutoConfigureOrder.DEFAULT_ORDER. }
false;private;0;4;;private boolean wasProcessed() {     return (this.autoConfigurationMetadata != null && this.autoConfigurationMetadata.wasProcessed(this.className)). }
false;private;1;11;;private Set<String> getAnnotationValue(Class<?> annotation) {     Map<String, Object> attributes = getAnnotationMetadata().getAnnotationAttributes(annotation.getName(), true).     if (attributes == null) {         return Collections.emptySet().     }     Set<String> value = new LinkedHashSet<>().     Collections.addAll(value, (String[]) attributes.get("value")).     Collections.addAll(value, (String[]) attributes.get("name")).     return value. }
false;private;0;14;;private AnnotationMetadata getAnnotationMetadata() {     if (this.annotationMetadata == null) {         try {             MetadataReader metadataReader = this.metadataReaderFactory.getMetadataReader(this.className).             this.annotationMetadata = metadataReader.getAnnotationMetadata().         } catch (IOException ex) {             throw new IllegalStateException("Unable to read meta-data for class " + this.className, ex).         }     }     return this.annotationMetadata. }
