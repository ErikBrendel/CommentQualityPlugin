commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;3;;public final Validator getTarget() {     return this.target. }
false;public;1;4;;@Override public boolean supports(Class<?> clazz) {     return this.target.supports(clazz). }
false;public;2;4;;@Override public void validate(Object target, Errors errors) {     this.target.validate(target, errors). }
false;public;3;4;;@Override public void validate(Object target, Errors errors, Object... validationHints) {     this.target.validate(target, errors, validationHints). }
false;public;1;8;;@Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {     if (!this.existingBean && this.target instanceof ApplicationContextAware) {         ((ApplicationContextAware) this.target).setApplicationContext(applicationContext).     } }
false;public;0;6;;@Override public void afterPropertiesSet() throws Exception {     if (!this.existingBean && this.target instanceof InitializingBean) {         ((InitializingBean) this.target).afterPropertiesSet().     } }
false;public;0;6;;@Override public void destroy() throws Exception {     if (!this.existingBean && this.target instanceof DisposableBean) {         ((DisposableBean) this.target).destroy().     } }
true;public,static;2;7;/**  * Return a {@link Validator} that only implements the {@link Validator} interface,  * wrapping it if necessary.  * <p>  * If the specified {@link Validator} is not {@code null}, it is wrapped. If not, a  * {@link javax.validation.Validator} is retrieved from the context and wrapped.  * Otherwise, a new default validator is created.  * @param applicationContext the application context  * @param validator an existing validator to use or {@code null}  * @return the validator to use  */ ;/**  * Return a {@link Validator} that only implements the {@link Validator} interface,  * wrapping it if necessary.  * <p>  * If the specified {@link Validator} is not {@code null}, it is wrapped. If not, a  * {@link javax.validation.Validator} is retrieved from the context and wrapped.  * Otherwise, a new default validator is created.  * @param applicationContext the application context  * @param validator an existing validator to use or {@code null}  * @return the validator to use  */ public static Validator get(ApplicationContext applicationContext, Validator validator) {     if (validator != null) {         return wrap(validator, false).     }     return getExistingOrCreate(applicationContext). }
false;private,static;1;7;;private static Validator getExistingOrCreate(ApplicationContext applicationContext) {     Validator existing = getExisting(applicationContext).     if (existing != null) {         return wrap(existing, true).     }     return create(). }
false;private,static;1;13;;private static Validator getExisting(ApplicationContext applicationContext) {     try {         javax.validation.Validator validator = applicationContext.getBean(javax.validation.Validator.class).         if (validator instanceof Validator) {             return (Validator) validator.         }         return new SpringValidatorAdapter(validator).     } catch (NoSuchBeanDefinitionException ex) {         return null.     } }
false;private,static;0;5;;private static Validator create() {     OptionalValidatorFactoryBean validator = new OptionalValidatorFactoryBean().     validator.setMessageInterpolator(new MessageInterpolatorFactory().getObject()).     return wrap(validator, false). }
false;private,static;2;12;;private static Validator wrap(Validator validator, boolean existingBean) {     if (validator instanceof javax.validation.Validator) {         if (validator instanceof SpringValidatorAdapter) {             return new ValidatorAdapter((SpringValidatorAdapter) validator, existingBean).         }         return new ValidatorAdapter(new SpringValidatorAdapter((javax.validation.Validator) validator), existingBean).     }     return validator. }
