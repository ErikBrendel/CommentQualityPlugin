commented;modifiers;parameterAmount;loc;comment;code
false;public;2;12;;@Override public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {     ConditionMessage.Builder message = ConditionMessage.forCondition("PooledDataSource").     if (getDataSourceClassLoader(context) != null) {         return ConditionOutcome.match(message.foundExactly("supported DataSource")).     }     return ConditionOutcome.noMatch(message.didNotFind("supported DataSource").atAll()). }
true;private;1;5;/**  * Returns the class loader for the {@link DataSource} class. Used to ensure that  * the driver class can actually be loaded by the data source.  * @param context the condition context  * @return the class loader  */ ;/**  * Returns the class loader for the {@link DataSource} class. Used to ensure that  * the driver class can actually be loaded by the data source.  * @param context the condition context  * @return the class loader  */ private ClassLoader getDataSourceClassLoader(ConditionContext context) {     Class<?> dataSourceClass = DataSourceBuilder.findType(context.getClassLoader()).     return (dataSourceClass != null) ? dataSourceClass.getClassLoader() : null. }
false;public;2;17;;@Override public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {     ConditionMessage.Builder message = ConditionMessage.forCondition("EmbeddedDataSource").     if (anyMatches(context, metadata, this.pooledCondition)) {         return ConditionOutcome.noMatch(message.foundExactly("supported pooled data source")).     }     EmbeddedDatabaseType type = EmbeddedDatabaseConnection.get(context.getClassLoader()).getType().     if (type == null) {         return ConditionOutcome.noMatch(message.didNotFind("embedded database").atAll()).     }     return ConditionOutcome.match(message.found("embedded database").items(type)). }
