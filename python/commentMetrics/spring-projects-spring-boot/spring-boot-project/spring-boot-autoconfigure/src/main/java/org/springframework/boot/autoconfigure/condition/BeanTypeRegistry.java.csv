commented;modifiers;parameterAmount;loc;comment;code
true;public;2;7;/**  * Return the names of beans matching the given type (including subclasses), judging  * from either bean definitions or the value of {@link FactoryBean#getObjectType()} in  * the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not  * cause early bean initialization.  * @param type the class or interface to match (must not be {@code null})  * @param typeExtractor function used to extract the actual type  * @return the names of beans (or objects created by FactoryBeans) matching the given  * object type (including subclasses), or an empty set if none  */ ;/**  * Return the names of beans matching the given type (including subclasses), judging  * from either bean definitions or the value of {@link FactoryBean#getObjectType()} in  * the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not  * cause early bean initialization.  * @param type the class or interface to match (must not be {@code null})  * @param typeExtractor function used to extract the actual type  * @return the names of beans (or objects created by FactoryBeans) matching the given  * object type (including subclasses), or an empty set if none  */ public Set<String> getNamesForType(Class<?> type, TypeExtractor typeExtractor) {     updateTypesIfNecessary().     return this.beanTypes.entrySet().stream().filter((entry) -> {         Class<?> beanType = extractType(entry.getValue(), typeExtractor).         return beanType != null && type.isAssignableFrom(beanType).     }).map(Map.Entry::getKey).collect(Collectors.toCollection(LinkedHashSet::new)). }
false;private;2;3;;private Class<?> extractType(ResolvableType type, TypeExtractor extractor) {     return (type != null) ? extractor.getBeanType(type) : null. }
true;public;1;8;/**  * Returns the names of beans annotated with the given {@code annotation}, judging  * from either bean definitions or the value of {@link FactoryBean#getObjectType()} in  * the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not  * cause early bean initialization.  * @param annotation the annotation to match (must not be {@code null})  * @return the names of beans (or objects created by FactoryBeans) annotated with the  * given annotation, or an empty set if none  */ ;/**  * Returns the names of beans annotated with the given {@code annotation}, judging  * from either bean definitions or the value of {@link FactoryBean#getObjectType()} in  * the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not  * cause early bean initialization.  * @param annotation the annotation to match (must not be {@code null})  * @return the names of beans (or objects created by FactoryBeans) annotated with the  * given annotation, or an empty set if none  */ public Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {     updateTypesIfNecessary().     return this.beanTypes.entrySet().stream().filter((entry) -> entry.getValue() != null && AnnotationUtils.findAnnotation(entry.getValue().resolve(), annotation) != null).map(Map.Entry::getKey).collect(Collectors.toCollection(LinkedHashSet::new)). }
false;public;0;6;;@Override public void afterSingletonsInstantiated() {     // We're done at this point, free up some memory     this.beanTypes.clear().     this.beanDefinitions.clear(). }
false;private;0;4;;private void updateTypesIfNecessary() {     this.beanFactory.getBeanNamesIterator().forEachRemaining(this::updateTypesIfNecessary). }
false;private;1;8;;private void updateTypesIfNecessary(String name) {     if (!this.beanTypes.containsKey(name)) {         addBeanType(name).     } else {         updateBeanType(name).     } }
false;private;1;8;;private void addBeanType(String name) {     if (this.beanFactory.containsSingleton(name)) {         this.beanTypes.put(name, getType(name, null)).     } else if (!this.beanFactory.isAlias(name)) {         addBeanTypeForNonAliasDefinition(name).     } }
false;private;1;6;;private void addBeanTypeForNonAliasDefinition(String name) {     RootBeanDefinition definition = getBeanDefinition(name).     if (definition != null) {         addBeanTypeForNonAliasDefinition(name, definition).     } }
false;private;1;13;;private void updateBeanType(String name) {     if (this.beanFactory.isAlias(name) || this.beanFactory.containsSingleton(name)) {         return.     }     RootBeanDefinition definition = getBeanDefinition(name).     if (definition == null) {         return.     }     RootBeanDefinition previous = this.beanDefinitions.put(name, definition).     if (previous != null && !definition.equals(previous)) {         addBeanTypeForNonAliasDefinition(name, definition).     } }
false;private;1;9;;private RootBeanDefinition getBeanDefinition(String name) {     try {         return (RootBeanDefinition) this.beanFactory.getMergedBeanDefinition(name).     } catch (BeanDefinitionStoreException ex) {         logIgnoredError("unresolvable metadata in bean definition", name, ex).         return null.     } }
false;private;2;26;;private void addBeanTypeForNonAliasDefinition(String name, RootBeanDefinition definition) {     try {         if (!definition.isAbstract() && !requiresEagerInit(definition.getFactoryBeanName())) {             ResolvableType factoryMethodReturnType = getFactoryMethodReturnType(definition).             String factoryBeanName = BeanFactory.FACTORY_BEAN_PREFIX + name.             if (this.beanFactory.isFactoryBean(factoryBeanName)) {                 ResolvableType factoryBeanGeneric = getFactoryBeanGeneric(this.beanFactory, definition, factoryMethodReturnType).                 this.beanTypes.put(name, factoryBeanGeneric).                 this.beanTypes.put(factoryBeanName, getType(factoryBeanName, factoryMethodReturnType)).             } else {                 this.beanTypes.put(name, getType(name, factoryMethodReturnType)).             }         }         this.beanDefinitions.put(name, definition).     } catch (CannotLoadBeanClassException ex) {         // Probably contains a placeholder         logIgnoredError("bean class loading failure for bean", name, ex).     } }
false;private;1;4;;private boolean requiresEagerInit(String factoryBeanName) {     return (factoryBeanName != null && this.beanFactory.isFactoryBean(factoryBeanName) && !this.beanFactory.containsSingleton(factoryBeanName)). }
false;private;1;14;;private ResolvableType getFactoryMethodReturnType(BeanDefinition definition) {     try {         if (StringUtils.hasLength(definition.getFactoryBeanName()) && StringUtils.hasLength(definition.getFactoryMethodName())) {             Method method = getFactoryMethod(this.beanFactory, definition).             ResolvableType type = (method != null) ? ResolvableType.forMethodReturnType(method) : null.             return type.         }     } catch (Exception ex) {     }     return null. }
false;private;2;16;;private Method getFactoryMethod(ConfigurableListableBeanFactory beanFactory, BeanDefinition definition) throws Exception {     if (definition instanceof AnnotatedBeanDefinition) {         MethodMetadata factoryMethodMetadata = ((AnnotatedBeanDefinition) definition).getFactoryMethodMetadata().         if (factoryMethodMetadata instanceof StandardMethodMetadata) {             return ((StandardMethodMetadata) factoryMethodMetadata).getIntrospectedMethod().         }     }     BeanDefinition factoryDefinition = beanFactory.getBeanDefinition(definition.getFactoryBeanName()).     Class<?> factoryClass = ClassUtils.forName(factoryDefinition.getBeanClassName(), beanFactory.getBeanClassLoader()).     return getFactoryMethod(definition, factoryClass). }
false;private;2;14;;private Method getFactoryMethod(BeanDefinition definition, Class<?> factoryClass) {     Method uniqueMethod = null.     for (Method candidate : getCandidateFactoryMethods(definition, factoryClass)) {         if (candidate.getName().equals(definition.getFactoryMethodName())) {             if (uniqueMethod == null) {                 uniqueMethod = candidate.             } else if (!hasMatchingParameterTypes(candidate, uniqueMethod)) {                 return null.             }         }     }     return uniqueMethod. }
false;private;2;6;;private Method[] getCandidateFactoryMethods(BeanDefinition definition, Class<?> factoryClass) {     return (shouldConsiderNonPublicMethods(definition) ? ReflectionUtils.getAllDeclaredMethods(factoryClass) : factoryClass.getMethods()). }
false;private;1;4;;private boolean shouldConsiderNonPublicMethods(BeanDefinition definition) {     return (definition instanceof AbstractBeanDefinition) && ((AbstractBeanDefinition) definition).isNonPublicAccessAllowed(). }
false;private;2;3;;private boolean hasMatchingParameterTypes(Method candidate, Method current) {     return Arrays.equals(candidate.getParameterTypes(), current.getParameterTypes()). }
false;private;3;5;;private void logIgnoredError(String message, String name, Exception ex) {     if (logger.isDebugEnabled()) {         logger.debug("Ignoring " + message + " '" + name + "'", ex).     } }
true;private;3;15;/**  * Attempt to guess the type that a {@link FactoryBean} will return based on the  * generics in its method signature.  * @param beanFactory the source bean factory  * @param definition the bean definition  * @param factoryMethodReturnType the factory method return type  * @return the generic type of the {@link FactoryBean} or {@code null}  */ ;/**  * Attempt to guess the type that a {@link FactoryBean} will return based on the  * generics in its method signature.  * @param beanFactory the source bean factory  * @param definition the bean definition  * @param factoryMethodReturnType the factory method return type  * @return the generic type of the {@link FactoryBean} or {@code null}  */ private ResolvableType getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, BeanDefinition definition, ResolvableType factoryMethodReturnType) {     try {         if (factoryMethodReturnType != null) {             return getFactoryBeanType(definition, factoryMethodReturnType).         }         if (StringUtils.hasLength(definition.getBeanClassName())) {             return getDirectFactoryBeanGeneric(beanFactory, definition).         }     } catch (Exception ex) {     }     return null. }
false;private;2;7;;private ResolvableType getDirectFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, BeanDefinition definition) throws ClassNotFoundException, LinkageError {     Class<?> factoryBeanClass = ClassUtils.forName(definition.getBeanClassName(), beanFactory.getBeanClassLoader()).     return getFactoryBeanType(definition, ResolvableType.forClass(factoryBeanClass)). }
false;private;2;10;;private ResolvableType getFactoryBeanType(BeanDefinition definition, ResolvableType type) throws ClassNotFoundException, LinkageError {     ResolvableType generic = type.as(FactoryBean.class).getGeneric().     if ((generic == null || generic.resolve().equals(Object.class)) && definition.hasAttribute(FACTORY_BEAN_OBJECT_TYPE)) {         generic = getTypeFromAttribute(definition.getAttribute(FACTORY_BEAN_OBJECT_TYPE)).     }     return generic. }
false;private;1;10;;private ResolvableType getTypeFromAttribute(Object attribute) throws ClassNotFoundException, LinkageError {     if (attribute instanceof Class<?>) {         return ResolvableType.forClass((Class<?>) attribute).     }     if (attribute instanceof String) {         return ResolvableType.forClass(ClassUtils.forName((String) attribute, null)).     }     return null. }
false;private;2;8;;private ResolvableType getType(String name, ResolvableType factoryMethodReturnType) {     if (factoryMethodReturnType != null && !factoryMethodReturnType.resolve(Object.class).equals(Object.class)) {         return factoryMethodReturnType.     }     Class<?> type = this.beanFactory.getType(name).     return (type != null) ? ResolvableType.forClass(type) : null. }
true;static;1;15;/**  * Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}.  * @param beanFactory the source bean factory  * @return the {@link BeanTypeRegistry} for the given bean factory  */ ;/**  * Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}.  * @param beanFactory the source bean factory  * @return the {@link BeanTypeRegistry} for the given bean factory  */ static BeanTypeRegistry get(ListableBeanFactory beanFactory) {     Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory).     DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory.     Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(), "Bean factory must allow eager class loading").     if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {         BeanDefinition definition = BeanDefinitionBuilder.genericBeanDefinition(BeanTypeRegistry.class, () -> new BeanTypeRegistry((DefaultListableBeanFactory) beanFactory)).getBeanDefinition().         listableBeanFactory.registerBeanDefinition(BEAN_NAME, definition).     }     return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class). }
false;;1;1;;Class<?> getBeanType(ResolvableType type).
