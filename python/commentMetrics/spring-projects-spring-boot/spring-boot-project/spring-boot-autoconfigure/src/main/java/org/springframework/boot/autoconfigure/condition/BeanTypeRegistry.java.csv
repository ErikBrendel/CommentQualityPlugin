# id;timestamp;commentText;codeText;commentWords;codeWords
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1507173536;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = new RootBeanDefinition(BeanTypeRegistry.class)__			bd.getConstructorArgumentValues().addIndexedArgumentValue(0, beanFactory)__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)___		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,new,root,bean,definition,bean,type,registry,class,bd,get,constructor,argument,values,add,indexed,argument,value,0,bean,factory,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1516665807;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = new RootBeanDefinition(BeanTypeRegistry.class)__			bd.getConstructorArgumentValues().addIndexedArgumentValue(0, beanFactory)__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)___		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,new,root,bean,definition,bean,type,registry,class,bd,get,constructor,argument,values,add,indexed,argument,value,0,bean,factory,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1517564108;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = new RootBeanDefinition(BeanTypeRegistry.class)__			bd.getConstructorArgumentValues().addIndexedArgumentValue(0, beanFactory)__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)___		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,new,root,bean,definition,bean,type,registry,class,bd,get,constructor,argument,values,add,indexed,argument,value,0,bean,factory,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1518087233;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = new RootBeanDefinition(BeanTypeRegistry.class)__			bd.getConstructorArgumentValues().addIndexedArgumentValue(0, beanFactory)__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)___		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,new,root,bean,definition,bean,type,registry,class,bd,get,constructor,argument,values,add,indexed,argument,value,0,bean,factory,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1522899137;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = new RootBeanDefinition(BeanTypeRegistry.class)__			bd.getConstructorArgumentValues().addIndexedArgumentValue(0, beanFactory)__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)___		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,new,root,bean,definition,bean,type,registry,class,bd,get,constructor,argument,values,add,indexed,argument,value,0,bean,factory,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1525376698;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = new RootBeanDefinition(BeanTypeRegistry.class)__			bd.getConstructorArgumentValues().addIndexedArgumentValue(0, beanFactory)__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)___		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,new,root,bean,definition,bean,type,registry,class,bd,get,constructor,argument,values,add,indexed,argument,value,0,bean,factory,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1531324318;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = new RootBeanDefinition(BeanTypeRegistry.class)__			bd.getConstructorArgumentValues().addIndexedArgumentValue(0, beanFactory)__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)___		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,new,root,bean,definition,bean,type,registry,class,bd,get,constructor,argument,values,add,indexed,argument,value,0,bean,factory,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1532102665;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = new RootBeanDefinition(BeanTypeRegistry.class)__			bd.getConstructorArgumentValues().addIndexedArgumentValue(0, beanFactory)__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)___		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,new,root,bean,definition,bean,type,registry,class,bd,get,constructor,argument,values,add,indexed,argument,value,0,bean,factory,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1535670145;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = new RootBeanDefinition(BeanTypeRegistry.class)__			bd.getConstructorArgumentValues().addIndexedArgumentValue(0, beanFactory)__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)___		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,new,root,bean,definition,bean,type,registry,class,bd,get,constructor,argument,values,add,indexed,argument,value,0,bean,factory,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1537383549;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = BeanDefinitionBuilder_					.genericBeanDefinition(BeanTypeRegistry.class,_							() -> new BeanTypeRegistry(_									(DefaultListableBeanFactory) beanFactory))_					.getBeanDefinition()__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)___		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,bean,definition,builder,generic,bean,definition,bean,type,registry,class,new,bean,type,registry,default,listable,bean,factory,bean,factory,get,bean,definition,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1540244103;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = BeanDefinitionBuilder_					.genericBeanDefinition(BeanTypeRegistry.class,_							() -> new BeanTypeRegistry(_									(DefaultListableBeanFactory) beanFactory))_					.getBeanDefinition()__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)__		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,bean,definition,builder,generic,bean,definition,bean,type,registry,class,new,bean,type,registry,default,listable,bean,factory,bean,factory,get,bean,definition,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1540419049;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition bd = BeanDefinitionBuilder_					.genericBeanDefinition(BeanTypeRegistry.class,_							() -> new BeanTypeRegistry(_									(DefaultListableBeanFactory) beanFactory))_					.getBeanDefinition()__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, bd)__		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,bd,bean,definition,builder,generic,bean,definition,bean,type,registry,class,new,bean,type,registry,default,listable,bean,factory,bean,factory,get,bean,definition,listable,bean,factory,register,bean,definition,bd,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> static BeanTypeRegistry get(ListableBeanFactory beanFactory);1540419049;Factory method to get the {@link BeanTypeRegistry} for a given {@link BeanFactory}._@param beanFactory the source bean factory_@return the {@link BeanTypeRegistry} for the given bean factory;static BeanTypeRegistry get(ListableBeanFactory beanFactory) {_		Assert.isInstanceOf(DefaultListableBeanFactory.class, beanFactory)__		DefaultListableBeanFactory listableBeanFactory = (DefaultListableBeanFactory) beanFactory__		Assert.isTrue(listableBeanFactory.isAllowEagerClassLoading(),_				"Bean factory must allow eager class loading")__		if (!listableBeanFactory.containsLocalBean(BEAN_NAME)) {_			BeanDefinition definition = BeanDefinitionBuilder_					.genericBeanDefinition(BeanTypeRegistry.class,_							() -> new BeanTypeRegistry(_									(DefaultListableBeanFactory) beanFactory))_					.getBeanDefinition()__			listableBeanFactory.registerBeanDefinition(BEAN_NAME, definition)__		}_		return listableBeanFactory.getBean(BEAN_NAME, BeanTypeRegistry.class)__	};factory,method,to,get,the,link,bean,type,registry,for,a,given,link,bean,factory,param,bean,factory,the,source,bean,factory,return,the,link,bean,type,registry,for,the,given,bean,factory;static,bean,type,registry,get,listable,bean,factory,bean,factory,assert,is,instance,of,default,listable,bean,factory,class,bean,factory,default,listable,bean,factory,listable,bean,factory,default,listable,bean,factory,bean,factory,assert,is,true,listable,bean,factory,is,allow,eager,class,loading,bean,factory,must,allow,eager,class,loading,if,listable,bean,factory,contains,local,bean,bean,definition,definition,bean,definition,builder,generic,bean,definition,bean,type,registry,class,new,bean,type,registry,default,listable,bean,factory,bean,factory,get,bean,definition,listable,bean,factory,register,bean,definition,definition,return,listable,bean,factory,get,bean,bean,type,registry,class
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1507173536;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		Set<String> matches = new LinkedHashSet<>()__		for (Map.Entry<String, Class<?>> entry : this.beanTypes.entrySet()) {_			if (entry.getValue() != null && AnnotationUtils_					.findAnnotation(entry.getValue(), annotation) != null) {_				matches.add(entry.getKey())__			}_		}_		return matches__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,set,string,matches,new,linked,hash,set,for,map,entry,string,class,entry,this,bean,types,entry,set,if,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,matches,add,entry,get,key,return,matches
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1516665807;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		Set<String> matches = new LinkedHashSet<>()__		for (Map.Entry<String, Class<?>> entry : this.beanTypes.entrySet()) {_			if (entry.getValue() != null && AnnotationUtils_					.findAnnotation(entry.getValue(), annotation) != null) {_				matches.add(entry.getKey())__			}_		}_		return matches__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,set,string,matches,new,linked,hash,set,for,map,entry,string,class,entry,this,bean,types,entry,set,if,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,matches,add,entry,get,key,return,matches
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1517564108;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		Set<String> matches = new LinkedHashSet<>()__		for (Map.Entry<String, Class<?>> entry : this.beanTypes.entrySet()) {_			if (entry.getValue() != null && AnnotationUtils_					.findAnnotation(entry.getValue(), annotation) != null) {_				matches.add(entry.getKey())__			}_		}_		return matches__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,set,string,matches,new,linked,hash,set,for,map,entry,string,class,entry,this,bean,types,entry,set,if,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,matches,add,entry,get,key,return,matches
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1518087233;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		Set<String> matches = new LinkedHashSet<>()__		for (Map.Entry<String, Class<?>> entry : this.beanTypes.entrySet()) {_			if (entry.getValue() != null && AnnotationUtils_					.findAnnotation(entry.getValue(), annotation) != null) {_				matches.add(entry.getKey())__			}_		}_		return matches__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,set,string,matches,new,linked,hash,set,for,map,entry,string,class,entry,this,bean,types,entry,set,if,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,matches,add,entry,get,key,return,matches
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1522899137;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null && AnnotationUtils_						.findAnnotation(entry.getValue(), annotation) != null)_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1525376698;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null && AnnotationUtils_						.findAnnotation(entry.getValue(), annotation) != null)_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1531324318;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null && AnnotationUtils_						.findAnnotation(entry.getValue(), annotation) != null)_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1532102665;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null && AnnotationUtils_						.findAnnotation(entry.getValue(), annotation) != null)_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1535670145;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null && AnnotationUtils_						.findAnnotation(entry.getValue(), annotation) != null)_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1537383549;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null && AnnotationUtils_						.findAnnotation(entry.getValue(), annotation) != null)_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1540244103;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null && AnnotationUtils_						.findAnnotation(entry.getValue(), annotation) != null)_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> public Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1540419049;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;public Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null && AnnotationUtils_						.findAnnotation(entry.getValue(), annotation) != null)_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;public,set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,annotation,null,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> public Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation);1540419049;Returns the names of beans annotated with the given {@code annotation}, judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param annotation the annotation to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) annotated with the_given annotation, or an empty set if none;public Set<String> getNamesForAnnotation(Class<? extends Annotation> annotation) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null && AnnotationUtils_						.findAnnotation(entry.getValue().resolve(), annotation) != null)_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};returns,the,names,of,beans,annotated,with,the,given,code,annotation,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,annotation,the,annotation,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,annotated,with,the,given,annotation,or,an,empty,set,if,none;public,set,string,get,names,for,annotation,class,extends,annotation,annotation,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,annotation,utils,find,annotation,entry,get,value,resolve,annotation,null,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition, String name);1507173536;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@param name the name of the bean_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition, String name) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition, name)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,param,name,the,name,of,the,bean,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,string,name,try,return,do,get,factory,bean,generic,bean,factory,definition,name,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition, String name);1516665807;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@param name the name of the bean_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition, String name) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition, name)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,param,name,the,name,of,the,bean,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,string,name,try,return,do,get,factory,bean,generic,bean,factory,definition,name,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition);1517564108;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,try,return,do,get,factory,bean,generic,bean,factory,definition,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition);1518087233;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,try,return,do,get,factory,bean,generic,bean,factory,definition,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition);1522899137;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,try,return,do,get,factory,bean,generic,bean,factory,definition,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition);1525376698;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,try,return,do,get,factory,bean,generic,bean,factory,definition,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition);1531324318;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,try,return,do,get,factory,bean,generic,bean,factory,definition,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition);1532102665;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,try,return,do,get,factory,bean,generic,bean,factory,definition,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition);1535670145;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,try,return,do,get,factory,bean,generic,bean,factory,definition,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition);1537383549;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,try,return,do,get,factory,bean,generic,bean,factory,definition,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition);1540244103;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,try,return,do,get,factory,bean,generic,bean,factory,definition,catch,exception,ex,return,null
BeanTypeRegistry -> private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory, 			BeanDefinition definition);1540419049;Attempt to guess the type that a {@link FactoryBean} will return based on the_generics in its method signature._@param beanFactory the source bean factory_@param definition the bean definition_@return the generic type of the {@link FactoryBean} or {@code null};private Class<?> getFactoryBeanGeneric(ConfigurableListableBeanFactory beanFactory,_			BeanDefinition definition) {_		try {_			return doGetFactoryBeanGeneric(beanFactory, definition)__		}_		catch (Exception ex) {_			return null__		}_	};attempt,to,guess,the,type,that,a,link,factory,bean,will,return,based,on,the,generics,in,its,method,signature,param,bean,factory,the,source,bean,factory,param,definition,the,bean,definition,return,the,generic,type,of,the,link,factory,bean,or,code,null;private,class,get,factory,bean,generic,configurable,listable,bean,factory,bean,factory,bean,definition,definition,try,return,do,get,factory,bean,generic,bean,factory,definition,catch,exception,ex,return,null
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1507173536;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		Set<String> matches = new LinkedHashSet<>()__		for (Map.Entry<String, Class<?>> entry : this.beanTypes.entrySet()) {_			if (entry.getValue() != null && type.isAssignableFrom(entry.getValue())) {_				matches.add(entry.getKey())__			}_		}_		return matches__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,set,string,matches,new,linked,hash,set,for,map,entry,string,class,entry,this,bean,types,entry,set,if,entry,get,value,null,type,is,assignable,from,entry,get,value,matches,add,entry,get,key,return,matches
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1516665807;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		Set<String> matches = new LinkedHashSet<>()__		for (Map.Entry<String, Class<?>> entry : this.beanTypes.entrySet()) {_			if (entry.getValue() != null && type.isAssignableFrom(entry.getValue())) {_				matches.add(entry.getKey())__			}_		}_		return matches__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,set,string,matches,new,linked,hash,set,for,map,entry,string,class,entry,this,bean,types,entry,set,if,entry,get,value,null,type,is,assignable,from,entry,get,value,matches,add,entry,get,key,return,matches
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1517564108;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		Set<String> matches = new LinkedHashSet<>()__		for (Map.Entry<String, Class<?>> entry : this.beanTypes.entrySet()) {_			if (entry.getValue() != null && type.isAssignableFrom(entry.getValue())) {_				matches.add(entry.getKey())__			}_		}_		return matches__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,set,string,matches,new,linked,hash,set,for,map,entry,string,class,entry,this,bean,types,entry,set,if,entry,get,value,null,type,is,assignable,from,entry,get,value,matches,add,entry,get,key,return,matches
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1518087233;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		Set<String> matches = new LinkedHashSet<>()__		for (Map.Entry<String, Class<?>> entry : this.beanTypes.entrySet()) {_			if (entry.getValue() != null && type.isAssignableFrom(entry.getValue())) {_				matches.add(entry.getKey())__			}_		}_		return matches__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,set,string,matches,new,linked,hash,set,for,map,entry,string,class,entry,this,bean,types,entry,set,if,entry,get,value,null,type,is,assignable,from,entry,get,value,matches,add,entry,get,key,return,matches
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1522899137;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null_						&& type.isAssignableFrom(entry.getValue()))_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,type,is,assignable,from,entry,get,value,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1525376698;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null_						&& type.isAssignableFrom(entry.getValue()))_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,type,is,assignable,from,entry,get,value,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1531324318;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null_						&& type.isAssignableFrom(entry.getValue()))_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,type,is,assignable,from,entry,get,value,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1532102665;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null_						&& type.isAssignableFrom(entry.getValue()))_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,type,is,assignable,from,entry,get,value,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1535670145;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null_						&& type.isAssignableFrom(entry.getValue()))_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,type,is,assignable,from,entry,get,value,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1537383549;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null_						&& type.isAssignableFrom(entry.getValue()))_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,type,is,assignable,from,entry,get,value,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
BeanTypeRegistry -> Set<String> getNamesForType(Class<?> type);1540244103;Return the names of beans matching the given type (including subclasses), judging_from either bean definitions or the value of {@link FactoryBean#getObjectType()} in_the case of {@link FactoryBean FactoryBeans}. Will include singletons but will not_cause early bean initialization._@param type the class or interface to match (must not be {@code null})_@return the names of beans (or objects created by FactoryBeans) matching the given_object type (including subclasses), or an empty set if none;Set<String> getNamesForType(Class<?> type) {_		updateTypesIfNecessary()__		return this.beanTypes.entrySet().stream()_				.filter((entry) -> entry.getValue() != null_						&& type.isAssignableFrom(entry.getValue()))_				.map(Map.Entry::getKey)_				.collect(Collectors.toCollection(LinkedHashSet::new))__	};return,the,names,of,beans,matching,the,given,type,including,subclasses,judging,from,either,bean,definitions,or,the,value,of,link,factory,bean,get,object,type,in,the,case,of,link,factory,bean,factory,beans,will,include,singletons,but,will,not,cause,early,bean,initialization,param,type,the,class,or,interface,to,match,must,not,be,code,null,return,the,names,of,beans,or,objects,created,by,factory,beans,matching,the,given,object,type,including,subclasses,or,an,empty,set,if,none;set,string,get,names,for,type,class,type,update,types,if,necessary,return,this,bean,types,entry,set,stream,filter,entry,entry,get,value,null,type,is,assignable,from,entry,get,value,map,map,entry,get,key,collect,collectors,to,collection,linked,hash,set,new
