commented;modifiers;parameterAmount;loc;comment;code
false;public;2;18;;@Override public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {     List<AnnotationAttributes> allAnnotationAttributes = annotationAttributesFromMultiValueMap(metadata.getAllAnnotationAttributes(ConditionalOnProperty.class.getName())).     List<ConditionMessage> noMatch = new ArrayList<>().     List<ConditionMessage> match = new ArrayList<>().     for (AnnotationAttributes annotationAttributes : allAnnotationAttributes) {         ConditionOutcome outcome = determineOutcome(annotationAttributes, context.getEnvironment()).         (outcome.isMatch() ? match : noMatch).add(outcome.getConditionMessage()).     }     if (!noMatch.isEmpty()) {         return ConditionOutcome.noMatch(ConditionMessage.of(noMatch)).     }     return ConditionOutcome.match(ConditionMessage.of(match)). }
false;private;1;22;;private List<AnnotationAttributes> annotationAttributesFromMultiValueMap(MultiValueMap<String, Object> multiValueMap) {     List<Map<String, Object>> maps = new ArrayList<>().     multiValueMap.forEach((key, value) -> {         for (int i = 0. i < value.size(). i++) {             Map<String, Object> map.             if (i < maps.size()) {                 map = maps.get(i).             } else {                 map = new HashMap<>().                 maps.add(map).             }             map.put(key, value.get(i)).         }     }).     List<AnnotationAttributes> annotationAttributes = new ArrayList<>(maps.size()).     for (Map<String, Object> map : maps) {         annotationAttributes.add(AnnotationAttributes.fromMap(map)).     }     return annotationAttributes. }
false;private;2;22;;private ConditionOutcome determineOutcome(AnnotationAttributes annotationAttributes, PropertyResolver resolver) {     Spec spec = new Spec(annotationAttributes).     List<String> missingProperties = new ArrayList<>().     List<String> nonMatchingProperties = new ArrayList<>().     spec.collectProperties(resolver, missingProperties, nonMatchingProperties).     if (!missingProperties.isEmpty()) {         return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnProperty.class, spec).didNotFind("property", "properties").items(Style.QUOTE, missingProperties)).     }     if (!nonMatchingProperties.isEmpty()) {         return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnProperty.class, spec).found("different value in property", "different value in properties").items(Style.QUOTE, nonMatchingProperties)).     }     return ConditionOutcome.match(ConditionMessage.forCondition(ConditionalOnProperty.class, spec).because("matched")). }
false;private;1;9;;private String[] getNames(Map<String, Object> annotationAttributes) {     String[] value = (String[]) annotationAttributes.get("value").     String[] name = (String[]) annotationAttributes.get("name").     Assert.state(value.length > 0 || name.length > 0, "The name or value attribute of @ConditionalOnProperty must be specified").     Assert.state(value.length == 0 || name.length == 0, "The name and value attributes of @ConditionalOnProperty are exclusive").     return (value.length > 0) ? value : name. }
false;private;3;16;;private void collectProperties(PropertyResolver resolver, List<String> missing, List<String> nonMatching) {     for (String name : this.names) {         String key = this.prefix + name.         if (resolver.containsProperty(key)) {             if (!isMatch(resolver.getProperty(key), this.havingValue)) {                 nonMatching.add(name).             }         } else {             if (!this.matchIfMissing) {                 missing.add(name).             }         }     } }
false;private;2;6;;private boolean isMatch(String value, String requiredValue) {     if (StringUtils.hasLength(requiredValue)) {         return requiredValue.equalsIgnoreCase(value).     }     return !"false".equalsIgnoreCase(value). }
false;public;0;19;;@Override public String toString() {     StringBuilder result = new StringBuilder().     result.append("(").     result.append(this.prefix).     if (this.names.length == 1) {         result.append(this.names[0]).     } else {         result.append("[").         result.append(StringUtils.arrayToCommaDelimitedString(this.names)).         result.append("]").     }     if (StringUtils.hasLength(this.havingValue)) {         result.append("=").append(this.havingValue).     }     result.append(")").     return result.toString(). }
