commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException {     Assert.isInstanceOf(ConfigurableListableBeanFactory.class, beanFactory).     this.beanFactory = (ConfigurableListableBeanFactory) beanFactory.     this.metadataReaderFactory = new CachingMetadataReaderFactory(this.beanFactory.getBeanClassLoader()).     // Get early as won't be accessible once context has failed to start     this.report = ConditionEvaluationReport.get(this.beanFactory). }
false;protected;3;39;;@Override protected FailureAnalysis analyze(Throwable rootFailure, NoSuchBeanDefinitionException cause, String description) {     if (cause.getNumberOfBeansFound() != 0) {         return null.     }     List<AutoConfigurationResult> autoConfigurationResults = getAutoConfigurationResults(cause).     List<UserConfigurationResult> userConfigurationResults = getUserConfigurationResults(cause).     StringBuilder message = new StringBuilder().     message.append(String.format("%s required %s that could not be found.%n", (description != null) ? description : "A component", getBeanDescription(cause))).     List<Annotation> injectionAnnotations = findInjectionAnnotations(rootFailure).     if (!injectionAnnotations.isEmpty()) {         message.append(String.format("%nThe injection point has the following annotations:%n")).         for (Annotation injectionAnnotation : injectionAnnotations) {             message.append(String.format("\t- %s%n", injectionAnnotation)).         }     }     if (!autoConfigurationResults.isEmpty() || !userConfigurationResults.isEmpty()) {         message.append(String.format("%nThe following candidates were found but could not be injected:%n")).         for (AutoConfigurationResult result : autoConfigurationResults) {             message.append(String.format("\t- %s%n", result)).         }         for (UserConfigurationResult result : userConfigurationResults) {             message.append(String.format("\t- %s%n", result)).         }     }     String action = String.format("Consider %s %s in your configuration.", (!autoConfigurationResults.isEmpty() || !userConfigurationResults.isEmpty()) ? "revisiting the entries above or defining" : "defining", getBeanDescription(cause)).     return new FailureAnalysis(message.toString(), action, cause). }
false;private;1;7;;private String getBeanDescription(NoSuchBeanDefinitionException cause) {     if (cause.getResolvableType() != null) {         Class<?> type = extractBeanType(cause.getResolvableType()).         return "a bean of type '" + type.getName() + "'".     }     return "a bean named '" + cause.getBeanName() + "'". }
false;private;1;3;;private Class<?> extractBeanType(ResolvableType resolvableType) {     return resolvableType.getRawClass(). }
false;private;1;7;;private List<AutoConfigurationResult> getAutoConfigurationResults(NoSuchBeanDefinitionException cause) {     List<AutoConfigurationResult> results = new ArrayList<>().     collectReportedConditionOutcomes(cause, results).     collectExcludedAutoConfiguration(cause, results).     return results. }
false;private;1;14;;private List<UserConfigurationResult> getUserConfigurationResults(NoSuchBeanDefinitionException cause) {     ResolvableType type = cause.getResolvableType().     if (type == null) {         return Collections.emptyList().     }     String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, type).     return Arrays.stream(beanNames).map((beanName) -> new UserConfigurationResult(getFactoryMethodMetadata(beanName), this.beanFactory.getBean(beanName).equals(null))).collect(Collectors.toList()). }
false;private;1;7;;private MethodMetadata getFactoryMethodMetadata(String beanName) {     BeanDefinition beanDefinition = this.beanFactory.getBeanDefinition(beanName).     if (beanDefinition instanceof AnnotatedBeanDefinition) {         return ((AnnotatedBeanDefinition) beanDefinition).getFactoryMethodMetadata().     }     return null. }
false;private;2;6;;private void collectReportedConditionOutcomes(NoSuchBeanDefinitionException cause, List<AutoConfigurationResult> results) {     this.report.getConditionAndOutcomesBySource().forEach((source, sourceOutcomes) -> collectReportedConditionOutcomes(cause, new Source(source), sourceOutcomes, results)). }
false;private;4;16;;private void collectReportedConditionOutcomes(NoSuchBeanDefinitionException cause, Source source, ConditionAndOutcomes sourceOutcomes, List<AutoConfigurationResult> results) {     if (sourceOutcomes.isFullMatch()) {         return.     }     BeanMethods methods = new BeanMethods(source, cause).     for (ConditionAndOutcome conditionAndOutcome : sourceOutcomes) {         if (!conditionAndOutcome.getOutcome().isMatch()) {             for (MethodMetadata method : methods) {                 results.add(new AutoConfigurationResult(method, conditionAndOutcome.getOutcome())).             }         }     } }
false;private;2;13;;private void collectExcludedAutoConfiguration(NoSuchBeanDefinitionException cause, List<AutoConfigurationResult> results) {     for (String excludedClass : this.report.getExclusions()) {         Source source = new Source(excludedClass).         BeanMethods methods = new BeanMethods(source, cause).         for (MethodMetadata method : methods) {             String message = String.format("auto-configuration '%s' was excluded", ClassUtils.getShortName(excludedClass)).             results.add(new AutoConfigurationResult(method, new ConditionOutcome(false, message))).         }     } }
false;private;1;9;;private List<Annotation> findInjectionAnnotations(Throwable failure) {     UnsatisfiedDependencyException unsatisfiedDependencyException = findCause(failure, UnsatisfiedDependencyException.class).     if (unsatisfiedDependencyException == null) {         return Collections.emptyList().     }     return Arrays.asList(unsatisfiedDependencyException.getInjectionPoint().getAnnotations()). }
false;public;0;3;;public String getClassName() {     return this.className. }
false;public;0;3;;public String getMethodName() {     return this.methodName. }
false;private;2;19;;private List<MethodMetadata> findBeanMethods(Source source, NoSuchBeanDefinitionException cause) {     try {         MetadataReader classMetadata = NoSuchBeanDefinitionFailureAnalyzer.this.metadataReaderFactory.getMetadataReader(source.getClassName()).         Set<MethodMetadata> candidates = classMetadata.getAnnotationMetadata().getAnnotatedMethods(Bean.class.getName()).         List<MethodMetadata> result = new ArrayList<>().         for (MethodMetadata candidate : candidates) {             if (isMatch(candidate, source, cause)) {                 result.add(candidate).             }         }         return Collections.unmodifiableList(result).     } catch (Exception ex) {         return Collections.emptyList().     } }
false;private;3;11;;private boolean isMatch(MethodMetadata candidate, Source source, NoSuchBeanDefinitionException cause) {     if (source.getMethodName() != null && !source.getMethodName().equals(candidate.getMethodName())) {         return false.     }     String name = cause.getBeanName().     ResolvableType resolvableType = cause.getResolvableType().     return ((name != null && hasName(candidate, name)) || (resolvableType != null && hasType(candidate, extractBeanType(resolvableType)))). }
false;private;2;15;;private boolean hasName(MethodMetadata methodMetadata, String name) {     Map<String, Object> attributes = methodMetadata.getAnnotationAttributes(Bean.class.getName()).     String[] candidates = (attributes != null) ? (String[]) attributes.get("name") : null.     if (candidates != null) {         for (String candidate : candidates) {             if (candidate.equals(name)) {                 return true.             }         }         return false.     }     return methodMetadata.getMethodName().equals(name). }
false;private;2;15;;private boolean hasType(MethodMetadata candidate, Class<?> type) {     String returnTypeName = candidate.getReturnTypeName().     if (type.getName().equals(returnTypeName)) {         return true.     }     try {         Class<?> returnType = ClassUtils.forName(returnTypeName, NoSuchBeanDefinitionFailureAnalyzer.this.beanFactory.getBeanClassLoader()).         return type.isAssignableFrom(returnType).     } catch (Throwable ex) {         return false.     } }
false;public;0;4;;@Override public Iterator<MethodMetadata> iterator() {     return this.methods.iterator(). }
false;public;0;7;;@Override public String toString() {     return String.format("Bean method '%s' in '%s' not loaded because %s", this.methodMetadata.getMethodName(), ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()), this.conditionOutcome.getMessage()). }
false;public;0;13;;@Override public String toString() {     StringBuilder sb = new StringBuilder("User-defined bean").     if (this.methodMetadata != null) {         sb.append(String.format(" method '%s' in '%s'", this.methodMetadata.getMethodName(), ClassUtils.getShortName(this.methodMetadata.getDeclaringClassName()))).     }     if (this.nullBean) {         sb.append(" ignored as the bean value is null").     }     return sb.toString(). }
