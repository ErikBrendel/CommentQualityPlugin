commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getDdlAuto() {     return this.ddlAuto. }
false;public;1;3;;public void setDdlAuto(String ddlAuto) {     this.ddlAuto = ddlAuto. }
false;public;0;3;;public Boolean isUseNewIdGeneratorMappings() {     return this.useNewIdGeneratorMappings. }
false;public;1;3;;public void setUseNewIdGeneratorMappings(Boolean useNewIdGeneratorMappings) {     this.useNewIdGeneratorMappings = useNewIdGeneratorMappings. }
false;public;0;3;;public Naming getNaming() {     return this.naming. }
true;public;2;6;/**  * Determine the configuration properties for the initialization of the main Hibernate  * EntityManagerFactory based on standard JPA properties and  * {@link HibernateSettings}.  * @param jpaProperties standard JPA properties  * @param settings the settings to apply when determining the configuration properties  * @return the Hibernate properties to use  */ ;/**  * Determine the configuration properties for the initialization of the main Hibernate  * EntityManagerFactory based on standard JPA properties and  * {@link HibernateSettings}.  * @param jpaProperties standard JPA properties  * @param settings the settings to apply when determining the configuration properties  * @return the Hibernate properties to use  */ public Map<String, Object> determineHibernateProperties(Map<String, String> jpaProperties, HibernateSettings settings) {     Assert.notNull(jpaProperties, "JpaProperties must not be null").     Assert.notNull(settings, "Settings must not be null").     return getAdditionalProperties(jpaProperties, settings). }
false;private;2;20;;private Map<String, Object> getAdditionalProperties(Map<String, String> existing, HibernateSettings settings) {     Map<String, Object> result = new HashMap<>(existing).     applyNewIdGeneratorMappings(result).     applyScanner(result).     getNaming().applyNamingStrategies(result).     String ddlAuto = determineDdlAuto(existing, settings::getDdlAuto).     if (StringUtils.hasText(ddlAuto) && !"none".equals(ddlAuto)) {         result.put(AvailableSettings.HBM2DDL_AUTO, ddlAuto).     } else {         result.remove(AvailableSettings.HBM2DDL_AUTO).     }     Collection<HibernatePropertiesCustomizer> customizers = settings.getHibernatePropertiesCustomizers().     if (!ObjectUtils.isEmpty(customizers)) {         customizers.forEach((customizer) -> customizer.customize(result)).     }     return result. }
false;private;1;9;;private void applyNewIdGeneratorMappings(Map<String, Object> result) {     if (this.useNewIdGeneratorMappings != null) {         result.put(AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS, this.useNewIdGeneratorMappings.toString()).     } else if (!result.containsKey(AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS)) {         result.put(AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS, "true").     } }
false;private;1;6;;private void applyScanner(Map<String, Object> result) {     if (!result.containsKey(AvailableSettings.SCANNER) && ClassUtils.isPresent(DISABLED_SCANNER_CLASS, null)) {         result.put(AvailableSettings.SCANNER, DISABLED_SCANNER_CLASS).     } }
false;private;2;8;;private String determineDdlAuto(Map<String, String> existing, Supplier<String> defaultDdlAuto) {     String ddlAuto = existing.get(AvailableSettings.HBM2DDL_AUTO).     if (ddlAuto != null) {         return ddlAuto.     }     return (this.ddlAuto != null) ? this.ddlAuto : defaultDdlAuto.get(). }
false;public;0;3;;public String getImplicitStrategy() {     return this.implicitStrategy. }
false;public;1;3;;public void setImplicitStrategy(String implicitStrategy) {     this.implicitStrategy = implicitStrategy. }
false;public;0;3;;public String getPhysicalStrategy() {     return this.physicalStrategy. }
false;public;1;3;;public void setPhysicalStrategy(String physicalStrategy) {     this.physicalStrategy = physicalStrategy. }
false;private;1;6;;private void applyNamingStrategies(Map<String, Object> properties) {     applyNamingStrategy(properties, AvailableSettings.IMPLICIT_NAMING_STRATEGY, this.implicitStrategy, SpringImplicitNamingStrategy.class.getName()).     applyNamingStrategy(properties, AvailableSettings.PHYSICAL_NAMING_STRATEGY, this.physicalStrategy, SpringPhysicalNamingStrategy.class.getName()). }
false;private;4;9;;private void applyNamingStrategy(Map<String, Object> properties, String key, Object strategy, Object defaultStrategy) {     if (strategy != null) {         properties.put(key, strategy).     } else if (defaultStrategy != null && !properties.containsKey(key)) {         properties.put(key, defaultStrategy).     } }
