commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Determine if the auto-configuration base packages for the given bean factory are  * available.  * @param beanFactory the source bean factory  * @return true if there are auto-config packages available  */ ;/**  * Determine if the auto-configuration base packages for the given bean factory are  * available.  * @param beanFactory the source bean factory  * @return true if there are auto-config packages available  */ public static boolean has(BeanFactory beanFactory) {     return beanFactory.containsBean(BEAN) && !get(beanFactory).isEmpty(). }
true;public,static;1;9;/**  * Return the auto-configuration base packages for the given bean factory.  * @param beanFactory the source bean factory  * @return a list of auto-configuration packages  * @throws IllegalStateException if auto-configuration is not enabled  */ ;/**  * Return the auto-configuration base packages for the given bean factory.  * @param beanFactory the source bean factory  * @return a list of auto-configuration packages  * @throws IllegalStateException if auto-configuration is not enabled  */ public static List<String> get(BeanFactory beanFactory) {     try {         return beanFactory.getBean(BEAN, BasePackages.class).get().     } catch (NoSuchBeanDefinitionException ex) {         throw new IllegalStateException("Unable to retrieve @EnableAutoConfiguration base packages").     } }
true;public,static;2;17;/**  * Programmatically registers the auto-configuration package names. Subsequent  * invocations will add the given package names to those that have already been  * registered. You can use this method to manually define the base packages that will  * be used for a given {@link BeanDefinitionRegistry}. Generally it's recommended that  * you don't call this method directly, but instead rely on the default convention  * where the package name is set from your {@code @EnableAutoConfiguration}  * configuration class or classes.  * @param registry the bean definition registry  * @param packageNames the package names to set  */ ;/**  * Programmatically registers the auto-configuration package names. Subsequent  * invocations will add the given package names to those that have already been  * registered. You can use this method to manually define the base packages that will  * be used for a given {@link BeanDefinitionRegistry}. Generally it's recommended that  * you don't call this method directly, but instead rely on the default convention  * where the package name is set from your {@code @EnableAutoConfiguration}  * configuration class or classes.  * @param registry the bean definition registry  * @param packageNames the package names to set  */ public static void register(BeanDefinitionRegistry registry, String... packageNames) {     if (registry.containsBeanDefinition(BEAN)) {         BeanDefinition beanDefinition = registry.getBeanDefinition(BEAN).         ConstructorArgumentValues constructorArguments = beanDefinition.getConstructorArgumentValues().         constructorArguments.addIndexedArgumentValue(0, addBasePackages(constructorArguments, packageNames)).     } else {         GenericBeanDefinition beanDefinition = new GenericBeanDefinition().         beanDefinition.setBeanClass(BasePackages.class).         beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(0, packageNames).         beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE).         registry.registerBeanDefinition(BEAN, beanDefinition).     } }
false;private,static;2;9;;private static String[] addBasePackages(ConstructorArgumentValues constructorArguments, String[] packageNames) {     String[] existing = (String[]) constructorArguments.getIndexedArgumentValue(0, String[].class).getValue().     Set<String> merged = new LinkedHashSet<>().     merged.addAll(Arrays.asList(existing)).     merged.addAll(Arrays.asList(packageNames)).     return StringUtils.toStringArray(merged). }
false;public;2;5;;@Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) {     register(registry, new PackageImport(metadata).getPackageName()). }
false;public;1;4;;@Override public Set<Object> determineImports(AnnotationMetadata metadata) {     return Collections.singleton(new PackageImport(metadata)). }
false;public;0;3;;public String getPackageName() {     return this.packageName. }
false;public;1;7;;@Override public boolean equals(Object obj) {     if (obj == null || getClass() != obj.getClass()) {         return false.     }     return this.packageName.equals(((PackageImport) obj).packageName). }
false;public;0;4;;@Override public int hashCode() {     return this.packageName.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "Package Import " + this.packageName. }
false;public;0;23;;public List<String> get() {     if (!this.loggedBasePackageInfo) {         if (this.packages.isEmpty()) {             if (logger.isWarnEnabled()) {                 logger.warn("@EnableAutoConfiguration was declared on a class " + "in the default package. Automatic @Repository and " + "@Entity scanning is not enabled.").             }         } else {             if (logger.isDebugEnabled()) {                 String packageNames = StringUtils.collectionToCommaDelimitedString(this.packages).                 logger.debug("@EnableAutoConfiguration was declared on a class " + "in the package '" + packageNames + "'. Automatic @Repository and @Entity scanning is " + "enabled.").             }         }         this.loggedBasePackageInfo = true.     }     return this.packages. }
