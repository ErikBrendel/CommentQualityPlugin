commented;modifiers;parameterAmount;loc;comment;code
false;public;2;18;;@Override public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {     String expression = (String) metadata.getAnnotationAttributes(ConditionalOnExpression.class.getName()).get("value").     expression = wrapIfNecessary(expression).     ConditionMessage.Builder messageBuilder = ConditionMessage.forCondition(ConditionalOnExpression.class, "(" + expression + ")").     expression = context.getEnvironment().resolvePlaceholders(expression).     ConfigurableListableBeanFactory beanFactory = context.getBeanFactory().     if (beanFactory != null) {         boolean result = evaluateExpression(beanFactory, expression).         return new ConditionOutcome(result, messageBuilder.resultedIn(result)).     }     return ConditionOutcome.noMatch(messageBuilder.because("no BeanFactory available.")). }
false;private;2;11;;private Boolean evaluateExpression(ConfigurableListableBeanFactory beanFactory, String expression) {     BeanExpressionResolver resolver = beanFactory.getBeanExpressionResolver().     if (resolver == null) {         resolver = new StandardBeanExpressionResolver().     }     BeanExpressionContext expressionContext = new BeanExpressionContext(beanFactory, null).     Object result = resolver.evaluate(expression, expressionContext).     return (result != null && (boolean) result). }
true;private;1;6;/**  * Allow user to provide bare expression with no '#{}' wrapper.  * @param expression source expression  * @return wrapped expression  */ ;/**  * Allow user to provide bare expression with no '#{}' wrapper.  * @param expression source expression  * @return wrapped expression  */ private String wrapIfNecessary(String expression) {     if (!expression.startsWith("#{")) {         return "#{" + expression + "}".     }     return expression. }
