commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Bean @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT) public DefaultErrorAttributes errorAttributes() {     return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException()). }
false;public;2;7;;@Bean @ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT) public BasicErrorController basicErrorController(ErrorAttributes errorAttributes, ObjectProvider<ErrorViewResolver> errorViewResolvers) {     return new BasicErrorController(errorAttributes, this.serverProperties.getError(), errorViewResolvers.orderedStream().collect(Collectors.toList())). }
false;public;1;5;;@Bean public ErrorPageCustomizer errorPageCustomizer(DispatcherServletPath dispatcherServletPath) {     return new ErrorPageCustomizer(this.serverProperties, dispatcherServletPath). }
false;public,static;0;4;;@Bean public static PreserveErrorControllerTargetClassPostProcessor preserveErrorControllerTargetClassPostProcessor() {     return new PreserveErrorControllerTargetClassPostProcessor(). }
false;public;0;7;;@Bean @ConditionalOnBean(DispatcherServlet.class) @ConditionalOnMissingBean public DefaultErrorViewResolver conventionErrorViewResolver() {     return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties). }
false;public;0;5;;@Bean(name = "error") @ConditionalOnMissingBean(name = "error") public View defaultErrorView() {     return this.defaultErrorView. }
true;public;0;7;// WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment. ;// If the user adds @EnableWebMvc then the bean name view resolver from // WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment. @Bean @ConditionalOnMissingBean public BeanNameViewResolver beanNameViewResolver() {     BeanNameViewResolver resolver = new BeanNameViewResolver().     resolver.setOrder(Ordered.LOWEST_PRECEDENCE - 10).     return resolver. }
false;public;2;17;;@Override public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {     ConditionMessage.Builder message = ConditionMessage.forCondition("ErrorTemplate Missing").     TemplateAvailabilityProviders providers = new TemplateAvailabilityProviders(context.getClassLoader()).     TemplateAvailabilityProvider provider = providers.getProvider("error", context.getEnvironment(), context.getClassLoader(), context.getResourceLoader()).     if (provider != null) {         return ConditionOutcome.noMatch(message.foundExactly("template from " + provider)).     }     return ConditionOutcome.match(message.didNotFind("error template view").atAll()). }
false;public;3;31;;@Override public void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response) throws Exception {     if (response.isCommitted()) {         String message = getMessage(model).         logger.error(message).         return.     }     StringBuilder builder = new StringBuilder().     Date timestamp = (Date) model.get("timestamp").     Object message = model.get("message").     Object trace = model.get("trace").     if (response.getContentType() == null) {         response.setContentType(getContentType()).     }     builder.append("<html><body><h1>Whitelabel Error Page</h1>").append("<p>This application has no explicit mapping for /error, so you are seeing this as a fallback.</p>").append("<div id='created'>").append(timestamp).append("</div>").append("<div>There was an unexpected error (type=").append(htmlEscape(model.get("error"))).append(", status=").append(htmlEscape(model.get("status"))).append(").</div>").     if (message != null) {         builder.append("<div>").append(htmlEscape(message)).append("</div>").     }     if (trace != null) {         builder.append("<div style='white-space:pre-wrap.'>").append(htmlEscape(trace)).append("</div>").     }     builder.append("</body></html>").     response.getWriter().append(builder.toString()). }
false;private;1;3;;private String htmlEscape(Object input) {     return (input != null) ? HtmlUtils.htmlEscape(input.toString()) : null. }
false;private;1;10;;private String getMessage(Map<String, ?> model) {     Object path = model.get("path").     String message = "Cannot render error page for request [" + path + "]".     if (model.get("message") != null) {         message += " and exception [" + model.get("message") + "]".     }     message += " as the response has already been committed.".     message += " As a result, the response may have the wrong status code.".     return message. }
false;public;0;4;;@Override public String getContentType() {     return "text/html". }
false;public;1;6;;@Override public void registerErrorPages(ErrorPageRegistry errorPageRegistry) {     ErrorPage errorPage = new ErrorPage(this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath())).     errorPageRegistry.addErrorPages(errorPage). }
false;public;0;4;;@Override public int getOrder() {     return 0. }
false;public;1;15;;@Override public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {     String[] errorControllerBeans = beanFactory.getBeanNamesForType(ErrorController.class, false, false).     for (String errorControllerBean : errorControllerBeans) {         try {             beanFactory.getBeanDefinition(errorControllerBean).setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE).         } catch (Throwable ex) {         // Ignore         }     } }
