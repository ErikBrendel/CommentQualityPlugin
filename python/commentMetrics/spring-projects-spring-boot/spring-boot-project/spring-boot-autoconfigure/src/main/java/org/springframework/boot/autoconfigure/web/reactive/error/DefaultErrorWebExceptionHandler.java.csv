commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;6;;@Override protected RouterFunction<ServerResponse> getRoutingFunction(ErrorAttributes errorAttributes) {     return route(acceptsTextHtml(), this::renderErrorView).andRoute(all(), this::renderErrorResponse). }
true;protected;1;15;/**  * Render the error information as an HTML view.  * @param request the current request  * @return a {@code Publisher} of the HTTP response  */ ;/**  * Render the error information as an HTML view.  * @param request the current request  * @return a {@code Publisher} of the HTTP response  */ protected Mono<ServerResponse> renderErrorView(ServerRequest request) {     boolean includeStackTrace = isIncludeStackTrace(request, MediaType.TEXT_HTML).     Map<String, Object> error = getErrorAttributes(request, includeStackTrace).     HttpStatus errorStatus = getHttpStatus(error).     ServerResponse.BodyBuilder responseBody = ServerResponse.status(errorStatus).contentType(MediaType.TEXT_HTML).     return Flux.just("error/" + errorStatus.value(), "error/" + SERIES_VIEWS.get(errorStatus.series()), "error/error").flatMap((viewName) -> renderErrorView(viewName, responseBody, error)).switchIfEmpty(this.errorProperties.getWhitelabel().isEnabled() ? renderDefaultErrorView(responseBody, error) : Mono.error(getError(request))).next(). }
true;protected;1;7;/**  * Render the error information as a JSON payload.  * @param request the current request  * @return a {@code Publisher} of the HTTP response  */ ;/**  * Render the error information as a JSON payload.  * @param request the current request  * @return a {@code Publisher} of the HTTP response  */ protected Mono<ServerResponse> renderErrorResponse(ServerRequest request) {     boolean includeStackTrace = isIncludeStackTrace(request, MediaType.ALL).     Map<String, Object> error = getErrorAttributes(request, includeStackTrace).     return ServerResponse.status(getHttpStatus(error)).contentType(MediaType.APPLICATION_JSON_UTF8).body(BodyInserters.fromObject(error)). }
true;protected;2;11;/**  * Determine if the stacktrace attribute should be included.  * @param request the source request  * @param produces the media type produced (or {@code MediaType.ALL})  * @return if the stacktrace attribute should be included  */ ;/**  * Determine if the stacktrace attribute should be included.  * @param request the source request  * @param produces the media type produced (or {@code MediaType.ALL})  * @return if the stacktrace attribute should be included  */ protected boolean isIncludeStackTrace(ServerRequest request, MediaType produces) {     ErrorProperties.IncludeStacktrace include = this.errorProperties.getIncludeStacktrace().     if (include == ErrorProperties.IncludeStacktrace.ALWAYS) {         return true.     }     if (include == ErrorProperties.IncludeStacktrace.ON_TRACE_PARAM) {         return isTraceEnabled(request).     }     return false. }
true;protected;1;4;/**  * Get the HTTP error status information from the error map.  * @param errorAttributes the current error information  * @return the error HTTP status  */ ;/**  * Get the HTTP error status information from the error map.  * @param errorAttributes the current error information  * @return the error HTTP status  */ protected HttpStatus getHttpStatus(Map<String, Object> errorAttributes) {     int statusCode = (int) errorAttributes.get("status").     return HttpStatus.valueOf(statusCode). }
true;protected;0;14;/**  * Predicate that checks whether the current request explicitly support  * {@code "text/html"} media type.  * <p>  * The "match-all" media type is not considered here.  * @return the request predicate  */ ;/**  * Predicate that checks whether the current request explicitly support  * {@code "text/html"} media type.  * <p>  * The "match-all" media type is not considered here.  * @return the request predicate  */ protected RequestPredicate acceptsTextHtml() {     return (serverRequest) -> {         try {             List<MediaType> acceptedMediaTypes = serverRequest.headers().accept().             acceptedMediaTypes.remove(MediaType.ALL).             MediaType.sortBySpecificityAndQuality(acceptedMediaTypes).             return acceptedMediaTypes.stream().anyMatch(MediaType.TEXT_HTML::isCompatibleWith).         } catch (InvalidMediaTypeException ex) {             return false.         }     }. }
