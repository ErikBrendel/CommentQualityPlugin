commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ConfigurationPhase getConfigurationPhase() {     return ConfigurationPhase.REGISTER_BEAN. }
false;protected,final;2;20;;@Override protected final ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, AutoConfigurationMetadata autoConfigurationMetadata) {     ConditionOutcome[] outcomes = new ConditionOutcome[autoConfigurationClasses.length].     for (int i = 0. i < outcomes.length. i++) {         String autoConfigurationClass = autoConfigurationClasses[i].         if (autoConfigurationClass != null) {             Set<String> onBeanTypes = autoConfigurationMetadata.getSet(autoConfigurationClass, "ConditionalOnBean").             outcomes[i] = getOutcome(onBeanTypes, ConditionalOnBean.class).             if (outcomes[i] == null) {                 Set<String> onSingleCandidateTypes = autoConfigurationMetadata.getSet(autoConfigurationClass, "ConditionalOnSingleCandidate").                 outcomes[i] = getOutcome(onSingleCandidateTypes, ConditionalOnSingleCandidate.class).             }         }     }     return outcomes. }
false;private;2;12;;private ConditionOutcome getOutcome(Set<String> requiredBeanTypes, Class<? extends Annotation> annotation) {     List<String> missing = filter(requiredBeanTypes, ClassNameFilter.MISSING, getBeanClassLoader()).     if (!missing.isEmpty()) {         ConditionMessage message = ConditionMessage.forCondition(annotation).didNotFind("required type", "required types").items(Style.QUOTE, missing).         return ConditionOutcome.noMatch(message).     }     return null. }
false;public;2;54;;@Override public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {     ConditionMessage matchMessage = ConditionMessage.empty().     if (metadata.isAnnotated(ConditionalOnBean.class.getName())) {         BeanSearchSpec spec = new BeanSearchSpec(context, metadata, ConditionalOnBean.class).         MatchResult matchResult = getMatchingBeans(context, spec).         if (!matchResult.isAllMatched()) {             String reason = createOnBeanNoMatchReason(matchResult).             return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnBean.class, spec).because(reason)).         }         matchMessage = matchMessage.andCondition(ConditionalOnBean.class, spec).found("bean", "beans").items(Style.QUOTE, matchResult.getNamesOfAllMatches()).     }     if (metadata.isAnnotated(ConditionalOnSingleCandidate.class.getName())) {         BeanSearchSpec spec = new SingleCandidateBeanSearchSpec(context, metadata, ConditionalOnSingleCandidate.class).         MatchResult matchResult = getMatchingBeans(context, spec).         if (!matchResult.isAllMatched()) {             return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnSingleCandidate.class, spec).didNotFind("any beans").atAll()).         } else if (!hasSingleAutowireCandidate(context.getBeanFactory(), matchResult.getNamesOfAllMatches(), spec.getStrategy() == SearchStrategy.ALL)) {             return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnSingleCandidate.class, spec).didNotFind("a primary bean from beans").items(Style.QUOTE, matchResult.getNamesOfAllMatches())).         }         matchMessage = matchMessage.andCondition(ConditionalOnSingleCandidate.class, spec).found("a primary bean from beans").items(Style.QUOTE, matchResult.getNamesOfAllMatches()).     }     if (metadata.isAnnotated(ConditionalOnMissingBean.class.getName())) {         BeanSearchSpec spec = new BeanSearchSpec(context, metadata, ConditionalOnMissingBean.class).         MatchResult matchResult = getMatchingBeans(context, spec).         if (matchResult.isAnyMatched()) {             String reason = createOnMissingBeanNoMatchReason(matchResult).             return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnMissingBean.class, spec).because(reason)).         }         matchMessage = matchMessage.andCondition(ConditionalOnMissingBean.class, spec).didNotFind("any beans").atAll().     }     return ConditionOutcome.match(matchMessage). }
false;protected,final;2;49;;protected final MatchResult getMatchingBeans(ConditionContext context, BeanSearchSpec beans) {     ConfigurableListableBeanFactory beanFactory = context.getBeanFactory().     if (beans.getStrategy() == SearchStrategy.ANCESTORS) {         BeanFactory parent = beanFactory.getParentBeanFactory().         Assert.isInstanceOf(ConfigurableListableBeanFactory.class, parent, "Unable to use SearchStrategy.PARENTS").         beanFactory = (ConfigurableListableBeanFactory) parent.     }     MatchResult matchResult = new MatchResult().     boolean considerHierarchy = beans.getStrategy() != SearchStrategy.CURRENT.     TypeExtractor typeExtractor = beans.getTypeExtractor(context.getClassLoader()).     List<String> beansIgnoredByType = getNamesOfBeansIgnoredByType(beans.getIgnoredTypes(), typeExtractor, beanFactory, context, considerHierarchy).     for (String type : beans.getTypes()) {         Collection<String> typeMatches = getBeanNamesForType(beanFactory, type, typeExtractor, context.getClassLoader(), considerHierarchy).         typeMatches.removeAll(beansIgnoredByType).         if (typeMatches.isEmpty()) {             matchResult.recordUnmatchedType(type).         } else {             matchResult.recordMatchedType(type, typeMatches).         }     }     for (String annotation : beans.getAnnotations()) {         List<String> annotationMatches = Arrays.asList(getBeanNamesForAnnotation(beanFactory, annotation, context.getClassLoader(), considerHierarchy)).         annotationMatches.removeAll(beansIgnoredByType).         if (annotationMatches.isEmpty()) {             matchResult.recordUnmatchedAnnotation(annotation).         } else {             matchResult.recordMatchedAnnotation(annotation, annotationMatches).         }     }     for (String beanName : beans.getNames()) {         if (!beansIgnoredByType.contains(beanName) && containsBean(beanFactory, beanName, considerHierarchy)) {             matchResult.recordMatchedName(beanName).         } else {             matchResult.recordUnmatchedName(beanName).         }     }     return matchResult. }
false;private;4;16;;private String[] getBeanNamesForAnnotation(ConfigurableListableBeanFactory beanFactory, String type, ClassLoader classLoader, boolean considerHierarchy) throws LinkageError {     Set<String> names = new HashSet<>().     try {         @SuppressWarnings("unchecked")         Class<? extends Annotation> annotationType = (Class<? extends Annotation>) ClassUtils.forName(type, classLoader).         collectBeanNamesForAnnotation(names, beanFactory, annotationType, considerHierarchy).     } catch (ClassNotFoundException ex) {     // Continue     }     return StringUtils.toStringArray(names). }
false;private;4;14;;private void collectBeanNamesForAnnotation(Set<String> names, ListableBeanFactory beanFactory, Class<? extends Annotation> annotationType, boolean considerHierarchy) {     BeanTypeRegistry registry = BeanTypeRegistry.get(beanFactory).     names.addAll(registry.getNamesForAnnotation(annotationType)).     if (considerHierarchy) {         BeanFactory parent = ((HierarchicalBeanFactory) beanFactory).getParentBeanFactory().         if (parent instanceof ListableBeanFactory) {             collectBeanNamesForAnnotation(names, (ListableBeanFactory) parent, annotationType, considerHierarchy).         }     } }
false;private;5;10;;private List<String> getNamesOfBeansIgnoredByType(List<String> ignoredTypes, TypeExtractor typeExtractor, ListableBeanFactory beanFactory, ConditionContext context, boolean considerHierarchy) {     List<String> beanNames = new ArrayList<>().     for (String ignoredType : ignoredTypes) {         beanNames.addAll(getBeanNamesForType(beanFactory, ignoredType, typeExtractor, context.getClassLoader(), considerHierarchy)).     }     return beanNames. }
false;private;3;7;;private boolean containsBean(ConfigurableListableBeanFactory beanFactory, String beanName, boolean considerHierarchy) {     if (considerHierarchy) {         return beanFactory.containsBean(beanName).     }     return beanFactory.containsLocalBean(beanName). }
false;private;5;11;;private Collection<String> getBeanNamesForType(ListableBeanFactory beanFactory, String type, TypeExtractor typeExtractor, ClassLoader classLoader, boolean considerHierarchy) throws LinkageError {     try {         return getBeanNamesForType(beanFactory, considerHierarchy, ClassUtils.forName(type, classLoader), typeExtractor).     } catch (ClassNotFoundException | NoClassDefFoundError ex) {         return Collections.emptySet().     } }
false;private;4;7;;private Collection<String> getBeanNamesForType(ListableBeanFactory beanFactory, boolean considerHierarchy, Class<?> type, TypeExtractor typeExtractor) {     Set<String> result = new LinkedHashSet<>().     collectBeanNamesForType(result, beanFactory, type, typeExtractor, considerHierarchy).     return result. }
false;private;5;14;;private void collectBeanNamesForType(Set<String> result, ListableBeanFactory beanFactory, Class<?> type, TypeExtractor typeExtractor, boolean considerHierarchy) {     BeanTypeRegistry registry = BeanTypeRegistry.get(beanFactory).     result.addAll(registry.getNamesForType(type, typeExtractor)).     if (considerHierarchy && beanFactory instanceof HierarchicalBeanFactory) {         BeanFactory parent = ((HierarchicalBeanFactory) beanFactory).getParentBeanFactory().         if (parent instanceof ListableBeanFactory) {             collectBeanNamesForType(result, (ListableBeanFactory) parent, type, typeExtractor, considerHierarchy).         }     } }
false;private;1;8;;private String createOnBeanNoMatchReason(MatchResult matchResult) {     StringBuilder reason = new StringBuilder().     appendMessageForNoMatches(reason, matchResult.getUnmatchedAnnotations(), "annotated with").     appendMessageForNoMatches(reason, matchResult.getUnmatchedTypes(), "of type").     appendMessageForNoMatches(reason, matchResult.getUnmatchedNames(), "named").     return reason.toString(). }
false;private;3;12;;private void appendMessageForNoMatches(StringBuilder reason, Collection<String> unmatched, String description) {     if (!unmatched.isEmpty()) {         if (reason.length() > 0) {             reason.append(" and ").         }         reason.append("did not find any beans ").         reason.append(description).         reason.append(" ").         reason.append(StringUtils.collectionToDelimitedString(unmatched, ", ")).     } }
false;private;1;15;;private String createOnMissingBeanNoMatchReason(MatchResult matchResult) {     StringBuilder reason = new StringBuilder().     appendMessageForMatches(reason, matchResult.getMatchedAnnotations(), "annotated with").     appendMessageForMatches(reason, matchResult.getMatchedTypes(), "of type").     if (!matchResult.getMatchedNames().isEmpty()) {         if (reason.length() > 0) {             reason.append(" and ").         }         reason.append("found beans named ").         reason.append(StringUtils.collectionToDelimitedString(matchResult.getMatchedNames(), ", ")).     }     return reason.toString(). }
false;private;3;16;;private void appendMessageForMatches(StringBuilder reason, Map<String, Collection<String>> matches, String description) {     if (!matches.isEmpty()) {         matches.forEach((key, value) -> {             if (reason.length() > 0) {                 reason.append(" and ").             }             reason.append("found beans ").             reason.append(description).             reason.append(" '").             reason.append(key).             reason.append("' ").             reason.append(StringUtils.collectionToDelimitedString(value, ", ")).         }).     } }
false;private;3;7;;private boolean hasSingleAutowireCandidate(ConfigurableListableBeanFactory beanFactory, Set<String> beanNames, boolean considerHierarchy) {     return (beanNames.size() == 1 || getPrimaryBeans(beanFactory, beanNames, considerHierarchy).size() == 1). }
false;private;3;12;;private List<String> getPrimaryBeans(ConfigurableListableBeanFactory beanFactory, Set<String> beanNames, boolean considerHierarchy) {     List<String> primaryBeans = new ArrayList<>().     for (String beanName : beanNames) {         BeanDefinition beanDefinition = findBeanDefinition(beanFactory, beanName, considerHierarchy).         if (beanDefinition != null && beanDefinition.isPrimary()) {             primaryBeans.add(beanName).         }     }     return primaryBeans. }
false;private;3;12;;private BeanDefinition findBeanDefinition(ConfigurableListableBeanFactory beanFactory, String beanName, boolean considerHierarchy) {     if (beanFactory.containsBeanDefinition(beanName)) {         return beanFactory.getBeanDefinition(beanName).     }     if (considerHierarchy && beanFactory.getParentBeanFactory() instanceof ConfigurableListableBeanFactory) {         return findBeanDefinition(((ConfigurableListableBeanFactory) beanFactory.getParentBeanFactory()), beanName, considerHierarchy).     }     return null. }
false;protected;1;11;;protected void validate(BeanTypeDeductionException ex) {     if (!hasAtLeastOne(this.types, this.names, this.annotations)) {         String message = getAnnotationName() + " did not specify a bean using type, name or annotation".         if (ex == null) {             throw new IllegalStateException(message).         }         throw new IllegalStateException(message + " and the attempt to deduce" + " the bean's type failed", ex).     } }
false;private;1;3;;private boolean hasAtLeastOne(List<?>... lists) {     return Arrays.stream(lists).anyMatch((list) -> !list.isEmpty()). }
false;protected,final;0;3;;protected final String getAnnotationName() {     return "@" + ClassUtils.getShortName(this.annotationType). }
false;protected;3;14;;protected void collect(MultiValueMap<String, Object> attributes, String key, List<String> destination) {     List<?> values = attributes.get(key).     if (values != null) {         for (Object value : values) {             if (value instanceof String[]) {                 Collections.addAll(destination, (String[]) value).             } else {                 destination.add((String) value).             }         }     } }
false;private;3;8;;private void addDeducedBeanType(ConditionContext context, AnnotatedTypeMetadata metadata, final List<String> beanTypes) {     if (metadata instanceof MethodMetadata && metadata.isAnnotated(Bean.class.getName())) {         addDeducedBeanTypeForBeanMethod(context, (MethodMetadata) metadata, beanTypes).     } }
false;private;3;11;;private void addDeducedBeanTypeForBeanMethod(ConditionContext context, MethodMetadata metadata, final List<String> beanTypes) {     try {         Class<?> returnType = getReturnType(context, metadata).         beanTypes.add(returnType.getName()).     } catch (Throwable ex) {         throw new BeanTypeDeductionException(metadata.getDeclaringClassName(), metadata.getMethodName(), ex).     } }
false;private;2;12;;private Class<?> getReturnType(ConditionContext context, MethodMetadata metadata) throws ClassNotFoundException, LinkageError {     // We should be safe to load at this point since we are in the     // REGISTER_BEAN phase     ClassLoader classLoader = context.getClassLoader().     Class<?> returnType = ClassUtils.forName(metadata.getReturnTypeName(), classLoader).     if (isParameterizedContainer(returnType, classLoader)) {         returnType = getReturnTypeGeneric(metadata, classLoader).     }     return returnType. }
false;private;2;7;;private Class<?> getReturnTypeGeneric(MethodMetadata metadata, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {     Class<?> declaringClass = ClassUtils.forName(metadata.getDeclaringClassName(), classLoader).     Method beanMethod = findBeanMethod(declaringClass, metadata.getMethodName()).     return ResolvableType.forMethodReturnType(beanMethod).resolveGeneric(). }
false;private;2;11;;private Method findBeanMethod(Class<?> declaringClass, String methodName) {     Method method = ReflectionUtils.findMethod(declaringClass, methodName).     if (isBeanMethod(method)) {         return method.     }     return Arrays.stream(ReflectionUtils.getAllDeclaredMethods(declaringClass)).filter((candidate) -> candidate.getName().equals(methodName)).filter(this::isBeanMethod).findFirst().orElseThrow(() -> new IllegalStateException("Unable to find bean method " + methodName)). }
false;private;1;4;;private boolean isBeanMethod(Method method) {     return method != null && AnnotatedElementUtils.hasAnnotation(method, Bean.class). }
false;public;1;12;;public TypeExtractor getTypeExtractor(ClassLoader classLoader) {     if (this.parameterizedContainers.isEmpty()) {         return ResolvableType::resolve.     }     return (type) -> {         Class<?> resolved = type.resolve().         if (isParameterizedContainer(resolved, classLoader)) {             return type.getGeneric().resolve().         }         return resolved.     }. }
false;private;2;13;;private boolean isParameterizedContainer(Class<?> type, ClassLoader classLoader) {     for (String candidate : this.parameterizedContainers) {         try {             if (ClassUtils.forName(candidate, classLoader).isAssignableFrom(type)) {                 return true.             }         } catch (Exception ex) {         }     }     return false. }
false;public;0;3;;public SearchStrategy getStrategy() {     return (this.strategy != null) ? this.strategy : SearchStrategy.ALL. }
false;public;0;3;;public List<String> getNames() {     return this.names. }
false;public;0;3;;public List<String> getTypes() {     return this.types. }
false;public;0;3;;public List<String> getAnnotations() {     return this.annotations. }
false;public;0;3;;public List<String> getIgnoredTypes() {     return this.ignoredTypes. }
false;public;0;20;;@Override public String toString() {     StringBuilder string = new StringBuilder().     string.append("(").     if (!this.names.isEmpty()) {         string.append("names: ").         string.append(StringUtils.collectionToCommaDelimitedString(this.names)).         if (!this.types.isEmpty()) {             string.append(". ").         }     }     if (!this.types.isEmpty()) {         string.append("types: ").         string.append(StringUtils.collectionToCommaDelimitedString(this.types)).     }     string.append(". SearchStrategy: ").     string.append(this.strategy.toString().toLowerCase(Locale.ENGLISH)).     string.append(")").     return string.toString(). }
false;protected;3;6;;@Override protected void collect(MultiValueMap<String, Object> attributes, String key, List<String> destination) {     super.collect(attributes, key, destination).     destination.removeAll(Arrays.asList("", Object.class.getName())). }
false;protected;1;5;;@Override protected void validate(BeanTypeDeductionException ex) {     Assert.isTrue(getTypes().size() == 1, () -> getAnnotationName() + " annotations must specify only one type (got " + getTypes() + ")"). }
false;private;1;4;;private void recordMatchedName(String name) {     this.matchedNames.add(name).     this.namesOfAllMatches.add(name). }
false;private;1;3;;private void recordUnmatchedName(String name) {     this.unmatchedNames.add(name). }
false;private;2;5;;private void recordMatchedAnnotation(String annotation, Collection<String> matchingNames) {     this.matchedAnnotations.put(annotation, matchingNames).     this.namesOfAllMatches.addAll(matchingNames). }
false;private;1;3;;private void recordUnmatchedAnnotation(String annotation) {     this.unmatchedAnnotations.add(annotation). }
false;private;2;4;;private void recordMatchedType(String type, Collection<String> matchingNames) {     this.matchedTypes.put(type, matchingNames).     this.namesOfAllMatches.addAll(matchingNames). }
false;private;1;3;;private void recordUnmatchedType(String type) {     this.unmatchedTypes.add(type). }
false;public;0;4;;public boolean isAllMatched() {     return this.unmatchedAnnotations.isEmpty() && this.unmatchedNames.isEmpty() && this.unmatchedTypes.isEmpty(). }
false;public;0;4;;public boolean isAnyMatched() {     return (!this.matchedAnnotations.isEmpty()) || (!this.matchedNames.isEmpty()) || (!this.matchedTypes.isEmpty()). }
false;public;0;3;;public Map<String, Collection<String>> getMatchedAnnotations() {     return this.matchedAnnotations. }
false;public;0;3;;public List<String> getMatchedNames() {     return this.matchedNames. }
false;public;0;3;;public Map<String, Collection<String>> getMatchedTypes() {     return this.matchedTypes. }
false;public;0;3;;public List<String> getUnmatchedAnnotations() {     return this.unmatchedAnnotations. }
false;public;0;3;;public List<String> getUnmatchedNames() {     return this.unmatchedNames. }
false;public;0;3;;public List<String> getUnmatchedTypes() {     return this.unmatchedTypes. }
false;public;0;3;;public Set<String> getNamesOfAllMatches() {     return this.namesOfAllMatches. }
