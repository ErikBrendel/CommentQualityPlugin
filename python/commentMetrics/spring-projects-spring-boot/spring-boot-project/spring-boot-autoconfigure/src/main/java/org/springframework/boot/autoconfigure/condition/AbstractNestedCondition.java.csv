commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ConfigurationPhase getConfigurationPhase() {     return this.configurationPhase. }
false;public;2;9;;@Override public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {     String className = getClass().getName().     MemberConditions memberConditions = new MemberConditions(context, this.configurationPhase, className).     MemberMatchOutcomes memberOutcomes = new MemberMatchOutcomes(memberConditions).     return getFinalMatchOutcome(memberOutcomes). }
false;protected,abstract;1;2;;protected abstract ConditionOutcome getFinalMatchOutcome(MemberMatchOutcomes memberOutcomes).
false;public;0;3;;public List<ConditionOutcome> getAll() {     return this.all. }
false;public;0;3;;public List<ConditionOutcome> getMatches() {     return this.matches. }
false;public;0;3;;public List<ConditionOutcome> getNonMatches() {     return this.nonMatches. }
false;private;3;15;;private Map<AnnotationMetadata, List<Condition>> getMemberConditions(String[] members, ConfigurationPhase phase, String className) {     MultiValueMap<AnnotationMetadata, Condition> memberConditions = new LinkedMultiValueMap<>().     for (String member : members) {         AnnotationMetadata metadata = getMetadata(member).         for (String[] conditionClasses : getConditionClasses(metadata)) {             for (String conditionClass : conditionClasses) {                 Condition condition = getCondition(conditionClass).                 validateMemberCondition(condition, phase, className).                 memberConditions.add(metadata, condition).             }         }     }     return Collections.unmodifiableMap(memberConditions). }
false;private;3;13;;private void validateMemberCondition(Condition condition, ConfigurationPhase nestedPhase, String nestedClassName) {     if (nestedPhase == ConfigurationPhase.PARSE_CONFIGURATION && condition instanceof ConfigurationCondition) {         ConfigurationPhase memberPhase = ((ConfigurationCondition) condition).getConfigurationPhase().         if (memberPhase == ConfigurationPhase.REGISTER_BEAN) {             throw new IllegalStateException("Nested condition " + nestedClassName + " uses a configuration " + "phase that is inappropriate for " + condition.getClass()).         }     } }
false;private;1;9;;private AnnotationMetadata getMetadata(String className) {     try {         return this.readerFactory.getMetadataReader(className).getAnnotationMetadata().     } catch (IOException ex) {         throw new IllegalStateException(ex).     } }
false;private;1;7;;@SuppressWarnings("unchecked") private List<String[]> getConditionClasses(AnnotatedTypeMetadata metadata) {     MultiValueMap<String, Object> attributes = metadata.getAllAnnotationAttributes(Conditional.class.getName(), true).     Object values = (attributes != null) ? attributes.get("value") : null.     return (List<String[]>) ((values != null) ? values : Collections.emptyList()). }
false;private;1;5;;private Condition getCondition(String conditionClassName) {     Class<?> conditionClass = ClassUtils.resolveClassName(conditionClassName, this.context.getClassLoader()).     return (Condition) BeanUtils.instantiateClass(conditionClass). }
false;public;0;7;;public List<ConditionOutcome> getMatchOutcomes() {     List<ConditionOutcome> outcomes = new ArrayList<>().     this.memberConditions.forEach((metadata, conditions) -> outcomes.add(new MemberOutcomes(this.context, metadata, conditions).getUltimateOutcome())).     return Collections.unmodifiableList(outcomes). }
false;private;2;9;;private ConditionOutcome getConditionOutcome(AnnotationMetadata metadata, Condition condition) {     if (condition instanceof SpringBootCondition) {         return ((SpringBootCondition) condition).getMatchOutcome(this.context, metadata).     }     return new ConditionOutcome(condition.matches(this.context, metadata), ConditionMessage.empty()). }
false;public;0;21;;public ConditionOutcome getUltimateOutcome() {     ConditionMessage.Builder message = ConditionMessage.forCondition("NestedCondition on " + ClassUtils.getShortName(this.metadata.getClassName())).     if (this.outcomes.size() == 1) {         ConditionOutcome outcome = this.outcomes.get(0).         return new ConditionOutcome(outcome.isMatch(), message.because(outcome.getMessage())).     }     List<ConditionOutcome> match = new ArrayList<>().     List<ConditionOutcome> nonMatch = new ArrayList<>().     for (ConditionOutcome outcome : this.outcomes) {         (outcome.isMatch() ? match : nonMatch).add(outcome).     }     if (nonMatch.isEmpty()) {         return ConditionOutcome.match(message.found("matching nested conditions").items(match)).     }     return ConditionOutcome.noMatch(message.found("non-matching nested conditions").items(nonMatch)). }
