commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Test public void testWithMessageContentsDelegateForTextMessage() throws Exception {     TextMessage textMessage = mock(TextMessage.class).     // TextMessage contents must be unwrapped...     given(textMessage.getText()).willReturn(TEXT).     MessageContentsDelegate delegate = mock(MessageContentsDelegate.class).     MessageListenerAdapter adapter = new MessageListenerAdapter(delegate).     adapter.onMessage(textMessage).     verify(delegate).handleMessage(TEXT). }
false;public;1;6;;@Override public Integer answer(InvocationOnMock invocation) throws Throwable {     byte[] bytes = (byte[]) invocation.getArguments()[0].     ByteArrayInputStream inputStream = new ByteArrayInputStream(TEXT.getBytes()).     return inputStream.read(bytes). }
false;public;0;21;;@Test public void testWithMessageContentsDelegateForBytesMessage() throws Exception {     BytesMessage bytesMessage = mock(BytesMessage.class).     // BytesMessage contents must be unwrapped...     given(bytesMessage.getBodyLength()).willReturn(new Long(TEXT.getBytes().length)).     given(bytesMessage.readBytes(any(byte[].class))).willAnswer(new Answer<Integer>() {          @Override         public Integer answer(InvocationOnMock invocation) throws Throwable {             byte[] bytes = (byte[]) invocation.getArguments()[0].             ByteArrayInputStream inputStream = new ByteArrayInputStream(TEXT.getBytes()).             return inputStream.read(bytes).         }     }).     MessageContentsDelegate delegate = mock(MessageContentsDelegate.class).     MessageListenerAdapter adapter = new MessageListenerAdapter(delegate).     adapter.onMessage(bytesMessage).     verify(delegate).handleMessage(TEXT.getBytes()). }
false;public;0;12;;@Test public void testWithMessageContentsDelegateForObjectMessage() throws Exception {     ObjectMessage objectMessage = mock(ObjectMessage.class).     given(objectMessage.getObject()).willReturn(NUMBER).     MessageContentsDelegate delegate = mock(MessageContentsDelegate.class).     MessageListenerAdapter adapter = new MessageListenerAdapter(delegate).     adapter.onMessage(objectMessage).     verify(delegate).handleMessage(NUMBER). }
false;public;0;12;;@Test public void testWithMessageContentsDelegateForObjectMessageWithPlainObject() throws Exception {     ObjectMessage objectMessage = mock(ObjectMessage.class).     given(objectMessage.getObject()).willReturn(OBJECT).     MessageContentsDelegate delegate = mock(MessageContentsDelegate.class).     MessageListenerAdapter adapter = new MessageListenerAdapter(delegate).     adapter.onMessage(objectMessage).     verify(delegate).handleMessage(OBJECT). }
false;public;0;13;;@Test public void testWithMessageDelegate() throws Exception {     TextMessage textMessage = mock(TextMessage.class).     MessageDelegate delegate = mock(MessageDelegate.class).     MessageListenerAdapter adapter = new MessageListenerAdapter(delegate).     // we DON'T want the default SimpleMessageConversion happening...     adapter.setMessageConverter(null).     adapter.onMessage(textMessage).     verify(delegate).handleMessage(textMessage). }
false;public;0;10;;@Test public void testWhenTheAdapterItselfIsTheDelegate() throws Exception {     TextMessage textMessage = mock(TextMessage.class).     // TextMessage contents must be unwrapped...     given(textMessage.getText()).willReturn(TEXT).     StubMessageListenerAdapter adapter = new StubMessageListenerAdapter().     adapter.onMessage(textMessage).     assertTrue(adapter.wasCalled()). }
false;public;0;11;;@Test public void testRainyDayWithNoApplicableHandlingMethods() throws Exception {     TextMessage textMessage = mock(TextMessage.class).     // TextMessage contents must be unwrapped...     given(textMessage.getText()).willReturn(TEXT).     StubMessageListenerAdapter adapter = new StubMessageListenerAdapter().     adapter.setDefaultListenerMethod("walnutsRock").     adapter.onMessage(textMessage).     assertFalse(adapter.wasCalled()). }
false;protected;1;10;;@Override protected void handleListenerException(Throwable ex) {     assertNotNull("The Throwable passed to the handleListenerException(..) method must never be null.", ex).     assertTrue("The Throwable passed to the handleListenerException(..) method must be of type [ListenerExecutionFailedException].", ex instanceof ListenerExecutionFailedException).     ListenerExecutionFailedException lefx = (ListenerExecutionFailedException) ex.     Throwable cause = lefx.getCause().     assertNotNull("The cause of a ListenerExecutionFailedException must be preserved.", cause).     assertSame(exception, cause). }
false;public;0;24;;@Test public void testThatAnExceptionThrownFromTheHandlingMethodIsSimplySwallowedByDefault() throws Exception {     final IllegalArgumentException exception = new IllegalArgumentException().     TextMessage textMessage = mock(TextMessage.class).     MessageDelegate delegate = mock(MessageDelegate.class).     willThrow(exception).given(delegate).handleMessage(textMessage).     MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {          @Override         protected void handleListenerException(Throwable ex) {             assertNotNull("The Throwable passed to the handleListenerException(..) method must never be null.", ex).             assertTrue("The Throwable passed to the handleListenerException(..) method must be of type [ListenerExecutionFailedException].", ex instanceof ListenerExecutionFailedException).             ListenerExecutionFailedException lefx = (ListenerExecutionFailedException) ex.             Throwable cause = lefx.getCause().             assertNotNull("The cause of a ListenerExecutionFailedException must be preserved.", cause).             assertSame(exception, cause).         }     }.     // we DON'T want the default SimpleMessageConversion happening...     adapter.setMessageConverter(null).     adapter.onMessage(textMessage). }
false;public;0;7;;@Test public void testThatTheDefaultMessageConverterisIndeedTheSimpleMessageConverter() throws Exception {     MessageListenerAdapter adapter = new MessageListenerAdapter().     assertNotNull("The default [MessageConverter] must never be null.", adapter.getMessageConverter()).     assertTrue("The default [MessageConverter] must be of the type [SimpleMessageConverter]", adapter.getMessageConverter() instanceof SimpleMessageConverter). }
false;public;0;5;;@Test public void testThatWhenNoDelegateIsSuppliedTheDelegateIsAssumedToBeTheMessageListenerAdapterItself() throws Exception {     MessageListenerAdapter adapter = new MessageListenerAdapter().     assertSame(adapter, adapter.getDelegate()). }
false;public;0;5;;@Test public void testThatTheDefaultMessageHandlingMethodNameIsTheConstantDefault() throws Exception {     MessageListenerAdapter adapter = new MessageListenerAdapter().     assertEquals(MessageListenerAdapter.ORIGINAL_DEFAULT_LISTENER_METHOD, adapter.getDefaultListenerMethod()). }
false;public;0;11;;@Test public void testWithResponsiveMessageDelegate_DoesNotSendReturnTextMessageIfNoSessionSupplied() throws Exception {     TextMessage textMessage = mock(TextMessage.class).     ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class).     given(delegate.handleMessage(textMessage)).willReturn(TEXT).     MessageListenerAdapter adapter = new MessageListenerAdapter(delegate).     // we DON'T want the default SimpleMessageConversion happening...     adapter.setMessageConverter(null).     adapter.onMessage(textMessage). }
false;protected;1;4;;@Override protected Object extractMessage(Message message) {     return message. }
false;public;0;34;;@Test public void testWithResponsiveMessageDelegateWithDefaultDestination_SendsReturnTextMessageWhenSessionSupplied() throws Exception {     Queue destination = mock(Queue.class).     TextMessage sentTextMessage = mock(TextMessage.class).     // correlation ID is queried when response is being created...     given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID).     // Reply-To is queried when response is being created...     // we want to fall back to the default...     given(sentTextMessage.getJMSReplyTo()).willReturn(null).     TextMessage responseTextMessage = mock(TextMessage.class).     QueueSender queueSender = mock(QueueSender.class).     Session session = mock(Session.class).     given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage).     given(session.createProducer(destination)).willReturn(queueSender).     ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class).     given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT).     MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {          @Override         protected Object extractMessage(Message message) {             return message.         }     }.     adapter.setDefaultResponseDestination(destination).     adapter.onMessage(sentTextMessage, session).     verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID).     verify(queueSender).send(responseTextMessage).     verify(queueSender).close().     verify(delegate).handleMessage(sentTextMessage). }
false;protected;1;4;;@Override protected Object extractMessage(Message message) {     return message. }
false;public;0;32;;@Test public void testWithResponsiveMessageDelegateNoDefaultDestination_SendsReturnTextMessageWhenSessionSupplied() throws Exception {     Queue destination = mock(Queue.class).     TextMessage sentTextMessage = mock(TextMessage.class).     // correlation ID is queried when response is being created...     given(sentTextMessage.getJMSCorrelationID()).willReturn(null).     given(sentTextMessage.getJMSMessageID()).willReturn(CORRELATION_ID).     // Reply-To is queried when response is being created...     given(sentTextMessage.getJMSReplyTo()).willReturn(destination).     TextMessage responseTextMessage = mock(TextMessage.class).     MessageProducer messageProducer = mock(MessageProducer.class).     Session session = mock(Session.class).     given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage).     given(session.createProducer(destination)).willReturn(messageProducer).     ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class).     given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT).     MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {          @Override         protected Object extractMessage(Message message) {             return message.         }     }.     adapter.onMessage(sentTextMessage, session).     verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID).     verify(messageProducer).send(responseTextMessage).     verify(messageProducer).close().     verify(delegate).handleMessage(sentTextMessage). }
false;protected;1;4;;@Override protected Object extractMessage(Message message) {     return message. }
false;public;0;32;;@Test public void testWithResponsiveMessageDelegateNoDefaultDestinationAndNoReplyToDestination_SendsReturnTextMessageWhenSessionSupplied() throws Exception {     final TextMessage sentTextMessage = mock(TextMessage.class).     // correlation ID is queried when response is being created...     given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID).     // Reply-To is queried when response is being created...     given(sentTextMessage.getJMSReplyTo()).willReturn(null).     TextMessage responseTextMessage = mock(TextMessage.class).     final QueueSession session = mock(QueueSession.class).     given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage).     ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class).     given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT).     final MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {          @Override         protected Object extractMessage(Message message) {             return message.         }     }.     try {         adapter.onMessage(sentTextMessage, session).         fail("expected CouldNotSendReplyException with InvalidDestinationException").     } catch (ReplyFailureException ex) {         assertEquals(InvalidDestinationException.class, ex.getCause().getClass()).     }     verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID).     verify(delegate).handleMessage(sentTextMessage). }
false;protected;1;4;;@Override protected Object extractMessage(Message message) {     return message. }
false;public;0;39;;@Test public void testWithResponsiveMessageDelegateNoDefaultDestination_SendsReturnTextMessageWhenSessionSupplied_AndSendingThrowsJMSException() throws Exception {     Queue destination = mock(Queue.class).     final TextMessage sentTextMessage = mock(TextMessage.class).     // correlation ID is queried when response is being created...     given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID).     // Reply-To is queried when response is being created...     given(sentTextMessage.getJMSReplyTo()).willReturn(destination).     TextMessage responseTextMessage = mock(TextMessage.class).     MessageProducer messageProducer = mock(MessageProducer.class).     willThrow(new JMSException("Doe!")).given(messageProducer).send(responseTextMessage).     final QueueSession session = mock(QueueSession.class).     given(session.createTextMessage(RESPONSE_TEXT)).willReturn(responseTextMessage).     given(session.createProducer(destination)).willReturn(messageProducer).     ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class).     given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT).     final MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {          @Override         protected Object extractMessage(Message message) {             return message.         }     }.     try {         adapter.onMessage(sentTextMessage, session).         fail("expected CouldNotSendReplyException with JMSException").     } catch (ReplyFailureException ex) {         assertEquals(JMSException.class, ex.getCause().getClass()).     }     verify(responseTextMessage).setJMSCorrelationID(CORRELATION_ID).     verify(messageProducer).close().     verify(delegate).handleMessage(sentTextMessage). }
false;protected;1;4;;@Override protected Object extractMessage(Message message) {     return message. }
false;public;0;20;;@Test public void testWithResponsiveMessageDelegateDoesNotSendReturnTextMessageWhenSessionSupplied_AndListenerMethodThrowsException() throws Exception {     final TextMessage message = mock(TextMessage.class).     final QueueSession session = mock(QueueSession.class).     ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class).     willThrow(new IllegalArgumentException("Doe!")).given(delegate).handleMessage(message).     final MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {          @Override         protected Object extractMessage(Message message) {             return message.         }     }.     try {         adapter.onMessage(message, session).         fail("expected ListenerExecutionFailedException").     } catch (ListenerExecutionFailedException ex) {     /* expected */     } }
false;protected;1;4;;@Override protected Object extractMessage(Message message) {     return message. }
false;public;0;22;;@Test public void testWithResponsiveMessageDelegateWhenReturnTypeIsNotAJMSMessageAndNoMessageConverterIsSupplied() throws Exception {     final TextMessage sentTextMessage = mock(TextMessage.class).     final Session session = mock(Session.class).     ResponsiveMessageDelegate delegate = mock(ResponsiveMessageDelegate.class).     given(delegate.handleMessage(sentTextMessage)).willReturn(RESPONSE_TEXT).     final MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {          @Override         protected Object extractMessage(Message message) {             return message.         }     }.     adapter.setMessageConverter(null).     try {         adapter.onMessage(sentTextMessage, session).         fail("expected CouldNotSendReplyException with MessageConversionException").     } catch (ReplyFailureException ex) {         assertEquals(MessageConversionException.class, ex.getCause().getClass()).     } }
false;protected;1;4;;@Override protected Object extractMessage(Message message) {     return message. }
false;public;0;31;;@Test public void testWithResponsiveMessageDelegateWhenReturnTypeIsAJMSMessageAndNoMessageConverterIsSupplied() throws Exception {     Queue destination = mock(Queue.class).     final TextMessage sentTextMessage = mock(TextMessage.class).     // correlation ID is queried when response is being created...     given(sentTextMessage.getJMSCorrelationID()).willReturn(CORRELATION_ID).     // Reply-To is queried when response is being created...     given(sentTextMessage.getJMSReplyTo()).willReturn(destination).     TextMessage responseMessage = mock(TextMessage.class).     QueueSender queueSender = mock(QueueSender.class).     Session session = mock(Session.class).     given(session.createProducer(destination)).willReturn(queueSender).     ResponsiveJmsTextMessageReturningMessageDelegate delegate = mock(ResponsiveJmsTextMessageReturningMessageDelegate.class).     given(delegate.handleMessage(sentTextMessage)).willReturn(responseMessage).     final MessageListenerAdapter adapter = new MessageListenerAdapter(delegate) {          @Override         protected Object extractMessage(Message message) {             return message.         }     }.     adapter.setMessageConverter(null).     adapter.onMessage(sentTextMessage, session).     verify(responseMessage).setJMSCorrelationID(CORRELATION_ID).     verify(queueSender).send(responseMessage).     verify(queueSender).close(). }
