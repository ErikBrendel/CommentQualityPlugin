commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Test public void testSettingMessageListenerToANullType() {     this.container.setMessageListener(null).     assertNull(this.container.getMessageListener()). }
false;public;0;4;;@Test(expected = IllegalArgumentException.class) public void testSettingMessageListenerToAnUnsupportedType() {     this.container.setMessageListener("Bingo"). }
false;public;0;7;;@Test public void testSessionTransactedModeReallyDoesDefaultToFalse() {     assertFalse("The [pubSubLocal] property of SimpleMessageListenerContainer " + "must default to false. Change this test (and the " + "attendant Javadoc) if you have changed the default.", this.container.isPubSubNoLocal()). }
false;public;0;5;;@Test(expected = IllegalArgumentException.class) public void testSettingConcurrentConsumersToZeroIsNotAllowed() {     this.container.setConcurrentConsumers(0).     this.container.afterPropertiesSet(). }
false;public;0;5;;@Test(expected = IllegalArgumentException.class) public void testSettingConcurrentConsumersToANegativeValueIsNotAllowed() {     this.container.setConcurrentConsumers(-198).     this.container.afterPropertiesSet(). }
false;public;0;29;;@Test public void testContextRefreshedEventDoesNotStartTheConnectionIfAutoStartIsSetToFalse() throws Exception {     MessageConsumer messageConsumer = mock(MessageConsumer.class).     Session session = mock(Session.class).     // Queue gets created in order to create MessageConsumer for that Destination...     given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION).     // and then the MessageConsumer gets created...     // no MessageSelector...     given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer).     Connection connection = mock(Connection.class).     // session gets created in order to register MessageListener...     given(connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode())).willReturn(session).     ConnectionFactory connectionFactory = mock(ConnectionFactory.class).     given(connectionFactory.createConnection()).willReturn(connection).     this.container.setConnectionFactory(connectionFactory).     this.container.setDestinationName(DESTINATION_NAME).     this.container.setMessageListener(new TestMessageListener()).     this.container.setAutoStartup(false).     this.container.afterPropertiesSet().     GenericApplicationContext context = new GenericApplicationContext().     context.getBeanFactory().registerSingleton("messageListenerContainer", this.container).     context.refresh().     verify(connection).setExceptionListener(this.container). }
false;public;0;30;;@Test public void testContextRefreshedEventStartsTheConnectionByDefault() throws Exception {     MessageConsumer messageConsumer = mock(MessageConsumer.class).     Session session = mock(Session.class).     // Queue gets created in order to create MessageConsumer for that Destination...     given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION).     // and then the MessageConsumer gets created...     // no MessageSelector...     given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer).     Connection connection = mock(Connection.class).     // session gets created in order to register MessageListener...     given(connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode())).willReturn(session).     // and the connection is start()ed after the listener is registered...     ConnectionFactory connectionFactory = mock(ConnectionFactory.class).     given(connectionFactory.createConnection()).willReturn(connection).     this.container.setConnectionFactory(connectionFactory).     this.container.setDestinationName(DESTINATION_NAME).     this.container.setMessageListener(new TestMessageListener()).     this.container.afterPropertiesSet().     GenericApplicationContext context = new GenericApplicationContext().     context.getBeanFactory().registerSingleton("messageListenerContainer", this.container).     context.refresh().     verify(connection).setExceptionListener(this.container).     verify(connection).start(). }
false;public;2;10;;@Override public void onMessage(Message message, @Nullable Session sess) {     try {         // Check correct Session passed into SessionAwareMessageListener.         assertSame(sess, session).     } catch (Throwable ex) {         failure.add("MessageListener execution failed: " + ex).     } }
false;public;0;52;;@Test public void testCorrectSessionExposedForSessionAwareMessageListenerInvocation() throws Exception {     final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer().     final Session session = mock(Session.class).     // Queue gets created in order to create MessageConsumer for that Destination...     given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION).     // and then the MessageConsumer gets created...     // no MessageSelector...     given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer).     // an exception is thrown, so the rollback logic is being applied here...     given(session.getTransacted()).willReturn(false).     given(session.getAcknowledgeMode()).willReturn(Session.AUTO_ACKNOWLEDGE).     Connection connection = mock(Connection.class).     // session gets created in order to register MessageListener...     given(connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode())).willReturn(session).     // and the connection is start()ed after the listener is registered...     final ConnectionFactory connectionFactory = mock(ConnectionFactory.class).     given(connectionFactory.createConnection()).willReturn(connection).     final Set<String> failure = new HashSet<>(1).     this.container.setConnectionFactory(connectionFactory).     this.container.setDestinationName(DESTINATION_NAME).     this.container.setMessageListener(new SessionAwareMessageListener<Message>() {          @Override         public void onMessage(Message message, @Nullable Session sess) {             try {                 // Check correct Session passed into SessionAwareMessageListener.                 assertSame(sess, session).             } catch (Throwable ex) {                 failure.add("MessageListener execution failed: " + ex).             }         }     }).     this.container.afterPropertiesSet().     this.container.start().     final Message message = mock(Message.class).     messageConsumer.sendMessage(message).     if (!failure.isEmpty()) {         fail(failure.iterator().next().toString()).     }     verify(connection).setExceptionListener(this.container).     verify(connection).start(). }
false;public;1;7;;@Override public void execute(Runnable task) {     listener.executorInvoked = true.     assertFalse(listener.listenerInvoked).     task.run().     assertTrue(listener.listenerInvoked). }
false;public;0;43;;@Test public void testTaskExecutorCorrectlyInvokedWhenSpecified() throws Exception {     final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer().     final Session session = mock(Session.class).     given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION).     // no MessageSelector...     given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer).     given(session.getTransacted()).willReturn(false).     given(session.getAcknowledgeMode()).willReturn(Session.AUTO_ACKNOWLEDGE).     Connection connection = mock(Connection.class).     given(connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode())).willReturn(session).     final ConnectionFactory connectionFactory = mock(ConnectionFactory.class).     given(connectionFactory.createConnection()).willReturn(connection).     final TestMessageListener listener = new TestMessageListener().     this.container.setConnectionFactory(connectionFactory).     this.container.setDestinationName(DESTINATION_NAME).     this.container.setMessageListener(listener).     this.container.setTaskExecutor(new TaskExecutor() {          @Override         public void execute(Runnable task) {             listener.executorInvoked = true.             assertFalse(listener.listenerInvoked).             task.run().             assertTrue(listener.listenerInvoked).         }     }).     this.container.afterPropertiesSet().     this.container.start().     final Message message = mock(Message.class).     messageConsumer.sendMessage(message).     assertTrue(listener.executorInvoked).     assertTrue(listener.listenerInvoked).     verify(connection).setExceptionListener(this.container).     verify(connection).start(). }
false;public;2;4;;@Override public void onMessage(Message message, @Nullable Session session) throws JMSException {     throw theException. }
false;public;0;49;;@Test public void testRegisteredExceptionListenerIsInvokedOnException() throws Exception {     final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer().     Session session = mock(Session.class).     // Queue gets created in order to create MessageConsumer for that Destination...     given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION).     // and then the MessageConsumer gets created...     // no MessageSelector...     given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer).     // an exception is thrown, so the rollback logic is being applied here...     given(session.getTransacted()).willReturn(false).     Connection connection = mock(Connection.class).     // session gets created in order to register MessageListener...     given(connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode())).willReturn(session).     // and the connection is start()ed after the listener is registered...     ConnectionFactory connectionFactory = mock(ConnectionFactory.class).     given(connectionFactory.createConnection()).willReturn(connection).     final JMSException theException = new JMSException(EXCEPTION_MESSAGE).     this.container.setConnectionFactory(connectionFactory).     this.container.setDestinationName(DESTINATION_NAME).     this.container.setMessageListener(new SessionAwareMessageListener<Message>() {          @Override         public void onMessage(Message message, @Nullable Session session) throws JMSException {             throw theException.         }     }).     ExceptionListener exceptionListener = mock(ExceptionListener.class).     this.container.setExceptionListener(exceptionListener).     this.container.afterPropertiesSet().     this.container.start().     // manually trigger an Exception with the above bad MessageListener...     final Message message = mock(Message.class).     // a Throwable from a MessageListener MUST simply be swallowed...     messageConsumer.sendMessage(message).     verify(connection).setExceptionListener(this.container).     verify(connection).start().     verify(exceptionListener).onException(theException). }
false;public;2;4;;@Override public void onMessage(Message message, @Nullable Session session) throws JMSException {     throw theException. }
false;public;0;47;;@Test public void testRegisteredErrorHandlerIsInvokedOnException() throws Exception {     final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer().     Session session = mock(Session.class).     // Queue gets created in order to create MessageConsumer for that Destination...     given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION).     // and then the MessageConsumer gets created...     // no MessageSelector...     given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer).     // an exception is thrown, so the rollback logic is being applied here...     given(session.getTransacted()).willReturn(false).     Connection connection = mock(Connection.class).     // session gets created in order to register MessageListener...     given(connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode())).willReturn(session).     ConnectionFactory connectionFactory = mock(ConnectionFactory.class).     given(connectionFactory.createConnection()).willReturn(connection).     final IllegalStateException theException = new IllegalStateException("intentional test failure").     this.container.setConnectionFactory(connectionFactory).     this.container.setDestinationName(DESTINATION_NAME).     this.container.setMessageListener(new SessionAwareMessageListener<Message>() {          @Override         public void onMessage(Message message, @Nullable Session session) throws JMSException {             throw theException.         }     }).     ErrorHandler errorHandler = mock(ErrorHandler.class).     this.container.setErrorHandler(errorHandler).     this.container.afterPropertiesSet().     this.container.start().     // manually trigger an Exception with the above bad MessageListener...     Message message = mock(Message.class).     // a Throwable from a MessageListener MUST simply be swallowed...     messageConsumer.sendMessage(message).     verify(connection).setExceptionListener(this.container).     verify(connection).start().     verify(errorHandler).handleError(theException). }
false;public;1;4;;@Override public void onMessage(Message message) {     throw new UnsupportedOperationException(). }
false;public;0;41;;@Test public void testNoRollbackOccursIfSessionIsNotTransactedAndThatExceptionsDo_NOT_Propagate() throws Exception {     final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer().     Session session = mock(Session.class).     // Queue gets created in order to create MessageConsumer for that Destination...     given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION).     // and then the MessageConsumer gets created...     // no MessageSelector...     given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer).     // an exception is thrown, so the rollback logic is being applied here...     given(session.getTransacted()).willReturn(false).     Connection connection = mock(Connection.class).     // session gets created in order to register MessageListener...     given(connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode())).willReturn(session).     // and the connection is start()ed after the listener is registered...     ConnectionFactory connectionFactory = mock(ConnectionFactory.class).     given(connectionFactory.createConnection()).willReturn(connection).     this.container.setConnectionFactory(connectionFactory).     this.container.setDestinationName(DESTINATION_NAME).     this.container.setMessageListener(new MessageListener() {          @Override         public void onMessage(Message message) {             throw new UnsupportedOperationException().         }     }).     this.container.afterPropertiesSet().     this.container.start().     // manually trigger an Exception with the above bad MessageListener...     final Message message = mock(Message.class).     // a Throwable from a MessageListener MUST simply be swallowed...     messageConsumer.sendMessage(message).     verify(connection).setExceptionListener(this.container).     verify(connection).start(). }
false;public;1;4;;@Override public void onMessage(Message message) {     throw new UnsupportedOperationException(). }
false;public;0;45;;@Test public void testTransactedSessionsGetRollbackLogicAppliedAndThatExceptionsStillDo_NOT_Propagate() throws Exception {     this.container.setSessionTransacted(true).     final SimpleMessageConsumer messageConsumer = new SimpleMessageConsumer().     Session session = mock(Session.class).     // Queue gets created in order to create MessageConsumer for that Destination...     given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION).     // and then the MessageConsumer gets created...     // no MessageSelector...     given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer).     // an exception is thrown, so the rollback logic is being applied here...     given(session.getTransacted()).willReturn(true).     Connection connection = mock(Connection.class).     // session gets created in order to register MessageListener...     given(connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode())).willReturn(session).     // and the connection is start()ed after the listener is registered...     ConnectionFactory connectionFactory = mock(ConnectionFactory.class).     given(connectionFactory.createConnection()).willReturn(connection).     this.container.setConnectionFactory(connectionFactory).     this.container.setDestinationName(DESTINATION_NAME).     this.container.setMessageListener(new MessageListener() {          @Override         public void onMessage(Message message) {             throw new UnsupportedOperationException().         }     }).     this.container.afterPropertiesSet().     this.container.start().     // manually trigger an Exception with the above bad MessageListener...     final Message message = mock(Message.class).     // a Throwable from a MessageListener MUST simply be swallowed...     messageConsumer.sendMessage(message).     // Session is rolled back 'cos it is transacted...     verify(session).rollback().     verify(connection).setExceptionListener(this.container).     verify(connection).start(). }
false;public;0;32;;@Test public void testDestroyClosesConsumersSessionsAndConnectionInThatOrder() throws Exception {     MessageConsumer messageConsumer = mock(MessageConsumer.class).     Session session = mock(Session.class).     // Queue gets created in order to create MessageConsumer for that Destination...     given(session.createQueue(DESTINATION_NAME)).willReturn(QUEUE_DESTINATION).     // and then the MessageConsumer gets created...     // no MessageSelector...     given(session.createConsumer(QUEUE_DESTINATION, null)).willReturn(messageConsumer).     Connection connection = mock(Connection.class).     // session gets created in order to register MessageListener...     given(connection.createSession(this.container.isSessionTransacted(), this.container.getSessionAcknowledgeMode())).willReturn(session).     // and the connection is start()ed after the listener is registered...     ConnectionFactory connectionFactory = mock(ConnectionFactory.class).     given(connectionFactory.createConnection()).willReturn(connection).     this.container.setConnectionFactory(connectionFactory).     this.container.setDestinationName(DESTINATION_NAME).     this.container.setMessageListener(new TestMessageListener()).     this.container.afterPropertiesSet().     this.container.start().     this.container.destroy().     verify(messageConsumer).close().     verify(session).close().     verify(connection).setExceptionListener(this.container).     verify(connection).start().     verify(connection).close(). }
false;public;1;4;;@Override public void onMessage(Message message) {     this.listenerInvoked = true. }
false;public;1;3;;public void sendMessage(Message message) {     this.messageListener.onMessage(message). }
false;public;0;4;;@Override public String getMessageSelector() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public MessageListener getMessageListener() {     return this.messageListener. }
false;public;1;4;;@Override public void setMessageListener(MessageListener messageListener) {     this.messageListener = messageListener. }
false;public;0;4;;@Override public Message receive() {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public Message receive(long l) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Message receiveNoWait() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public void close() {     throw new UnsupportedOperationException(). }
