commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Test public void testHitsCacheSecondTimeThrough() throws Exception {     Session session = mock(Session.class).     JndiDestinationResolver resolver = new OneTimeLookupJndiDestinationResolver().     Destination destination = resolver.resolveDestinationName(session, DESTINATION_NAME, true).     assertNotNull(destination).     assertSame(DESTINATION, destination). }
false;public;0;18;;@Test public void testDoesNotUseCacheIfCachingIsTurnedOff() throws Exception {     Session session = mock(Session.class).     CountingCannedJndiDestinationResolver resolver = new CountingCannedJndiDestinationResolver().     resolver.setCache(false).     Destination destination = resolver.resolveDestinationName(session, DESTINATION_NAME, true).     assertNotNull(destination).     assertSame(DESTINATION, destination).     assertEquals(1, resolver.getCallCount()).     destination = resolver.resolveDestinationName(session, DESTINATION_NAME, true).     assertNotNull(destination).     assertSame(DESTINATION, destination).     assertEquals(2, resolver.getCallCount()). }
false;protected;2;4;;@Override protected <T> T lookup(String jndiName, Class<T> requiredClass) throws NamingException {     throw new NamingException(). }
false;public;0;21;;@Test public void testDelegatesToFallbackIfNotResolvedInJndi() throws Exception {     Session session = mock(Session.class).     DestinationResolver dynamicResolver = mock(DestinationResolver.class).     given(dynamicResolver.resolveDestinationName(session, DESTINATION_NAME, true)).willReturn(DESTINATION).     JndiDestinationResolver resolver = new JndiDestinationResolver() {          @Override         protected <T> T lookup(String jndiName, Class<T> requiredClass) throws NamingException {             throw new NamingException().         }     }.     resolver.setFallbackToDynamicDestination(true).     resolver.setDynamicDestinationResolver(dynamicResolver).     Destination destination = resolver.resolveDestinationName(session, DESTINATION_NAME, true).     assertNotNull(destination).     assertSame(DESTINATION, destination). }
false;protected;2;4;;@Override protected <T> T lookup(String jndiName, Class<T> requiredClass) throws NamingException {     throw new NamingException(). }
false;public;0;21;;@Test public void testDoesNotDelegateToFallbackIfNotResolvedInJndi() throws Exception {     final Session session = mock(Session.class).     DestinationResolver dynamicResolver = mock(DestinationResolver.class).     final JndiDestinationResolver resolver = new JndiDestinationResolver() {          @Override         protected <T> T lookup(String jndiName, Class<T> requiredClass) throws NamingException {             throw new NamingException().         }     }.     resolver.setDynamicDestinationResolver(dynamicResolver).     try {         resolver.resolveDestinationName(session, DESTINATION_NAME, true).         fail("expected DestinationResolutionException").     } catch (DestinationResolutionException ex) {     // expected     } }
false;protected;2;9;;@Override protected <T> T lookup(String jndiName, Class<T> requiredType) throws NamingException {     if (called) {         fail("Must not be delegating to lookup(..), must be resolving from cache.").     }     assertEquals(DESTINATION_NAME, jndiName).     called = true.     return requiredType.cast(DESTINATION). }
false;public;0;3;;public int getCallCount() {     return this.callCount. }
false;protected;2;5;;@Override protected <T> T lookup(String jndiName, Class<T> requiredType) throws NamingException {     ++this.callCount.     return requiredType.cast(DESTINATION). }
