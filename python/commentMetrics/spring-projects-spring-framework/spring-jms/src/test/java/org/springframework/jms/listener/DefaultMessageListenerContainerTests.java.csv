commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Test public void applyBackOff() {     BackOff backOff = mock(BackOff.class).     BackOffExecution execution = mock(BackOffExecution.class).     given(execution.nextBackOff()).willReturn(BackOffExecution.STOP).     given(backOff.start()).willReturn(execution).     DefaultMessageListenerContainer container = createContainer(createFailingContainerFactory()).     container.setBackOff(backOff).     container.start().     assertEquals(true, container.isRunning()).     container.refreshConnectionUntilSuccessful().     assertEquals(false, container.isRunning()).     verify(backOff).start().     verify(execution).nextBackOff(). }
false;public;0;16;;@Test public void applyBackOffRetry() {     BackOff backOff = mock(BackOff.class).     BackOffExecution execution = mock(BackOffExecution.class).     given(execution.nextBackOff()).willReturn(50L, BackOffExecution.STOP).     given(backOff.start()).willReturn(execution).     DefaultMessageListenerContainer container = createContainer(createFailingContainerFactory()).     container.setBackOff(backOff).     container.start().     container.refreshConnectionUntilSuccessful().     assertEquals(false, container.isRunning()).     verify(backOff).start().     verify(execution, times(2)).nextBackOff(). }
false;public;0;16;;@Test public void recoverResetBackOff() {     BackOff backOff = mock(BackOff.class).     BackOffExecution execution = mock(BackOffExecution.class).     // 3 attempts max     given(execution.nextBackOff()).willReturn(50L, 50L, 50L).     given(backOff.start()).willReturn(execution).     DefaultMessageListenerContainer container = createContainer(createRecoverableContainerFactory(1)).     container.setBackOff(backOff).     container.start().     container.refreshConnectionUntilSuccessful().     assertEquals(true, container.isRunning()).     verify(backOff).start().     // only on attempt as the second one lead to a recovery     verify(execution, times(1)).nextBackOff(). }
false;public;0;10;;@Test public void runnableIsInvokedEvenIfContainerIsNotRunning() throws InterruptedException {     DefaultMessageListenerContainer container = createRunningContainer().     container.stop().     // container is stopped but should nevertheless invoke the runnable argument     TestRunnable runnable2 = new TestRunnable().     container.stop(runnable2).     runnable2.waitForCompletion(). }
false;private;0;6;;private DefaultMessageListenerContainer createRunningContainer() {     DefaultMessageListenerContainer container = createContainer(createSuccessfulConnectionFactory()).     container.afterPropertiesSet().     container.start().     return container. }
false;private;1;9;;private DefaultMessageListenerContainer createContainer(ConnectionFactory connectionFactory) {     Destination destination = new Destination() {     }.     DefaultMessageListenerContainer container = new DefaultMessageListenerContainer().     container.setConnectionFactory(connectionFactory).     container.setCacheLevel(DefaultMessageListenerContainer.CACHE_NONE).     container.setDestination(destination).     return container. }
false;private;0;12;;private ConnectionFactory createFailingContainerFactory() {     try {         ConnectionFactory connectionFactory = mock(ConnectionFactory.class).         given(connectionFactory.createConnection()).will(invocation -> {             throw new JMSException("Test exception").         }).         return connectionFactory.     } catch (JMSException ex) {         // never happen         throw new IllegalStateException(ex).     } }
false;public;1;10;;@Override public Object answer(InvocationOnMock invocation) throws Throwable {     currentAttempts++.     if (currentAttempts <= failingAttempts) {         throw new JMSException("Test exception (attempt " + currentAttempts + ")").     } else {         return mock(Connection.class).     } }
false;private;1;22;;private ConnectionFactory createRecoverableContainerFactory(final int failingAttempts) {     try {         ConnectionFactory connectionFactory = mock(ConnectionFactory.class).         given(connectionFactory.createConnection()).will(new Answer<Object>() {              int currentAttempts = 0.              @Override             public Object answer(InvocationOnMock invocation) throws Throwable {                 currentAttempts++.                 if (currentAttempts <= failingAttempts) {                     throw new JMSException("Test exception (attempt " + currentAttempts + ")").                 } else {                     return mock(Connection.class).                 }             }         }).         return connectionFactory.     } catch (JMSException ex) {         // never happen         throw new IllegalStateException(ex).     } }
false;private;0;10;;private ConnectionFactory createSuccessfulConnectionFactory() {     try {         ConnectionFactory connectionFactory = mock(ConnectionFactory.class).         given(connectionFactory.createConnection()).willReturn(mock(Connection.class)).         return connectionFactory.     } catch (JMSException ex) {         // never happen         throw new IllegalStateException(ex).     } }
false;public;0;4;;@Override public void run() {     this.countDownLatch.countDown(). }
false;public;0;4;;public void waitForCompletion() throws InterruptedException {     this.countDownLatch.await(2, TimeUnit.SECONDS).     assertEquals("callback was not invoked", 0, this.countDownLatch.getCount()). }
