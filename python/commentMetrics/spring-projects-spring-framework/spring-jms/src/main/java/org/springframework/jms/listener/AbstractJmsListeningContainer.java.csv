commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the JMS client ID for a shared Connection created and used  * by this container.  * <p>Note that client IDs need to be unique among all active Connections  * of the underlying JMS provider. Furthermore, a client ID can only be  * assigned if the original ConnectionFactory hasn't already assigned one.  * @see javax.jms.Connection#setClientID  * @see #setConnectionFactory  */ ;/**  * Specify the JMS client ID for a shared Connection created and used  * by this container.  * <p>Note that client IDs need to be unique among all active Connections  * of the underlying JMS provider. Furthermore, a client ID can only be  * assigned if the original ConnectionFactory hasn't already assigned one.  * @see javax.jms.Connection#setClientID  * @see #setConnectionFactory  */ public void setClientId(@Nullable String clientId) {     this.clientId = clientId. }
true;public;0;4;/**  * Return the JMS client ID for the shared Connection created and used  * by this container, if any.  */ ;/**  * Return the JMS client ID for the shared Connection created and used  * by this container, if any.  */ @Nullable public String getClientId() {     return this.clientId. }
true;public;1;3;/**  * Set whether to automatically start the container after initialization.  * <p>Default is "true". set this to "false" to allow for manual startup  * through the {@link #start()} method.  */ ;/**  * Set whether to automatically start the container after initialization.  * <p>Default is "true". set this to "false" to allow for manual startup  * through the {@link #start()} method.  */ public void setAutoStartup(boolean autoStartup) {     this.autoStartup = autoStartup. }
false;public;0;4;;@Override public boolean isAutoStartup() {     return this.autoStartup. }
true;public;1;3;/**  * Specify the phase in which this container should be started and  * stopped. The startup order proceeds from lowest to highest, and  * the shutdown order is the reverse of that. By default this value  * is Integer.MAX_VALUE meaning that this container starts as late  * as possible and stops as soon as possible.  */ ;/**  * Specify the phase in which this container should be started and  * stopped. The startup order proceeds from lowest to highest, and  * the shutdown order is the reverse of that. By default this value  * is Integer.MAX_VALUE meaning that this container starts as late  * as possible and stops as soon as possible.  */ public void setPhase(int phase) {     this.phase = phase. }
true;public;0;4;/**  * Return the phase in which this container will be started and stopped.  */ ;/**  * Return the phase in which this container will be started and stopped.  */ @Override public int getPhase() {     return this.phase. }
false;public;1;4;;@Override public void setBeanName(@Nullable String beanName) {     this.beanName = beanName. }
true;protected,final;0;4;/**  * Return the bean name that this listener container has been assigned  * in its containing bean factory, if any.  */ ;/**  * Return the bean name that this listener container has been assigned  * in its containing bean factory, if any.  */ @Nullable protected final String getBeanName() {     return this.beanName. }
true;public;0;6;/**  * Delegates to {@link #validateConfiguration()} and {@link #initialize()}.  */ ;/**  * Delegates to {@link #validateConfiguration()} and {@link #initialize()}.  */ @Override public void afterPropertiesSet() {     super.afterPropertiesSet().     validateConfiguration().     initialize(). }
true;protected;0;2;/**  * Validate the configuration of this container.  * <p>The default implementation is empty. To be overridden in subclasses.  */ ;/**  * Validate the configuration of this container.  * <p>The default implementation is empty. To be overridden in subclasses.  */ protected void validateConfiguration() { }
true;public;0;4;/**  * Calls {@link #shutdown()} when the BeanFactory destroys the container instance.  * @see #shutdown()  */ ;/**  * Calls {@link #shutdown()} when the BeanFactory destroys the container instance.  * @see #shutdown()  */ @Override public void destroy() {     shutdown(). }
true;public;0;16;/**  * Initialize this container.  * <p>Creates a JMS Connection, starts the {@link javax.jms.Connection}  * (if {@link #setAutoStartup(boolean) "autoStartup"} hasn't been turned off),  * and calls {@link #doInitialize()}.  * @throws org.springframework.jms.JmsException if startup failed  */ ;// ------------------------------------------------------------------------- // Lifecycle methods for starting and stopping the container // ------------------------------------------------------------------------- /**  * Initialize this container.  * <p>Creates a JMS Connection, starts the {@link javax.jms.Connection}  * (if {@link #setAutoStartup(boolean) "autoStartup"} hasn't been turned off),  * and calls {@link #doInitialize()}.  * @throws org.springframework.jms.JmsException if startup failed  */ public void initialize() throws JmsException {     try {         synchronized (this.lifecycleMonitor) {             this.active = true.             this.lifecycleMonitor.notifyAll().         }         doInitialize().     } catch (JMSException ex) {         synchronized (this.sharedConnectionMonitor) {             ConnectionFactoryUtils.releaseConnection(this.sharedConnection, getConnectionFactory(), this.autoStartup).             this.sharedConnection = null.         }         throw convertJmsAccessException(ex).     } }
true;public;0;37;/**  * Stop the shared Connection, call {@link #doShutdown()},  * and close this container.  * @throws JmsException if shutdown failed  */ ;/**  * Stop the shared Connection, call {@link #doShutdown()},  * and close this container.  * @throws JmsException if shutdown failed  */ public void shutdown() throws JmsException {     logger.debug("Shutting down JMS listener container").     boolean wasRunning.     synchronized (this.lifecycleMonitor) {         wasRunning = this.running.         this.running = false.         this.active = false.         this.pausedTasks.clear().         this.lifecycleMonitor.notifyAll().     }     // Stop shared Connection early, if necessary.     if (wasRunning && sharedConnectionEnabled()) {         try {             stopSharedConnection().         } catch (Throwable ex) {             logger.debug("Could not stop JMS Connection on shutdown", ex).         }     }     // Shut down the invokers.     try {         doShutdown().     } catch (JMSException ex) {         throw convertJmsAccessException(ex).     } finally {         if (sharedConnectionEnabled()) {             synchronized (this.sharedConnectionMonitor) {                 ConnectionFactoryUtils.releaseConnection(this.sharedConnection, getConnectionFactory(), false).                 this.sharedConnection = null.             }         }     } }
true;public,final;0;5;/**  * Return whether this container is currently active,  * that is, whether it has been set up but not shut down yet.  */ ;/**  * Return whether this container is currently active,  * that is, whether it has been set up but not shut down yet.  */ public final boolean isActive() {     synchronized (this.lifecycleMonitor) {         return this.active.     } }
true;public;0;9;/**  * Start this container.  * @throws JmsException if starting failed  * @see #doStart  */ ;/**  * Start this container.  * @throws JmsException if starting failed  * @see #doStart  */ @Override public void start() throws JmsException {     try {         doStart().     } catch (JMSException ex) {         throw convertJmsAccessException(ex).     } }
true;protected;0;18;/**  * Start the shared Connection, if any, and notify all invoker tasks.  * @throws JMSException if thrown by JMS API methods  * @see #startSharedConnection  */ ;/**  * Start the shared Connection, if any, and notify all invoker tasks.  * @throws JMSException if thrown by JMS API methods  * @see #startSharedConnection  */ protected void doStart() throws JMSException {     // Lazily establish a shared Connection, if necessary.     if (sharedConnectionEnabled()) {         establishSharedConnection().     }     // Reschedule paused tasks, if any.     synchronized (this.lifecycleMonitor) {         this.running = true.         this.lifecycleMonitor.notifyAll().         resumePausedTasks().     }     // Start the shared Connection, if any.     if (sharedConnectionEnabled()) {         startSharedConnection().     } }
true;public;0;9;/**  * Stop this container.  * @throws JmsException if stopping failed  * @see #doStop  */ ;/**  * Stop this container.  * @throws JmsException if stopping failed  * @see #doStop  */ @Override public void stop() throws JmsException {     try {         doStop().     } catch (JMSException ex) {         throw convertJmsAccessException(ex).     } }
true;protected;0;10;/**  * Notify all invoker tasks and stop the shared Connection, if any.  * @throws JMSException if thrown by JMS API methods  * @see #stopSharedConnection  */ ;/**  * Notify all invoker tasks and stop the shared Connection, if any.  * @throws JMSException if thrown by JMS API methods  * @see #stopSharedConnection  */ protected void doStop() throws JMSException {     synchronized (this.lifecycleMonitor) {         this.running = false.         this.lifecycleMonitor.notifyAll().     }     if (sharedConnectionEnabled()) {         stopSharedConnection().     } }
true;public,final;0;4;/**  * Determine whether this container is currently running,  * that is, whether it has been started and not stopped yet.  * @see #start()  * @see #stop()  * @see #runningAllowed()  */ ;/**  * Determine whether this container is currently running,  * that is, whether it has been started and not stopped yet.  * @see #start()  * @see #stop()  * @see #runningAllowed()  */ @Override public final boolean isRunning() {     return (this.running && runningAllowed()). }
true;protected;0;3;/**  * Check whether this container's listeners are generally allowed to run.  * <p>This implementation always returns {@code true}. the default 'running'  * state is purely determined by {@link #start()} / {@link #stop()}.  * <p>Subclasses may override this method to check against temporary  * conditions that prevent listeners from actually running. In other words,  * they may apply further restrictions to the 'running' state, returning  * {@code false} if such a restriction prevents listeners from running.  */ ;/**  * Check whether this container's listeners are generally allowed to run.  * <p>This implementation always returns {@code true}. the default 'running'  * state is purely determined by {@link #start()} / {@link #stop()}.  * <p>Subclasses may override this method to check against temporary  * conditions that prevent listeners from actually running. In other words,  * they may apply further restrictions to the 'running' state, returning  * {@code false} if such a restriction prevents listeners from running.  */ protected boolean runningAllowed() {     return true. }
true;protected;0;8;/**  * Establish a shared Connection for this container.  * <p>The default implementation delegates to {@link #createSharedConnection()},  * which does one immediate attempt and throws an exception if it fails.  * Can be overridden to have a recovery process in place, retrying  * until a Connection can be successfully established.  * @throws JMSException if thrown by JMS API methods  */ ;// ------------------------------------------------------------------------- // Management of a shared JMS Connection // ------------------------------------------------------------------------- /**  * Establish a shared Connection for this container.  * <p>The default implementation delegates to {@link #createSharedConnection()},  * which does one immediate attempt and throws an exception if it fails.  * Can be overridden to have a recovery process in place, retrying  * until a Connection can be successfully established.  * @throws JMSException if thrown by JMS API methods  */ protected void establishSharedConnection() throws JMSException {     synchronized (this.sharedConnectionMonitor) {         if (this.sharedConnection == null) {             this.sharedConnection = createSharedConnection().             logger.debug("Established shared JMS Connection").         }     } }
true;protected,final;0;11;/**  * Refresh the shared Connection that this container holds.  * <p>Called on startup and also after an infrastructure exception  * that occurred during invoker setup and/or execution.  * @throws JMSException if thrown by JMS API methods  */ ;/**  * Refresh the shared Connection that this container holds.  * <p>Called on startup and also after an infrastructure exception  * that occurred during invoker setup and/or execution.  * @throws JMSException if thrown by JMS API methods  */ protected final void refreshSharedConnection() throws JMSException {     synchronized (this.sharedConnectionMonitor) {         ConnectionFactoryUtils.releaseConnection(this.sharedConnection, getConnectionFactory(), this.sharedConnectionStarted).         this.sharedConnection = null.         this.sharedConnection = createSharedConnection().         if (this.sharedConnectionStarted) {             this.sharedConnection.start().         }     } }
true;protected;0;11;/**  * Create a shared Connection for this container.  * <p>The default implementation creates a standard Connection  * and prepares it through {@link #prepareSharedConnection}.  * @return the prepared Connection  * @throws JMSException if the creation failed  */ ;/**  * Create a shared Connection for this container.  * <p>The default implementation creates a standard Connection  * and prepares it through {@link #prepareSharedConnection}.  * @return the prepared Connection  * @throws JMSException if the creation failed  */ protected Connection createSharedConnection() throws JMSException {     Connection con = createConnection().     try {         prepareSharedConnection(con).         return con.     } catch (JMSException ex) {         JmsUtils.closeConnection(con).         throw ex.     } }
true;protected;1;6;/**  * Prepare the given Connection, which is about to be registered  * as shared Connection for this container.  * <p>The default implementation sets the specified client id, if any.  * Subclasses can override this to apply further settings.  * @param connection the Connection to prepare  * @throws JMSException if the preparation efforts failed  * @see #getClientId()  */ ;/**  * Prepare the given Connection, which is about to be registered  * as shared Connection for this container.  * <p>The default implementation sets the specified client id, if any.  * Subclasses can override this to apply further settings.  * @param connection the Connection to prepare  * @throws JMSException if the preparation efforts failed  * @see #getClientId()  */ protected void prepareSharedConnection(Connection connection) throws JMSException {     String clientId = getClientId().     if (clientId != null) {         connection.setClientID(clientId).     } }
true;protected;0;13;/**  * Start the shared Connection.  * @throws JMSException if thrown by JMS API methods  * @see javax.jms.Connection#start()  */ ;/**  * Start the shared Connection.  * @throws JMSException if thrown by JMS API methods  * @see javax.jms.Connection#start()  */ protected void startSharedConnection() throws JMSException {     synchronized (this.sharedConnectionMonitor) {         this.sharedConnectionStarted = true.         if (this.sharedConnection != null) {             try {                 this.sharedConnection.start().             } catch (javax.jms.IllegalStateException ex) {                 logger.debug("Ignoring Connection start exception - assuming already started: " + ex).             }         }     } }
true;protected;0;13;/**  * Stop the shared Connection.  * @throws JMSException if thrown by JMS API methods  * @see javax.jms.Connection#start()  */ ;/**  * Stop the shared Connection.  * @throws JMSException if thrown by JMS API methods  * @see javax.jms.Connection#start()  */ protected void stopSharedConnection() throws JMSException {     synchronized (this.sharedConnectionMonitor) {         this.sharedConnectionStarted = false.         if (this.sharedConnection != null) {             try {                 this.sharedConnection.stop().             } catch (javax.jms.IllegalStateException ex) {                 logger.debug("Ignoring Connection stop exception - assuming already stopped: " + ex).             }         }     } }
true;protected,final;0;13;/**  * Return the shared JMS Connection maintained by this container.  * Available after initialization.  * @return the shared Connection (never {@code null})  * @throws IllegalStateException if this container does not maintain a  * shared Connection, or if the Connection hasn't been initialized yet  * @see #sharedConnectionEnabled()  */ ;/**  * Return the shared JMS Connection maintained by this container.  * Available after initialization.  * @return the shared Connection (never {@code null})  * @throws IllegalStateException if this container does not maintain a  * shared Connection, or if the Connection hasn't been initialized yet  * @see #sharedConnectionEnabled()  */ protected final Connection getSharedConnection() {     if (!sharedConnectionEnabled()) {         throw new IllegalStateException("This listener container does not maintain a shared Connection").     }     synchronized (this.sharedConnectionMonitor) {         if (this.sharedConnection == null) {             throw new SharedConnectionNotInitializedException("This listener container's shared Connection has not been initialized yet").         }         return this.sharedConnection.     } }
true;protected,final;1;19;/**  * Take the given task object and reschedule it, either immediately if  * this container is currently running, or later once this container  * has been restarted.  * <p>If this container has already been shut down, the task will not  * get rescheduled at all.  * @param task the task object to reschedule  * @return whether the task has been rescheduled  * (either immediately or for a restart of this container)  * @see #doRescheduleTask  */ ;// ------------------------------------------------------------------------- // Management of paused tasks // ------------------------------------------------------------------------- /**  * Take the given task object and reschedule it, either immediately if  * this container is currently running, or later once this container  * has been restarted.  * <p>If this container has already been shut down, the task will not  * get rescheduled at all.  * @param task the task object to reschedule  * @return whether the task has been rescheduled  * (either immediately or for a restart of this container)  * @see #doRescheduleTask  */ protected final boolean rescheduleTaskIfNecessary(Object task) {     if (this.running) {         try {             doRescheduleTask(task).         } catch (RuntimeException ex) {             logRejectedTask(task, ex).             this.pausedTasks.add(task).         }         return true.     } else if (this.active) {         this.pausedTasks.add(task).         return true.     } else {         return false.     } }
true;protected;0;20;/**  * Try to resume all paused tasks.  * Tasks for which rescheduling failed simply remain in paused mode.  */ ;/**  * Try to resume all paused tasks.  * Tasks for which rescheduling failed simply remain in paused mode.  */ protected void resumePausedTasks() {     synchronized (this.lifecycleMonitor) {         if (!this.pausedTasks.isEmpty()) {             for (Iterator<?> it = this.pausedTasks.iterator(). it.hasNext(). ) {                 Object task = it.next().                 try {                     doRescheduleTask(task).                     it.remove().                     if (logger.isDebugEnabled()) {                         logger.debug("Resumed paused task: " + task).                     }                 } catch (RuntimeException ex) {                     logRejectedTask(task, ex).                 // Keep the task in paused mode...                 }             }         }     } }
true;public;0;5;/**  * Determine the number of currently paused tasks, if any.  */ ;/**  * Determine the number of currently paused tasks, if any.  */ public int getPausedTaskCount() {     synchronized (this.lifecycleMonitor) {         return this.pausedTasks.size().     } }
true;protected;1;4;/**  * Reschedule the given task object immediately.  * <p>To be implemented by subclasses if they ever call  * {@code rescheduleTaskIfNecessary}.  * This implementation throws an UnsupportedOperationException.  * @param task the task object to reschedule  * @see #rescheduleTaskIfNecessary  */ ;/**  * Reschedule the given task object immediately.  * <p>To be implemented by subclasses if they ever call  * {@code rescheduleTaskIfNecessary}.  * This implementation throws an UnsupportedOperationException.  * @param task the task object to reschedule  * @see #rescheduleTaskIfNecessary  */ protected void doRescheduleTask(Object task) {     throw new UnsupportedOperationException(ClassUtils.getShortName(getClass()) + " does not support rescheduling of tasks"). }
true;protected;2;5;/**  * Log a task that has been rejected by {@link #doRescheduleTask}.  * <p>The default implementation simply logs a corresponding message  * at debug level.  * @param task the rejected task object  * @param ex the exception thrown from {@link #doRescheduleTask}  */ ;/**  * Log a task that has been rejected by {@link #doRescheduleTask}.  * <p>The default implementation simply logs a corresponding message  * at debug level.  * @param task the rejected task object  * @param ex the exception thrown from {@link #doRescheduleTask}  */ protected void logRejectedTask(Object task, RuntimeException ex) {     if (logger.isDebugEnabled()) {         logger.debug("Listener container task [" + task + "] has been rejected and paused: " + ex).     } }
true;protected,abstract;0;1;/**  * Return whether a shared JMS Connection should be maintained  * by this container base class.  * @see #getSharedConnection()  */ ;// ------------------------------------------------------------------------- // Template methods to be implemented by subclasses // ------------------------------------------------------------------------- /**  * Return whether a shared JMS Connection should be maintained  * by this container base class.  * @see #getSharedConnection()  */ protected abstract boolean sharedConnectionEnabled().
true;protected,abstract;0;1;/**  * Register any invokers within this container.  * <p>Subclasses need to implement this method for their specific  * invoker management process.  * <p>A shared JMS Connection, if any, will already have been  * started at this point.  * @throws JMSException if registration failed  * @see #getSharedConnection()  */ ;/**  * Register any invokers within this container.  * <p>Subclasses need to implement this method for their specific  * invoker management process.  * <p>A shared JMS Connection, if any, will already have been  * started at this point.  * @throws JMSException if registration failed  * @see #getSharedConnection()  */ protected abstract void doInitialize() throws JMSException.
true;protected,abstract;0;1;/**  * Close the registered invokers.  * <p>Subclasses need to implement this method for their specific  * invoker management process.  * <p>A shared JMS Connection, if any, will automatically be closed  * <i>afterwards</i>.  * @throws JMSException if shutdown failed  * @see #shutdown()  */ ;/**  * Close the registered invokers.  * <p>Subclasses need to implement this method for their specific  * invoker management process.  * <p>A shared JMS Connection, if any, will automatically be closed  * <i>afterwards</i>.  * @throws JMSException if shutdown failed  * @see #shutdown()  */ protected abstract void doShutdown() throws JMSException.
