commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the default destination to send response messages to. This will be applied  * in case of a request message that does not carry a "JMSReplyTo" field.  * <p>Response destinations are only relevant for listener methods that return  * result objects, which will be wrapped in a response message and sent to a  * response destination.  * <p>Alternatively, specify a "defaultResponseQueueName" or "defaultResponseTopicName",  * to be dynamically resolved via the DestinationResolver.  * @see #setDefaultResponseQueueName(String)  * @see #setDefaultResponseTopicName(String)  * @see #getResponseDestination  */ ;/**  * Set the default destination to send response messages to. This will be applied  * in case of a request message that does not carry a "JMSReplyTo" field.  * <p>Response destinations are only relevant for listener methods that return  * result objects, which will be wrapped in a response message and sent to a  * response destination.  * <p>Alternatively, specify a "defaultResponseQueueName" or "defaultResponseTopicName",  * to be dynamically resolved via the DestinationResolver.  * @see #setDefaultResponseQueueName(String)  * @see #setDefaultResponseTopicName(String)  * @see #getResponseDestination  */ public void setDefaultResponseDestination(Destination destination) {     this.defaultResponseDestination = destination. }
true;public;1;3;/**  * Set the name of the default response queue to send response messages to.  * This will be applied in case of a request message that does not carry a  * "JMSReplyTo" field.  * <p>Alternatively, specify a JMS Destination object as "defaultResponseDestination".  * @see #setDestinationResolver  * @see #setDefaultResponseDestination(javax.jms.Destination)  */ ;/**  * Set the name of the default response queue to send response messages to.  * This will be applied in case of a request message that does not carry a  * "JMSReplyTo" field.  * <p>Alternatively, specify a JMS Destination object as "defaultResponseDestination".  * @see #setDestinationResolver  * @see #setDefaultResponseDestination(javax.jms.Destination)  */ public void setDefaultResponseQueueName(String destinationName) {     this.defaultResponseDestination = new DestinationNameHolder(destinationName, false). }
true;public;1;3;/**  * Set the name of the default response topic to send response messages to.  * This will be applied in case of a request message that does not carry a  * "JMSReplyTo" field.  * <p>Alternatively, specify a JMS Destination object as "defaultResponseDestination".  * @see #setDestinationResolver  * @see #setDefaultResponseDestination(javax.jms.Destination)  */ ;/**  * Set the name of the default response topic to send response messages to.  * This will be applied in case of a request message that does not carry a  * "JMSReplyTo" field.  * <p>Alternatively, specify a JMS Destination object as "defaultResponseDestination".  * @see #setDestinationResolver  * @see #setDefaultResponseDestination(javax.jms.Destination)  */ public void setDefaultResponseTopicName(String destinationName) {     this.defaultResponseDestination = new DestinationNameHolder(destinationName, true). }
true;public;1;4;/**  * Set the DestinationResolver that should be used to resolve response  * destination names for this adapter.  * <p>The default resolver is a DynamicDestinationResolver. Specify a  * JndiDestinationResolver for resolving destination names as JNDI locations.  * @see org.springframework.jms.support.destination.DynamicDestinationResolver  * @see org.springframework.jms.support.destination.JndiDestinationResolver  */ ;/**  * Set the DestinationResolver that should be used to resolve response  * destination names for this adapter.  * <p>The default resolver is a DynamicDestinationResolver. Specify a  * JndiDestinationResolver for resolving destination names as JNDI locations.  * @see org.springframework.jms.support.destination.DynamicDestinationResolver  * @see org.springframework.jms.support.destination.JndiDestinationResolver  */ public void setDestinationResolver(DestinationResolver destinationResolver) {     Assert.notNull(destinationResolver, "DestinationResolver must not be null").     this.destinationResolver = destinationResolver. }
true;protected;0;3;/**  * Return the DestinationResolver for this adapter.  */ ;/**  * Return the DestinationResolver for this adapter.  */ protected DestinationResolver getDestinationResolver() {     return this.destinationResolver. }
true;public;1;3;/**  * Set the converter that will convert incoming JMS messages to  * listener method arguments, and objects returned from listener  * methods back to JMS messages.  * <p>The default converter is a {@link SimpleMessageConverter}, which is able  * to handle {@link javax.jms.BytesMessage BytesMessages},  * {@link javax.jms.TextMessage TextMessages} and  * {@link javax.jms.ObjectMessage ObjectMessages}.  */ ;/**  * Set the converter that will convert incoming JMS messages to  * listener method arguments, and objects returned from listener  * methods back to JMS messages.  * <p>The default converter is a {@link SimpleMessageConverter}, which is able  * to handle {@link javax.jms.BytesMessage BytesMessages},  * {@link javax.jms.TextMessage TextMessages} and  * {@link javax.jms.ObjectMessage ObjectMessages}.  */ public void setMessageConverter(@Nullable MessageConverter messageConverter) {     this.messageConverter = messageConverter. }
true;protected;0;4;/**  * Return the converter that will convert incoming JMS messages to  * listener method arguments, and objects returned from listener  * methods back to JMS messages.  */ ;/**  * Return the converter that will convert incoming JMS messages to  * listener method arguments, and objects returned from listener  * methods back to JMS messages.  */ @Nullable protected MessageConverter getMessageConverter() {     return this.messageConverter. }
true;public;1;4;/**  * Set the {@link JmsHeaderMapper} implementation to use to map the standard  * JMS headers. By default, a {@link SimpleJmsHeaderMapper} is used.  * @see SimpleJmsHeaderMapper  */ ;/**  * Set the {@link JmsHeaderMapper} implementation to use to map the standard  * JMS headers. By default, a {@link SimpleJmsHeaderMapper} is used.  * @see SimpleJmsHeaderMapper  */ public void setHeaderMapper(JmsHeaderMapper headerMapper) {     Assert.notNull(headerMapper, "HeaderMapper must not be null").     this.messagingMessageConverter.setHeaderMapper(headerMapper). }
true;protected,final;0;3;/**  * Return the {@link MessagingMessageConverter} for this listener,  * being able to convert {@link org.springframework.messaging.Message}.  */ ;/**  * Return the {@link MessagingMessageConverter} for this listener,  * being able to convert {@link org.springframework.messaging.Message}.  */ protected final MessagingMessageConverter getMessagingMessageConverter() {     return this.messagingMessageConverter. }
true;public;1;3;/**  * Set the {@link QosSettings} to use when sending a response. Can be set to  * {@code null} to indicate that the broker's defaults should be used.  * @param responseQosSettings the QoS settings to use when sending a response or  * {@code null} to use the default values.  * @since 5.0  */ ;/**  * Set the {@link QosSettings} to use when sending a response. Can be set to  * {@code null} to indicate that the broker's defaults should be used.  * @param responseQosSettings the QoS settings to use when sending a response or  * {@code null} to use the default values.  * @since 5.0  */ public void setResponseQosSettings(@Nullable QosSettings responseQosSettings) {     this.responseQosSettings = responseQosSettings. }
true;protected;0;4;/**  * Return the {@link QosSettings} to use when sending a response,  * or {@code null} if the defaults should be used.  * @since 5.0  */ ;/**  * Return the {@link QosSettings} to use when sending a response,  * or {@code null} if the defaults should be used.  * @since 5.0  */ @Nullable protected QosSettings getResponseQosSettings() {     return this.responseQosSettings. }
true;public;1;9;/**  * Standard JMS {@link MessageListener} entry point.  * <p>Delegates the message to the target listener method, with appropriate  * conversion of the message argument. In case of an exception, the  * {@link #handleListenerException(Throwable)} method will be invoked.  * <p><b>Note:</b> Does not support sending response messages based on  * result objects returned from listener methods. Use the  * {@link SessionAwareMessageListener} entry point (typically through a Spring  * message listener container) for handling result objects as well.  * @param message the incoming JMS message  * @see #handleListenerException  * @see #onMessage(javax.jms.Message, javax.jms.Session)  */ ;/**  * Standard JMS {@link MessageListener} entry point.  * <p>Delegates the message to the target listener method, with appropriate  * conversion of the message argument. In case of an exception, the  * {@link #handleListenerException(Throwable)} method will be invoked.  * <p><b>Note:</b> Does not support sending response messages based on  * result objects returned from listener methods. Use the  * {@link SessionAwareMessageListener} entry point (typically through a Spring  * message listener container) for handling result objects as well.  * @param message the incoming JMS message  * @see #handleListenerException  * @see #onMessage(javax.jms.Message, javax.jms.Session)  */ @Override public void onMessage(Message message) {     try {         onMessage(message, null).     } catch (Throwable ex) {         handleListenerException(ex).     } }
false;public,abstract;2;2;;@Override public abstract void onMessage(Message message, @Nullable Session session) throws JMSException.
true;protected;1;3;/**  * Handle the given exception that arose during listener execution.  * The default implementation logs the exception at error level.  * <p>This method only applies when used as standard JMS {@link MessageListener}.  * In case of the Spring {@link SessionAwareMessageListener} mechanism,  * exceptions get handled by the caller instead.  * @param ex the exception to handle  * @see #onMessage(javax.jms.Message)  */ ;/**  * Handle the given exception that arose during listener execution.  * The default implementation logs the exception at error level.  * <p>This method only applies when used as standard JMS {@link MessageListener}.  * In case of the Spring {@link SessionAwareMessageListener} mechanism,  * exceptions get handled by the caller instead.  * @param ex the exception to handle  * @see #onMessage(javax.jms.Message)  */ protected void handleListenerException(Throwable ex) {     logger.error("Listener execution failed", ex). }
true;protected;1;12;/**  * Extract the message body from the given JMS message.  * @param message the JMS {@code Message}  * @return the content of the message, to be passed into the listener method  * as an argument  * @throws MessageConversionException if the message could not be extracted  */ ;/**  * Extract the message body from the given JMS message.  * @param message the JMS {@code Message}  * @return the content of the message, to be passed into the listener method  * as an argument  * @throws MessageConversionException if the message could not be extracted  */ protected Object extractMessage(Message message) {     try {         MessageConverter converter = getMessageConverter().         if (converter != null) {             return converter.fromMessage(message).         }         return message.     } catch (JMSException ex) {         throw new MessageConversionException("Could not convert JMS message", ex).     } }
true;protected;3;25;/**  * Handle the given result object returned from the listener method,  * sending a response message back.  * @param result the result object to handle (never {@code null})  * @param request the original request message  * @param session the JMS Session to operate on (may be {@code null})  * @throws ReplyFailureException if the response message could not be sent  * @see #buildMessage  * @see #postProcessResponse  * @see #getResponseDestination  * @see #sendResponse  */ ;/**  * Handle the given result object returned from the listener method,  * sending a response message back.  * @param result the result object to handle (never {@code null})  * @param request the original request message  * @param session the JMS Session to operate on (may be {@code null})  * @throws ReplyFailureException if the response message could not be sent  * @see #buildMessage  * @see #postProcessResponse  * @see #getResponseDestination  * @see #sendResponse  */ protected void handleResult(Object result, Message request, @Nullable Session session) {     if (session != null) {         if (logger.isDebugEnabled()) {             logger.debug("Listener method returned result [" + result + "] - generating response message for it").         }         try {             Message response = buildMessage(session, result).             postProcessResponse(request, response).             Destination destination = getResponseDestination(request, response, session, result).             sendResponse(session, destination, response).         } catch (Exception ex) {             throw new ReplyFailureException("Failed to send reply with payload [" + result + "]", ex).         }     } else {         // No JMS Session available         if (logger.isWarnEnabled()) {             logger.warn("Listener method returned result [" + result + "]: not generating response message for it because of no JMS Session given").         }     } }
true;protected;2;20;/**  * Build a JMS message to be sent as response based on the given result object.  * @param session the JMS Session to operate on  * @param result the content of the message, as returned from the listener method  * @return the JMS {@code Message} (never {@code null})  * @throws JMSException if thrown by JMS API methods  * @see #setMessageConverter  */ ;/**  * Build a JMS message to be sent as response based on the given result object.  * @param session the JMS Session to operate on  * @param result the content of the message, as returned from the listener method  * @return the JMS {@code Message} (never {@code null})  * @throws JMSException if thrown by JMS API methods  * @see #setMessageConverter  */ protected Message buildMessage(Session session, Object result) throws JMSException {     Object content = preProcessResponse(result instanceof JmsResponse ? ((JmsResponse<?>) result).getResponse() : result).     MessageConverter converter = getMessageConverter().     if (converter != null) {         if (content instanceof org.springframework.messaging.Message) {             return this.messagingMessageConverter.toMessage(content, session).         } else {             return converter.toMessage(content, session).         }     }     if (!(content instanceof Message)) {         throw new MessageConversionException("No MessageConverter specified - cannot handle message [" + content + "]").     }     return (Message) content. }
true;protected;1;3;/**  * Pre-process the given result before it is converted to a {@link Message}.  * @param result the result of the invocation  * @return the payload response to handle, either the {@code result} argument  * or any other object (for instance wrapping the result).  * @since 4.3  */ ;/**  * Pre-process the given result before it is converted to a {@link Message}.  * @param result the result of the invocation  * @return the payload response to handle, either the {@code result} argument  * or any other object (for instance wrapping the result).  * @since 4.3  */ protected Object preProcessResponse(Object result) {     return result. }
true;protected;2;7;/**  * Post-process the given response message before it will be sent.  * <p>The default implementation sets the response's correlation id  * to the request message's correlation id, if any. otherwise to the  * request message id.  * @param request the original incoming JMS message  * @param response the outgoing JMS message about to be sent  * @throws JMSException if thrown by JMS API methods  * @see javax.jms.Message#setJMSCorrelationID  */ ;/**  * Post-process the given response message before it will be sent.  * <p>The default implementation sets the response's correlation id  * to the request message's correlation id, if any. otherwise to the  * request message id.  * @param request the original incoming JMS message  * @param response the outgoing JMS message about to be sent  * @throws JMSException if thrown by JMS API methods  * @see javax.jms.Message#setJMSCorrelationID  */ protected void postProcessResponse(Message request, Message response) throws JMSException {     String correlation = request.getJMSCorrelationID().     if (correlation == null) {         correlation = request.getJMSMessageID().     }     response.setJMSCorrelationID(correlation). }
false;private;4;12;;private Destination getResponseDestination(Message request, Message response, Session session, Object result) throws JMSException {     if (result instanceof JmsResponse) {         JmsResponse<?> jmsResponse = (JmsResponse) result.         Destination destination = jmsResponse.resolveDestination(getDestinationResolver(), session).         if (destination != null) {             return destination.         }     }     return getResponseDestination(request, response, session). }
true;protected;3;13;/**  * Determine a response destination for the given message.  * <p>The default implementation first checks the JMS Reply-To  * {@link Destination} of the supplied request. if that is not {@code null}  * it is returned. if it is {@code null}, then the configured  * {@link #resolveDefaultResponseDestination default response destination}  * is returned. if this too is {@code null}, then an  * {@link javax.jms.InvalidDestinationException} is thrown.  * @param request the original incoming JMS message  * @param response the outgoing JMS message about to be sent  * @param session the JMS Session to operate on  * @return the response destination (never {@code null})  * @throws JMSException if thrown by JMS API methods  * @throws javax.jms.InvalidDestinationException if no {@link Destination} can be determined  * @see #setDefaultResponseDestination  * @see javax.jms.Message#getJMSReplyTo()  */ ;/**  * Determine a response destination for the given message.  * <p>The default implementation first checks the JMS Reply-To  * {@link Destination} of the supplied request. if that is not {@code null}  * it is returned. if it is {@code null}, then the configured  * {@link #resolveDefaultResponseDestination default response destination}  * is returned. if this too is {@code null}, then an  * {@link javax.jms.InvalidDestinationException} is thrown.  * @param request the original incoming JMS message  * @param response the outgoing JMS message about to be sent  * @param session the JMS Session to operate on  * @return the response destination (never {@code null})  * @throws JMSException if thrown by JMS API methods  * @throws javax.jms.InvalidDestinationException if no {@link Destination} can be determined  * @see #setDefaultResponseDestination  * @see javax.jms.Message#getJMSReplyTo()  */ protected Destination getResponseDestination(Message request, Message response, Session session) throws JMSException {     Destination replyTo = request.getJMSReplyTo().     if (replyTo == null) {         replyTo = resolveDefaultResponseDestination(session).         if (replyTo == null) {             throw new InvalidDestinationException("Cannot determine response destination: " + "Request message does not contain reply-to destination, and no default response destination set.").         }     }     return replyTo. }
true;protected;1;11;/**  * Resolve the default response destination into a JMS {@link Destination}, using this  * accessor's {@link DestinationResolver} in case of a destination name.  * @return the located {@link Destination}  * @throws javax.jms.JMSException if resolution failed  * @see #setDefaultResponseDestination  * @see #setDefaultResponseQueueName  * @see #setDefaultResponseTopicName  * @see #setDestinationResolver  */ ;/**  * Resolve the default response destination into a JMS {@link Destination}, using this  * accessor's {@link DestinationResolver} in case of a destination name.  * @return the located {@link Destination}  * @throws javax.jms.JMSException if resolution failed  * @see #setDefaultResponseDestination  * @see #setDefaultResponseQueueName  * @see #setDefaultResponseTopicName  * @see #setDestinationResolver  */ @Nullable protected Destination resolveDefaultResponseDestination(Session session) throws JMSException {     if (this.defaultResponseDestination instanceof Destination) {         return (Destination) this.defaultResponseDestination.     }     if (this.defaultResponseDestination instanceof DestinationNameHolder) {         DestinationNameHolder nameHolder = (DestinationNameHolder) this.defaultResponseDestination.         return getDestinationResolver().resolveDestinationName(session, nameHolder.name, nameHolder.isTopic).     }     return null. }
true;protected;3;17;/**  * Send the given response message to the given destination.  * @param response the JMS message to send  * @param destination the JMS destination to send to  * @param session the JMS session to operate on  * @throws JMSException if thrown by JMS API methods  * @see #postProcessProducer  * @see javax.jms.Session#createProducer  * @see javax.jms.MessageProducer#send  */ ;/**  * Send the given response message to the given destination.  * @param response the JMS message to send  * @param destination the JMS destination to send to  * @param session the JMS session to operate on  * @throws JMSException if thrown by JMS API methods  * @see #postProcessProducer  * @see javax.jms.Session#createProducer  * @see javax.jms.MessageProducer#send  */ protected void sendResponse(Session session, Destination destination, Message response) throws JMSException {     MessageProducer producer = session.createProducer(destination).     try {         postProcessProducer(producer, response).         QosSettings settings = getResponseQosSettings().         if (settings != null) {             producer.send(response, settings.getDeliveryMode(), settings.getPriority(), settings.getTimeToLive()).         } else {             producer.send(response).         }     } finally {         JmsUtils.closeMessageProducer(producer).     } }
true;protected;2;2;/**  * Post-process the given message producer before using it to send the response.  * <p>The default implementation is empty.  * @param producer the JMS message producer that will be used to send the message  * @param response the outgoing JMS message about to be sent  * @throws JMSException if thrown by JMS API methods  */ ;/**  * Post-process the given message producer before using it to send the response.  * <p>The default implementation is empty.  * @param producer the JMS message producer that will be used to send the message  * @param response the outgoing JMS message about to be sent  * @throws JMSException if thrown by JMS API methods  */ protected void postProcessProducer(MessageProducer producer, Message response) throws JMSException { }
false;public;1;5;;@SuppressWarnings("unchecked") @Override public Object fromMessage(javax.jms.Message message) throws JMSException, MessageConversionException {     return new LazyResolutionMessage(message). }
false;protected;1;16;;@Override protected Object extractPayload(Message message) throws JMSException {     Object payload = extractMessage(message).     if (message instanceof BytesMessage) {         try {             // In case the BytesMessage is going to be received as a user argument:             // reset it, otherwise it would appear empty to such processing code...             ((BytesMessage) message).reset().         } catch (JMSException ex) {             // Continue since the BytesMessage typically won't be used any further.             logger.debug("Failed to reset BytesMessage after payload extraction", ex).         }     }     return payload. }
false;protected;3;14;;@Override protected Message createMessageForPayload(Object payload, Session session, @Nullable Object conversionHint) throws JMSException {     MessageConverter converter = getMessageConverter().     if (converter == null) {         throw new IllegalStateException("No message converter, cannot handle '" + payload + "'").     }     if (converter instanceof SmartMessageConverter) {         return ((SmartMessageConverter) converter).toMessage(payload, session, conversionHint).     }     return converter.toMessage(payload, session). }
false;public;0;13;;@Override public Object getPayload() {     if (this.payload == null) {         try {             this.payload = unwrapPayload().         } catch (JMSException ex) {             throw new MessageConversionException("Failed to extract payload from [" + this.message + "]", ex).         }     }     return this.payload. }
true;private;0;7;/**  * Extract the payload of the current message. Since we deferred the resolution  * of the payload, a custom converter may still return a full message for it. In  * this case, its payload is returned.  * @return the payload of the message  */ ;/**  * Extract the payload of the current message. Since we deferred the resolution  * of the payload, a custom converter may still return a full message for it. In  * this case, its payload is returned.  * @return the payload of the message  */ private Object unwrapPayload() throws JMSException {     Object payload = extractPayload(this.message).     if (payload instanceof org.springframework.messaging.Message) {         return ((org.springframework.messaging.Message) payload).getPayload().     }     return payload. }
false;public;0;7;;@Override public MessageHeaders getHeaders() {     if (this.headers == null) {         this.headers = extractHeaders(this.message).     }     return this.headers. }
