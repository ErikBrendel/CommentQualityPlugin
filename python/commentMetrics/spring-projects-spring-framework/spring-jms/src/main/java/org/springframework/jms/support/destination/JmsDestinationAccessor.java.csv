commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set the {@link DestinationResolver} that is to be used to resolve  * {@link javax.jms.Destination} references for this accessor.  * <p>The default resolver is a DynamicDestinationResolver. Specify a  * JndiDestinationResolver for resolving destination names as JNDI locations.  * @see org.springframework.jms.support.destination.DynamicDestinationResolver  * @see org.springframework.jms.support.destination.JndiDestinationResolver  */ ;/**  * Set the {@link DestinationResolver} that is to be used to resolve  * {@link javax.jms.Destination} references for this accessor.  * <p>The default resolver is a DynamicDestinationResolver. Specify a  * JndiDestinationResolver for resolving destination names as JNDI locations.  * @see org.springframework.jms.support.destination.DynamicDestinationResolver  * @see org.springframework.jms.support.destination.JndiDestinationResolver  */ public void setDestinationResolver(DestinationResolver destinationResolver) {     Assert.notNull(destinationResolver, "'destinationResolver' must not be null").     this.destinationResolver = destinationResolver. }
true;public;0;3;/**  * Return the DestinationResolver for this accessor (never {@code null}).  */ ;/**  * Return the DestinationResolver for this accessor (never {@code null}).  */ public DestinationResolver getDestinationResolver() {     return this.destinationResolver. }
true;public;1;3;/**  * Configure the destination accessor with knowledge of the JMS domain used.  * Default is Point-to-Point (Queues).  * <p>This setting primarily indicates what type of destination to resolve  * if dynamic destinations are enabled.  * @param pubSubDomain "true" for the Publish/Subscribe domain ({@link javax.jms.Topic Topics}),  * "false" for the Point-to-Point domain ({@link javax.jms.Queue Queues})  * @see #setDestinationResolver  */ ;/**  * Configure the destination accessor with knowledge of the JMS domain used.  * Default is Point-to-Point (Queues).  * <p>This setting primarily indicates what type of destination to resolve  * if dynamic destinations are enabled.  * @param pubSubDomain "true" for the Publish/Subscribe domain ({@link javax.jms.Topic Topics}),  * "false" for the Point-to-Point domain ({@link javax.jms.Queue Queues})  * @see #setDestinationResolver  */ public void setPubSubDomain(boolean pubSubDomain) {     this.pubSubDomain = pubSubDomain. }
true;public;0;3;/**  * Return whether the Publish/Subscribe domain ({@link javax.jms.Topic Topics}) is used.  * Otherwise, the Point-to-Point domain ({@link javax.jms.Queue Queues}) is used.  */ ;/**  * Return whether the Publish/Subscribe domain ({@link javax.jms.Topic Topics}) is used.  * Otherwise, the Point-to-Point domain ({@link javax.jms.Queue Queues}) is used.  */ public boolean isPubSubDomain() {     return this.pubSubDomain. }
true;protected;2;3;/**  * Resolve the given destination name into a JMS {@link Destination},  * via this accessor's {@link DestinationResolver}.  * @param session the current JMS {@link Session}  * @param destinationName the name of the destination  * @return the located {@link Destination}  * @throws javax.jms.JMSException if resolution failed  * @see #setDestinationResolver  */ ;/**  * Resolve the given destination name into a JMS {@link Destination},  * via this accessor's {@link DestinationResolver}.  * @param session the current JMS {@link Session}  * @param destinationName the name of the destination  * @return the located {@link Destination}  * @throws javax.jms.JMSException if resolution failed  * @see #setDestinationResolver  */ protected Destination resolveDestinationName(Session session, String destinationName) throws JMSException {     return getDestinationResolver().resolveDestinationName(session, destinationName, isPubSubDomain()). }
true;protected;2;12;/**  * Actually receive a message from the given consumer.  * @param consumer the JMS MessageConsumer to receive with  * @param timeout the receive timeout (a negative value indicates  * a no-wait receive. 0 indicates an indefinite wait attempt)  * @return the JMS Message received, or {@code null} if none  * @throws JMSException if thrown by JMS API methods  * @since 4.3  * @see #RECEIVE_TIMEOUT_NO_WAIT  * @see #RECEIVE_TIMEOUT_INDEFINITE_WAIT  */ ;/**  * Actually receive a message from the given consumer.  * @param consumer the JMS MessageConsumer to receive with  * @param timeout the receive timeout (a negative value indicates  * a no-wait receive. 0 indicates an indefinite wait attempt)  * @return the JMS Message received, or {@code null} if none  * @throws JMSException if thrown by JMS API methods  * @since 4.3  * @see #RECEIVE_TIMEOUT_NO_WAIT  * @see #RECEIVE_TIMEOUT_INDEFINITE_WAIT  */ @Nullable protected Message receiveFromConsumer(MessageConsumer consumer, long timeout) throws JMSException {     if (timeout > 0) {         return consumer.receive(timeout).     } else if (timeout < 0) {         return consumer.receiveNoWait().     } else {         return consumer.receive().     } }
