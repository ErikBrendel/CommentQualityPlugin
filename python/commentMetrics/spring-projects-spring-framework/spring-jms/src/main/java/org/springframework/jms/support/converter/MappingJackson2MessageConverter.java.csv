commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Specify the {@link ObjectMapper} to use instead of using the default.  */ ;/**  * Specify the {@link ObjectMapper} to use instead of using the default.  */ public void setObjectMapper(ObjectMapper objectMapper) {     Assert.notNull(objectMapper, "ObjectMapper must not be null").     this.objectMapper = objectMapper. }
true;public;1;4;/**  * Specify whether {@link #toMessage(Object, Session)} should marshal to a  * {@link BytesMessage} or a {@link TextMessage}.  * <p>The default is {@link MessageType#BYTES}, i.e. this converter marshals to  * a {@link BytesMessage}. Note that the default version of this converter  * supports {@link MessageType#BYTES} and {@link MessageType#TEXT} only.  * @see MessageType#BYTES  * @see MessageType#TEXT  */ ;/**  * Specify whether {@link #toMessage(Object, Session)} should marshal to a  * {@link BytesMessage} or a {@link TextMessage}.  * <p>The default is {@link MessageType#BYTES}, i.e. this converter marshals to  * a {@link BytesMessage}. Note that the default version of this converter  * supports {@link MessageType#BYTES} and {@link MessageType#TEXT} only.  * @see MessageType#BYTES  * @see MessageType#TEXT  */ public void setTargetType(MessageType targetType) {     Assert.notNull(targetType, "MessageType must not be null").     this.targetType = targetType. }
true;public;1;3;/**  * Specify the encoding to use when converting to and from text-based  * message body content. The default encoding will be "UTF-8".  * <p>When reading from a a text-based message, an encoding may have been  * suggested through a special JMS property which will then be preferred  * over the encoding set on this MessageConverter instance.  * @see #setEncodingPropertyName  */ ;/**  * Specify the encoding to use when converting to and from text-based  * message body content. The default encoding will be "UTF-8".  * <p>When reading from a a text-based message, an encoding may have been  * suggested through a special JMS property which will then be preferred  * over the encoding set on this MessageConverter instance.  * @see #setEncodingPropertyName  */ public void setEncoding(String encoding) {     this.encoding = encoding. }
true;public;1;3;/**  * Specify the name of the JMS message property that carries the encoding from  * bytes to String and back is BytesMessage is used during the conversion process.  * <p>Default is none. Setting this property is optional. if not set, UTF-8 will  * be used for decoding any incoming bytes message.  * @see #setEncoding  */ ;/**  * Specify the name of the JMS message property that carries the encoding from  * bytes to String and back is BytesMessage is used during the conversion process.  * <p>Default is none. Setting this property is optional. if not set, UTF-8 will  * be used for decoding any incoming bytes message.  * @see #setEncoding  */ public void setEncodingPropertyName(String encodingPropertyName) {     this.encodingPropertyName = encodingPropertyName. }
true;public;1;3;/**  * Specify the name of the JMS message property that carries the type id for the  * contained object: either a mapped id value or a raw Java class name.  * <p>Default is none. <b>NOTE: This property needs to be set in order to allow  * for converting from an incoming message to a Java object.</b>  * @see #setTypeIdMappings  */ ;/**  * Specify the name of the JMS message property that carries the type id for the  * contained object: either a mapped id value or a raw Java class name.  * <p>Default is none. <b>NOTE: This property needs to be set in order to allow  * for converting from an incoming message to a Java object.</b>  * @see #setTypeIdMappings  */ public void setTypeIdPropertyName(String typeIdPropertyName) {     this.typeIdPropertyName = typeIdPropertyName. }
true;public;1;7;/**  * Specify mappings from type ids to Java classes, if desired.  * This allows for synthetic ids in the type id message property,  * instead of transferring Java class names.  * <p>Default is no custom mappings, i.e. transferring raw Java class names.  * @param typeIdMappings a Map with type id values as keys and Java classes as values  */ ;/**  * Specify mappings from type ids to Java classes, if desired.  * This allows for synthetic ids in the type id message property,  * instead of transferring Java class names.  * <p>Default is no custom mappings, i.e. transferring raw Java class names.  * @param typeIdMappings a Map with type id values as keys and Java classes as values  */ public void setTypeIdMappings(Map<String, Class<?>> typeIdMappings) {     this.idClassMappings = new HashMap<>().     typeIdMappings.forEach((id, clazz) -> {         this.idClassMappings.put(id, clazz).         this.classIdMappings.put(clazz, id).     }). }
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader classLoader) {     this.beanClassLoader = classLoader. }
false;public;2;21;;@Override public Message toMessage(Object object, Session session) throws JMSException, MessageConversionException {     Message message.     try {         switch(this.targetType) {             case TEXT:                 message = mapToTextMessage(object, session, this.objectMapper.writer()).                 break.             case BYTES:                 message = mapToBytesMessage(object, session, this.objectMapper.writer()).                 break.             default:                 message = mapToMessage(object, session, this.objectMapper.writer(), this.targetType).         }     } catch (IOException ex) {         throw new MessageConversionException("Could not map JSON object [" + object + "]", ex).     }     setTypeIdOnMessage(object, message).     return message. }
false;public;3;6;;@Override public Message toMessage(Object object, Session session, @Nullable Object conversionHint) throws JMSException, MessageConversionException {     return toMessage(object, session, getSerializationView(conversionHint)). }
true;public;3;10;/**  * Convert a Java object to a JMS Message using the specified json view  * and the supplied session  to create the message object.  * @param object the object to convert  * @param session the Session to use for creating a JMS Message  * @param jsonView the view to use to filter the content  * @return the JMS Message  * @throws javax.jms.JMSException if thrown by JMS API methods  * @throws MessageConversionException in case of conversion failure  * @since 4.3  */ ;/**  * Convert a Java object to a JMS Message using the specified json view  * and the supplied session  to create the message object.  * @param object the object to convert  * @param session the Session to use for creating a JMS Message  * @param jsonView the view to use to filter the content  * @return the JMS Message  * @throws javax.jms.JMSException if thrown by JMS API methods  * @throws MessageConversionException in case of conversion failure  * @since 4.3  */ public Message toMessage(Object object, Session session, @Nullable Class<?> jsonView) throws JMSException, MessageConversionException {     if (jsonView != null) {         return toMessage(object, session, this.objectMapper.writerWithView(jsonView)).     } else {         return toMessage(object, session, this.objectMapper.writer()).     } }
false;public;1;10;;@Override public Object fromMessage(Message message) throws JMSException, MessageConversionException {     try {         JavaType targetJavaType = getJavaTypeForMessage(message).         return convertToObject(message, targetJavaType).     } catch (IOException ex) {         throw new MessageConversionException("Failed to convert JSON message content", ex).     } }
false;protected;3;22;;protected Message toMessage(Object object, Session session, ObjectWriter objectWriter) throws JMSException, MessageConversionException {     Message message.     try {         switch(this.targetType) {             case TEXT:                 message = mapToTextMessage(object, session, objectWriter).                 break.             case BYTES:                 message = mapToBytesMessage(object, session, objectWriter).                 break.             default:                 message = mapToMessage(object, session, objectWriter, this.targetType).         }     } catch (IOException ex) {         throw new MessageConversionException("Could not map JSON object [" + object + "]", ex).     }     setTypeIdOnMessage(object, message).     return message. }
true;protected;3;7;/**  * Map the given object to a {@link TextMessage}.  * @param object the object to be mapped  * @param session current JMS session  * @param objectWriter the writer to use  * @return the resulting message  * @throws JMSException if thrown by JMS methods  * @throws IOException in case of I/O errors  * @since 4.3  * @see Session#createBytesMessage  */ ;/**  * Map the given object to a {@link TextMessage}.  * @param object the object to be mapped  * @param session current JMS session  * @param objectWriter the writer to use  * @return the resulting message  * @throws JMSException if thrown by JMS methods  * @throws IOException in case of I/O errors  * @since 4.3  * @see Session#createBytesMessage  */ protected TextMessage mapToTextMessage(Object object, Session session, ObjectWriter objectWriter) throws JMSException, IOException {     StringWriter writer = new StringWriter().     objectWriter.writeValue(writer, object).     return session.createTextMessage(writer.toString()). }
true;protected;3;22;/**  * Map the given object to a {@link BytesMessage}.  * @param object the object to be mapped  * @param session current JMS session  * @param objectWriter the writer to use  * @return the resulting message  * @throws JMSException if thrown by JMS methods  * @throws IOException in case of I/O errors  * @since 4.3  * @see Session#createBytesMessage  */ ;/**  * Map the given object to a {@link BytesMessage}.  * @param object the object to be mapped  * @param session current JMS session  * @param objectWriter the writer to use  * @return the resulting message  * @throws JMSException if thrown by JMS methods  * @throws IOException in case of I/O errors  * @since 4.3  * @see Session#createBytesMessage  */ protected BytesMessage mapToBytesMessage(Object object, Session session, ObjectWriter objectWriter) throws JMSException, IOException {     ByteArrayOutputStream bos = new ByteArrayOutputStream(1024).     if (this.encoding != null) {         OutputStreamWriter writer = new OutputStreamWriter(bos, this.encoding).         objectWriter.writeValue(writer, object).     } else {         // Jackson usually defaults to UTF-8 but can also go straight to bytes, e.g. for Smile.         // We use a direct byte array argument for the latter case to work as well.         objectWriter.writeValue(bos, object).     }     BytesMessage message = session.createBytesMessage().     message.writeBytes(bos.toByteArray()).     if (this.encodingPropertyName != null) {         message.setStringProperty(this.encodingPropertyName, (this.encoding != null ? this.encoding : DEFAULT_ENCODING)).     }     return message. }
true;protected;4;6;/**  * Template method that allows for custom message mapping.  * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or  * {@link MessageType#BYTES}.  * <p>The default implementation throws an {@link IllegalArgumentException}.  * @param object the object to marshal  * @param session the JMS Session  * @param objectWriter the writer to use  * @param targetType the target message type (other than TEXT or BYTES)  * @return the resulting message  * @throws JMSException if thrown by JMS methods  * @throws IOException in case of I/O errors  */ ;/**  * Template method that allows for custom message mapping.  * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or  * {@link MessageType#BYTES}.  * <p>The default implementation throws an {@link IllegalArgumentException}.  * @param object the object to marshal  * @param session the JMS Session  * @param objectWriter the writer to use  * @param targetType the target message type (other than TEXT or BYTES)  * @return the resulting message  * @throws JMSException if thrown by JMS methods  * @throws IOException in case of I/O errors  */ protected Message mapToMessage(Object object, Session session, ObjectWriter objectWriter, MessageType targetType) throws JMSException, IOException {     throw new IllegalArgumentException("Unsupported message type [" + targetType + "]. MappingJackson2MessageConverter by default only supports TextMessages and BytesMessages."). }
true;protected;2;9;/**  * Set a type id for the given payload object on the given JMS Message.  * <p>The default implementation consults the configured type id mapping and  * sets the resulting value (either a mapped id or the raw Java class name)  * into the configured type id message property.  * @param object the payload object to set a type id for  * @param message the JMS Message to set the type id on  * @throws JMSException if thrown by JMS methods  * @see #getJavaTypeForMessage(javax.jms.Message)  * @see #setTypeIdPropertyName(String)  * @see #setTypeIdMappings(java.util.Map)  */ ;/**  * Set a type id for the given payload object on the given JMS Message.  * <p>The default implementation consults the configured type id mapping and  * sets the resulting value (either a mapped id or the raw Java class name)  * into the configured type id message property.  * @param object the payload object to set a type id for  * @param message the JMS Message to set the type id on  * @throws JMSException if thrown by JMS methods  * @see #getJavaTypeForMessage(javax.jms.Message)  * @see #setTypeIdPropertyName(String)  * @see #setTypeIdMappings(java.util.Map)  */ protected void setTypeIdOnMessage(Object object, Message message) throws JMSException {     if (this.typeIdPropertyName != null) {         String typeId = this.classIdMappings.get(object.getClass()).         if (typeId == null) {             typeId = object.getClass().getName().         }         message.setStringProperty(this.typeIdPropertyName, typeId).     } }
true;private;2;11;/**  * Convenience method to dispatch to converters for individual message types.  */ ;/**  * Convenience method to dispatch to converters for individual message types.  */ private Object convertToObject(Message message, JavaType targetJavaType) throws JMSException, IOException {     if (message instanceof TextMessage) {         return convertFromTextMessage((TextMessage) message, targetJavaType).     } else if (message instanceof BytesMessage) {         return convertFromBytesMessage((BytesMessage) message, targetJavaType).     } else {         return convertFromMessage(message, targetJavaType).     } }
true;protected;2;6;/**  * Convert a TextMessage to a Java Object with the specified type.  * @param message the input message  * @param targetJavaType the target type  * @return the message converted to an object  * @throws JMSException if thrown by JMS  * @throws IOException in case of I/O errors  */ ;/**  * Convert a TextMessage to a Java Object with the specified type.  * @param message the input message  * @param targetJavaType the target type  * @return the message converted to an object  * @throws JMSException if thrown by JMS  * @throws IOException in case of I/O errors  */ protected Object convertFromTextMessage(TextMessage message, JavaType targetJavaType) throws JMSException, IOException {     String body = message.getText().     return this.objectMapper.readValue(body, targetJavaType). }
true;protected;2;23;/**  * Convert a BytesMessage to a Java Object with the specified type.  * @param message the input message  * @param targetJavaType the target type  * @return the message converted to an object  * @throws JMSException if thrown by JMS  * @throws IOException in case of I/O errors  */ ;/**  * Convert a BytesMessage to a Java Object with the specified type.  * @param message the input message  * @param targetJavaType the target type  * @return the message converted to an object  * @throws JMSException if thrown by JMS  * @throws IOException in case of I/O errors  */ protected Object convertFromBytesMessage(BytesMessage message, JavaType targetJavaType) throws JMSException, IOException {     String encoding = this.encoding.     if (this.encodingPropertyName != null && message.propertyExists(this.encodingPropertyName)) {         encoding = message.getStringProperty(this.encodingPropertyName).     }     byte[] bytes = new byte[(int) message.getBodyLength()].     message.readBytes(bytes).     if (encoding != null) {         try {             String body = new String(bytes, encoding).             return this.objectMapper.readValue(body, targetJavaType).         } catch (UnsupportedEncodingException ex) {             throw new MessageConversionException("Cannot convert bytes to String", ex).         }     } else {         // Jackson internally performs encoding detection, falling back to UTF-8.         return this.objectMapper.readValue(bytes, targetJavaType).     } }
true;protected;2;6;/**  * Template method that allows for custom message mapping.  * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or  * {@link MessageType#BYTES}.  * <p>The default implementation throws an {@link IllegalArgumentException}.  * @param message the input message  * @param targetJavaType the target type  * @return the message converted to an object  * @throws JMSException if thrown by JMS  * @throws IOException in case of I/O errors  */ ;/**  * Template method that allows for custom message mapping.  * Invoked when {@link #setTargetType} is not {@link MessageType#TEXT} or  * {@link MessageType#BYTES}.  * <p>The default implementation throws an {@link IllegalArgumentException}.  * @param message the input message  * @param targetJavaType the target type  * @return the message converted to an object  * @throws JMSException if thrown by JMS  * @throws IOException in case of I/O errors  */ protected Object convertFromMessage(Message message, JavaType targetJavaType) throws JMSException, IOException {     throw new IllegalArgumentException("Unsupported message type [" + message.getClass() + "]. MappingJacksonMessageConverter by default only supports TextMessages and BytesMessages."). }
true;protected;1;19;/**  * Determine a Jackson JavaType for the given JMS Message,  * typically parsing a type id message property.  * <p>The default implementation parses the configured type id property name  * and consults the configured type id mapping. This can be overridden with  * a different strategy, e.g. doing some heuristics based on message origin.  * @param message the JMS Message to set the type id on  * @throws JMSException if thrown by JMS methods  * @see #setTypeIdOnMessage(Object, javax.jms.Message)  * @see #setTypeIdPropertyName(String)  * @see #setTypeIdMappings(java.util.Map)  */ ;/**  * Determine a Jackson JavaType for the given JMS Message,  * typically parsing a type id message property.  * <p>The default implementation parses the configured type id property name  * and consults the configured type id mapping. This can be overridden with  * a different strategy, e.g. doing some heuristics based on message origin.  * @param message the JMS Message to set the type id on  * @throws JMSException if thrown by JMS methods  * @see #setTypeIdOnMessage(Object, javax.jms.Message)  * @see #setTypeIdPropertyName(String)  * @see #setTypeIdMappings(java.util.Map)  */ protected JavaType getJavaTypeForMessage(Message message) throws JMSException {     String typeId = message.getStringProperty(this.typeIdPropertyName).     if (typeId == null) {         throw new MessageConversionException("Could not find type id property [" + this.typeIdPropertyName + "] on message [" + message.getJMSMessageID() + "] from destination [" + message.getJMSDestination() + "]").     }     Class<?> mappedClass = this.idClassMappings.get(typeId).     if (mappedClass != null) {         return this.objectMapper.getTypeFactory().constructType(mappedClass).     }     try {         Class<?> typeClass = ClassUtils.forName(typeId, this.beanClassLoader).         return this.objectMapper.getTypeFactory().constructType(typeClass).     } catch (Throwable ex) {         throw new MessageConversionException("Failed to resolve type id [" + typeId + "]", ex).     } }
true;protected;1;23;/**  * Determine a Jackson serialization view based on the given conversion hint.  * @param conversionHint the conversion hint Object as passed into the  * converter for the current conversion attempt  * @return the serialization view class, or {@code null} if none  */ ;/**  * Determine a Jackson serialization view based on the given conversion hint.  * @param conversionHint the conversion hint Object as passed into the  * converter for the current conversion attempt  * @return the serialization view class, or {@code null} if none  */ @Nullable protected Class<?> getSerializationView(@Nullable Object conversionHint) {     if (conversionHint instanceof MethodParameter) {         MethodParameter methodParam = (MethodParameter) conversionHint.         JsonView annotation = methodParam.getParameterAnnotation(JsonView.class).         if (annotation == null) {             annotation = methodParam.getMethodAnnotation(JsonView.class).             if (annotation == null) {                 return null.             }         }         return extractViewClass(annotation, conversionHint).     } else if (conversionHint instanceof JsonView) {         return extractViewClass((JsonView) conversionHint, conversionHint).     } else if (conversionHint instanceof Class) {         return (Class<?>) conversionHint.     } else {         return null.     } }
false;private;2;8;;private Class<?> extractViewClass(JsonView annotation, Object conversionHint) {     Class<?>[] classes = annotation.value().     if (classes.length != 1) {         throw new IllegalArgumentException("@JsonView only supported for handler methods with exactly 1 class argument: " + conversionHint).     }     return classes[0]. }
