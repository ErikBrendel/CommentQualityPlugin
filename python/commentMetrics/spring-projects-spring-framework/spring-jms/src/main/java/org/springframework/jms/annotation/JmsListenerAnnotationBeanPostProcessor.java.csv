commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int getOrder() {     return LOWEST_PRECEDENCE. }
true;public;1;3;/**  * Set the name of the {@link JmsListenerContainerFactory} to use by default.  * <p>If none is specified, "jmsListenerContainerFactory" is assumed to be defined.  */ ;/**  * Set the name of the {@link JmsListenerContainerFactory} to use by default.  * <p>If none is specified, "jmsListenerContainerFactory" is assumed to be defined.  */ public void setContainerFactoryBeanName(String containerFactoryBeanName) {     this.containerFactoryBeanName = containerFactoryBeanName. }
true;public;1;3;/**  * Set the {@link JmsListenerEndpointRegistry} that will hold the created  * endpoint and manage the lifecycle of the related listener container.  */ ;/**  * Set the {@link JmsListenerEndpointRegistry} that will hold the created  * endpoint and manage the lifecycle of the related listener container.  */ public void setEndpointRegistry(JmsListenerEndpointRegistry endpointRegistry) {     this.endpointRegistry = endpointRegistry. }
true;public;1;3;/**  * Set the {@link MessageHandlerMethodFactory} to use to configure the message  * listener responsible to serve an endpoint detected by this processor.  * <p>By default, {@link DefaultMessageHandlerMethodFactory} is used and it  * can be configured further to support additional method arguments  * or to customize conversion and validation support. See  * {@link DefaultMessageHandlerMethodFactory} Javadoc for more details.  */ ;/**  * Set the {@link MessageHandlerMethodFactory} to use to configure the message  * listener responsible to serve an endpoint detected by this processor.  * <p>By default, {@link DefaultMessageHandlerMethodFactory} is used and it  * can be configured further to support additional method arguments  * or to customize conversion and validation support. See  * {@link DefaultMessageHandlerMethodFactory} Javadoc for more details.  */ public void setMessageHandlerMethodFactory(MessageHandlerMethodFactory messageHandlerMethodFactory) {     this.messageHandlerMethodFactory.setMessageHandlerMethodFactory(messageHandlerMethodFactory). }
true;public;1;8;/**  * Making a {@link BeanFactory} available is optional. if not set,  * {@link JmsListenerConfigurer} beans won't get autodetected and an  * {@link #setEndpointRegistry endpoint registry} has to be explicitly configured.  */ ;/**  * Making a {@link BeanFactory} available is optional. if not set,  * {@link JmsListenerConfigurer} beans won't get autodetected and an  * {@link #setEndpointRegistry endpoint registry} has to be explicitly configured.  */ @Override public void setBeanFactory(BeanFactory beanFactory) {     this.beanFactory = beanFactory.     if (beanFactory instanceof ConfigurableBeanFactory) {         this.embeddedValueResolver = new EmbeddedValueResolver((ConfigurableBeanFactory) beanFactory).     }     this.registrar.setBeanFactory(beanFactory). }
false;public;0;40;;@Override public void afterSingletonsInstantiated() {     // Remove resolved singleton classes from cache     this.nonAnnotatedClasses.clear().     if (this.beanFactory instanceof ListableBeanFactory) {         // Apply JmsListenerConfigurer beans from the BeanFactory, if any         Map<String, JmsListenerConfigurer> beans = ((ListableBeanFactory) this.beanFactory).getBeansOfType(JmsListenerConfigurer.class).         List<JmsListenerConfigurer> configurers = new ArrayList<>(beans.values()).         AnnotationAwareOrderComparator.sort(configurers).         for (JmsListenerConfigurer configurer : configurers) {             configurer.configureJmsListeners(this.registrar).         }     }     if (this.containerFactoryBeanName != null) {         this.registrar.setContainerFactoryBeanName(this.containerFactoryBeanName).     }     if (this.registrar.getEndpointRegistry() == null) {         // Determine JmsListenerEndpointRegistry bean from the BeanFactory         if (this.endpointRegistry == null) {             Assert.state(this.beanFactory != null, "BeanFactory must be set to find endpoint registry by bean name").             this.endpointRegistry = this.beanFactory.getBean(JmsListenerConfigUtils.JMS_LISTENER_ENDPOINT_REGISTRY_BEAN_NAME, JmsListenerEndpointRegistry.class).         }         this.registrar.setEndpointRegistry(this.endpointRegistry).     }     // Set the custom handler method factory once resolved by the configurer     MessageHandlerMethodFactory handlerMethodFactory = this.registrar.getMessageHandlerMethodFactory().     if (handlerMethodFactory != null) {         this.messageHandlerMethodFactory.setMessageHandlerMethodFactory(handlerMethodFactory).     }     // Actually register all listeners     this.registrar.afterPropertiesSet(). }
false;public;3;3;;@Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class<?> beanType, String beanName) { }
false;public;2;4;;@Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {     return bean. }
false;public;2;34;;@Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {     if (bean instanceof AopInfrastructureBean || bean instanceof JmsListenerContainerFactory || bean instanceof JmsListenerEndpointRegistry) {         // Ignore AOP infrastructure such as scoped proxies.         return bean.     }     Class<?> targetClass = AopProxyUtils.ultimateTargetClass(bean).     if (!this.nonAnnotatedClasses.contains(targetClass)) {         Map<Method, Set<JmsListener>> annotatedMethods = MethodIntrospector.selectMethods(targetClass, (MethodIntrospector.MetadataLookup<Set<JmsListener>>) method -> {             Set<JmsListener> listenerMethods = AnnotatedElementUtils.getMergedRepeatableAnnotations(method, JmsListener.class, JmsListeners.class).             return (!listenerMethods.isEmpty() ? listenerMethods : null).         }).         if (annotatedMethods.isEmpty()) {             this.nonAnnotatedClasses.add(targetClass).             if (logger.isTraceEnabled()) {                 logger.trace("No @JmsListener annotations found on bean type: " + targetClass).             }         } else {             // Non-empty set of methods             annotatedMethods.forEach((method, listeners) -> listeners.forEach(listener -> processJmsListener(listener, method, bean))).             if (logger.isDebugEnabled()) {                 logger.debug(annotatedMethods.size() + " @JmsListener methods processed on bean '" + beanName + "': " + annotatedMethods).             }         }     }     return bean. }
true;protected;3;38;/**  * Process the given {@link JmsListener} annotation on the given method,  * registering a corresponding endpoint for the given bean instance.  * @param jmsListener the annotation to process  * @param mostSpecificMethod the annotated method  * @param bean the instance to invoke the method on  * @see #createMethodJmsListenerEndpoint()  * @see JmsListenerEndpointRegistrar#registerEndpoint  */ ;/**  * Process the given {@link JmsListener} annotation on the given method,  * registering a corresponding endpoint for the given bean instance.  * @param jmsListener the annotation to process  * @param mostSpecificMethod the annotated method  * @param bean the instance to invoke the method on  * @see #createMethodJmsListenerEndpoint()  * @see JmsListenerEndpointRegistrar#registerEndpoint  */ protected void processJmsListener(JmsListener jmsListener, Method mostSpecificMethod, Object bean) {     Method invocableMethod = AopUtils.selectInvocableMethod(mostSpecificMethod, bean.getClass()).     MethodJmsListenerEndpoint endpoint = createMethodJmsListenerEndpoint().     endpoint.setBean(bean).     endpoint.setMethod(invocableMethod).     endpoint.setMostSpecificMethod(mostSpecificMethod).     endpoint.setMessageHandlerMethodFactory(this.messageHandlerMethodFactory).     endpoint.setEmbeddedValueResolver(this.embeddedValueResolver).     endpoint.setBeanFactory(this.beanFactory).     endpoint.setId(getEndpointId(jmsListener)).     endpoint.setDestination(resolve(jmsListener.destination())).     if (StringUtils.hasText(jmsListener.selector())) {         endpoint.setSelector(resolve(jmsListener.selector())).     }     if (StringUtils.hasText(jmsListener.subscription())) {         endpoint.setSubscription(resolve(jmsListener.subscription())).     }     if (StringUtils.hasText(jmsListener.concurrency())) {         endpoint.setConcurrency(resolve(jmsListener.concurrency())).     }     JmsListenerContainerFactory<?> factory = null.     String containerFactoryBeanName = resolve(jmsListener.containerFactory()).     if (StringUtils.hasText(containerFactoryBeanName)) {         Assert.state(this.beanFactory != null, "BeanFactory must be set to obtain container factory by bean name").         try {             factory = this.beanFactory.getBean(containerFactoryBeanName, JmsListenerContainerFactory.class).         } catch (NoSuchBeanDefinitionException ex) {             throw new BeanInitializationException("Could not register JMS listener endpoint on [" + mostSpecificMethod + "], no " + JmsListenerContainerFactory.class.getSimpleName() + " with id '" + containerFactoryBeanName + "' was found in the application context", ex).         }     }     this.registrar.registerEndpoint(endpoint, factory). }
true;protected;0;3;/**  * Instantiate an empty {@link MethodJmsListenerEndpoint} for further  * configuration with provided parameters in {@link #processJmsListener}.  * @return a new {@code MethodJmsListenerEndpoint} or subclass thereof  * @since 4.1.9  * @see MethodJmsListenerEndpoint#createMessageListenerInstance()  */ ;/**  * Instantiate an empty {@link MethodJmsListenerEndpoint} for further  * configuration with provided parameters in {@link #processJmsListener}.  * @return a new {@code MethodJmsListenerEndpoint} or subclass thereof  * @since 4.1.9  * @see MethodJmsListenerEndpoint#createMessageListenerInstance()  */ protected MethodJmsListenerEndpoint createMethodJmsListenerEndpoint() {     return new MethodJmsListenerEndpoint(). }
false;private;1;9;;private String getEndpointId(JmsListener jmsListener) {     if (StringUtils.hasText(jmsListener.id())) {         String id = resolve(jmsListener.id()).         return (id != null ? id : "").     } else {         return "org.springframework.jms.JmsListenerEndpointContainer#" + this.counter.getAndIncrement().     } }
false;private;1;4;;@Nullable private String resolve(String value) {     return (this.embeddedValueResolver != null ? this.embeddedValueResolver.resolveStringValue(value) : value). }
false;public;1;3;;public void setMessageHandlerMethodFactory(MessageHandlerMethodFactory messageHandlerMethodFactory) {     this.messageHandlerMethodFactory = messageHandlerMethodFactory. }
false;public;2;4;;@Override public InvocableHandlerMethod createInvocableHandlerMethod(Object bean, Method method) {     return getMessageHandlerMethodFactory().createInvocableHandlerMethod(bean, method). }
false;private;0;6;;private MessageHandlerMethodFactory getMessageHandlerMethodFactory() {     if (this.messageHandlerMethodFactory == null) {         this.messageHandlerMethodFactory = createDefaultJmsHandlerMethodFactory().     }     return this.messageHandlerMethodFactory. }
false;private;0;8;;private MessageHandlerMethodFactory createDefaultJmsHandlerMethodFactory() {     DefaultMessageHandlerMethodFactory defaultFactory = new DefaultMessageHandlerMethodFactory().     if (beanFactory != null) {         defaultFactory.setBeanFactory(beanFactory).     }     defaultFactory.afterPropertiesSet().     return defaultFactory. }
