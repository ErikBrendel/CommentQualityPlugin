commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the QueueConnectionFactory to use for obtaining JMS QueueConnections.  */ ;/**  * Set the QueueConnectionFactory to use for obtaining JMS QueueConnections.  */ public void setConnectionFactory(@Nullable ConnectionFactory connectionFactory) {     this.connectionFactory = connectionFactory. }
true;protected;0;4;/**  * Return the QueueConnectionFactory to use for obtaining JMS QueueConnections.  */ ;/**  * Return the QueueConnectionFactory to use for obtaining JMS QueueConnections.  */ @Nullable protected ConnectionFactory getConnectionFactory() {     return this.connectionFactory. }
true;public;1;3;/**  * Set the target Queue to send invoker requests to.  */ ;/**  * Set the target Queue to send invoker requests to.  */ public void setQueue(Queue queue) {     this.queue = queue. }
true;public;1;3;/**  * Set the name of target queue to send invoker requests to.  * <p>The specified name will be dynamically resolved via the  * {@link #setDestinationResolver DestinationResolver}.  */ ;/**  * Set the name of target queue to send invoker requests to.  * <p>The specified name will be dynamically resolved via the  * {@link #setDestinationResolver DestinationResolver}.  */ public void setQueueName(String queueName) {     this.queue = queueName. }
true;public;1;4;/**  * Set the DestinationResolver that is to be used to resolve Queue  * references for this accessor.  * <p>The default resolver is a {@code DynamicDestinationResolver}. Specify a  * {@code JndiDestinationResolver} for resolving destination names as JNDI locations.  * @see org.springframework.jms.support.destination.DynamicDestinationResolver  * @see org.springframework.jms.support.destination.JndiDestinationResolver  */ ;/**  * Set the DestinationResolver that is to be used to resolve Queue  * references for this accessor.  * <p>The default resolver is a {@code DynamicDestinationResolver}. Specify a  * {@code JndiDestinationResolver} for resolving destination names as JNDI locations.  * @see org.springframework.jms.support.destination.DynamicDestinationResolver  * @see org.springframework.jms.support.destination.JndiDestinationResolver  */ public void setDestinationResolver(@Nullable DestinationResolver destinationResolver) {     this.destinationResolver = (destinationResolver != null ? destinationResolver : new DynamicDestinationResolver()). }
true;public;1;4;/**  * Set the {@link RemoteInvocationFactory} to use for this accessor.  * <p>Default is a {@link DefaultRemoteInvocationFactory}.  * <p>A custom invocation factory can add further context information  * to the invocation, for example user credentials.  */ ;/**  * Set the {@link RemoteInvocationFactory} to use for this accessor.  * <p>Default is a {@link DefaultRemoteInvocationFactory}.  * <p>A custom invocation factory can add further context information  * to the invocation, for example user credentials.  */ public void setRemoteInvocationFactory(@Nullable RemoteInvocationFactory remoteInvocationFactory) {     this.remoteInvocationFactory = (remoteInvocationFactory != null ? remoteInvocationFactory : new DefaultRemoteInvocationFactory()). }
true;public;1;3;/**  * Specify the {@link MessageConverter} to use for turning  * {@link org.springframework.remoting.support.RemoteInvocation}  * objects into request messages, as well as response messages into  * {@link org.springframework.remoting.support.RemoteInvocationResult} objects.  * <p>Default is a {@link SimpleMessageConverter}, using a standard JMS  * {@link javax.jms.ObjectMessage} for each invocation / invocation result  * object.  * <p>Custom implementations may generally adapt {@link java.io.Serializable}  * objects into special kinds of messages, or might be specifically tailored for  * translating {@code RemoteInvocation(Result)s} into specific kinds of messages.  */ ;/**  * Specify the {@link MessageConverter} to use for turning  * {@link org.springframework.remoting.support.RemoteInvocation}  * objects into request messages, as well as response messages into  * {@link org.springframework.remoting.support.RemoteInvocationResult} objects.  * <p>Default is a {@link SimpleMessageConverter}, using a standard JMS  * {@link javax.jms.ObjectMessage} for each invocation / invocation result  * object.  * <p>Custom implementations may generally adapt {@link java.io.Serializable}  * objects into special kinds of messages, or might be specifically tailored for  * translating {@code RemoteInvocation(Result)s} into specific kinds of messages.  */ public void setMessageConverter(@Nullable MessageConverter messageConverter) {     this.messageConverter = (messageConverter != null ? messageConverter : new SimpleMessageConverter()). }
true;public;1;3;/**  * Set the timeout to use for receiving the response message for a request  * (in milliseconds).  * <p>The default is 0, which indicates a blocking receive without timeout.  * @see javax.jms.MessageConsumer#receive(long)  * @see javax.jms.MessageConsumer#receive()  */ ;/**  * Set the timeout to use for receiving the response message for a request  * (in milliseconds).  * <p>The default is 0, which indicates a blocking receive without timeout.  * @see javax.jms.MessageConsumer#receive(long)  * @see javax.jms.MessageConsumer#receive()  */ public void setReceiveTimeout(long receiveTimeout) {     this.receiveTimeout = receiveTimeout. }
true;protected;0;3;/**  * Return the timeout to use for receiving the response message for a request  * (in milliseconds).  */ ;/**  * Return the timeout to use for receiving the response message for a request  * (in milliseconds).  */ protected long getReceiveTimeout() {     return this.receiveTimeout. }
false;public;0;9;;@Override public void afterPropertiesSet() {     if (getConnectionFactory() == null) {         throw new IllegalArgumentException("Property 'connectionFactory' is required").     }     if (this.queue == null) {         throw new IllegalArgumentException("'queue' or 'queueName' is required").     } }
false;public;1;28;;@Override @Nullable public Object invoke(MethodInvocation methodInvocation) throws Throwable {     if (AopUtils.isToStringMethod(methodInvocation.getMethod())) {         return "JMS invoker proxy for queue [" + this.queue + "]".     }     RemoteInvocation invocation = createRemoteInvocation(methodInvocation).     RemoteInvocationResult result.     try {         result = executeRequest(invocation).     } catch (JMSException ex) {         throw convertJmsInvokerAccessException(ex).     }     try {         return recreateRemoteInvocationResult(result).     } catch (Throwable ex) {         if (result.hasInvocationTargetException()) {             throw ex.         } else {             throw new RemoteInvocationFailureException("Invocation of method [" + methodInvocation.getMethod() + "] failed in JMS invoker remote service at queue [" + this.queue + "]", ex).         }     } }
true;protected;1;3;/**  * Create a new {@code RemoteInvocation} object for the given AOP method invocation.  * <p>The default implementation delegates to the {@link RemoteInvocationFactory}.  * <p>Can be overridden in subclasses to provide custom {@code RemoteInvocation}  * subclasses, containing additional invocation parameters like user credentials.  * Note that it is preferable to use a custom {@code RemoteInvocationFactory} which  * is a reusable strategy.  * @param methodInvocation the current AOP method invocation  * @return the RemoteInvocation object  * @see RemoteInvocationFactory#createRemoteInvocation  */ ;/**  * Create a new {@code RemoteInvocation} object for the given AOP method invocation.  * <p>The default implementation delegates to the {@link RemoteInvocationFactory}.  * <p>Can be overridden in subclasses to provide custom {@code RemoteInvocation}  * subclasses, containing additional invocation parameters like user credentials.  * Note that it is preferable to use a custom {@code RemoteInvocationFactory} which  * is a reusable strategy.  * @param methodInvocation the current AOP method invocation  * @return the RemoteInvocation object  * @see RemoteInvocationFactory#createRemoteInvocation  */ protected RemoteInvocation createRemoteInvocation(MethodInvocation methodInvocation) {     return this.remoteInvocationFactory.createRemoteInvocation(methodInvocation). }
true;protected;1;21;/**  * Execute the given remote invocation, sending an invoker request message  * to this accessor's target queue and waiting for a corresponding response.  * @param invocation the RemoteInvocation to execute  * @return the RemoteInvocationResult object  * @throws JMSException in case of JMS failure  * @see #doExecuteRequest  */ ;/**  * Execute the given remote invocation, sending an invoker request message  * to this accessor's target queue and waiting for a corresponding response.  * @param invocation the RemoteInvocation to execute  * @return the RemoteInvocationResult object  * @throws JMSException in case of JMS failure  * @see #doExecuteRequest  */ protected RemoteInvocationResult executeRequest(RemoteInvocation invocation) throws JMSException {     Connection con = createConnection().     Session session = null.     try {         session = createSession(con).         Queue queueToUse = resolveQueue(session).         Message requestMessage = createRequestMessage(session, invocation).         con.start().         Message responseMessage = doExecuteRequest(session, queueToUse, requestMessage).         if (responseMessage != null) {             return extractInvocationResult(responseMessage).         } else {             return onReceiveTimeout(invocation).         }     } finally {         JmsUtils.closeSession(session).         ConnectionFactoryUtils.releaseConnection(con, getConnectionFactory(), true).     } }
true;protected;0;5;/**  * Create a new JMS Connection for this JMS invoker.  */ ;/**  * Create a new JMS Connection for this JMS invoker.  */ protected Connection createConnection() throws JMSException {     ConnectionFactory connectionFactory = getConnectionFactory().     Assert.state(connectionFactory != null, "No ConnectionFactory set").     return connectionFactory.createConnection(). }
true;protected;1;3;/**  * Create a new JMS Session for this JMS invoker.  */ ;/**  * Create a new JMS Session for this JMS invoker.  */ protected Session createSession(Connection con) throws JMSException {     return con.createSession(false, Session.AUTO_ACKNOWLEDGE). }
true;protected;1;12;/**  * Resolve this accessor's target queue.  * @param session the current JMS Session  * @return the resolved target Queue  * @throws JMSException if resolution failed  */ ;/**  * Resolve this accessor's target queue.  * @param session the current JMS Session  * @return the resolved target Queue  * @throws JMSException if resolution failed  */ protected Queue resolveQueue(Session session) throws JMSException {     if (this.queue instanceof Queue) {         return (Queue) this.queue.     } else if (this.queue instanceof String) {         return resolveQueueName(session, (String) this.queue).     } else {         throw new javax.jms.IllegalStateException("Queue object [" + this.queue + "] is neither a [javax.jms.Queue] nor a queue name String").     } }
true;protected;2;3;/**  * Resolve the given queue name into a JMS {@link javax.jms.Queue},  * via this accessor's {@link DestinationResolver}.  * @param session the current JMS Session  * @param queueName the name of the queue  * @return the located Queue  * @throws JMSException if resolution failed  * @see #setDestinationResolver  */ ;/**  * Resolve the given queue name into a JMS {@link javax.jms.Queue},  * via this accessor's {@link DestinationResolver}.  * @param session the current JMS Session  * @param queueName the name of the queue  * @return the located Queue  * @throws JMSException if resolution failed  * @see #setDestinationResolver  */ protected Queue resolveQueueName(Session session, String queueName) throws JMSException {     return (Queue) this.destinationResolver.resolveDestinationName(session, queueName, false). }
true;protected;2;3;/**  * Create the invoker request message.  * <p>The default implementation creates a JMS {@link javax.jms.ObjectMessage}  * for the given RemoteInvocation object.  * @param session the current JMS Session  * @param invocation the remote invocation to send  * @return the JMS Message to send  * @throws JMSException if the message could not be created  */ ;/**  * Create the invoker request message.  * <p>The default implementation creates a JMS {@link javax.jms.ObjectMessage}  * for the given RemoteInvocation object.  * @param session the current JMS Session  * @param invocation the remote invocation to send  * @return the JMS Message to send  * @throws JMSException if the message could not be created  */ protected Message createRequestMessage(Session session, RemoteInvocation invocation) throws JMSException {     return this.messageConverter.toMessage(invocation, session). }
true;protected;3;22;/**  * Actually execute the given request, sending the invoker request message  * to the specified target queue and waiting for a corresponding response.  * <p>The default implementation is based on standard JMS send/receive,  * using a {@link javax.jms.TemporaryQueue} for receiving the response.  * @param session the JMS Session to use  * @param queue the resolved target Queue to send to  * @param requestMessage the JMS Message to send  * @return the RemoteInvocationResult object  * @throws JMSException in case of JMS failure  */ ;/**  * Actually execute the given request, sending the invoker request message  * to the specified target queue and waiting for a corresponding response.  * <p>The default implementation is based on standard JMS send/receive,  * using a {@link javax.jms.TemporaryQueue} for receiving the response.  * @param session the JMS Session to use  * @param queue the resolved target Queue to send to  * @param requestMessage the JMS Message to send  * @return the RemoteInvocationResult object  * @throws JMSException in case of JMS failure  */ @Nullable protected Message doExecuteRequest(Session session, Queue queue, Message requestMessage) throws JMSException {     TemporaryQueue responseQueue = null.     MessageProducer producer = null.     MessageConsumer consumer = null.     try {         responseQueue = session.createTemporaryQueue().         producer = session.createProducer(queue).         consumer = session.createConsumer(responseQueue).         requestMessage.setJMSReplyTo(responseQueue).         producer.send(requestMessage).         long timeout = getReceiveTimeout().         return (timeout > 0 ? consumer.receive(timeout) : consumer.receive()).     } finally {         JmsUtils.closeMessageConsumer(consumer).         JmsUtils.closeMessageProducer(producer).         if (responseQueue != null) {             responseQueue.delete().         }     } }
true;protected;1;7;/**  * Extract the invocation result from the response message.  * <p>The default implementation expects a JMS {@link javax.jms.ObjectMessage}  * carrying a {@link RemoteInvocationResult} object. If an invalid response  * message is encountered, the {@code onInvalidResponse} callback gets invoked.  * @param responseMessage the response message  * @return the invocation result  * @throws JMSException is thrown if a JMS exception occurs  * @see #onInvalidResponse  */ ;/**  * Extract the invocation result from the response message.  * <p>The default implementation expects a JMS {@link javax.jms.ObjectMessage}  * carrying a {@link RemoteInvocationResult} object. If an invalid response  * message is encountered, the {@code onInvalidResponse} callback gets invoked.  * @param responseMessage the response message  * @return the invocation result  * @throws JMSException is thrown if a JMS exception occurs  * @see #onInvalidResponse  */ protected RemoteInvocationResult extractInvocationResult(Message responseMessage) throws JMSException {     Object content = this.messageConverter.fromMessage(responseMessage).     if (content instanceof RemoteInvocationResult) {         return (RemoteInvocationResult) content.     }     return onInvalidResponse(responseMessage). }
true;protected;1;3;/**  * Callback that is invoked by {@link #executeRequest} when the receive  * timeout has expired for the specified {@link RemoteInvocation}.  * <p>By default, an {@link RemoteTimeoutException} is thrown. Sub-classes  * can choose to either throw a more dedicated exception or even return  * a default {@link RemoteInvocationResult} as a fallback.  * @param invocation the invocation  * @return a default result when the receive timeout has expired  */ ;/**  * Callback that is invoked by {@link #executeRequest} when the receive  * timeout has expired for the specified {@link RemoteInvocation}.  * <p>By default, an {@link RemoteTimeoutException} is thrown. Sub-classes  * can choose to either throw a more dedicated exception or even return  * a default {@link RemoteInvocationResult} as a fallback.  * @param invocation the invocation  * @return a default result when the receive timeout has expired  */ protected RemoteInvocationResult onReceiveTimeout(RemoteInvocation invocation) {     throw new RemoteTimeoutException("Receive timeout after " + this.receiveTimeout + " ms for " + invocation). }
true;protected;1;3;/**  * Callback that is invoked by {@link #extractInvocationResult} when  * it encounters an invalid response message.  * <p>The default implementation throws a {@link MessageFormatException}.  * @param responseMessage the invalid response message  * @return an alternative invocation result that should be returned to  * the caller (if desired)  * @throws JMSException if the invalid response should lead to an  * infrastructure exception propagated to the caller  * @see #extractInvocationResult  */ ;/**  * Callback that is invoked by {@link #extractInvocationResult} when  * it encounters an invalid response message.  * <p>The default implementation throws a {@link MessageFormatException}.  * @param responseMessage the invalid response message  * @return an alternative invocation result that should be returned to  * the caller (if desired)  * @throws JMSException if the invalid response should lead to an  * infrastructure exception propagated to the caller  * @see #extractInvocationResult  */ protected RemoteInvocationResult onInvalidResponse(Message responseMessage) throws JMSException {     throw new MessageFormatException("Invalid response message: " + responseMessage). }
true;protected;1;4;/**  * Recreate the invocation result contained in the given {@link RemoteInvocationResult}  * object.  * <p>The default implementation calls the default {@code recreate()} method.  * <p>Can be overridden in subclasses to provide custom recreation, potentially  * processing the returned result object.  * @param result the RemoteInvocationResult to recreate  * @return a return value if the invocation result is a successful return  * @throws Throwable if the invocation result is an exception  * @see org.springframework.remoting.support.RemoteInvocationResult#recreate()  */ ;/**  * Recreate the invocation result contained in the given {@link RemoteInvocationResult}  * object.  * <p>The default implementation calls the default {@code recreate()} method.  * <p>Can be overridden in subclasses to provide custom recreation, potentially  * processing the returned result object.  * @param result the RemoteInvocationResult to recreate  * @return a return value if the invocation result is a successful return  * @throws Throwable if the invocation result is an exception  * @see org.springframework.remoting.support.RemoteInvocationResult#recreate()  */ @Nullable protected Object recreateRemoteInvocationResult(RemoteInvocationResult result) throws Throwable {     return result.recreate(). }
true;protected;1;3;/**  * Convert the given JMS invoker access exception to an appropriate  * Spring {@link RemoteAccessException}.  * @param ex the exception to convert  * @return the RemoteAccessException to throw  */ ;/**  * Convert the given JMS invoker access exception to an appropriate  * Spring {@link RemoteAccessException}.  * @param ex the exception to convert  * @return the RemoteAccessException to throw  */ protected RemoteAccessException convertJmsInvokerAccessException(JMSException ex) {     return new RemoteAccessException("Could not access JMS invoker queue [" + this.queue + "]", ex). }
