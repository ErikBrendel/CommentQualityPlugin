commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify whether to connect lazily, i.e. whether to establish the JMS Connection  * and the corresponding Sessions and MessageConsumers as late as possible -  * in the start phase of this container.  * <p>Default is "false": connecting early, i.e. during the bean initialization phase.  * Set this flag to "true" in order to switch to lazy connecting if your target broker  * is likely to not have started up yet and you prefer to not even try a connection.  * @see #start()  * @see #initialize()  */ ;/**  * Specify whether to connect lazily, i.e. whether to establish the JMS Connection  * and the corresponding Sessions and MessageConsumers as late as possible -  * in the start phase of this container.  * <p>Default is "false": connecting early, i.e. during the bean initialization phase.  * Set this flag to "true" in order to switch to lazy connecting if your target broker  * is likely to not have started up yet and you prefer to not even try a connection.  * @see #start()  * @see #initialize()  */ public void setConnectLazily(boolean connectLazily) {     this.connectLazily = connectLazily. }
true;public;1;18;/**  * Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple  * upper limit String, e.g. "10".  * <p>This listener container will always hold on to the maximum number of  * consumers {@link #setConcurrentConsumers} since it is unable to scale.  * <p>This property is primarily supported for configuration compatibility with  * {@link DefaultMessageListenerContainer}. For this local listener container,  * generally use {@link #setConcurrentConsumers} instead.  */ ;/**  * Specify concurrency limits via a "lower-upper" String, e.g. "5-10", or a simple  * upper limit String, e.g. "10".  * <p>This listener container will always hold on to the maximum number of  * consumers {@link #setConcurrentConsumers} since it is unable to scale.  * <p>This property is primarily supported for configuration compatibility with  * {@link DefaultMessageListenerContainer}. For this local listener container,  * generally use {@link #setConcurrentConsumers} instead.  */ @Override public void setConcurrency(String concurrency) {     try {         int separatorIndex = concurrency.indexOf('-').         if (separatorIndex != -1) {             setConcurrentConsumers(Integer.parseInt(concurrency.substring(separatorIndex + 1, concurrency.length()))).         } else {             setConcurrentConsumers(Integer.parseInt(concurrency)).         }     } catch (NumberFormatException ex) {         throw new IllegalArgumentException("Invalid concurrency value [" + concurrency + "]: only " + "single maximum integer (e.g. \"5\") and minimum-maximum combo (e.g. \"3-5\") supported. " + "Note that SimpleMessageListenerContainer will effectively ignore the minimum value and " + "always keep a fixed number of consumers according to the maximum value.").     } }
true;public;1;4;/**  * Specify the number of concurrent consumers to create. Default is 1.  * <p>Raising the number of concurrent consumers is recommendable in order  * to scale the consumption of messages coming in from a queue. However,  * note that any ordering guarantees are lost once multiple consumers are  * registered. In general, stick with 1 consumer for low-volume queues.  * <p><b>Do not raise the number of concurrent consumers for a topic.</b>  * This would lead to concurrent consumption of the same message,  * which is hardly ever desirable.  */ ;/**  * Specify the number of concurrent consumers to create. Default is 1.  * <p>Raising the number of concurrent consumers is recommendable in order  * to scale the consumption of messages coming in from a queue. However,  * note that any ordering guarantees are lost once multiple consumers are  * registered. In general, stick with 1 consumer for low-volume queues.  * <p><b>Do not raise the number of concurrent consumers for a topic.</b>  * This would lead to concurrent consumption of the same message,  * which is hardly ever desirable.  */ public void setConcurrentConsumers(int concurrentConsumers) {     Assert.isTrue(concurrentConsumers > 0, "'concurrentConsumers' value must be at least 1 (one)").     this.concurrentConsumers = concurrentConsumers. }
true;public;1;3;/**  * Set the Spring TaskExecutor to use for executing the listener once  * a message has been received by the provider.  * <p>Default is none, that is, to run in the JMS provider's own receive thread,  * blocking the provider's receive endpoint while executing the listener.  * <p>Specify a TaskExecutor for executing the listener in a different thread,  * rather than blocking the JMS provider, usually integrating with an existing  * thread pool. This allows to keep the number of concurrent consumers low (1)  * while still processing messages concurrently (decoupled from receiving!).  * <p><b>NOTE: Specifying a TaskExecutor for listener execution affects  * acknowledgement semantics.</b> Messages will then always get acknowledged  * before listener execution, with the underlying Session immediately reused  * for receiving the next message. Using this in combination with a transacted  * session or with client acknowledgement will lead to unspecified results!  * <p><b>NOTE: Concurrent listener execution via a TaskExecutor will lead  * to concurrent processing of messages that have been received by the same  * underlying Session.</b> As a consequence, it is not recommended to use  * this setting with a {@link SessionAwareMessageListener}, at least not  * if the latter performs actual work on the given Session. A standard  * {@link javax.jms.MessageListener} will work fine, in general.  * @see #setConcurrentConsumers  * @see org.springframework.core.task.SimpleAsyncTaskExecutor  * @see org.springframework.scheduling.commonj.WorkManagerTaskExecutor  */ ;/**  * Set the Spring TaskExecutor to use for executing the listener once  * a message has been received by the provider.  * <p>Default is none, that is, to run in the JMS provider's own receive thread,  * blocking the provider's receive endpoint while executing the listener.  * <p>Specify a TaskExecutor for executing the listener in a different thread,  * rather than blocking the JMS provider, usually integrating with an existing  * thread pool. This allows to keep the number of concurrent consumers low (1)  * while still processing messages concurrently (decoupled from receiving!).  * <p><b>NOTE: Specifying a TaskExecutor for listener execution affects  * acknowledgement semantics.</b> Messages will then always get acknowledged  * before listener execution, with the underlying Session immediately reused  * for receiving the next message. Using this in combination with a transacted  * session or with client acknowledgement will lead to unspecified results!  * <p><b>NOTE: Concurrent listener execution via a TaskExecutor will lead  * to concurrent processing of messages that have been received by the same  * underlying Session.</b> As a consequence, it is not recommended to use  * this setting with a {@link SessionAwareMessageListener}, at least not  * if the latter performs actual work on the given Session. A standard  * {@link javax.jms.MessageListener} will work fine, in general.  * @see #setConcurrentConsumers  * @see org.springframework.core.task.SimpleAsyncTaskExecutor  * @see org.springframework.scheduling.commonj.WorkManagerTaskExecutor  */ public void setTaskExecutor(Executor taskExecutor) {     this.taskExecutor = taskExecutor. }
false;protected;0;7;;@Override protected void validateConfiguration() {     super.validateConfiguration().     if (isSubscriptionDurable() && this.concurrentConsumers != 1) {         throw new IllegalArgumentException("Only 1 concurrent consumer supported for durable subscription").     } }
true;protected,final;0;4;/**  * Always use a shared JMS Connection.  */ ;// ------------------------------------------------------------------------- // Implementation of AbstractMessageListenerContainer's template methods // ------------------------------------------------------------------------- /**  * Always use a shared JMS Connection.  */ @Override protected final boolean sharedConnectionEnabled() {     return true. }
true;protected;0;13;/**  * Creates the specified number of concurrent consumers,  * in the form of a JMS Session plus associated MessageConsumer.  * @see #createListenerConsumer  */ ;/**  * Creates the specified number of concurrent consumers,  * in the form of a JMS Session plus associated MessageConsumer.  * @see #createListenerConsumer  */ @Override protected void doInitialize() throws JMSException {     if (!this.connectLazily) {         try {             establishSharedConnection().         } catch (JMSException ex) {             logger.debug("Could not connect on initialization - registering message consumers lazily", ex).             return.         }         initializeConsumers().     } }
true;protected;0;5;/**  * Re-initializes this container's JMS message consumers,  * if not initialized already.  */ ;/**  * Re-initializes this container's JMS message consumers,  * if not initialized already.  */ @Override protected void doStart() throws JMSException {     super.doStart().     initializeConsumers(). }
true;protected;1;5;/**  * Registers this listener container as JMS ExceptionListener on the shared connection.  */ ;/**  * Registers this listener container as JMS ExceptionListener on the shared connection.  */ @Override protected void prepareSharedConnection(Connection connection) throws JMSException {     super.prepareSharedConnection(connection).     connection.setExceptionListener(this). }
true;public;1;23;/**  * JMS ExceptionListener implementation, invoked by the JMS provider in  * case of connection failures. Re-initializes this listener container's  * shared connection and its sessions and consumers.  * @param ex the reported connection exception  */ ;/**  * JMS ExceptionListener implementation, invoked by the JMS provider in  * case of connection failures. Re-initializes this listener container's  * shared connection and its sessions and consumers.  * @param ex the reported connection exception  */ @Override public void onException(JMSException ex) {     // First invoke the user-specific ExceptionListener, if any.     invokeExceptionListener(ex).     // Now try to recover the shared Connection and all consumers...     if (logger.isDebugEnabled()) {         logger.debug("Trying to recover from JMS Connection exception: " + ex).     }     try {         synchronized (this.consumersMonitor) {             this.sessions = null.             this.consumers = null.         }         refreshSharedConnection().         initializeConsumers().         logger.debug("Successfully refreshed JMS Connection").     } catch (JMSException recoverEx) {         logger.debug("Failed to recover JMS Connection", recoverEx).         logger.error("Encountered non-recoverable JMSException", ex).     } }
true;protected;0;16;/**  * Initialize the JMS Sessions and MessageConsumers for this container.  * @throws JMSException in case of setup failure  */ ;/**  * Initialize the JMS Sessions and MessageConsumers for this container.  * @throws JMSException in case of setup failure  */ protected void initializeConsumers() throws JMSException {     // Register Sessions and MessageConsumers.     synchronized (this.consumersMonitor) {         if (this.consumers == null) {             this.sessions = new HashSet<>(this.concurrentConsumers).             this.consumers = new HashSet<>(this.concurrentConsumers).             Connection con = getSharedConnection().             for (int i = 0. i < this.concurrentConsumers. i++) {                 Session session = createSession(con).                 MessageConsumer consumer = createListenerConsumer(session).                 this.sessions.add(session).                 this.consumers.add(consumer).             }         }     } }
true;protected;1;18;/**  * Create a MessageConsumer for the given JMS Session,  * registering a MessageListener for the specified listener.  * @param session the JMS Session to work on  * @return the MessageConsumer  * @throws JMSException if thrown by JMS methods  * @see #executeListener  */ ;/**  * Create a MessageConsumer for the given JMS Session,  * registering a MessageListener for the specified listener.  * @param session the JMS Session to work on  * @return the MessageConsumer  * @throws JMSException if thrown by JMS methods  * @see #executeListener  */ protected MessageConsumer createListenerConsumer(final Session session) throws JMSException {     Destination destination = getDestination().     if (destination == null) {         String destinationName = getDestinationName().         Assert.state(destinationName != null, "No destination set").         destination = resolveDestinationName(session, destinationName).     }     MessageConsumer consumer = createConsumer(session, destination).     if (this.taskExecutor != null) {         consumer.setMessageListener(message -> this.taskExecutor.execute(() -> processMessage(message, session))).     } else {         consumer.setMessageListener(message -> processMessage(message, session)).     }     return consumer. }
true;protected;2;16;/**  * Process a message received from the provider.  * <p>Executes the listener, exposing the current JMS Session as  * thread-bound resource (if "exposeListenerSession" is "true").  * @param message the received JMS Message  * @param session the JMS Session to operate on  * @see #executeListener  * @see #setExposeListenerSession  */ ;/**  * Process a message received from the provider.  * <p>Executes the listener, exposing the current JMS Session as  * thread-bound resource (if "exposeListenerSession" is "true").  * @param message the received JMS Message  * @param session the JMS Session to operate on  * @see #executeListener  * @see #setExposeListenerSession  */ protected void processMessage(Message message, Session session) {     ConnectionFactory connectionFactory = getConnectionFactory().     boolean exposeResource = (connectionFactory != null && isExposeListenerSession()).     if (exposeResource) {         TransactionSynchronizationManager.bindResource(connectionFactory, new LocallyExposedJmsResourceHolder(session)).     }     try {         executeListener(session, message).     } finally {         if (exposeResource) {             TransactionSynchronizationManager.unbindResource(getConnectionFactory()).         }     } }
true;protected;0;17;/**  * Destroy the registered JMS Sessions and associated MessageConsumers.  */ ;/**  * Destroy the registered JMS Sessions and associated MessageConsumers.  */ @Override protected void doShutdown() throws JMSException {     synchronized (this.consumersMonitor) {         if (this.consumers != null) {             logger.debug("Closing JMS MessageConsumers").             for (MessageConsumer consumer : this.consumers) {                 JmsUtils.closeMessageConsumer(consumer).             }             if (this.sessions != null) {                 logger.debug("Closing JMS Sessions").                 for (Session session : this.sessions) {                     JmsUtils.closeSession(session).                 }             }         }     } }
