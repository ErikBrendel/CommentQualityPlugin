commented;modifiers;parameterAmount;loc;comment;code
true;public,final;1;4;/**  * Set the target ConnectionFactory that this ConnectionFactory should delegate to.  */ ;/**  * Set the target ConnectionFactory that this ConnectionFactory should delegate to.  */ public final void setTargetConnectionFactory(ConnectionFactory targetConnectionFactory) {     Assert.notNull(targetConnectionFactory, "'targetConnectionFactory' must not be null").     this.targetConnectionFactory = targetConnectionFactory. }
true;protected;0;5;/**  * Return the target ConnectionFactory that this ConnectionFactory should delegate to.  */ ;/**  * Return the target ConnectionFactory that this ConnectionFactory should delegate to.  */ protected ConnectionFactory getTargetConnectionFactory() {     ConnectionFactory target = this.targetConnectionFactory.     Assert.state(target != null, "'targetConnectionFactory' is required").     return target. }
true;public;1;3;/**  * Set whether to allow for a local JMS transaction that is synchronized with a  * Spring-managed transaction (where the main transaction might be a JDBC-based  * one for a specific DataSource, for example), with the JMS transaction committing  * right after the main transaction. If not allowed, the given ConnectionFactory  * needs to handle transaction enlistment underneath the covers.  * <p>Default is "false": If not within a managed transaction that encompasses  * the underlying JMS ConnectionFactory, standard Sessions will be returned.  * Turn this flag on to allow participation in any Spring-managed transaction,  * with a local JMS transaction synchronized with the main transaction.  */ ;/**  * Set whether to allow for a local JMS transaction that is synchronized with a  * Spring-managed transaction (where the main transaction might be a JDBC-based  * one for a specific DataSource, for example), with the JMS transaction committing  * right after the main transaction. If not allowed, the given ConnectionFactory  * needs to handle transaction enlistment underneath the covers.  * <p>Default is "false": If not within a managed transaction that encompasses  * the underlying JMS ConnectionFactory, standard Sessions will be returned.  * Turn this flag on to allow participation in any Spring-managed transaction,  * with a local JMS transaction synchronized with the main transaction.  */ public void setSynchedLocalTransactionAllowed(boolean synchedLocalTransactionAllowed) {     this.synchedLocalTransactionAllowed = synchedLocalTransactionAllowed. }
true;protected;0;3;/**  * Return whether to allow for a local JMS transaction that is synchronized  * with a Spring-managed transaction.  */ ;/**  * Return whether to allow for a local JMS transaction that is synchronized  * with a Spring-managed transaction.  */ protected boolean isSynchedLocalTransactionAllowed() {     return this.synchedLocalTransactionAllowed. }
false;public;0;5;;@Override public Connection createConnection() throws JMSException {     Connection targetConnection = getTargetConnectionFactory().createConnection().     return getTransactionAwareConnectionProxy(targetConnection). }
false;public;2;5;;@Override public Connection createConnection(String username, String password) throws JMSException {     Connection targetConnection = getTargetConnectionFactory().createConnection(username, password).     return getTransactionAwareConnectionProxy(targetConnection). }
false;public;0;9;;@Override public QueueConnection createQueueConnection() throws JMSException {     ConnectionFactory target = getTargetConnectionFactory().     if (!(target instanceof QueueConnectionFactory)) {         throw new javax.jms.IllegalStateException("'targetConnectionFactory' is no QueueConnectionFactory").     }     QueueConnection targetConnection = ((QueueConnectionFactory) target).createQueueConnection().     return (QueueConnection) getTransactionAwareConnectionProxy(targetConnection). }
false;public;2;9;;@Override public QueueConnection createQueueConnection(String username, String password) throws JMSException {     ConnectionFactory target = getTargetConnectionFactory().     if (!(target instanceof QueueConnectionFactory)) {         throw new javax.jms.IllegalStateException("'targetConnectionFactory' is no QueueConnectionFactory").     }     QueueConnection targetConnection = ((QueueConnectionFactory) target).createQueueConnection(username, password).     return (QueueConnection) getTransactionAwareConnectionProxy(targetConnection). }
false;public;0;9;;@Override public TopicConnection createTopicConnection() throws JMSException {     ConnectionFactory target = getTargetConnectionFactory().     if (!(target instanceof TopicConnectionFactory)) {         throw new javax.jms.IllegalStateException("'targetConnectionFactory' is no TopicConnectionFactory").     }     TopicConnection targetConnection = ((TopicConnectionFactory) target).createTopicConnection().     return (TopicConnection) getTransactionAwareConnectionProxy(targetConnection). }
false;public;2;9;;@Override public TopicConnection createTopicConnection(String username, String password) throws JMSException {     ConnectionFactory target = getTargetConnectionFactory().     if (!(target instanceof TopicConnectionFactory)) {         throw new javax.jms.IllegalStateException("'targetConnectionFactory' is no TopicConnectionFactory").     }     TopicConnection targetConnection = ((TopicConnectionFactory) target).createTopicConnection(username, password).     return (TopicConnection) getTransactionAwareConnectionProxy(targetConnection). }
false;public;0;4;;@Override public JMSContext createContext() {     return getTargetConnectionFactory().createContext(). }
false;public;2;4;;@Override public JMSContext createContext(String userName, String password) {     return getTargetConnectionFactory().createContext(userName, password). }
false;public;3;4;;@Override public JMSContext createContext(String userName, String password, int sessionMode) {     return getTargetConnectionFactory().createContext(userName, password, sessionMode). }
false;public;1;4;;@Override public JMSContext createContext(int sessionMode) {     return getTargetConnectionFactory().createContext(sessionMode). }
true;protected;1;12;/**  * Wrap the given Connection with a proxy that delegates every method call to it  * but handles Session lookup in a transaction-aware fashion.  * @param target the original Connection to wrap  * @return the wrapped Connection  */ ;/**  * Wrap the given Connection with a proxy that delegates every method call to it  * but handles Session lookup in a transaction-aware fashion.  * @param target the original Connection to wrap  * @return the wrapped Connection  */ protected Connection getTransactionAwareConnectionProxy(Connection target) {     List<Class<?>> classes = new ArrayList<>(3).     classes.add(Connection.class).     if (target instanceof QueueConnection) {         classes.add(QueueConnection.class).     }     if (target instanceof TopicConnection) {         classes.add(TopicConnection.class).     }     return (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), ClassUtils.toClassArray(classes), new TransactionAwareConnectionInvocationHandler(target)). }
false;public;3;44;;@Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (method.getName().equals("equals")) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (method.getName().equals("hashCode")) {         // Use hashCode of Connection proxy.         return System.identityHashCode(proxy).     } else if (Session.class == method.getReturnType()) {         Session session = ConnectionFactoryUtils.getTransactionalSession(getTargetConnectionFactory(), this.target, isSynchedLocalTransactionAllowed()).         if (session != null) {             return getCloseSuppressingSessionProxy(session).         }     } else if (QueueSession.class == method.getReturnType()) {         QueueSession session = ConnectionFactoryUtils.getTransactionalQueueSession((QueueConnectionFactory) getTargetConnectionFactory(), (QueueConnection) this.target, isSynchedLocalTransactionAllowed()).         if (session != null) {             return getCloseSuppressingSessionProxy(session).         }     } else if (TopicSession.class == method.getReturnType()) {         TopicSession session = ConnectionFactoryUtils.getTransactionalTopicSession((TopicConnectionFactory) getTargetConnectionFactory(), (TopicConnection) this.target, isSynchedLocalTransactionAllowed()).         if (session != null) {             return getCloseSuppressingSessionProxy(session).         }     }     // Invoke method on target Connection.     try {         return method.invoke(this.target, args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
false;private;1;12;;private Session getCloseSuppressingSessionProxy(Session target) {     List<Class<?>> classes = new ArrayList<>(3).     classes.add(SessionProxy.class).     if (target instanceof QueueSession) {         classes.add(QueueSession.class).     }     if (target instanceof TopicSession) {         classes.add(TopicSession.class).     }     return (Session) Proxy.newProxyInstance(SessionProxy.class.getClassLoader(), ClassUtils.toClassArray(classes), new CloseSuppressingSessionInvocationHandler(target)). }
false;public;3;36;;@Override @Nullable public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (method.getName().equals("equals")) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (method.getName().equals("hashCode")) {         // Use hashCode of Connection proxy.         return System.identityHashCode(proxy).     } else if (method.getName().equals("commit")) {         throw new TransactionInProgressException("Commit call not allowed within a managed transaction").     } else if (method.getName().equals("rollback")) {         throw new TransactionInProgressException("Rollback call not allowed within a managed transaction").     } else if (method.getName().equals("close")) {         // Handle close method: not to be closed within a transaction.         return null.     } else if (method.getName().equals("getTargetSession")) {         // Handle getTargetSession method: return underlying Session.         return this.target.     }     // Invoke method on target Session.     try {         return method.invoke(this.target, args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
