commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return whether this resource holder is frozen, i.e. does not  * allow for adding further Connections and Sessions to it.  * @see #addConnection  * @see #addSession  */ ;/**  * Return whether this resource holder is frozen, i.e. does not  * allow for adding further Connections and Sessions to it.  * @see #addConnection  * @see #addSession  */ public final boolean isFrozen() {     return this.frozen. }
true;public,final;1;7;/**  * Add the given Connection to this resource holder.  */ ;/**  * Add the given Connection to this resource holder.  */ public final void addConnection(Connection connection) {     Assert.isTrue(!this.frozen, "Cannot add Connection because JmsResourceHolder is frozen").     Assert.notNull(connection, "Connection must not be null").     if (!this.connections.contains(connection)) {         this.connections.add(connection).     } }
true;public,final;1;3;/**  * Add the given Session to this resource holder.  */ ;/**  * Add the given Session to this resource holder.  */ public final void addSession(Session session) {     addSession(session, null). }
true;public,final;2;12;/**  * Add the given Session to this resource holder,  * registered for a specific Connection.  */ ;/**  * Add the given Session to this resource holder,  * registered for a specific Connection.  */ public final void addSession(Session session, @Nullable Connection connection) {     Assert.isTrue(!this.frozen, "Cannot add Session because JmsResourceHolder is frozen").     Assert.notNull(session, "Session must not be null").     if (!this.sessions.contains(session)) {         this.sessions.add(session).         if (connection != null) {             LinkedList<Session> sessions = this.sessionsPerConnection.computeIfAbsent(connection, k -> new LinkedList<>()).             sessions.add(session).         }     } }
true;public;1;3;/**  * Determine whether the given Session is registered  * with this resource holder.  */ ;/**  * Determine whether the given Session is registered  * with this resource holder.  */ public boolean containsSession(Session session) {     return this.sessions.contains(session). }
true;public;0;4;/**  * Return this resource holder's default Connection,  * or {@code null} if none.  */ ;/**  * Return this resource holder's default Connection,  * or {@code null} if none.  */ @Nullable public Connection getConnection() {     return this.connections.peek(). }
true;public;1;4;/**  * Return this resource holder's Connection of the given type,  * or {@code null} if none.  */ ;/**  * Return this resource holder's Connection of the given type,  * or {@code null} if none.  */ @Nullable public <C extends Connection> C getConnection(Class<C> connectionType) {     return CollectionUtils.findValueOfType(this.connections, connectionType). }
true;;0;4;/**  * Return an existing original Session, if any.  * <p>In contrast to {@link #getSession()}, this must not lazily initialize  * a new Session, not even in {@link JmsResourceHolder} subclasses.  */ ;/**  * Return an existing original Session, if any.  * <p>In contrast to {@link #getSession()}, this must not lazily initialize  * a new Session, not even in {@link JmsResourceHolder} subclasses.  */ @Nullable Session getOriginalSession() {     return this.sessions.peek(). }
true;public;0;4;/**  * Return this resource holder's default Session,  * or {@code null} if none.  */ ;/**  * Return this resource holder's default Session,  * or {@code null} if none.  */ @Nullable public Session getSession() {     return this.sessions.peek(). }
true;public;1;4;/**  * Return this resource holder's Session of the given type,  * or {@code null} if none.  */ ;/**  * Return this resource holder's Session of the given type,  * or {@code null} if none.  */ @Nullable public <S extends Session> S getSession(Class<S> sessionType) {     return getSession(sessionType, null). }
true;public;2;6;/**  * Return this resource holder's Session of the given type  * for the given connection, or {@code null} if none.  */ ;/**  * Return this resource holder's Session of the given type  * for the given connection, or {@code null} if none.  */ @Nullable public <S extends Session> S getSession(Class<S> sessionType, @Nullable Connection connection) {     LinkedList<Session> sessions = (connection != null ? this.sessionsPerConnection.get(connection) : this.sessions).     return CollectionUtils.findValueOfType(sessions, sessionType). }
true;public;0;40;/**  * Commit all of this resource holder's Sessions.  * @throws JMSException if thrown from a Session commit attempt  * @see Session#commit()  */ ;/**  * Commit all of this resource holder's Sessions.  * @throws JMSException if thrown from a Session commit attempt  * @see Session#commit()  */ public void commitAll() throws JMSException {     for (Session session : this.sessions) {         try {             session.commit().         } catch (TransactionInProgressException ex) {         // Ignore -> can only happen in case of a JTA transaction.         } catch (javax.jms.IllegalStateException ex) {             if (this.connectionFactory != null) {                 try {                     Method getDataSourceMethod = this.connectionFactory.getClass().getMethod("getDataSource").                     Object ds = ReflectionUtils.invokeMethod(getDataSourceMethod, this.connectionFactory).                     while (ds != null) {                         if (TransactionSynchronizationManager.hasResource(ds)) {                             // which typically gets committed first, e.g. with Oracle AQ --> ignore                             return.                         }                         try {                             // Check for decorated DataSource a la Spring's DelegatingDataSource                             Method getTargetDataSourceMethod = ds.getClass().getMethod("getTargetDataSource").                             ds = ReflectionUtils.invokeMethod(getTargetDataSourceMethod, ds).                         } catch (NoSuchMethodException nsme) {                             ds = null.                         }                     }                 } catch (Throwable ex2) {                     if (logger.isDebugEnabled()) {                         logger.debug("No working getDataSource method found on ConnectionFactory: " + ex2).                     }                 // No working getDataSource method - cannot perform DataSource transaction check                 }             }             throw ex.         }     } }
true;public;0;16;/**  * Close all of this resource holder's Sessions and clear its state.  * @see Session#close()  */ ;/**  * Close all of this resource holder's Sessions and clear its state.  * @see Session#close()  */ public void closeAll() {     for (Session session : this.sessions) {         try {             session.close().         } catch (Throwable ex) {             logger.debug("Could not close synchronized JMS Session after transaction", ex).         }     }     for (Connection con : this.connections) {         ConnectionFactoryUtils.releaseConnection(con, this.connectionFactory, true).     }     this.connections.clear().     this.sessions.clear().     this.sessionsPerConnection.clear(). }
