commented;modifiers;parameterAmount;loc;comment;code
true;protected;1;52;/**  * This implementation guesses the ActivationSpec class name from the  * provider's class name: e.g. "ActiveMQResourceAdapter" ->  * "ActiveMQActivationSpec" in the same package, or a class named  * "ActivationSpecImpl" in the same package as the ResourceAdapter class.  */ ;/**  * This implementation guesses the ActivationSpec class name from the  * provider's class name: e.g. "ActiveMQResourceAdapter" ->  * "ActiveMQActivationSpec" in the same package, or a class named  * "ActivationSpecImpl" in the same package as the ResourceAdapter class.  */ @Override protected Class<?> determineActivationSpecClass(ResourceAdapter adapter) {     String adapterClassName = adapter.getClass().getName().     if (adapterClassName.endsWith(RESOURCE_ADAPTER_SUFFIX)) {         // e.g. ActiveMQ         String providerName = adapterClassName.substring(0, adapterClassName.length() - RESOURCE_ADAPTER_SUFFIX.length()).         String specClassName = providerName + ACTIVATION_SPEC_SUFFIX.         try {             return adapter.getClass().getClassLoader().loadClass(specClassName).         } catch (ClassNotFoundException ex) {             logger.debug("No default <Provider>ActivationSpec class found: " + specClassName).         }     } else if (adapterClassName.endsWith(RESOURCE_ADAPTER_IMPL_SUFFIX)) {         // e.g. WebSphere         String providerName = adapterClassName.substring(0, adapterClassName.length() - RESOURCE_ADAPTER_IMPL_SUFFIX.length()).         String specClassName = providerName + ACTIVATION_SPEC_IMPL_SUFFIX.         try {             return adapter.getClass().getClassLoader().loadClass(specClassName).         } catch (ClassNotFoundException ex) {             logger.debug("No default <Provider>ActivationSpecImpl class found: " + specClassName).         }     }     // e.g. JORAM     String providerPackage = adapterClassName.substring(0, adapterClassName.lastIndexOf('.') + 1).     String specClassName = providerPackage + ACTIVATION_SPEC_IMPL_SUFFIX.     try {         return adapter.getClass().getClassLoader().loadClass(specClassName).     } catch (ClassNotFoundException ex) {         logger.debug("No default ActivationSpecImpl class found in provider package: " + specClassName).     }     // ActivationSpecImpl class in "inbound" subpackage (WebSphere MQ 6.0.2.1)     specClassName = providerPackage + "inbound." + ACTIVATION_SPEC_IMPL_SUFFIX.     try {         return adapter.getClass().getClassLoader().loadClass(specClassName).     } catch (ClassNotFoundException ex) {         logger.debug("No default ActivationSpecImpl class found in inbound subpackage: " + specClassName).     }     throw new IllegalStateException("No ActivationSpec class defined - " + "specify the 'activationSpecClass' property or override the 'determineActivationSpecClass' method"). }
true;protected;2;32;/**  * This implementation supports Spring's extended "maxConcurrency"  * and "prefetchSize" settings through detecting corresponding  * ActivationSpec properties: "maxSessions"/"maxNumberOfWorks" and  * "maxMessagesPerSessions"/"maxMessages", respectively  * (following ActiveMQ's and JORAM's naming conventions).  */ ;/**  * This implementation supports Spring's extended "maxConcurrency"  * and "prefetchSize" settings through detecting corresponding  * ActivationSpec properties: "maxSessions"/"maxNumberOfWorks" and  * "maxMessagesPerSessions"/"maxMessages", respectively  * (following ActiveMQ's and JORAM's naming conventions).  */ @Override protected void populateActivationSpecProperties(BeanWrapper bw, JmsActivationSpecConfig config) {     super.populateActivationSpecProperties(bw, config).     if (config.getMaxConcurrency() > 0) {         if (bw.isWritableProperty("maxSessions")) {             // ActiveMQ             bw.setPropertyValue("maxSessions", Integer.toString(config.getMaxConcurrency())).         } else if (bw.isWritableProperty("maxNumberOfWorks")) {             // JORAM             bw.setPropertyValue("maxNumberOfWorks", Integer.toString(config.getMaxConcurrency())).         } else if (bw.isWritableProperty("maxConcurrency")) {             // WebSphere             bw.setPropertyValue("maxConcurrency", Integer.toString(config.getMaxConcurrency())).         }     }     if (config.getPrefetchSize() > 0) {         if (bw.isWritableProperty("maxMessagesPerSessions")) {             // ActiveMQ             bw.setPropertyValue("maxMessagesPerSessions", Integer.toString(config.getPrefetchSize())).         } else if (bw.isWritableProperty("maxMessages")) {             // JORAM             bw.setPropertyValue("maxMessages", Integer.toString(config.getPrefetchSize())).         } else if (bw.isWritableProperty("maxBatchSize")) {             // WebSphere             bw.setPropertyValue("maxBatchSize", Integer.toString(config.getPrefetchSize())).         }     } }
true;protected;2;10;/**  * This implementation maps {@code SESSION_TRANSACTED} onto an  * ActivationSpec property named "useRAManagedTransaction", if available  * (following ActiveMQ's naming conventions).  */ ;/**  * This implementation maps {@code SESSION_TRANSACTED} onto an  * ActivationSpec property named "useRAManagedTransaction", if available  * (following ActiveMQ's naming conventions).  */ @Override protected void applyAcknowledgeMode(BeanWrapper bw, int ackMode) {     if (ackMode == Session.SESSION_TRANSACTED && bw.isWritableProperty("useRAManagedTransaction")) {         // ActiveMQ         bw.setPropertyValue("useRAManagedTransaction", "true").     } else {         super.applyAcknowledgeMode(bw, ackMode).     } }
