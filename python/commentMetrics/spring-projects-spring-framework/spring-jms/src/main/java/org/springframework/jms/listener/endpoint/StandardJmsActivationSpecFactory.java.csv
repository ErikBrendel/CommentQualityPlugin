commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the fully-qualified ActivationSpec class name for the target  * provider (e.g. "org.apache.activemq.ra.ActiveMQActivationSpec").  */ ;/**  * Specify the fully-qualified ActivationSpec class name for the target  * provider (e.g. "org.apache.activemq.ra.ActiveMQActivationSpec").  */ public void setActivationSpecClass(Class<?> activationSpecClass) {     this.activationSpecClass = activationSpecClass. }
true;public;1;3;/**  * Specify custom default properties, with String keys and String values.  * <p>Applied to each ActivationSpec object before it gets populated with  * listener-specific settings. Allows for configuring vendor-specific properties  * beyond the Spring-defined settings in {@link JmsActivationSpecConfig}.  */ ;/**  * Specify custom default properties, with String keys and String values.  * <p>Applied to each ActivationSpec object before it gets populated with  * listener-specific settings. Allows for configuring vendor-specific properties  * beyond the Spring-defined settings in {@link JmsActivationSpecConfig}.  */ public void setDefaultProperties(Map<String, String> defaultProperties) {     this.defaultProperties = defaultProperties. }
true;public;1;3;/**  * Set the DestinationResolver to use for resolving destination names  * into the JCA 1.5 ActivationSpec "destination" property.  * <p>If not specified, destination names will simply be passed in as Strings.  * If specified, destination names will be resolved into Destination objects first.  * <p>Note that a DestinationResolver for use with this factory must be  * able to work <i>without</i> an active JMS Session: e.g.  * {@link org.springframework.jms.support.destination.JndiDestinationResolver}  * or {@link org.springframework.jms.support.destination.BeanFactoryDestinationResolver}  * but not {@link org.springframework.jms.support.destination.DynamicDestinationResolver}.  */ ;/**  * Set the DestinationResolver to use for resolving destination names  * into the JCA 1.5 ActivationSpec "destination" property.  * <p>If not specified, destination names will simply be passed in as Strings.  * If specified, destination names will be resolved into Destination objects first.  * <p>Note that a DestinationResolver for use with this factory must be  * able to work <i>without</i> an active JMS Session: e.g.  * {@link org.springframework.jms.support.destination.JndiDestinationResolver}  * or {@link org.springframework.jms.support.destination.BeanFactoryDestinationResolver}  * but not {@link org.springframework.jms.support.destination.DynamicDestinationResolver}.  */ public void setDestinationResolver(@Nullable DestinationResolver destinationResolver) {     this.destinationResolver = destinationResolver. }
true;public;0;4;/**  * Return the {@link DestinationResolver} to use for resolving destinations names.  */ ;/**  * Return the {@link DestinationResolver} to use for resolving destinations names.  */ @Nullable public DestinationResolver getDestinationResolver() {     return this.destinationResolver. }
false;public;2;18;;@Override public ActivationSpec createActivationSpec(ResourceAdapter adapter, JmsActivationSpecConfig config) {     Class<?> activationSpecClassToUse = this.activationSpecClass.     if (activationSpecClassToUse == null) {         activationSpecClassToUse = determineActivationSpecClass(adapter).         if (activationSpecClassToUse == null) {             throw new IllegalStateException("Property 'activationSpecClass' is required").         }     }     ActivationSpec spec = (ActivationSpec) BeanUtils.instantiateClass(activationSpecClassToUse).     BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(spec).     if (this.defaultProperties != null) {         bw.setPropertyValues(this.defaultProperties).     }     populateActivationSpecProperties(bw, config).     return spec. }
true;protected;1;4;/**  * Determine the ActivationSpec class for the given ResourceAdapter,  * if possible. Called if no 'activationSpecClass' has been set explicitly  * @param adapter the ResourceAdapter to check  * @return the corresponding ActivationSpec class, or {@code null}  * if not determinable  * @see #setActivationSpecClass  */ ;/**  * Determine the ActivationSpec class for the given ResourceAdapter,  * if possible. Called if no 'activationSpecClass' has been set explicitly  * @param adapter the ResourceAdapter to check  * @return the corresponding ActivationSpec class, or {@code null}  * if not determinable  * @see #setActivationSpecClass  */ @Nullable protected Class<?> determineActivationSpecClass(ResourceAdapter adapter) {     return null. }
true;protected;2;40;/**  * Populate the given ApplicationSpec object with the settings  * defined in the given configuration object.  * <p>This implementation applies all standard JMS settings, but ignores  * "maxConcurrency" and "prefetchSize" - not supported in standard JCA 1.5.  * @param bw the BeanWrapper wrapping the ActivationSpec object  * @param config the configured object holding common JMS settings  */ ;/**  * Populate the given ApplicationSpec object with the settings  * defined in the given configuration object.  * <p>This implementation applies all standard JMS settings, but ignores  * "maxConcurrency" and "prefetchSize" - not supported in standard JCA 1.5.  * @param bw the BeanWrapper wrapping the ActivationSpec object  * @param config the configured object holding common JMS settings  */ protected void populateActivationSpecProperties(BeanWrapper bw, JmsActivationSpecConfig config) {     String destinationName = config.getDestinationName().     if (destinationName != null) {         boolean pubSubDomain = config.isPubSubDomain().         Object destination = destinationName.         if (this.destinationResolver != null) {             try {                 destination = this.destinationResolver.resolveDestinationName(null, destinationName, pubSubDomain).             } catch (JMSException ex) {                 throw new DestinationResolutionException("Cannot resolve destination name [" + destinationName + "]", ex).             }         }         bw.setPropertyValue("destination", destination).         bw.setPropertyValue("destinationType", pubSubDomain ? Topic.class.getName() : Queue.class.getName()).     }     if (bw.isWritableProperty("subscriptionDurability")) {         bw.setPropertyValue("subscriptionDurability", config.isSubscriptionDurable() ? "Durable" : "NonDurable").     } else if (config.isSubscriptionDurable()) {         // Standard JCA 1.5 "subscriptionDurability" apparently not supported...         throw new IllegalArgumentException("Durable subscriptions not supported by underlying provider").     }     if (config.isSubscriptionShared()) {         throw new IllegalArgumentException("Shared subscriptions not supported for JCA-driven endpoints").     }     if (config.getSubscriptionName() != null) {         bw.setPropertyValue("subscriptionName", config.getSubscriptionName()).     }     if (config.getClientId() != null) {         bw.setPropertyValue("clientId", config.getClientId()).     }     if (config.getMessageSelector() != null) {         bw.setPropertyValue("messageSelector", config.getMessageSelector()).     }     applyAcknowledgeMode(bw, config.getAcknowledgeMode()). }
true;protected;2;18;/**  * Apply the specified acknowledge mode to the ActivationSpec object.  * <p>This implementation applies the standard JCA 1.5 acknowledge modes  * "Auto-acknowledge" and "Dups-ok-acknowledge". It throws an exception in  * case of {@code CLIENT_ACKNOWLEDGE} or {@code SESSION_TRANSACTED}  * having been requested.  * @param bw the BeanWrapper wrapping the ActivationSpec object  * @param ackMode the configured acknowledge mode  * (according to the constants in {@link javax.jms.Session}  * @see javax.jms.Session#AUTO_ACKNOWLEDGE  * @see javax.jms.Session#DUPS_OK_ACKNOWLEDGE  * @see javax.jms.Session#CLIENT_ACKNOWLEDGE  * @see javax.jms.Session#SESSION_TRANSACTED  */ ;/**  * Apply the specified acknowledge mode to the ActivationSpec object.  * <p>This implementation applies the standard JCA 1.5 acknowledge modes  * "Auto-acknowledge" and "Dups-ok-acknowledge". It throws an exception in  * case of {@code CLIENT_ACKNOWLEDGE} or {@code SESSION_TRANSACTED}  * having been requested.  * @param bw the BeanWrapper wrapping the ActivationSpec object  * @param ackMode the configured acknowledge mode  * (according to the constants in {@link javax.jms.Session}  * @see javax.jms.Session#AUTO_ACKNOWLEDGE  * @see javax.jms.Session#DUPS_OK_ACKNOWLEDGE  * @see javax.jms.Session#CLIENT_ACKNOWLEDGE  * @see javax.jms.Session#SESSION_TRANSACTED  */ protected void applyAcknowledgeMode(BeanWrapper bw, int ackMode) {     if (ackMode == Session.SESSION_TRANSACTED) {         throw new IllegalArgumentException("No support for SESSION_TRANSACTED: Only \"Auto-acknowledge\" " + "and \"Dups-ok-acknowledge\" supported in standard JCA 1.5").     } else if (ackMode == Session.CLIENT_ACKNOWLEDGE) {         throw new IllegalArgumentException("No support for CLIENT_ACKNOWLEDGE: Only \"Auto-acknowledge\" " + "and \"Dups-ok-acknowledge\" supported in standard JCA 1.5").     } else if (bw.isWritableProperty("acknowledgeMode")) {         bw.setPropertyValue("acknowledgeMode", ackMode == Session.DUPS_OK_ACKNOWLEDGE ? "Dups-ok-acknowledge" : "Auto-acknowledge").     } else if (ackMode == Session.DUPS_OK_ACKNOWLEDGE) {         // Standard JCA 1.5 "acknowledgeMode" apparently not supported (e.g. WebSphere MQ 6.0.2.1)         throw new IllegalArgumentException("Dups-ok-acknowledge not supported by underlying provider").     } }
