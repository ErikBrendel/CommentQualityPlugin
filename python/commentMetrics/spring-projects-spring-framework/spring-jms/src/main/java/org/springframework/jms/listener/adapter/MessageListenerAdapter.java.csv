commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Set a target object to delegate message listening to.  * Specified listener methods have to be present on this target object.  * <p>If no explicit delegate object has been specified, listener  * methods are expected to present on this adapter instance, that is,  * on a custom subclass of this adapter, defining listener methods.  */ ;/**  * Set a target object to delegate message listening to.  * Specified listener methods have to be present on this target object.  * <p>If no explicit delegate object has been specified, listener  * methods are expected to present on this adapter instance, that is,  * on a custom subclass of this adapter, defining listener methods.  */ public void setDelegate(Object delegate) {     Assert.notNull(delegate, "Delegate must not be null").     this.delegate = delegate. }
true;protected;0;3;/**  * Return the target object to delegate message listening to.  */ ;/**  * Return the target object to delegate message listening to.  */ protected Object getDelegate() {     return this.delegate. }
true;public;1;3;/**  * Specify the name of the default listener method to delegate to,  * for the case where no specific listener method has been determined.  * Out-of-the-box value is {@link #ORIGINAL_DEFAULT_LISTENER_METHOD "handleMessage"}.  * @see #getListenerMethodName  */ ;/**  * Specify the name of the default listener method to delegate to,  * for the case where no specific listener method has been determined.  * Out-of-the-box value is {@link #ORIGINAL_DEFAULT_LISTENER_METHOD "handleMessage"}.  * @see #getListenerMethodName  */ public void setDefaultListenerMethod(String defaultListenerMethod) {     this.defaultListenerMethod = defaultListenerMethod. }
true;protected;0;3;/**  * Return the name of the default listener method to delegate to.  */ ;/**  * Return the name of the default listener method to delegate to.  */ protected String getDefaultListenerMethod() {     return this.defaultListenerMethod. }
true;public;2;32;/**  * Spring {@link SessionAwareMessageListener} entry point.  * <p>Delegates the message to the target listener method, with appropriate  * conversion of the message argument. If the target method returns a  * non-null object, wrap in a JMS message and send it back.  * @param message the incoming JMS message  * @param session the JMS session to operate on  * @throws JMSException if thrown by JMS API methods  */ ;/**  * Spring {@link SessionAwareMessageListener} entry point.  * <p>Delegates the message to the target listener method, with appropriate  * conversion of the message argument. If the target method returns a  * non-null object, wrap in a JMS message and send it back.  * @param message the incoming JMS message  * @param session the JMS session to operate on  * @throws JMSException if thrown by JMS API methods  */ @Override @SuppressWarnings("unchecked") public void onMessage(Message message, @Nullable Session session) throws JMSException {     // Check whether the delegate is a MessageListener impl itself.     // In that case, the adapter will simply act as a pass-through.     Object delegate = getDelegate().     if (delegate != this) {         if (delegate instanceof SessionAwareMessageListener) {             Assert.state(session != null, "Session is required for SessionAwareMessageListener").             ((SessionAwareMessageListener<Message>) delegate).onMessage(message, session).             return.         }         if (delegate instanceof MessageListener) {             ((MessageListener) delegate).onMessage(message).             return.         }     }     // Regular case: find a handler method reflectively.     Object convertedMessage = extractMessage(message).     String methodName = getListenerMethodName(message, convertedMessage).     // Invoke the handler method with appropriate arguments.     Object[] listenerArguments = buildListenerArguments(convertedMessage).     Object result = invokeListenerMethod(methodName, listenerArguments).     if (result != null) {         handleResult(result, message, session).     } else {         logger.trace("No result object given - no result to handle").     } }
false;public;0;10;;@Override public String getSubscriptionName() {     Object delegate = getDelegate().     if (delegate != this && delegate instanceof SubscriptionNameProvider) {         return ((SubscriptionNameProvider) delegate).getSubscriptionName().     } else {         return delegate.getClass().getName().     } }
true;protected;2;3;/**  * Determine the name of the listener method that is supposed to  * handle the given message.  * <p>The default implementation simply returns the configured  * default listener method, if any.  * @param originalMessage the JMS request message  * @param extractedMessage the converted JMS request message,  * to be passed into the listener method as argument  * @return the name of the listener method (never {@code null})  * @throws JMSException if thrown by JMS API methods  * @see #setDefaultListenerMethod  */ ;/**  * Determine the name of the listener method that is supposed to  * handle the given message.  * <p>The default implementation simply returns the configured  * default listener method, if any.  * @param originalMessage the JMS request message  * @param extractedMessage the converted JMS request message,  * to be passed into the listener method as argument  * @return the name of the listener method (never {@code null})  * @throws JMSException if thrown by JMS API methods  * @see #setDefaultListenerMethod  */ protected String getListenerMethodName(Message originalMessage, Object extractedMessage) throws JMSException {     return getDefaultListenerMethod(). }
true;protected;1;3;/**  * Build an array of arguments to be passed into the target listener method.  * Allows for multiple method arguments to be built from a single message object.  * <p>The default implementation builds an array with the given message object  * as sole element. This means that the extracted message will always be passed  * into a <i>single</i> method argument, even if it is an array, with the target  * method having a corresponding single argument of the array's type declared.  * <p>This can be overridden to treat special message content such as arrays  * differently, for example passing in each element of the message array  * as distinct method argument.  * @param extractedMessage the content of the message  * @return the array of arguments to be passed into the  * listener method (each element of the array corresponding  * to a distinct method argument)  */ ;/**  * Build an array of arguments to be passed into the target listener method.  * Allows for multiple method arguments to be built from a single message object.  * <p>The default implementation builds an array with the given message object  * as sole element. This means that the extracted message will always be passed  * into a <i>single</i> method argument, even if it is an array, with the target  * method having a corresponding single argument of the array's type declared.  * <p>This can be overridden to treat special message content such as arrays  * differently, for example passing in each element of the message array  * as distinct method argument.  * @param extractedMessage the content of the message  * @return the array of arguments to be passed into the  * listener method (each element of the array corresponding  * to a distinct method argument)  */ protected Object[] buildListenerArguments(Object extractedMessage) {     return new Object[] { extractedMessage }. }
true;protected;2;25;/**  * Invoke the specified listener method.  * @param methodName the name of the listener method  * @param arguments the message arguments to be passed in  * @return the result returned from the listener method  * @throws JMSException if thrown by JMS API methods  * @see #getListenerMethodName  * @see #buildListenerArguments  */ ;/**  * Invoke the specified listener method.  * @param methodName the name of the listener method  * @param arguments the message arguments to be passed in  * @return the result returned from the listener method  * @throws JMSException if thrown by JMS API methods  * @see #getListenerMethodName  * @see #buildListenerArguments  */ @Nullable protected Object invokeListenerMethod(String methodName, Object[] arguments) throws JMSException {     try {         MethodInvoker methodInvoker = new MethodInvoker().         methodInvoker.setTargetObject(getDelegate()).         methodInvoker.setTargetMethod(methodName).         methodInvoker.setArguments(arguments).         methodInvoker.prepare().         return methodInvoker.invoke().     } catch (InvocationTargetException ex) {         Throwable targetEx = ex.getTargetException().         if (targetEx instanceof JMSException) {             throw (JMSException) targetEx.         } else {             throw new ListenerExecutionFailedException("Listener method '" + methodName + "' threw exception", targetEx).         }     } catch (Throwable ex) {         throw new ListenerExecutionFailedException("Failed to invoke target method '" + methodName + "' with arguments " + ObjectUtils.nullSafeToString(arguments), ex).     } }
