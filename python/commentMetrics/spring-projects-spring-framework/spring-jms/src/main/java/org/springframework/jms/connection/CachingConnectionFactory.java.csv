commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Specify the desired size for the JMS Session cache (per JMS Session type).  * <p>This cache size is the maximum limit for the number of cached Sessions  * per session acknowledgement type (auto, client, dups_ok, transacted).  * As a consequence, the actual number of cached Sessions may be up to  * four times as high as the specified value - in the unlikely case  * of mixing and matching different acknowledgement types.  * <p>Default is 1: caching a single Session, (re-)creating further ones on  * demand. Specify a number like 10 if you'd like to raise the number of cached  * Sessions. that said, 1 may be sufficient for low-concurrency scenarios.  * @see #setCacheProducers  */ ;/**  * Specify the desired size for the JMS Session cache (per JMS Session type).  * <p>This cache size is the maximum limit for the number of cached Sessions  * per session acknowledgement type (auto, client, dups_ok, transacted).  * As a consequence, the actual number of cached Sessions may be up to  * four times as high as the specified value - in the unlikely case  * of mixing and matching different acknowledgement types.  * <p>Default is 1: caching a single Session, (re-)creating further ones on  * demand. Specify a number like 10 if you'd like to raise the number of cached  * Sessions. that said, 1 may be sufficient for low-concurrency scenarios.  * @see #setCacheProducers  */ public void setSessionCacheSize(int sessionCacheSize) {     Assert.isTrue(sessionCacheSize >= 1, "Session cache size must be 1 or higher").     this.sessionCacheSize = sessionCacheSize. }
true;public;0;3;/**  * Return the desired size for the JMS Session cache (per JMS Session type).  */ ;/**  * Return the desired size for the JMS Session cache (per JMS Session type).  */ public int getSessionCacheSize() {     return this.sessionCacheSize. }
true;public;1;3;/**  * Specify whether to cache JMS MessageProducers per JMS Session instance  * (more specifically: one MessageProducer per Destination and Session).  * <p>Default is "true". Switch this to "false" in order to always  * recreate MessageProducers on demand.  */ ;/**  * Specify whether to cache JMS MessageProducers per JMS Session instance  * (more specifically: one MessageProducer per Destination and Session).  * <p>Default is "true". Switch this to "false" in order to always  * recreate MessageProducers on demand.  */ public void setCacheProducers(boolean cacheProducers) {     this.cacheProducers = cacheProducers. }
true;public;0;3;/**  * Return whether to cache JMS MessageProducers per JMS Session instance.  */ ;/**  * Return whether to cache JMS MessageProducers per JMS Session instance.  */ public boolean isCacheProducers() {     return this.cacheProducers. }
true;public;1;3;/**  * Specify whether to cache JMS MessageConsumers per JMS Session instance  * (more specifically: one MessageConsumer per Destination, selector String  * and Session). Note that durable subscribers will only be cached until  * logical closing of the Session handle.  * <p>Default is "true". Switch this to "false" in order to always  * recreate MessageConsumers on demand.  */ ;/**  * Specify whether to cache JMS MessageConsumers per JMS Session instance  * (more specifically: one MessageConsumer per Destination, selector String  * and Session). Note that durable subscribers will only be cached until  * logical closing of the Session handle.  * <p>Default is "true". Switch this to "false" in order to always  * recreate MessageConsumers on demand.  */ public void setCacheConsumers(boolean cacheConsumers) {     this.cacheConsumers = cacheConsumers. }
true;public;0;3;/**  * Return whether to cache JMS MessageConsumers per JMS Session instance.  */ ;/**  * Return whether to cache JMS MessageConsumers per JMS Session instance.  */ public boolean isCacheConsumers() {     return this.cacheConsumers. }
true;public;0;25;/**  * Resets the Session cache as well.  */ ;/**  * Resets the Session cache as well.  */ @Override public void resetConnection() {     this.active = false.     synchronized (this.cachedSessions) {         for (LinkedList<Session> sessionList : this.cachedSessions.values()) {             synchronized (sessionList) {                 for (Session session : sessionList) {                     try {                         session.close().                     } catch (Throwable ex) {                         logger.trace("Could not close cached JMS Session", ex).                     }                 }             }         }         this.cachedSessions.clear().     }     // Now proceed with actual closing of the shared Connection...     super.resetConnection().     this.active = true. }
true;protected;2;28;/**  * Checks for a cached Session for the given mode.  */ ;/**  * Checks for a cached Session for the given mode.  */ @Override protected Session getSession(Connection con, Integer mode) throws JMSException {     if (!this.active) {         return null.     }     LinkedList<Session> sessionList = this.cachedSessions.computeIfAbsent(mode, k -> new LinkedList<>()).     Session session = null.     synchronized (sessionList) {         if (!sessionList.isEmpty()) {             session = sessionList.removeFirst().         }     }     if (session != null) {         if (logger.isTraceEnabled()) {             logger.trace("Found cached JMS Session for mode " + mode + ": " + (session instanceof SessionProxy ? ((SessionProxy) session).getTargetSession() : session)).         }     } else {         Session targetSession = createSession(con, mode).         if (logger.isDebugEnabled()) {             logger.debug("Registering cached JMS Session for mode " + mode + ": " + targetSession).         }         session = getCachedSessionProxy(targetSession, sessionList).     }     return session. }
true;protected;2;12;/**  * Wrap the given Session with a proxy that delegates every method call to it  * but adapts close calls. This is useful for allowing application code to  * handle a special framework Session just like an ordinary Session.  * @param target the original Session to wrap  * @param sessionList the List of cached Sessions that the given Session belongs to  * @return the wrapped Session  */ ;/**  * Wrap the given Session with a proxy that delegates every method call to it  * but adapts close calls. This is useful for allowing application code to  * handle a special framework Session just like an ordinary Session.  * @param target the original Session to wrap  * @param sessionList the List of cached Sessions that the given Session belongs to  * @return the wrapped Session  */ protected Session getCachedSessionProxy(Session target, LinkedList<Session> sessionList) {     List<Class<?>> classes = new ArrayList<>(3).     classes.add(SessionProxy.class).     if (target instanceof QueueSession) {         classes.add(QueueSession.class).     }     if (target instanceof TopicSession) {         classes.add(TopicSession.class).     }     return (Session) Proxy.newProxyInstance(SessionProxy.class.getClassLoader(), ClassUtils.toClassArray(classes), new CachedSessionInvocationHandler(target, sessionList)). }
false;public;3;105;;@Override @Nullable public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     String methodName = method.getName().     if (methodName.equals("equals")) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (methodName.equals("hashCode")) {         // Use hashCode of Session proxy.         return System.identityHashCode(proxy).     } else if (methodName.equals("toString")) {         return "Cached JMS Session: " + this.target.     } else if (methodName.equals("close")) {         // Handle close method: don't pass the call on.         if (active) {             synchronized (this.sessionList) {                 if (this.sessionList.size() < getSessionCacheSize()) {                     try {                         logicalClose((Session) proxy).                         // Remain open in the session list.                         return null.                     } catch (JMSException ex) {                         logger.trace("Logical close of cached JMS Session failed - discarding it", ex).                     // Proceed to physical close from here...                     }                 }             }         }         // If we get here, we're supposed to shut down.         physicalClose().         return null.     } else if (methodName.equals("getTargetSession")) {         // Handle getTargetSession method: return underlying Session.         return this.target.     } else if (methodName.equals("commit") || methodName.equals("rollback")) {         this.transactionOpen = false.     } else if (methodName.startsWith("create")) {         this.transactionOpen = true.         if (isCacheProducers() && (methodName.equals("createProducer") || methodName.equals("createSender") || methodName.equals("createPublisher"))) {             // Destination argument being null is ok for a producer             Destination dest = (Destination) args[0].             if (!(dest instanceof TemporaryQueue || dest instanceof TemporaryTopic)) {                 return getCachedProducer(dest).             }         } else if (isCacheConsumers()) {             // let raw JMS invocation throw an exception if Destination (i.e. args[0]) is null             if ((methodName.equals("createConsumer") || methodName.equals("createReceiver") || methodName.equals("createSubscriber"))) {                 Destination dest = (Destination) args[0].                 if (dest != null && !(dest instanceof TemporaryQueue || dest instanceof TemporaryTopic)) {                     return getCachedConsumer(dest, (args.length > 1 ? (String) args[1] : null), (args.length > 2 && (Boolean) args[2]), null, false).                 }             } else if (methodName.equals("createDurableConsumer") || methodName.equals("createDurableSubscriber")) {                 Destination dest = (Destination) args[0].                 if (dest != null) {                     return getCachedConsumer(dest, (args.length > 2 ? (String) args[2] : null), (args.length > 3 && (Boolean) args[3]), (String) args[1], true).                 }             } else if (methodName.equals("createSharedConsumer")) {                 Destination dest = (Destination) args[0].                 if (dest != null) {                     return getCachedConsumer(dest, (args.length > 2 ? (String) args[2] : null), null, (String) args[1], false).                 }             } else if (methodName.equals("createSharedDurableConsumer")) {                 Destination dest = (Destination) args[0].                 if (dest != null) {                     return getCachedConsumer(dest, (args.length > 2 ? (String) args[2] : null), null, (String) args[1], true).                 }             }         }     }     try {         return method.invoke(this.target, args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
false;private;1;17;;private MessageProducer getCachedProducer(@Nullable Destination dest) throws JMSException {     DestinationCacheKey cacheKey = (dest != null ? new DestinationCacheKey(dest) : null).     MessageProducer producer = this.cachedProducers.get(cacheKey).     if (producer != null) {         if (logger.isTraceEnabled()) {             logger.trace("Found cached JMS MessageProducer for destination [" + dest + "]: " + producer).         }     } else {         producer = this.target.createProducer(dest).         if (logger.isDebugEnabled()) {             logger.debug("Registering cached JMS MessageProducer for destination [" + dest + "]: " + producer).         }         this.cachedProducers.put(cacheKey, producer).     }     return new CachedMessageProducer(producer). }
false;private;5;33;;private MessageConsumer getCachedConsumer(Destination dest, @Nullable String selector, @Nullable Boolean noLocal, @Nullable String subscription, boolean durable) throws JMSException {     ConsumerCacheKey cacheKey = new ConsumerCacheKey(dest, selector, noLocal, subscription, durable).     MessageConsumer consumer = this.cachedConsumers.get(cacheKey).     if (consumer != null) {         if (logger.isTraceEnabled()) {             logger.trace("Found cached JMS MessageConsumer for destination [" + dest + "]: " + consumer).         }     } else {         if (dest instanceof Topic) {             if (noLocal == null) {                 consumer = (durable ? this.target.createSharedDurableConsumer((Topic) dest, subscription, selector) : this.target.createSharedConsumer((Topic) dest, subscription, selector)).             } else {                 consumer = (durable ? this.target.createDurableSubscriber((Topic) dest, subscription, selector, noLocal) : this.target.createConsumer(dest, selector, noLocal)).             }         } else {             consumer = this.target.createConsumer(dest, selector).         }         if (logger.isDebugEnabled()) {             logger.debug("Registering cached JMS MessageConsumer for destination [" + dest + "]: " + consumer).         }         this.cachedConsumers.put(cacheKey, consumer).     }     return new CachedMessageConsumer(consumer). }
false;private;1;26;;private void logicalClose(Session proxy) throws JMSException {     // Preserve rollback-on-close semantics.     if (this.transactionOpen && this.target.getTransacted()) {         this.transactionOpen = false.         this.target.rollback().     }     // Physically close durable subscribers at time of Session close call.     for (Iterator<Map.Entry<ConsumerCacheKey, MessageConsumer>> it = this.cachedConsumers.entrySet().iterator(). it.hasNext(). ) {         Map.Entry<ConsumerCacheKey, MessageConsumer> entry = it.next().         if (entry.getKey().subscription != null) {             entry.getValue().close().             it.remove().         }     }     // Allow for multiple close calls...     boolean returned = false.     synchronized (this.sessionList) {         if (!this.sessionList.contains(proxy)) {             this.sessionList.addLast(proxy).             returned = true.         }     }     if (returned && logger.isTraceEnabled()) {         logger.trace("Returned cached Session: " + this.target).     } }
false;private;0;21;;private void physicalClose() throws JMSException {     if (logger.isDebugEnabled()) {         logger.debug("Closing cached Session: " + this.target).     }     // this Session happens to cache...     try {         for (MessageProducer producer : this.cachedProducers.values()) {             producer.close().         }         for (MessageConsumer consumer : this.cachedConsumers.values()) {             consumer.close().         }     } finally {         this.cachedProducers.clear().         this.cachedConsumers.clear().         // Now actually close the Session.         this.target.close().     } }
false;private;0;6;;private String getDestinationString() {     if (this.destinationString == null) {         this.destinationString = this.destination.toString().     }     return this.destinationString. }
false;protected;1;5;;protected boolean destinationEquals(DestinationCacheKey otherKey) {     return (this.destination.getClass() == otherKey.destination.getClass() && (this.destination.equals(otherKey.destination) || getDestinationString().equals(otherKey.getDestinationString()))). }
false;public;1;6;;@Override public boolean equals(Object other) {     // On WebSphere MQ, Destination objects do not implement equals...     return (this == other || destinationEquals((DestinationCacheKey) other)). }
false;public;0;7;;@Override public int hashCode() {     // for equivalent destinations... Thanks a lot, WebSphere MQ!     return this.destination.getClass().hashCode(). }
false;public;0;4;;@Override public String toString() {     return getDestinationString(). }
false;public;1;4;;@Override public int compareTo(DestinationCacheKey other) {     return getDestinationString().compareTo(other.getDestinationString()). }
false;public;1;12;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     ConsumerCacheKey otherKey = (ConsumerCacheKey) other.     return (destinationEquals(otherKey) && ObjectUtils.nullSafeEquals(this.selector, otherKey.selector) && ObjectUtils.nullSafeEquals(this.noLocal, otherKey.noLocal) && ObjectUtils.nullSafeEquals(this.subscription, otherKey.subscription) && this.durable == otherKey.durable). }
false;public;0;4;;@Override public int hashCode() {     return 31 * super.hashCode() + ObjectUtils.nullSafeHashCode(this.selector). }
false;public;0;5;;@Override public String toString() {     return super.toString() + " [selector=" + this.selector + ", noLocal=" + this.noLocal + ", subscription=" + this.subscription + ", durable=" + this.durable + "]". }
