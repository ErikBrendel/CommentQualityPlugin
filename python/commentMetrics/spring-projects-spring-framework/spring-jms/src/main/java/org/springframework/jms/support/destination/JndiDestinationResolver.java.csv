commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set whether to cache resolved destinations. Default is "true".  * <p>This flag can be turned off to re-lookup a destination for each operation,  * which allows for hot restarting of destinations. This is mainly useful  * during development.  * <p>Note that dynamic queues and topics get cached by destination name.  * As a consequence, you need to use unique destination names across both  * queues and topics.  */ ;/**  * Set whether to cache resolved destinations. Default is "true".  * <p>This flag can be turned off to re-lookup a destination for each operation,  * which allows for hot restarting of destinations. This is mainly useful  * during development.  * <p>Note that dynamic queues and topics get cached by destination name.  * As a consequence, you need to use unique destination names across both  * queues and topics.  */ public void setCache(boolean cache) {     this.cache = cache. }
true;public;1;3;/**  * Set whether this resolver is supposed to create dynamic destinations  * if the destination name is not found in JNDI. Default is "false".  * <p>Turn this flag on to enable transparent fallback to dynamic destinations.  * @see #setDynamicDestinationResolver  */ ;/**  * Set whether this resolver is supposed to create dynamic destinations  * if the destination name is not found in JNDI. Default is "false".  * <p>Turn this flag on to enable transparent fallback to dynamic destinations.  * @see #setDynamicDestinationResolver  */ public void setFallbackToDynamicDestination(boolean fallbackToDynamicDestination) {     this.fallbackToDynamicDestination = fallbackToDynamicDestination. }
true;public;1;3;/**  * Set the {@link DestinationResolver} to use when falling back to dynamic  * destinations.  * <p>The default is Spring's standard {@link DynamicDestinationResolver}.  * @see #setFallbackToDynamicDestination  * @see DynamicDestinationResolver  */ ;/**  * Set the {@link DestinationResolver} to use when falling back to dynamic  * destinations.  * <p>The default is Spring's standard {@link DynamicDestinationResolver}.  * @see #setFallbackToDynamicDestination  * @see DynamicDestinationResolver  */ public void setDynamicDestinationResolver(DestinationResolver dynamicDestinationResolver) {     this.dynamicDestinationResolver = dynamicDestinationResolver. }
false;public;3;32;;@Override public Destination resolveDestinationName(@Nullable Session session, String destinationName, boolean pubSubDomain) throws JMSException {     Assert.notNull(destinationName, "Destination name must not be null").     Destination dest = this.destinationCache.get(destinationName).     if (dest != null) {         validateDestination(dest, destinationName, pubSubDomain).     } else {         try {             dest = lookup(destinationName, Destination.class).             validateDestination(dest, destinationName, pubSubDomain).         } catch (NamingException ex) {             if (logger.isDebugEnabled()) {                 logger.debug("Destination [" + destinationName + "] not found in JNDI", ex).             }             if (this.fallbackToDynamicDestination) {                 dest = this.dynamicDestinationResolver.resolveDestinationName(session, destinationName, pubSubDomain).             } else {                 throw new DestinationResolutionException("Destination [" + destinationName + "] not found in JNDI", ex).             }         }         if (this.cache) {             this.destinationCache.put(destinationName, dest).         }     }     return dest. }
true;protected;3;10;/**  * Validate the given Destination object, checking whether it matches  * the expected type.  * @param destination the Destination object to validate  * @param destinationName the name of the destination  * @param pubSubDomain {@code true} if a Topic is expected,  * {@code false} in case of a Queue  */ ;/**  * Validate the given Destination object, checking whether it matches  * the expected type.  * @param destination the Destination object to validate  * @param destinationName the name of the destination  * @param pubSubDomain {@code true} if a Topic is expected,  * {@code false} in case of a Queue  */ protected void validateDestination(Destination destination, String destinationName, boolean pubSubDomain) {     Class<?> targetClass = Queue.class.     if (pubSubDomain) {         targetClass = Topic.class.     }     if (!targetClass.isInstance(destination)) {         throw new DestinationResolutionException("Destination [" + destinationName + "] is not of expected type [" + targetClass.getName() + "]").     } }
false;public;1;4;;@Override public void removeFromCache(String destinationName) {     this.destinationCache.remove(destinationName). }
false;public;0;4;;@Override public void clearCache() {     this.destinationCache.clear(). }
