commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;1;1;/**  * Specify concurrency limits.  */ ;/**  * Specify concurrency limits.  */ public abstract void setConcurrency(String concurrency).
true;public;1;7;/**  * Set the destination to receive messages from.  * <p>Alternatively, specify a "destinationName", to be dynamically  * resolved via the {@link org.springframework.jms.support.destination.DestinationResolver}.  * <p>Note: The destination may be replaced at runtime, with the listener  * container picking up the new destination immediately (works e.g. with  * DefaultMessageListenerContainer, as long as the cache level is less than  * CACHE_CONSUMER). However, this is considered advanced usage. use it with care!  * @see #setDestinationName(String)  */ ;/**  * Set the destination to receive messages from.  * <p>Alternatively, specify a "destinationName", to be dynamically  * resolved via the {@link org.springframework.jms.support.destination.DestinationResolver}.  * <p>Note: The destination may be replaced at runtime, with the listener  * container picking up the new destination immediately (works e.g. with  * DefaultMessageListenerContainer, as long as the cache level is less than  * CACHE_CONSUMER). However, this is considered advanced usage. use it with care!  * @see #setDestinationName(String)  */ public void setDestination(@Nullable Destination destination) {     this.destination = destination.     if (destination instanceof Topic && !(destination instanceof Queue)) {         // Clearly a Topic: let's set the "pubSubDomain" flag accordingly.         setPubSubDomain(true).     } }
true;public;0;4;/**  * Return the destination to receive messages from. Will be {@code null}  * if the configured destination is not an actual {@link Destination} type.  * c.f. {@link #setDestinationName(String) when the destination is a String}.  */ ;/**  * Return the destination to receive messages from. Will be {@code null}  * if the configured destination is not an actual {@link Destination} type.  * c.f. {@link #setDestinationName(String) when the destination is a String}.  */ @Nullable public Destination getDestination() {     return (this.destination instanceof Destination ? (Destination) this.destination : null). }
true;public;1;3;/**  * Set the name of the destination to receive messages from.  * <p>The specified name will be dynamically resolved via the configured  * {@link #setDestinationResolver destination resolver}.  * <p>Alternatively, specify a JMS {@link Destination} object as "destination".  * <p>Note: The destination may be replaced at runtime, with the listener  * container picking up the new destination immediately (works e.g. with  * DefaultMessageListenerContainer, as long as the cache level is less than  * CACHE_CONSUMER). However, this is considered advanced usage. use it with care!  * @see #setDestination(javax.jms.Destination)  */ ;/**  * Set the name of the destination to receive messages from.  * <p>The specified name will be dynamically resolved via the configured  * {@link #setDestinationResolver destination resolver}.  * <p>Alternatively, specify a JMS {@link Destination} object as "destination".  * <p>Note: The destination may be replaced at runtime, with the listener  * container picking up the new destination immediately (works e.g. with  * DefaultMessageListenerContainer, as long as the cache level is less than  * CACHE_CONSUMER). However, this is considered advanced usage. use it with care!  * @see #setDestination(javax.jms.Destination)  */ public void setDestinationName(@Nullable String destinationName) {     this.destination = destinationName. }
true;public;0;4;/**  * Return the name of the destination to receive messages from.  * Will be {@code null} if the configured destination is not a  * {@link String} type. c.f. {@link #setDestination(Destination) when  * it is an actual Destination}.  */ ;/**  * Return the name of the destination to receive messages from.  * Will be {@code null} if the configured destination is not a  * {@link String} type. c.f. {@link #setDestination(Destination) when  * it is an actual Destination}.  */ @Nullable public String getDestinationName() {     return (this.destination instanceof String ? (String) this.destination : null). }
true;protected;0;4;/**  * Return a descriptive String for this container's JMS destination  * (never {@code null}).  */ ;/**  * Return a descriptive String for this container's JMS destination  * (never {@code null}).  */ protected String getDestinationDescription() {     Object destination = this.destination.     return (destination != null ? destination.toString() : ""). }
true;public;1;3;/**  * Set the JMS message selector expression (or {@code null} if none).  * Default is none.  * <p>See the JMS specification for a detailed definition of selector expressions.  * <p>Note: The message selector may be replaced at runtime, with the listener  * container picking up the new selector value immediately (works e.g. with  * DefaultMessageListenerContainer, as long as the cache level is less than  * CACHE_CONSUMER). However, this is considered advanced usage. use it with care!  */ ;/**  * Set the JMS message selector expression (or {@code null} if none).  * Default is none.  * <p>See the JMS specification for a detailed definition of selector expressions.  * <p>Note: The message selector may be replaced at runtime, with the listener  * container picking up the new selector value immediately (works e.g. with  * DefaultMessageListenerContainer, as long as the cache level is less than  * CACHE_CONSUMER). However, this is considered advanced usage. use it with care!  */ public void setMessageSelector(@Nullable String messageSelector) {     this.messageSelector = messageSelector. }
true;public;0;4;/**  * Return the JMS message selector expression (or {@code null} if none).  */ ;/**  * Return the JMS message selector expression (or {@code null} if none).  */ @Nullable public String getMessageSelector() {     return this.messageSelector. }
true;public;1;7;/**  * Set the message listener implementation to register.  * This can be either a standard JMS {@link MessageListener} object  * or a Spring {@link SessionAwareMessageListener} object.  * <p>Note: The message listener may be replaced at runtime, with the listener  * container picking up the new listener object immediately (works e.g. with  * DefaultMessageListenerContainer, as long as the cache level is less than  * CACHE_CONSUMER). However, this is considered advanced usage. use it with care!  * @throws IllegalArgumentException if the supplied listener is not a  * {@link MessageListener} or a {@link SessionAwareMessageListener}  * @see javax.jms.MessageListener  * @see SessionAwareMessageListener  */ ;/**  * Set the message listener implementation to register.  * This can be either a standard JMS {@link MessageListener} object  * or a Spring {@link SessionAwareMessageListener} object.  * <p>Note: The message listener may be replaced at runtime, with the listener  * container picking up the new listener object immediately (works e.g. with  * DefaultMessageListenerContainer, as long as the cache level is less than  * CACHE_CONSUMER). However, this is considered advanced usage. use it with care!  * @throws IllegalArgumentException if the supplied listener is not a  * {@link MessageListener} or a {@link SessionAwareMessageListener}  * @see javax.jms.MessageListener  * @see SessionAwareMessageListener  */ public void setMessageListener(@Nullable Object messageListener) {     checkMessageListener(messageListener).     this.messageListener = messageListener.     if (messageListener != null && this.subscriptionName == null) {         this.subscriptionName = getDefaultSubscriptionName(messageListener).     } }
true;public;0;4;/**  * Return the message listener object to register.  */ ;/**  * Return the message listener object to register.  */ @Nullable public Object getMessageListener() {     return this.messageListener. }
true;protected;1;8;/**  * Check the given message listener, throwing an exception  * if it does not correspond to a supported listener type.  * <p>By default, only a standard JMS {@link MessageListener} object or a  * Spring {@link SessionAwareMessageListener} object will be accepted.  * @param messageListener the message listener object to check  * @throws IllegalArgumentException if the supplied listener is not a  * {@link MessageListener} or a {@link SessionAwareMessageListener}  * @see javax.jms.MessageListener  * @see SessionAwareMessageListener  */ ;/**  * Check the given message listener, throwing an exception  * if it does not correspond to a supported listener type.  * <p>By default, only a standard JMS {@link MessageListener} object or a  * Spring {@link SessionAwareMessageListener} object will be accepted.  * @param messageListener the message listener object to check  * @throws IllegalArgumentException if the supplied listener is not a  * {@link MessageListener} or a {@link SessionAwareMessageListener}  * @see javax.jms.MessageListener  * @see SessionAwareMessageListener  */ protected void checkMessageListener(@Nullable Object messageListener) {     if (messageListener != null && !(messageListener instanceof MessageListener || messageListener instanceof SessionAwareMessageListener)) {         throw new IllegalArgumentException("Message listener needs to be of type [" + MessageListener.class.getName() + "] or [" + SessionAwareMessageListener.class.getName() + "]").     } }
true;protected;1;8;/**  * Determine the default subscription name for the given message listener.  * @param messageListener the message listener object to check  * @return the default subscription name  * @see SubscriptionNameProvider  */ ;/**  * Determine the default subscription name for the given message listener.  * @param messageListener the message listener object to check  * @return the default subscription name  * @see SubscriptionNameProvider  */ protected String getDefaultSubscriptionName(Object messageListener) {     if (messageListener instanceof SubscriptionNameProvider) {         return ((SubscriptionNameProvider) messageListener).getSubscriptionName().     } else {         return messageListener.getClass().getName().     } }
true;public;1;6;/**  * Set whether to make the subscription durable. The durable subscription name  * to be used can be specified through the "subscriptionName" property.  * <p>Default is "false". Set this to "true" to register a durable subscription,  * typically in combination with a "subscriptionName" value (unless  * your message listener class name is good enough as subscription name).  * <p>Only makes sense when listening to a topic (pub-sub domain),  * therefore this method switches the "pubSubDomain" flag as well.  * @see #setSubscriptionName  * @see #setPubSubDomain  */ ;/**  * Set whether to make the subscription durable. The durable subscription name  * to be used can be specified through the "subscriptionName" property.  * <p>Default is "false". Set this to "true" to register a durable subscription,  * typically in combination with a "subscriptionName" value (unless  * your message listener class name is good enough as subscription name).  * <p>Only makes sense when listening to a topic (pub-sub domain),  * therefore this method switches the "pubSubDomain" flag as well.  * @see #setSubscriptionName  * @see #setPubSubDomain  */ public void setSubscriptionDurable(boolean subscriptionDurable) {     this.subscriptionDurable = subscriptionDurable.     if (subscriptionDurable) {         setPubSubDomain(true).     } }
true;public;0;3;/**  * Return whether to make the subscription durable.  */ ;/**  * Return whether to make the subscription durable.  */ public boolean isSubscriptionDurable() {     return this.subscriptionDurable. }
true;public;1;6;/**  * Set whether to make the subscription shared. The shared subscription name  * to be used can be specified through the "subscriptionName" property.  * <p>Default is "false". Set this to "true" to register a shared subscription,  * typically in combination with a "subscriptionName" value (unless  * your message listener class name is good enough as subscription name).  * Note that shared subscriptions may also be durable, so this flag can  * (and often will) be combined with "subscriptionDurable" as well.  * <p>Only makes sense when listening to a topic (pub-sub domain),  * therefore this method switches the "pubSubDomain" flag as well.  * <p><b>Requires a JMS 2.0 compatible message broker.</b>  * @since 4.1  * @see #setSubscriptionName  * @see #setSubscriptionDurable  * @see #setPubSubDomain  */ ;/**  * Set whether to make the subscription shared. The shared subscription name  * to be used can be specified through the "subscriptionName" property.  * <p>Default is "false". Set this to "true" to register a shared subscription,  * typically in combination with a "subscriptionName" value (unless  * your message listener class name is good enough as subscription name).  * Note that shared subscriptions may also be durable, so this flag can  * (and often will) be combined with "subscriptionDurable" as well.  * <p>Only makes sense when listening to a topic (pub-sub domain),  * therefore this method switches the "pubSubDomain" flag as well.  * <p><b>Requires a JMS 2.0 compatible message broker.</b>  * @since 4.1  * @see #setSubscriptionName  * @see #setSubscriptionDurable  * @see #setPubSubDomain  */ public void setSubscriptionShared(boolean subscriptionShared) {     this.subscriptionShared = subscriptionShared.     if (subscriptionShared) {         setPubSubDomain(true).     } }
true;public;0;3;/**  * Return whether to make the subscription shared.  * @since 4.1  */ ;/**  * Return whether to make the subscription shared.  * @since 4.1  */ public boolean isSubscriptionShared() {     return this.subscriptionShared. }
true;public;1;3;/**  * Set the name of a subscription to create. To be applied in case  * of a topic (pub-sub domain) with a shared or durable subscription.  * <p>The subscription name needs to be unique within this client's  * JMS client id. Default is the class name of the specified message listener.  * <p>Note: Only 1 concurrent consumer (which is the default of this  * message listener container) is allowed for each subscription,  * except for a shared subscription (which requires JMS 2.0).  * @since 4.1  * @see #setPubSubDomain  * @see #setSubscriptionDurable  * @see #setSubscriptionShared  * @see #setClientId  * @see #setMessageListener  */ ;/**  * Set the name of a subscription to create. To be applied in case  * of a topic (pub-sub domain) with a shared or durable subscription.  * <p>The subscription name needs to be unique within this client's  * JMS client id. Default is the class name of the specified message listener.  * <p>Note: Only 1 concurrent consumer (which is the default of this  * message listener container) is allowed for each subscription,  * except for a shared subscription (which requires JMS 2.0).  * @since 4.1  * @see #setPubSubDomain  * @see #setSubscriptionDurable  * @see #setSubscriptionShared  * @see #setClientId  * @see #setMessageListener  */ public void setSubscriptionName(@Nullable String subscriptionName) {     this.subscriptionName = subscriptionName. }
true;public;0;4;/**  * Return the name of a subscription to create, if any.  * @since 4.1  */ ;/**  * Return the name of a subscription to create, if any.  * @since 4.1  */ @Nullable public String getSubscriptionName() {     return this.subscriptionName. }
true;public;1;4;/**  * Set the name of a durable subscription to create. This method switches  * to pub-sub domain mode and activates subscription durability as well.  * <p>The durable subscription name needs to be unique within this client's  * JMS client id. Default is the class name of the specified message listener.  * <p>Note: Only 1 concurrent consumer (which is the default of this  * message listener container) is allowed for each durable subscription,  * except for a shared durable subscription (which requires JMS 2.0).  * @see #setPubSubDomain  * @see #setSubscriptionDurable  * @see #setSubscriptionShared  * @see #setClientId  * @see #setMessageListener  */ ;/**  * Set the name of a durable subscription to create. This method switches  * to pub-sub domain mode and activates subscription durability as well.  * <p>The durable subscription name needs to be unique within this client's  * JMS client id. Default is the class name of the specified message listener.  * <p>Note: Only 1 concurrent consumer (which is the default of this  * message listener container) is allowed for each durable subscription,  * except for a shared durable subscription (which requires JMS 2.0).  * @see #setPubSubDomain  * @see #setSubscriptionDurable  * @see #setSubscriptionShared  * @see #setClientId  * @see #setMessageListener  */ public void setDurableSubscriptionName(@Nullable String durableSubscriptionName) {     this.subscriptionName = durableSubscriptionName.     this.subscriptionDurable = (durableSubscriptionName != null). }
true;public;0;4;/**  * Return the name of a durable subscription to create, if any.  */ ;/**  * Return the name of a durable subscription to create, if any.  */ @Nullable public String getDurableSubscriptionName() {     return (this.subscriptionDurable ? this.subscriptionName : null). }
true;public;1;3;/**  * Set whether to inhibit the delivery of messages published by its own connection.  * Default is "false".  * @since 4.1  * @see javax.jms.Session#createConsumer(javax.jms.Destination, String, boolean)  */ ;/**  * Set whether to inhibit the delivery of messages published by its own connection.  * Default is "false".  * @since 4.1  * @see javax.jms.Session#createConsumer(javax.jms.Destination, String, boolean)  */ public void setPubSubNoLocal(boolean pubSubNoLocal) {     this.pubSubNoLocal = pubSubNoLocal. }
true;public;0;3;/**  * Return whether to inhibit the delivery of messages published by its own connection.  * @since 4.1  */ ;/**  * Return whether to inhibit the delivery of messages published by its own connection.  * @since 4.1  */ public boolean isPubSubNoLocal() {     return this.pubSubNoLocal. }
true;public;1;3;/**  * Configure the reply destination type. By default, the configured {@code pubSubDomain}  * value is used (see {@link #isPubSubDomain()}.  * <p>This setting primarily indicates what type of destination to resolve if dynamic  * destinations are enabled.  * @param replyPubSubDomain "true" for the Publish/Subscribe domain ({@link Topic Topics}),  * "false" for the Point-to-Point domain ({@link Queue Queues})  * @since 4.2  * @see #setDestinationResolver  */ ;/**  * Configure the reply destination type. By default, the configured {@code pubSubDomain}  * value is used (see {@link #isPubSubDomain()}.  * <p>This setting primarily indicates what type of destination to resolve if dynamic  * destinations are enabled.  * @param replyPubSubDomain "true" for the Publish/Subscribe domain ({@link Topic Topics}),  * "false" for the Point-to-Point domain ({@link Queue Queues})  * @since 4.2  * @see #setDestinationResolver  */ public void setReplyPubSubDomain(boolean replyPubSubDomain) {     this.replyPubSubDomain = replyPubSubDomain. }
true;public;0;9;/**  * Return whether the Publish/Subscribe domain ({@link javax.jms.Topic Topics}) is used  * for replies. Otherwise, the Point-to-Point domain ({@link javax.jms.Queue Queues})  * is used.  * @since 4.2  */ ;/**  * Return whether the Publish/Subscribe domain ({@link javax.jms.Topic Topics}) is used  * for replies. Otherwise, the Point-to-Point domain ({@link javax.jms.Queue Queues})  * is used.  * @since 4.2  */ @Override public boolean isReplyPubSubDomain() {     if (this.replyPubSubDomain != null) {         return this.replyPubSubDomain.     } else {         return isPubSubDomain().     } }
true;public;1;3;/**  * Configure the {@link QosSettings} to use when sending a reply. Can be set to  * {@code null} to indicate that the broker's defaults should be used.  * @param replyQosSettings the QoS settings to use when sending a reply or {@code null}  * to use the default vas.  * @since 5.0  */ ;/**  * Configure the {@link QosSettings} to use when sending a reply. Can be set to  * {@code null} to indicate that the broker's defaults should be used.  * @param replyQosSettings the QoS settings to use when sending a reply or {@code null}  * to use the default vas.  * @since 5.0  */ public void setReplyQosSettings(@Nullable QosSettings replyQosSettings) {     this.replyQosSettings = replyQosSettings. }
false;public;0;5;;@Override @Nullable public QosSettings getReplyQosSettings() {     return this.replyQosSettings. }
true;public;1;3;/**  * Set the {@link MessageConverter} strategy for converting JMS Messages.  * @since 4.1  */ ;/**  * Set the {@link MessageConverter} strategy for converting JMS Messages.  * @since 4.1  */ public void setMessageConverter(@Nullable MessageConverter messageConverter) {     this.messageConverter = messageConverter. }
false;public;0;5;;@Override @Nullable public MessageConverter getMessageConverter() {     return this.messageConverter. }
true;public;1;3;/**  * Set the JMS ExceptionListener to notify in case of a JMSException thrown  * by the registered message listener or the invocation infrastructure.  */ ;/**  * Set the JMS ExceptionListener to notify in case of a JMSException thrown  * by the registered message listener or the invocation infrastructure.  */ public void setExceptionListener(@Nullable ExceptionListener exceptionListener) {     this.exceptionListener = exceptionListener. }
true;public;0;4;/**  * Return the JMS ExceptionListener to notify in case of a JMSException thrown  * by the registered message listener or the invocation infrastructure, if any.  */ ;/**  * Return the JMS ExceptionListener to notify in case of a JMSException thrown  * by the registered message listener or the invocation infrastructure, if any.  */ @Nullable public ExceptionListener getExceptionListener() {     return this.exceptionListener. }
true;public;1;3;/**  * Set the ErrorHandler to be invoked in case of any uncaught exceptions thrown  * while processing a Message.  * <p>By default, there will be <b>no</b> ErrorHandler so that error-level  * logging is the only result.  */ ;/**  * Set the ErrorHandler to be invoked in case of any uncaught exceptions thrown  * while processing a Message.  * <p>By default, there will be <b>no</b> ErrorHandler so that error-level  * logging is the only result.  */ public void setErrorHandler(@Nullable ErrorHandler errorHandler) {     this.errorHandler = errorHandler. }
true;public;0;4;/**  * Return the ErrorHandler to be invoked in case of any uncaught exceptions thrown  * while processing a Message.  * @since 4.1  */ ;/**  * Return the ErrorHandler to be invoked in case of any uncaught exceptions thrown  * while processing a Message.  * @since 4.1  */ @Nullable public ErrorHandler getErrorHandler() {     return this.errorHandler. }
true;public;1;3;/**  * Set whether to expose the listener JMS Session to a registered  * {@link SessionAwareMessageListener} as well as to  * {@link org.springframework.jms.core.JmsTemplate} calls.  * <p>Default is "true", reusing the listener's {@link Session}.  * Turn this off to expose a fresh JMS Session fetched from the same  * underlying JMS {@link Connection} instead, which might be necessary  * on some JMS providers.  * <p>Note that Sessions managed by an external transaction manager will  * always get exposed to {@link org.springframework.jms.core.JmsTemplate}  * calls. So in terms of JmsTemplate exposure, this setting only affects  * locally transacted Sessions.  * @see SessionAwareMessageListener  */ ;/**  * Set whether to expose the listener JMS Session to a registered  * {@link SessionAwareMessageListener} as well as to  * {@link org.springframework.jms.core.JmsTemplate} calls.  * <p>Default is "true", reusing the listener's {@link Session}.  * Turn this off to expose a fresh JMS Session fetched from the same  * underlying JMS {@link Connection} instead, which might be necessary  * on some JMS providers.  * <p>Note that Sessions managed by an external transaction manager will  * always get exposed to {@link org.springframework.jms.core.JmsTemplate}  * calls. So in terms of JmsTemplate exposure, this setting only affects  * locally transacted Sessions.  * @see SessionAwareMessageListener  */ public void setExposeListenerSession(boolean exposeListenerSession) {     this.exposeListenerSession = exposeListenerSession. }
true;public;0;3;/**  * Return whether to expose the listener JMS {@link Session} to a  * registered {@link SessionAwareMessageListener}.  */ ;/**  * Return whether to expose the listener JMS {@link Session} to a  * registered {@link SessionAwareMessageListener}.  */ public boolean isExposeListenerSession() {     return this.exposeListenerSession. }
true;public;1;3;/**  * Set whether to accept received messages while the listener container  * in the process of stopping.  * <p>Default is "false", rejecting such messages through aborting the  * receive attempt. Switch this flag on to fully process such messages  * even in the stopping phase, with the drawback that even newly sent  * messages might still get processed (if coming in before all receive  * timeouts have expired).  * <p><b>NOTE:</b> Aborting receive attempts for such incoming messages  * might lead to the provider's retry count decreasing for the affected  * messages. If you have a high number of concurrent consumers, make sure  * that the number of retries is higher than the number of consumers,  * to be on the safe side for all potential stopping scenarios.  */ ;/**  * Set whether to accept received messages while the listener container  * in the process of stopping.  * <p>Default is "false", rejecting such messages through aborting the  * receive attempt. Switch this flag on to fully process such messages  * even in the stopping phase, with the drawback that even newly sent  * messages might still get processed (if coming in before all receive  * timeouts have expired).  * <p><b>NOTE:</b> Aborting receive attempts for such incoming messages  * might lead to the provider's retry count decreasing for the affected  * messages. If you have a high number of concurrent consumers, make sure  * that the number of retries is higher than the number of consumers,  * to be on the safe side for all potential stopping scenarios.  */ public void setAcceptMessagesWhileStopping(boolean acceptMessagesWhileStopping) {     this.acceptMessagesWhileStopping = acceptMessagesWhileStopping. }
true;public;0;3;/**  * Return whether to accept received messages while the listener container  * in the process of stopping.  */ ;/**  * Return whether to accept received messages while the listener container  * in the process of stopping.  */ public boolean isAcceptMessagesWhileStopping() {     return this.acceptMessagesWhileStopping. }
false;protected;0;6;;@Override protected void validateConfiguration() {     if (this.destination == null) {         throw new IllegalArgumentException("Property 'destination' or 'destinationName' is required").     } }
false;public;1;4;;@Override public void setupMessageListener(Object messageListener) {     setMessageListener(messageListener). }
true;protected;2;8;/**  * Execute the specified listener,  * committing or rolling back the transaction afterwards (if necessary).  * @param session the JMS Session to operate on  * @param message the received JMS Message  * @see #invokeListener  * @see #commitIfNecessary  * @see #rollbackOnExceptionIfNecessary  * @see #handleListenerException  */ ;// ------------------------------------------------------------------------- // Template methods for listener execution // ------------------------------------------------------------------------- /**  * Execute the specified listener,  * committing or rolling back the transaction afterwards (if necessary).  * @param session the JMS Session to operate on  * @param message the received JMS Message  * @see #invokeListener  * @see #commitIfNecessary  * @see #rollbackOnExceptionIfNecessary  * @see #handleListenerException  */ protected void executeListener(Session session, Message message) {     try {         doExecuteListener(session, message).     } catch (Throwable ex) {         handleListenerException(ex).     } }
true;protected;2;19;/**  * Execute the specified listener,  * committing or rolling back the transaction afterwards (if necessary).  * @param session the JMS Session to operate on  * @param message the received JMS Message  * @throws JMSException if thrown by JMS API methods  * @see #invokeListener  * @see #commitIfNecessary  * @see #rollbackOnExceptionIfNecessary  * @see #convertJmsAccessException  */ ;/**  * Execute the specified listener,  * committing or rolling back the transaction afterwards (if necessary).  * @param session the JMS Session to operate on  * @param message the received JMS Message  * @throws JMSException if thrown by JMS API methods  * @see #invokeListener  * @see #commitIfNecessary  * @see #rollbackOnExceptionIfNecessary  * @see #convertJmsAccessException  */ protected void doExecuteListener(Session session, Message message) throws JMSException {     if (!isAcceptMessagesWhileStopping() && !isRunning()) {         if (logger.isWarnEnabled()) {             logger.warn("Rejecting received message because of the listener container " + "having been stopped in the meantime: " + message).         }         rollbackIfNecessary(session).         throw new MessageRejectedWhileStoppingException().     }     try {         invokeListener(session, message).     } catch (JMSException | RuntimeException | Error ex) {         rollbackOnExceptionIfNecessary(session, ex).         throw ex.     }     commitIfNecessary(session, message). }
true;protected;2;18;/**  * Invoke the specified listener: either as standard JMS MessageListener  * or (preferably) as Spring SessionAwareMessageListener.  * @param session the JMS Session to operate on  * @param message the received JMS Message  * @throws JMSException if thrown by JMS API methods  * @see #setMessageListener  */ ;/**  * Invoke the specified listener: either as standard JMS MessageListener  * or (preferably) as Spring SessionAwareMessageListener.  * @param session the JMS Session to operate on  * @param message the received JMS Message  * @throws JMSException if thrown by JMS API methods  * @see #setMessageListener  */ @SuppressWarnings("rawtypes") protected void invokeListener(Session session, Message message) throws JMSException {     Object listener = getMessageListener().     if (listener instanceof SessionAwareMessageListener) {         doInvokeListener((SessionAwareMessageListener) listener, session, message).     } else if (listener instanceof MessageListener) {         doInvokeListener((MessageListener) listener, message).     } else if (listener != null) {         throw new IllegalArgumentException("Only MessageListener and SessionAwareMessageListener supported: " + listener).     } else {         throw new IllegalStateException("No message listener specified - see property 'messageListener'").     } }
true;protected;3;29;/**  * Invoke the specified listener as Spring SessionAwareMessageListener,  * exposing a new JMS Session (potentially with its own transaction)  * to the listener if demanded.  * @param listener the Spring SessionAwareMessageListener to invoke  * @param session the JMS Session to operate on  * @param message the received JMS Message  * @throws JMSException if thrown by JMS API methods  * @see SessionAwareMessageListener  * @see #setExposeListenerSession  */ ;/**  * Invoke the specified listener as Spring SessionAwareMessageListener,  * exposing a new JMS Session (potentially with its own transaction)  * to the listener if demanded.  * @param listener the Spring SessionAwareMessageListener to invoke  * @param session the JMS Session to operate on  * @param message the received JMS Message  * @throws JMSException if thrown by JMS API methods  * @see SessionAwareMessageListener  * @see #setExposeListenerSession  */ @SuppressWarnings({ "unchecked", "rawtypes" }) protected void doInvokeListener(SessionAwareMessageListener listener, Session session, Message message) throws JMSException {     Connection conToClose = null.     Session sessionToClose = null.     try {         Session sessionToUse = session.         if (!isExposeListenerSession()) {             // We need to expose a separate Session.             conToClose = createConnection().             sessionToClose = createSession(conToClose).             sessionToUse = sessionToClose.         }         // Actually invoke the message listener...         listener.onMessage(message, sessionToUse).         // Clean up specially exposed Session, if any.         if (sessionToUse != session) {             if (sessionToUse.getTransacted() && isSessionLocallyTransacted(sessionToUse)) {                 // Transacted session created by this container -> commit.                 JmsUtils.commitIfNecessary(sessionToUse).             }         }     } finally {         JmsUtils.closeSession(sessionToClose).         JmsUtils.closeConnection(conToClose).     } }
true;protected;2;3;/**  * Invoke the specified listener as standard JMS MessageListener.  * <p>Default implementation performs a plain invocation of the  * {@code onMessage} method.  * @param listener the JMS MessageListener to invoke  * @param message the received JMS Message  * @throws JMSException if thrown by JMS API methods  * @see javax.jms.MessageListener#onMessage  */ ;/**  * Invoke the specified listener as standard JMS MessageListener.  * <p>Default implementation performs a plain invocation of the  * {@code onMessage} method.  * @param listener the JMS MessageListener to invoke  * @param message the received JMS Message  * @throws JMSException if thrown by JMS API methods  * @see javax.jms.MessageListener#onMessage  */ protected void doInvokeListener(MessageListener listener, Message message) throws JMSException {     listener.onMessage(message). }
true;protected;2;13;/**  * Perform a commit or message acknowledgement, as appropriate.  * @param session the JMS Session to commit  * @param message the Message to acknowledge  * @throws javax.jms.JMSException in case of commit failure  */ ;/**  * Perform a commit or message acknowledgement, as appropriate.  * @param session the JMS Session to commit  * @param message the Message to acknowledge  * @throws javax.jms.JMSException in case of commit failure  */ protected void commitIfNecessary(Session session, @Nullable Message message) throws JMSException {     // Commit session or acknowledge message.     if (session.getTransacted()) {         // Commit necessary - but avoid commit call within a JTA transaction.         if (isSessionLocallyTransacted(session)) {             // Transacted session created by this container -> commit.             JmsUtils.commitIfNecessary(session).         }     } else if (message != null && isClientAcknowledge(session)) {         message.acknowledge().     } }
true;protected;1;11;/**  * Perform a rollback, if appropriate.  * @param session the JMS Session to rollback  * @throws javax.jms.JMSException in case of a rollback error  */ ;/**  * Perform a rollback, if appropriate.  * @param session the JMS Session to rollback  * @throws javax.jms.JMSException in case of a rollback error  */ protected void rollbackIfNecessary(Session session) throws JMSException {     if (session.getTransacted()) {         if (isSessionLocallyTransacted(session)) {             // Transacted session created by this container -> rollback.             JmsUtils.rollbackIfNecessary(session).         }     } else if (isClientAcknowledge(session)) {         session.recover().     } }
true;protected;2;23;/**  * Perform a rollback, handling rollback exceptions properly.  * @param session the JMS Session to rollback  * @param ex the thrown application exception or error  * @throws javax.jms.JMSException in case of a rollback error  */ ;/**  * Perform a rollback, handling rollback exceptions properly.  * @param session the JMS Session to rollback  * @param ex the thrown application exception or error  * @throws javax.jms.JMSException in case of a rollback error  */ protected void rollbackOnExceptionIfNecessary(Session session, Throwable ex) throws JMSException {     try {         if (session.getTransacted()) {             if (isSessionLocallyTransacted(session)) {                 // Transacted session created by this container -> rollback.                 if (logger.isDebugEnabled()) {                     logger.debug("Initiating transaction rollback on application exception", ex).                 }                 JmsUtils.rollbackIfNecessary(session).             }         } else if (isClientAcknowledge(session)) {             session.recover().         }     } catch (IllegalStateException ex2) {         logger.debug("Could not roll back because Session already closed", ex2).     } catch (JMSException | RuntimeException | Error ex2) {         logger.error("Application exception overridden by rollback error", ex).         throw ex2.     } }
true;protected;1;3;/**  * Check whether the given Session is locally transacted, that is, whether  * its transaction is managed by this listener container's Session handling  * and not by an external transaction coordinator.  * <p>Note: The Session's own transacted flag will already have been checked  * before. This method is about finding out whether the Session's transaction  * is local or externally coordinated.  * @param session the Session to check  * @return whether the given Session is locally transacted  * @see #isSessionTransacted()  * @see org.springframework.jms.connection.ConnectionFactoryUtils#isSessionTransactional  */ ;/**  * Check whether the given Session is locally transacted, that is, whether  * its transaction is managed by this listener container's Session handling  * and not by an external transaction coordinator.  * <p>Note: The Session's own transacted flag will already have been checked  * before. This method is about finding out whether the Session's transaction  * is local or externally coordinated.  * @param session the Session to check  * @return whether the given Session is locally transacted  * @see #isSessionTransacted()  * @see org.springframework.jms.connection.ConnectionFactoryUtils#isSessionTransactional  */ protected boolean isSessionLocallyTransacted(Session session) {     return isSessionTransacted(). }
true;protected;2;22;/**  * Create a JMS MessageConsumer for the given Session and Destination.  * <p>This implementation uses JMS 1.1 API.  * @param session the JMS Session to create a MessageConsumer for  * @param destination the JMS Destination to create a MessageConsumer for  * @return the new JMS MessageConsumer  * @throws javax.jms.JMSException if thrown by JMS API methods  */ ;/**  * Create a JMS MessageConsumer for the given Session and Destination.  * <p>This implementation uses JMS 1.1 API.  * @param session the JMS Session to create a MessageConsumer for  * @param destination the JMS Destination to create a MessageConsumer for  * @return the new JMS MessageConsumer  * @throws javax.jms.JMSException if thrown by JMS API methods  */ protected MessageConsumer createConsumer(Session session, Destination destination) throws JMSException {     if (isPubSubDomain() && destination instanceof Topic) {         if (isSubscriptionShared()) {             return (isSubscriptionDurable() ? session.createSharedDurableConsumer((Topic) destination, getSubscriptionName(), getMessageSelector()) : session.createSharedConsumer((Topic) destination, getSubscriptionName(), getMessageSelector())).         } else if (isSubscriptionDurable()) {             return session.createDurableSubscriber((Topic) destination, getSubscriptionName(), getMessageSelector(), isPubSubNoLocal()).         } else {             // in case of the NoLocal flag being specified for a Queue.             return session.createConsumer(destination, getMessageSelector(), isPubSubNoLocal()).         }     } else {         return session.createConsumer(destination, getMessageSelector()).     } }
true;protected;1;19;/**  * Handle the given exception that arose during listener execution.  * <p>The default implementation logs the exception at warn level,  * not propagating it to the JMS provider &mdash. assuming that all handling of  * acknowledgement and/or transactions is done by this listener container.  * This can be overridden in subclasses.  * @param ex the exception to handle  */ ;/**  * Handle the given exception that arose during listener execution.  * <p>The default implementation logs the exception at warn level,  * not propagating it to the JMS provider &mdash. assuming that all handling of  * acknowledgement and/or transactions is done by this listener container.  * This can be overridden in subclasses.  * @param ex the exception to handle  */ protected void handleListenerException(Throwable ex) {     if (ex instanceof MessageRejectedWhileStoppingException) {         // Internal exception - has been handled before.         return.     }     if (ex instanceof JMSException) {         invokeExceptionListener((JMSException) ex).     }     if (isActive()) {         // Regular case: failed while active.         // Invoke ErrorHandler if available.         invokeErrorHandler(ex).     } else {         // Rare case: listener thread failed after container shutdown.         // Log at debug level, to avoid spamming the shutdown log.         logger.debug("Listener exception after container shutdown", ex).     } }
true;protected;1;6;/**  * Invoke the registered JMS ExceptionListener, if any.  * @param ex the exception that arose during JMS processing  * @see #setExceptionListener  */ ;/**  * Invoke the registered JMS ExceptionListener, if any.  * @param ex the exception that arose during JMS processing  * @see #setExceptionListener  */ protected void invokeExceptionListener(JMSException ex) {     ExceptionListener exceptionListener = getExceptionListener().     if (exceptionListener != null) {         exceptionListener.onException(ex).     } }
true;protected;1;9;/**  * Invoke the registered ErrorHandler, if any. Log at warn level otherwise.  * @param ex the uncaught error that arose during JMS processing.  * @see #setErrorHandler  */ ;/**  * Invoke the registered ErrorHandler, if any. Log at warn level otherwise.  * @param ex the uncaught error that arose during JMS processing.  * @see #setErrorHandler  */ protected void invokeErrorHandler(Throwable ex) {     ErrorHandler errorHandler = getErrorHandler().     if (errorHandler != null) {         errorHandler.handleError(ex).     } else {         logger.warn("Execution of JMS message listener failed, and no ErrorHandler has been set.", ex).     } }
