# id;timestamp;commentText;codeText;commentWords;codeWords
ConnectionFactoryUtils -> public static QueueSession getTransactionalQueueSession( 			final QueueConnectionFactory cf, final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1328020251;Obtain a JMS QueueSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be <code>null</code>)_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or <code>null</code> if none found_@throws JMSException in case of JMS failure;public static QueueSession getTransactionalQueueSession(_			final QueueConnectionFactory cf, final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(QueueSession.class, existingCon)__			}_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class))__			}_			public Connection createConnection() throws JMSException {_				return cf.createQueueConnection()__			}_			public Session createSession(Connection con) throws JMSException {_				return ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,queue,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,code,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,code,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,queue,session,get,transactional,queue,session,final,queue,connection,factory,cf,final,queue,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,queue,session,do,get,transactional,session,cf,new,resource,factory,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,queue,session,class,existing,con,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,queue,connection,class,public,connection,create,connection,throws,jmsexception,return,cf,create,queue,connection,public,session,create,session,connection,con,throws,jmsexception,return,queue,connection,con,create,queue,session,synched,local,transaction,allowed,session,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static QueueSession getTransactionalQueueSession( 			final QueueConnectionFactory cf, final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1356735495;Obtain a JMS QueueSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static QueueSession getTransactionalQueueSession(_			final QueueConnectionFactory cf, final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(QueueSession.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class))__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createQueueConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,queue,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,queue,session,get,transactional,queue,session,final,queue,connection,factory,cf,final,queue,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,queue,session,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,queue,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,queue,connection,class,override,public,connection,create,connection,throws,jmsexception,return,cf,create,queue,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,queue,connection,con,create,queue,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static QueueSession getTransactionalQueueSession( 			final QueueConnectionFactory cf, final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1357119239;Obtain a JMS QueueSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static QueueSession getTransactionalQueueSession(_			final QueueConnectionFactory cf, final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(QueueSession.class, existingCon)__			}_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class))__			}_			public Connection createConnection() throws JMSException {_				return cf.createQueueConnection()__			}_			public Session createSession(Connection con) throws JMSException {_				return ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,queue,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,queue,session,get,transactional,queue,session,final,queue,connection,factory,cf,final,queue,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,queue,session,do,get,transactional,session,cf,new,resource,factory,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,queue,session,class,existing,con,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,queue,connection,class,public,connection,create,connection,throws,jmsexception,return,cf,create,queue,connection,public,session,create,session,connection,con,throws,jmsexception,return,queue,connection,con,create,queue,session,synched,local,transaction,allowed,session,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static QueueSession getTransactionalQueueSession( 			final QueueConnectionFactory cf, final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1368482696;Obtain a JMS QueueSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static QueueSession getTransactionalQueueSession(_			final QueueConnectionFactory cf, final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(QueueSession.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class))__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createQueueConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,queue,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,queue,session,get,transactional,queue,session,final,queue,connection,factory,cf,final,queue,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,queue,session,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,queue,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,queue,connection,class,override,public,connection,create,connection,throws,jmsexception,return,cf,create,queue,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,queue,connection,con,create,queue,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> ResourceFactory -> Connection createConnection() throws JMSException_;1328020251;Create a new JMS Connection for registration with a JmsResourceHolder._@return the new JMS Connection_@throws JMSException if thrown by JMS API methods;Connection createConnection() throws JMSException_;create,a,new,jms,connection,for,registration,with,a,jms,resource,holder,return,the,new,jms,connection,throws,jmsexception,if,thrown,by,jms,api,methods;connection,create,connection,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Connection createConnection() throws JMSException_;1356735495;Create a new JMS Connection for registration with a JmsResourceHolder._@return the new JMS Connection_@throws JMSException if thrown by JMS API methods;Connection createConnection() throws JMSException_;create,a,new,jms,connection,for,registration,with,a,jms,resource,holder,return,the,new,jms,connection,throws,jmsexception,if,thrown,by,jms,api,methods;connection,create,connection,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Connection createConnection() throws JMSException_;1357119239;Create a new JMS Connection for registration with a JmsResourceHolder._@return the new JMS Connection_@throws JMSException if thrown by JMS API methods;Connection createConnection() throws JMSException_;create,a,new,jms,connection,for,registration,with,a,jms,resource,holder,return,the,new,jms,connection,throws,jmsexception,if,thrown,by,jms,api,methods;connection,create,connection,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Connection createConnection() throws JMSException_;1368482696;Create a new JMS Connection for registration with a JmsResourceHolder._@return the new JMS Connection_@throws JMSException if thrown by JMS API methods;Connection createConnection() throws JMSException_;create,a,new,jms,connection,for,registration,with,a,jms,resource,holder,return,the,new,jms,connection,throws,jmsexception,if,thrown,by,jms,api,methods;connection,create,connection,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Connection createConnection() throws JMSException_;1486720600;Create a new JMS Connection for registration with a JmsResourceHolder._@return the new JMS Connection_@throws JMSException if thrown by JMS API methods;Connection createConnection() throws JMSException_;create,a,new,jms,connection,for,registration,with,a,jms,resource,holder,return,the,new,jms,connection,throws,jmsexception,if,thrown,by,jms,api,methods;connection,create,connection,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Connection createConnection() throws JMSException_;1495868221;Create a new JMS Connection for registration with a JmsResourceHolder._@return the new JMS Connection_@throws JMSException if thrown by JMS API methods;Connection createConnection() throws JMSException_;create,a,new,jms,connection,for,registration,with,a,jms,resource,holder,return,the,new,jms,connection,throws,jmsexception,if,thrown,by,jms,api,methods;connection,create,connection,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Connection createConnection() throws JMSException_;1496837955;Create a new JMS Connection for registration with a JmsResourceHolder._@return the new JMS Connection_@throws JMSException if thrown by JMS API methods;Connection createConnection() throws JMSException_;create,a,new,jms,connection,for,registration,with,a,jms,resource,holder,return,the,new,jms,connection,throws,jmsexception,if,thrown,by,jms,api,methods;connection,create,connection,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Connection createConnection() throws JMSException_;1502974979;Create a new JMS Connection for registration with a JmsResourceHolder._@return the new JMS Connection_@throws JMSException if thrown by JMS API methods;Connection createConnection() throws JMSException_;create,a,new,jms,connection,for,registration,with,a,jms,resource,holder,return,the,new,jms,connection,throws,jmsexception,if,thrown,by,jms,api,methods;connection,create,connection,throws,jmsexception
ConnectionFactoryUtils -> @Nullable 	public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection) 			throws JMSException;1495868221;Obtain a JMS Session that is synchronized with the current transaction, if any._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@param startConnection whether the underlying JMS Connection approach should be_started in order to allow for receiving messages. Note that a reused Connection_may already have been started before, even if this flag is {@code false}._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)_			throws JMSException {__		Assert.notNull(connectionFactory, "ConnectionFactory must not be null")__		Assert.notNull(resourceFactory, "ResourceFactory must not be null")___		JmsResourceHolder resourceHolder =_				(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory)__		if (resourceHolder != null) {_			Session session = resourceFactory.getSession(resourceHolder)__			if (session != null) {_				if (startConnection) {_					Connection con = resourceFactory.getConnection(resourceHolder)__					if (con != null) {_						con.start()__					}_				}_				return session__			}_			if (resourceHolder.isFrozen()) {_				return null__			}_		}_		if (!TransactionSynchronizationManager.isSynchronizationActive()) {_			return null__		}_		JmsResourceHolder resourceHolderToUse = resourceHolder__		if (resourceHolderToUse == null) {_			resourceHolderToUse = new JmsResourceHolder(connectionFactory)__		}_		Connection con = resourceFactory.getConnection(resourceHolderToUse)__		Session session = null__		try {_			boolean isExistingCon = (con != null)__			if (!isExistingCon) {_				con = resourceFactory.createConnection()__				resourceHolderToUse.addConnection(con)__			}_			session = resourceFactory.createSession(con)__			resourceHolderToUse.addSession(session, con)__			if (startConnection) {_				con.start()__			}_		}_		catch (JMSException ex) {_			if (session != null) {_				try {_					session.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			if (con != null) {_				try {_					con.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			throw ex__		}_		if (resourceHolderToUse != resourceHolder) {_			TransactionSynchronizationManager.registerSynchronization(_					new JmsResourceSynchronization(resourceHolderToUse, connectionFactory,_							resourceFactory.isSynchedLocalTransactionAllowed()))__			resourceHolderToUse.setSynchronizedWithTransaction(true)__			TransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse)__		}_		return session__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,param,start,connection,whether,the,underlying,jms,connection,approach,should,be,started,in,order,to,allow,for,receiving,messages,note,that,a,reused,connection,may,already,have,been,started,before,even,if,this,flag,is,code,false,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,boolean,start,connection,throws,jmsexception,assert,not,null,connection,factory,connection,factory,must,not,be,null,assert,not,null,resource,factory,resource,factory,must,not,be,null,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,connection,factory,if,resource,holder,null,session,session,resource,factory,get,session,resource,holder,if,session,null,if,start,connection,connection,con,resource,factory,get,connection,resource,holder,if,con,null,con,start,return,session,if,resource,holder,is,frozen,return,null,if,transaction,synchronization,manager,is,synchronization,active,return,null,jms,resource,holder,resource,holder,to,use,resource,holder,if,resource,holder,to,use,null,resource,holder,to,use,new,jms,resource,holder,connection,factory,connection,con,resource,factory,get,connection,resource,holder,to,use,session,session,null,try,boolean,is,existing,con,con,null,if,is,existing,con,con,resource,factory,create,connection,resource,holder,to,use,add,connection,con,session,resource,factory,create,session,con,resource,holder,to,use,add,session,session,con,if,start,connection,con,start,catch,jmsexception,ex,if,session,null,try,session,close,catch,throwable,ex2,if,con,null,try,con,close,catch,throwable,ex2,throw,ex,if,resource,holder,to,use,resource,holder,transaction,synchronization,manager,register,synchronization,new,jms,resource,synchronization,resource,holder,to,use,connection,factory,resource,factory,is,synched,local,transaction,allowed,resource,holder,to,use,set,synchronized,with,transaction,true,transaction,synchronization,manager,bind,resource,connection,factory,resource,holder,to,use,return,session
ConnectionFactoryUtils -> @Nullable 	public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection) 			throws JMSException;1496837955;Obtain a JMS Session that is synchronized with the current transaction, if any._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@param startConnection whether the underlying JMS Connection approach should be_started in order to allow for receiving messages. Note that a reused Connection_may already have been started before, even if this flag is {@code false}._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)_			throws JMSException {__		Assert.notNull(connectionFactory, "ConnectionFactory must not be null")__		Assert.notNull(resourceFactory, "ResourceFactory must not be null")___		JmsResourceHolder resourceHolder =_				(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory)__		if (resourceHolder != null) {_			Session session = resourceFactory.getSession(resourceHolder)__			if (session != null) {_				if (startConnection) {_					Connection con = resourceFactory.getConnection(resourceHolder)__					if (con != null) {_						con.start()__					}_				}_				return session__			}_			if (resourceHolder.isFrozen()) {_				return null__			}_		}_		if (!TransactionSynchronizationManager.isSynchronizationActive()) {_			return null__		}_		JmsResourceHolder resourceHolderToUse = resourceHolder__		if (resourceHolderToUse == null) {_			resourceHolderToUse = new JmsResourceHolder(connectionFactory)__		}_		Connection con = resourceFactory.getConnection(resourceHolderToUse)__		Session session = null__		try {_			boolean isExistingCon = (con != null)__			if (!isExistingCon) {_				con = resourceFactory.createConnection()__				resourceHolderToUse.addConnection(con)__			}_			session = resourceFactory.createSession(con)__			resourceHolderToUse.addSession(session, con)__			if (startConnection) {_				con.start()__			}_		}_		catch (JMSException ex) {_			if (session != null) {_				try {_					session.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			if (con != null) {_				try {_					con.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			throw ex__		}_		if (resourceHolderToUse != resourceHolder) {_			TransactionSynchronizationManager.registerSynchronization(_					new JmsResourceSynchronization(resourceHolderToUse, connectionFactory,_							resourceFactory.isSynchedLocalTransactionAllowed()))__			resourceHolderToUse.setSynchronizedWithTransaction(true)__			TransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse)__		}_		return session__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,param,start,connection,whether,the,underlying,jms,connection,approach,should,be,started,in,order,to,allow,for,receiving,messages,note,that,a,reused,connection,may,already,have,been,started,before,even,if,this,flag,is,code,false,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,boolean,start,connection,throws,jmsexception,assert,not,null,connection,factory,connection,factory,must,not,be,null,assert,not,null,resource,factory,resource,factory,must,not,be,null,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,connection,factory,if,resource,holder,null,session,session,resource,factory,get,session,resource,holder,if,session,null,if,start,connection,connection,con,resource,factory,get,connection,resource,holder,if,con,null,con,start,return,session,if,resource,holder,is,frozen,return,null,if,transaction,synchronization,manager,is,synchronization,active,return,null,jms,resource,holder,resource,holder,to,use,resource,holder,if,resource,holder,to,use,null,resource,holder,to,use,new,jms,resource,holder,connection,factory,connection,con,resource,factory,get,connection,resource,holder,to,use,session,session,null,try,boolean,is,existing,con,con,null,if,is,existing,con,con,resource,factory,create,connection,resource,holder,to,use,add,connection,con,session,resource,factory,create,session,con,resource,holder,to,use,add,session,session,con,if,start,connection,con,start,catch,jmsexception,ex,if,session,null,try,session,close,catch,throwable,ex2,if,con,null,try,con,close,catch,throwable,ex2,throw,ex,if,resource,holder,to,use,resource,holder,transaction,synchronization,manager,register,synchronization,new,jms,resource,synchronization,resource,holder,to,use,connection,factory,resource,factory,is,synched,local,transaction,allowed,resource,holder,to,use,set,synchronized,with,transaction,true,transaction,synchronization,manager,bind,resource,connection,factory,resource,holder,to,use,return,session
ConnectionFactoryUtils -> @Nullable 	public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection) 			throws JMSException;1502974979;Obtain a JMS Session that is synchronized with the current transaction, if any._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@param startConnection whether the underlying JMS Connection approach should be_started in order to allow for receiving messages. Note that a reused Connection_may already have been started before, even if this flag is {@code false}._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)_			throws JMSException {__		Assert.notNull(connectionFactory, "ConnectionFactory must not be null")__		Assert.notNull(resourceFactory, "ResourceFactory must not be null")___		JmsResourceHolder resourceHolder =_				(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory)__		if (resourceHolder != null) {_			Session session = resourceFactory.getSession(resourceHolder)__			if (session != null) {_				if (startConnection) {_					Connection con = resourceFactory.getConnection(resourceHolder)__					if (con != null) {_						con.start()__					}_				}_				return session__			}_			if (resourceHolder.isFrozen()) {_				return null__			}_		}_		if (!TransactionSynchronizationManager.isSynchronizationActive()) {_			return null__		}_		JmsResourceHolder resourceHolderToUse = resourceHolder__		if (resourceHolderToUse == null) {_			resourceHolderToUse = new JmsResourceHolder(connectionFactory)__		}_		Connection con = resourceFactory.getConnection(resourceHolderToUse)__		Session session = null__		try {_			boolean isExistingCon = (con != null)__			if (!isExistingCon) {_				con = resourceFactory.createConnection()__				resourceHolderToUse.addConnection(con)__			}_			session = resourceFactory.createSession(con)__			resourceHolderToUse.addSession(session, con)__			if (startConnection) {_				con.start()__			}_		}_		catch (JMSException ex) {_			if (session != null) {_				try {_					session.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			if (con != null) {_				try {_					con.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			throw ex__		}_		if (resourceHolderToUse != resourceHolder) {_			TransactionSynchronizationManager.registerSynchronization(_					new JmsResourceSynchronization(resourceHolderToUse, connectionFactory,_							resourceFactory.isSynchedLocalTransactionAllowed()))__			resourceHolderToUse.setSynchronizedWithTransaction(true)__			TransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse)__		}_		return session__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,param,start,connection,whether,the,underlying,jms,connection,approach,should,be,started,in,order,to,allow,for,receiving,messages,note,that,a,reused,connection,may,already,have,been,started,before,even,if,this,flag,is,code,false,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,boolean,start,connection,throws,jmsexception,assert,not,null,connection,factory,connection,factory,must,not,be,null,assert,not,null,resource,factory,resource,factory,must,not,be,null,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,connection,factory,if,resource,holder,null,session,session,resource,factory,get,session,resource,holder,if,session,null,if,start,connection,connection,con,resource,factory,get,connection,resource,holder,if,con,null,con,start,return,session,if,resource,holder,is,frozen,return,null,if,transaction,synchronization,manager,is,synchronization,active,return,null,jms,resource,holder,resource,holder,to,use,resource,holder,if,resource,holder,to,use,null,resource,holder,to,use,new,jms,resource,holder,connection,factory,connection,con,resource,factory,get,connection,resource,holder,to,use,session,session,null,try,boolean,is,existing,con,con,null,if,is,existing,con,con,resource,factory,create,connection,resource,holder,to,use,add,connection,con,session,resource,factory,create,session,con,resource,holder,to,use,add,session,session,con,if,start,connection,con,start,catch,jmsexception,ex,if,session,null,try,session,close,catch,throwable,ex2,if,con,null,try,con,close,catch,throwable,ex2,throw,ex,if,resource,holder,to,use,resource,holder,transaction,synchronization,manager,register,synchronization,new,jms,resource,synchronization,resource,holder,to,use,connection,factory,resource,factory,is,synched,local,transaction,allowed,resource,holder,to,use,set,synchronized,with,transaction,true,transaction,synchronization,manager,bind,resource,connection,factory,resource,holder,to,use,return,session
ConnectionFactoryUtils -> public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection) 			throws JMSException;1328020251;Obtain a JMS Session that is synchronized with the current transaction, if any._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@param startConnection whether the underlying JMS Connection approach should be_started in order to allow for receiving messages. Note that a reused Connection_may already have been started before, even if this flag is <code>false</code>._@return the transactional Session, or <code>null</code> if none found_@throws JMSException in case of JMS failure;public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)_			throws JMSException {__		Assert.notNull(connectionFactory, "ConnectionFactory must not be null")__		Assert.notNull(resourceFactory, "ResourceFactory must not be null")___		JmsResourceHolder resourceHolder =_				(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory)__		if (resourceHolder != null) {_			Session session = resourceFactory.getSession(resourceHolder)__			if (session != null) {_				if (startConnection) {_					Connection con = resourceFactory.getConnection(resourceHolder)__					if (con != null) {_						con.start()__					}_				}_				return session__			}_			if (resourceHolder.isFrozen()) {_				return null__			}_		}_		if (!TransactionSynchronizationManager.isSynchronizationActive()) {_			return null__		}_		JmsResourceHolder resourceHolderToUse = resourceHolder__		if (resourceHolderToUse == null) {_			resourceHolderToUse = new JmsResourceHolder(connectionFactory)__		}_		Connection con = resourceFactory.getConnection(resourceHolderToUse)__		Session session = null__		try {_			boolean isExistingCon = (con != null)__			if (!isExistingCon) {_				con = resourceFactory.createConnection()__				resourceHolderToUse.addConnection(con)__			}_			session = resourceFactory.createSession(con)__			resourceHolderToUse.addSession(session, con)__			if (startConnection) {_				con.start()__			}_		}_		catch (JMSException ex) {_			if (session != null) {_				try {_					session.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			if (con != null) {_				try {_					con.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			throw ex__		}_		if (resourceHolderToUse != resourceHolder) {_			TransactionSynchronizationManager.registerSynchronization(_					new JmsResourceSynchronization(_							resourceHolderToUse, connectionFactory, resourceFactory.isSynchedLocalTransactionAllowed()))__			resourceHolderToUse.setSynchronizedWithTransaction(true)__			TransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse)__		}_		return session__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,param,start,connection,whether,the,underlying,jms,connection,approach,should,be,started,in,order,to,allow,for,receiving,messages,note,that,a,reused,connection,may,already,have,been,started,before,even,if,this,flag,is,code,false,code,return,the,transactional,session,or,code,null,code,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,boolean,start,connection,throws,jmsexception,assert,not,null,connection,factory,connection,factory,must,not,be,null,assert,not,null,resource,factory,resource,factory,must,not,be,null,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,connection,factory,if,resource,holder,null,session,session,resource,factory,get,session,resource,holder,if,session,null,if,start,connection,connection,con,resource,factory,get,connection,resource,holder,if,con,null,con,start,return,session,if,resource,holder,is,frozen,return,null,if,transaction,synchronization,manager,is,synchronization,active,return,null,jms,resource,holder,resource,holder,to,use,resource,holder,if,resource,holder,to,use,null,resource,holder,to,use,new,jms,resource,holder,connection,factory,connection,con,resource,factory,get,connection,resource,holder,to,use,session,session,null,try,boolean,is,existing,con,con,null,if,is,existing,con,con,resource,factory,create,connection,resource,holder,to,use,add,connection,con,session,resource,factory,create,session,con,resource,holder,to,use,add,session,session,con,if,start,connection,con,start,catch,jmsexception,ex,if,session,null,try,session,close,catch,throwable,ex2,if,con,null,try,con,close,catch,throwable,ex2,throw,ex,if,resource,holder,to,use,resource,holder,transaction,synchronization,manager,register,synchronization,new,jms,resource,synchronization,resource,holder,to,use,connection,factory,resource,factory,is,synched,local,transaction,allowed,resource,holder,to,use,set,synchronized,with,transaction,true,transaction,synchronization,manager,bind,resource,connection,factory,resource,holder,to,use,return,session
ConnectionFactoryUtils -> public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection) 			throws JMSException;1356735495;Obtain a JMS Session that is synchronized with the current transaction, if any._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@param startConnection whether the underlying JMS Connection approach should be_started in order to allow for receiving messages. Note that a reused Connection_may already have been started before, even if this flag is {@code false}._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)_			throws JMSException {__		Assert.notNull(connectionFactory, "ConnectionFactory must not be null")__		Assert.notNull(resourceFactory, "ResourceFactory must not be null")___		JmsResourceHolder resourceHolder =_				(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory)__		if (resourceHolder != null) {_			Session session = resourceFactory.getSession(resourceHolder)__			if (session != null) {_				if (startConnection) {_					Connection con = resourceFactory.getConnection(resourceHolder)__					if (con != null) {_						con.start()__					}_				}_				return session__			}_			if (resourceHolder.isFrozen()) {_				return null__			}_		}_		if (!TransactionSynchronizationManager.isSynchronizationActive()) {_			return null__		}_		JmsResourceHolder resourceHolderToUse = resourceHolder__		if (resourceHolderToUse == null) {_			resourceHolderToUse = new JmsResourceHolder(connectionFactory)__		}_		Connection con = resourceFactory.getConnection(resourceHolderToUse)__		Session session = null__		try {_			boolean isExistingCon = (con != null)__			if (!isExistingCon) {_				con = resourceFactory.createConnection()__				resourceHolderToUse.addConnection(con)__			}_			session = resourceFactory.createSession(con)__			resourceHolderToUse.addSession(session, con)__			if (startConnection) {_				con.start()__			}_		}_		catch (JMSException ex) {_			if (session != null) {_				try {_					session.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			if (con != null) {_				try {_					con.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			throw ex__		}_		if (resourceHolderToUse != resourceHolder) {_			TransactionSynchronizationManager.registerSynchronization(_					new JmsResourceSynchronization(_							resourceHolderToUse, connectionFactory, resourceFactory.isSynchedLocalTransactionAllowed()))__			resourceHolderToUse.setSynchronizedWithTransaction(true)__			TransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse)__		}_		return session__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,param,start,connection,whether,the,underlying,jms,connection,approach,should,be,started,in,order,to,allow,for,receiving,messages,note,that,a,reused,connection,may,already,have,been,started,before,even,if,this,flag,is,code,false,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,boolean,start,connection,throws,jmsexception,assert,not,null,connection,factory,connection,factory,must,not,be,null,assert,not,null,resource,factory,resource,factory,must,not,be,null,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,connection,factory,if,resource,holder,null,session,session,resource,factory,get,session,resource,holder,if,session,null,if,start,connection,connection,con,resource,factory,get,connection,resource,holder,if,con,null,con,start,return,session,if,resource,holder,is,frozen,return,null,if,transaction,synchronization,manager,is,synchronization,active,return,null,jms,resource,holder,resource,holder,to,use,resource,holder,if,resource,holder,to,use,null,resource,holder,to,use,new,jms,resource,holder,connection,factory,connection,con,resource,factory,get,connection,resource,holder,to,use,session,session,null,try,boolean,is,existing,con,con,null,if,is,existing,con,con,resource,factory,create,connection,resource,holder,to,use,add,connection,con,session,resource,factory,create,session,con,resource,holder,to,use,add,session,session,con,if,start,connection,con,start,catch,jmsexception,ex,if,session,null,try,session,close,catch,throwable,ex2,if,con,null,try,con,close,catch,throwable,ex2,throw,ex,if,resource,holder,to,use,resource,holder,transaction,synchronization,manager,register,synchronization,new,jms,resource,synchronization,resource,holder,to,use,connection,factory,resource,factory,is,synched,local,transaction,allowed,resource,holder,to,use,set,synchronized,with,transaction,true,transaction,synchronization,manager,bind,resource,connection,factory,resource,holder,to,use,return,session
ConnectionFactoryUtils -> public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection) 			throws JMSException;1357119239;Obtain a JMS Session that is synchronized with the current transaction, if any._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@param startConnection whether the underlying JMS Connection approach should be_started in order to allow for receiving messages. Note that a reused Connection_may already have been started before, even if this flag is {@code false}._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)_			throws JMSException {__		Assert.notNull(connectionFactory, "ConnectionFactory must not be null")__		Assert.notNull(resourceFactory, "ResourceFactory must not be null")___		JmsResourceHolder resourceHolder =_				(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory)__		if (resourceHolder != null) {_			Session session = resourceFactory.getSession(resourceHolder)__			if (session != null) {_				if (startConnection) {_					Connection con = resourceFactory.getConnection(resourceHolder)__					if (con != null) {_						con.start()__					}_				}_				return session__			}_			if (resourceHolder.isFrozen()) {_				return null__			}_		}_		if (!TransactionSynchronizationManager.isSynchronizationActive()) {_			return null__		}_		JmsResourceHolder resourceHolderToUse = resourceHolder__		if (resourceHolderToUse == null) {_			resourceHolderToUse = new JmsResourceHolder(connectionFactory)__		}_		Connection con = resourceFactory.getConnection(resourceHolderToUse)__		Session session = null__		try {_			boolean isExistingCon = (con != null)__			if (!isExistingCon) {_				con = resourceFactory.createConnection()__				resourceHolderToUse.addConnection(con)__			}_			session = resourceFactory.createSession(con)__			resourceHolderToUse.addSession(session, con)__			if (startConnection) {_				con.start()__			}_		}_		catch (JMSException ex) {_			if (session != null) {_				try {_					session.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			if (con != null) {_				try {_					con.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			throw ex__		}_		if (resourceHolderToUse != resourceHolder) {_			TransactionSynchronizationManager.registerSynchronization(_					new JmsResourceSynchronization(_							resourceHolderToUse, connectionFactory, resourceFactory.isSynchedLocalTransactionAllowed()))__			resourceHolderToUse.setSynchronizedWithTransaction(true)__			TransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse)__		}_		return session__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,param,start,connection,whether,the,underlying,jms,connection,approach,should,be,started,in,order,to,allow,for,receiving,messages,note,that,a,reused,connection,may,already,have,been,started,before,even,if,this,flag,is,code,false,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,boolean,start,connection,throws,jmsexception,assert,not,null,connection,factory,connection,factory,must,not,be,null,assert,not,null,resource,factory,resource,factory,must,not,be,null,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,connection,factory,if,resource,holder,null,session,session,resource,factory,get,session,resource,holder,if,session,null,if,start,connection,connection,con,resource,factory,get,connection,resource,holder,if,con,null,con,start,return,session,if,resource,holder,is,frozen,return,null,if,transaction,synchronization,manager,is,synchronization,active,return,null,jms,resource,holder,resource,holder,to,use,resource,holder,if,resource,holder,to,use,null,resource,holder,to,use,new,jms,resource,holder,connection,factory,connection,con,resource,factory,get,connection,resource,holder,to,use,session,session,null,try,boolean,is,existing,con,con,null,if,is,existing,con,con,resource,factory,create,connection,resource,holder,to,use,add,connection,con,session,resource,factory,create,session,con,resource,holder,to,use,add,session,session,con,if,start,connection,con,start,catch,jmsexception,ex,if,session,null,try,session,close,catch,throwable,ex2,if,con,null,try,con,close,catch,throwable,ex2,throw,ex,if,resource,holder,to,use,resource,holder,transaction,synchronization,manager,register,synchronization,new,jms,resource,synchronization,resource,holder,to,use,connection,factory,resource,factory,is,synched,local,transaction,allowed,resource,holder,to,use,set,synchronized,with,transaction,true,transaction,synchronization,manager,bind,resource,connection,factory,resource,holder,to,use,return,session
ConnectionFactoryUtils -> public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection) 			throws JMSException;1368482696;Obtain a JMS Session that is synchronized with the current transaction, if any._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@param startConnection whether the underlying JMS Connection approach should be_started in order to allow for receiving messages. Note that a reused Connection_may already have been started before, even if this flag is {@code false}._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)_			throws JMSException {__		Assert.notNull(connectionFactory, "ConnectionFactory must not be null")__		Assert.notNull(resourceFactory, "ResourceFactory must not be null")___		JmsResourceHolder resourceHolder =_				(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory)__		if (resourceHolder != null) {_			Session session = resourceFactory.getSession(resourceHolder)__			if (session != null) {_				if (startConnection) {_					Connection con = resourceFactory.getConnection(resourceHolder)__					if (con != null) {_						con.start()__					}_				}_				return session__			}_			if (resourceHolder.isFrozen()) {_				return null__			}_		}_		if (!TransactionSynchronizationManager.isSynchronizationActive()) {_			return null__		}_		JmsResourceHolder resourceHolderToUse = resourceHolder__		if (resourceHolderToUse == null) {_			resourceHolderToUse = new JmsResourceHolder(connectionFactory)__		}_		Connection con = resourceFactory.getConnection(resourceHolderToUse)__		Session session = null__		try {_			boolean isExistingCon = (con != null)__			if (!isExistingCon) {_				con = resourceFactory.createConnection()__				resourceHolderToUse.addConnection(con)__			}_			session = resourceFactory.createSession(con)__			resourceHolderToUse.addSession(session, con)__			if (startConnection) {_				con.start()__			}_		}_		catch (JMSException ex) {_			if (session != null) {_				try {_					session.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			if (con != null) {_				try {_					con.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			throw ex__		}_		if (resourceHolderToUse != resourceHolder) {_			TransactionSynchronizationManager.registerSynchronization(_					new JmsResourceSynchronization(_							resourceHolderToUse, connectionFactory, resourceFactory.isSynchedLocalTransactionAllowed()))__			resourceHolderToUse.setSynchronizedWithTransaction(true)__			TransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse)__		}_		return session__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,param,start,connection,whether,the,underlying,jms,connection,approach,should,be,started,in,order,to,allow,for,receiving,messages,note,that,a,reused,connection,may,already,have,been,started,before,even,if,this,flag,is,code,false,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,boolean,start,connection,throws,jmsexception,assert,not,null,connection,factory,connection,factory,must,not,be,null,assert,not,null,resource,factory,resource,factory,must,not,be,null,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,connection,factory,if,resource,holder,null,session,session,resource,factory,get,session,resource,holder,if,session,null,if,start,connection,connection,con,resource,factory,get,connection,resource,holder,if,con,null,con,start,return,session,if,resource,holder,is,frozen,return,null,if,transaction,synchronization,manager,is,synchronization,active,return,null,jms,resource,holder,resource,holder,to,use,resource,holder,if,resource,holder,to,use,null,resource,holder,to,use,new,jms,resource,holder,connection,factory,connection,con,resource,factory,get,connection,resource,holder,to,use,session,session,null,try,boolean,is,existing,con,con,null,if,is,existing,con,con,resource,factory,create,connection,resource,holder,to,use,add,connection,con,session,resource,factory,create,session,con,resource,holder,to,use,add,session,session,con,if,start,connection,con,start,catch,jmsexception,ex,if,session,null,try,session,close,catch,throwable,ex2,if,con,null,try,con,close,catch,throwable,ex2,throw,ex,if,resource,holder,to,use,resource,holder,transaction,synchronization,manager,register,synchronization,new,jms,resource,synchronization,resource,holder,to,use,connection,factory,resource,factory,is,synched,local,transaction,allowed,resource,holder,to,use,set,synchronized,with,transaction,true,transaction,synchronization,manager,bind,resource,connection,factory,resource,holder,to,use,return,session
ConnectionFactoryUtils -> public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection) 			throws JMSException;1486720600;Obtain a JMS Session that is synchronized with the current transaction, if any._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@param startConnection whether the underlying JMS Connection approach should be_started in order to allow for receiving messages. Note that a reused Connection_may already have been started before, even if this flag is {@code false}._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection)_			throws JMSException {__		Assert.notNull(connectionFactory, "ConnectionFactory must not be null")__		Assert.notNull(resourceFactory, "ResourceFactory must not be null")___		JmsResourceHolder resourceHolder =_				(JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory)__		if (resourceHolder != null) {_			Session session = resourceFactory.getSession(resourceHolder)__			if (session != null) {_				if (startConnection) {_					Connection con = resourceFactory.getConnection(resourceHolder)__					if (con != null) {_						con.start()__					}_				}_				return session__			}_			if (resourceHolder.isFrozen()) {_				return null__			}_		}_		if (!TransactionSynchronizationManager.isSynchronizationActive()) {_			return null__		}_		JmsResourceHolder resourceHolderToUse = resourceHolder__		if (resourceHolderToUse == null) {_			resourceHolderToUse = new JmsResourceHolder(connectionFactory)__		}_		Connection con = resourceFactory.getConnection(resourceHolderToUse)__		Session session = null__		try {_			boolean isExistingCon = (con != null)__			if (!isExistingCon) {_				con = resourceFactory.createConnection()__				resourceHolderToUse.addConnection(con)__			}_			session = resourceFactory.createSession(con)__			resourceHolderToUse.addSession(session, con)__			if (startConnection) {_				con.start()__			}_		}_		catch (JMSException ex) {_			if (session != null) {_				try {_					session.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			if (con != null) {_				try {_					con.close()__				}_				catch (Throwable ex2) {_					_				}_			}_			throw ex__		}_		if (resourceHolderToUse != resourceHolder) {_			TransactionSynchronizationManager.registerSynchronization(_					new JmsResourceSynchronization(resourceHolderToUse, connectionFactory,_							resourceFactory.isSynchedLocalTransactionAllowed()))__			resourceHolderToUse.setSynchronizedWithTransaction(true)__			TransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse)__		}_		return session__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,param,start,connection,whether,the,underlying,jms,connection,approach,should,be,started,in,order,to,allow,for,receiving,messages,note,that,a,reused,connection,may,already,have,been,started,before,even,if,this,flag,is,code,false,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,boolean,start,connection,throws,jmsexception,assert,not,null,connection,factory,connection,factory,must,not,be,null,assert,not,null,resource,factory,resource,factory,must,not,be,null,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,connection,factory,if,resource,holder,null,session,session,resource,factory,get,session,resource,holder,if,session,null,if,start,connection,connection,con,resource,factory,get,connection,resource,holder,if,con,null,con,start,return,session,if,resource,holder,is,frozen,return,null,if,transaction,synchronization,manager,is,synchronization,active,return,null,jms,resource,holder,resource,holder,to,use,resource,holder,if,resource,holder,to,use,null,resource,holder,to,use,new,jms,resource,holder,connection,factory,connection,con,resource,factory,get,connection,resource,holder,to,use,session,session,null,try,boolean,is,existing,con,con,null,if,is,existing,con,con,resource,factory,create,connection,resource,holder,to,use,add,connection,con,session,resource,factory,create,session,con,resource,holder,to,use,add,session,session,con,if,start,connection,con,start,catch,jmsexception,ex,if,session,null,try,session,close,catch,throwable,ex2,if,con,null,try,con,close,catch,throwable,ex2,throw,ex,if,resource,holder,to,use,resource,holder,transaction,synchronization,manager,register,synchronization,new,jms,resource,synchronization,resource,holder,to,use,connection,factory,resource,factory,is,synched,local,transaction,allowed,resource,holder,to,use,set,synchronized,with,transaction,true,transaction,synchronization,manager,bind,resource,connection,factory,resource,holder,to,use,return,session
ConnectionFactoryUtils -> public static TopicSession getTransactionalTopicSession( 			final TopicConnectionFactory cf, final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1328020251;Obtain a JMS TopicSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be <code>null</code>)_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or <code>null</code> if none found_@throws JMSException in case of JMS failure;public static TopicSession getTransactionalTopicSession(_			final TopicConnectionFactory cf, final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(TopicSession.class, existingCon)__			}_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class))__			}_			public Connection createConnection() throws JMSException {_				return cf.createTopicConnection()__			}_			public Session createSession(Connection con) throws JMSException {_				return ((TopicConnection) con).createTopicSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,topic,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,code,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,code,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,topic,session,get,transactional,topic,session,final,topic,connection,factory,cf,final,topic,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,topic,session,do,get,transactional,session,cf,new,resource,factory,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,topic,session,class,existing,con,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,topic,connection,class,public,connection,create,connection,throws,jmsexception,return,cf,create,topic,connection,public,session,create,session,connection,con,throws,jmsexception,return,topic,connection,con,create,topic,session,synched,local,transaction,allowed,session,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static TopicSession getTransactionalTopicSession( 			final TopicConnectionFactory cf, final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1356735495;Obtain a JMS TopicSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static TopicSession getTransactionalTopicSession(_			final TopicConnectionFactory cf, final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(TopicSession.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class))__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createTopicConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return ((TopicConnection) con).createTopicSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,topic,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,topic,session,get,transactional,topic,session,final,topic,connection,factory,cf,final,topic,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,topic,session,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,topic,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,topic,connection,class,override,public,connection,create,connection,throws,jmsexception,return,cf,create,topic,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,topic,connection,con,create,topic,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static TopicSession getTransactionalTopicSession( 			final TopicConnectionFactory cf, final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1357119239;Obtain a JMS TopicSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static TopicSession getTransactionalTopicSession(_			final TopicConnectionFactory cf, final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(TopicSession.class, existingCon)__			}_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class))__			}_			public Connection createConnection() throws JMSException {_				return cf.createTopicConnection()__			}_			public Session createSession(Connection con) throws JMSException {_				return ((TopicConnection) con).createTopicSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,topic,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,topic,session,get,transactional,topic,session,final,topic,connection,factory,cf,final,topic,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,topic,session,do,get,transactional,session,cf,new,resource,factory,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,topic,session,class,existing,con,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,topic,connection,class,public,connection,create,connection,throws,jmsexception,return,cf,create,topic,connection,public,session,create,session,connection,con,throws,jmsexception,return,topic,connection,con,create,topic,session,synched,local,transaction,allowed,session,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static TopicSession getTransactionalTopicSession( 			final TopicConnectionFactory cf, final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1368482696;Obtain a JMS TopicSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static TopicSession getTransactionalTopicSession(_			final TopicConnectionFactory cf, final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(TopicSession.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class))__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createTopicConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return ((TopicConnection) con).createTopicSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,topic,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,topic,session,get,transactional,topic,session,final,topic,connection,factory,cf,final,topic,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,topic,session,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,topic,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,topic,connection,class,override,public,connection,create,connection,throws,jmsexception,return,cf,create,topic,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,topic,connection,con,create,topic,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> ResourceFactory -> Connection getConnection(JmsResourceHolder holder)_;1328020251;Fetch an appropriate Connection from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Connection fetched from the holder,_or <code>null</code> if none found;Connection getConnection(JmsResourceHolder holder)_;fetch,an,appropriate,connection,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,connection,fetched,from,the,holder,or,code,null,code,if,none,found;connection,get,connection,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> Connection getConnection(JmsResourceHolder holder)_;1356735495;Fetch an appropriate Connection from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Connection fetched from the holder,_or {@code null} if none found;Connection getConnection(JmsResourceHolder holder)_;fetch,an,appropriate,connection,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,connection,fetched,from,the,holder,or,code,null,if,none,found;connection,get,connection,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> Connection getConnection(JmsResourceHolder holder)_;1357119239;Fetch an appropriate Connection from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Connection fetched from the holder,_or {@code null} if none found;Connection getConnection(JmsResourceHolder holder)_;fetch,an,appropriate,connection,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,connection,fetched,from,the,holder,or,code,null,if,none,found;connection,get,connection,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> Connection getConnection(JmsResourceHolder holder)_;1368482696;Fetch an appropriate Connection from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Connection fetched from the holder,_or {@code null} if none found;Connection getConnection(JmsResourceHolder holder)_;fetch,an,appropriate,connection,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,connection,fetched,from,the,holder,or,code,null,if,none,found;connection,get,connection,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> Connection getConnection(JmsResourceHolder holder)_;1486720600;Fetch an appropriate Connection from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Connection fetched from the holder,_or {@code null} if none found;Connection getConnection(JmsResourceHolder holder)_;fetch,an,appropriate,connection,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,connection,fetched,from,the,holder,or,code,null,if,none,found;connection,get,connection,jms,resource,holder,holder
ConnectionFactoryUtils -> public static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started);1496837955;Release the given Connection, stopping it (if necessary) and eventually closing it._<p>Checks {@link SmartConnectionFactory#shouldStop}, if available._This is essentially a more sophisticated version of_{@link org.springframework.jms.support.JmsUtils#closeConnection}._@param con the Connection to release_(if this is {@code null}, the call will be ignored)_@param cf the ConnectionFactory that the Connection was obtained from_(may be {@code null})_@param started whether the Connection might have been started by the application_@see SmartConnectionFactory#shouldStop_@see org.springframework.jms.support.JmsUtils#closeConnection;public static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started) {_		if (con == null) {_			return__		}_		if (started && cf instanceof SmartConnectionFactory && ((SmartConnectionFactory) cf).shouldStop(con)) {_			try {_				con.stop()__			}_			catch (Throwable ex) {_				logger.debug("Could not stop JMS Connection before closing it", ex)__			}_		}_		try {_			con.close()__		}_		catch (Throwable ex) {_			logger.debug("Could not close JMS Connection", ex)__		}_	};release,the,given,connection,stopping,it,if,necessary,and,eventually,closing,it,p,checks,link,smart,connection,factory,should,stop,if,available,this,is,essentially,a,more,sophisticated,version,of,link,org,springframework,jms,support,jms,utils,close,connection,param,con,the,connection,to,release,if,this,is,code,null,the,call,will,be,ignored,param,cf,the,connection,factory,that,the,connection,was,obtained,from,may,be,code,null,param,started,whether,the,connection,might,have,been,started,by,the,application,see,smart,connection,factory,should,stop,see,org,springframework,jms,support,jms,utils,close,connection;public,static,void,release,connection,nullable,connection,con,nullable,connection,factory,cf,boolean,started,if,con,null,return,if,started,cf,instanceof,smart,connection,factory,smart,connection,factory,cf,should,stop,con,try,con,stop,catch,throwable,ex,logger,debug,could,not,stop,jms,connection,before,closing,it,ex,try,con,close,catch,throwable,ex,logger,debug,could,not,close,jms,connection,ex
ConnectionFactoryUtils -> public static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started);1502974979;Release the given Connection, stopping it (if necessary) and eventually closing it._<p>Checks {@link SmartConnectionFactory#shouldStop}, if available._This is essentially a more sophisticated version of_{@link org.springframework.jms.support.JmsUtils#closeConnection}._@param con the Connection to release_(if this is {@code null}, the call will be ignored)_@param cf the ConnectionFactory that the Connection was obtained from_(may be {@code null})_@param started whether the Connection might have been started by the application_@see SmartConnectionFactory#shouldStop_@see org.springframework.jms.support.JmsUtils#closeConnection;public static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started) {_		if (con == null) {_			return__		}_		if (started && cf instanceof SmartConnectionFactory && ((SmartConnectionFactory) cf).shouldStop(con)) {_			try {_				con.stop()__			}_			catch (Throwable ex) {_				logger.debug("Could not stop JMS Connection before closing it", ex)__			}_		}_		try {_			con.close()__		}_		catch (Throwable ex) {_			logger.debug("Could not close JMS Connection", ex)__		}_	};release,the,given,connection,stopping,it,if,necessary,and,eventually,closing,it,p,checks,link,smart,connection,factory,should,stop,if,available,this,is,essentially,a,more,sophisticated,version,of,link,org,springframework,jms,support,jms,utils,close,connection,param,con,the,connection,to,release,if,this,is,code,null,the,call,will,be,ignored,param,cf,the,connection,factory,that,the,connection,was,obtained,from,may,be,code,null,param,started,whether,the,connection,might,have,been,started,by,the,application,see,smart,connection,factory,should,stop,see,org,springframework,jms,support,jms,utils,close,connection;public,static,void,release,connection,nullable,connection,con,nullable,connection,factory,cf,boolean,started,if,con,null,return,if,started,cf,instanceof,smart,connection,factory,smart,connection,factory,cf,should,stop,con,try,con,stop,catch,throwable,ex,logger,debug,could,not,stop,jms,connection,before,closing,it,ex,try,con,close,catch,throwable,ex,logger,debug,could,not,close,jms,connection,ex
ConnectionFactoryUtils -> ResourceFactory -> @Nullable 		Connection getConnection(JmsResourceHolder holder)_;1495868221;Fetch an appropriate Connection from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Connection fetched from the holder,_or {@code null} if none found;@Nullable_		Connection getConnection(JmsResourceHolder holder)_;fetch,an,appropriate,connection,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,connection,fetched,from,the,holder,or,code,null,if,none,found;nullable,connection,get,connection,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> @Nullable 		Connection getConnection(JmsResourceHolder holder)_;1496837955;Fetch an appropriate Connection from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Connection fetched from the holder,_or {@code null} if none found;@Nullable_		Connection getConnection(JmsResourceHolder holder)_;fetch,an,appropriate,connection,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,connection,fetched,from,the,holder,or,code,null,if,none,found;nullable,connection,get,connection,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> @Nullable 		Connection getConnection(JmsResourceHolder holder)_;1502974979;Fetch an appropriate Connection from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Connection fetched from the holder,_or {@code null} if none found;@Nullable_		Connection getConnection(JmsResourceHolder holder)_;fetch,an,appropriate,connection,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,connection,fetched,from,the,holder,or,code,null,if,none,found;nullable,connection,get,connection,jms,resource,holder,holder
ConnectionFactoryUtils -> public static Session getTransactionalSession( 			final ConnectionFactory cf, final Connection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1328020251;Obtain a JMS Session that is synchronized with the current transaction, if any._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be <code>null</code>)_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or <code>null</code> if none found_@throws JMSException in case of JMS failure;public static Session getTransactionalSession(_			final ConnectionFactory cf, final Connection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return doGetTransactionalSession(cf, new ResourceFactory() {_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(Session.class, existingCon)__			}_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection())__			}_			public Connection createConnection() throws JMSException {_				return cf.createConnection()__			}_			public Session createSession(Connection con) throws JMSException {_				return con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,code,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,code,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,session,get,transactional,session,final,connection,factory,cf,final,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,do,get,transactional,session,cf,new,resource,factory,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,session,class,existing,con,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,public,connection,create,connection,throws,jmsexception,return,cf,create,connection,public,session,create,session,connection,con,throws,jmsexception,return,con,create,session,synched,local,transaction,allowed,session,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static Session getTransactionalSession( 			final ConnectionFactory cf, final Connection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1356735495;Obtain a JMS Session that is synchronized with the current transaction, if any._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static Session getTransactionalSession(_			final ConnectionFactory cf, final Connection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(Session.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection())__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,session,get,transactional,session,final,connection,factory,cf,final,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,override,public,connection,create,connection,throws,jmsexception,return,cf,create,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,con,create,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static Session getTransactionalSession( 			final ConnectionFactory cf, final Connection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1357119239;Obtain a JMS Session that is synchronized with the current transaction, if any._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static Session getTransactionalSession(_			final ConnectionFactory cf, final Connection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return doGetTransactionalSession(cf, new ResourceFactory() {_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(Session.class, existingCon)__			}_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection())__			}_			public Connection createConnection() throws JMSException {_				return cf.createConnection()__			}_			public Session createSession(Connection con) throws JMSException {_				return con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,session,get,transactional,session,final,connection,factory,cf,final,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,do,get,transactional,session,cf,new,resource,factory,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,session,class,existing,con,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,public,connection,create,connection,throws,jmsexception,return,cf,create,connection,public,session,create,session,connection,con,throws,jmsexception,return,con,create,session,synched,local,transaction,allowed,session,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static Session getTransactionalSession( 			final ConnectionFactory cf, final Connection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1368482696;Obtain a JMS Session that is synchronized with the current transaction, if any._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;public static Session getTransactionalSession(_			final ConnectionFactory cf, final Connection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(Session.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection())__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;public,static,session,get,transactional,session,final,connection,factory,cf,final,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,override,public,connection,create,connection,throws,jmsexception,return,cf,create,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,con,create,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException;1328020251;Obtain a JMS Session that is synchronized with the current transaction, if any._<p>This <code>doGetTransactionalSession</code> variant always starts the underlying_JMS Connection, assuming that the Session will be used for receiving messages._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@return the transactional Session, or <code>null</code> if none found_@throws JMSException in case of JMS failure_@see #doGetTransactionalSession(javax.jms.ConnectionFactory, ResourceFactory, boolean);public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {__		return doGetTransactionalSession(connectionFactory, resourceFactory, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,p,this,code,do,get,transactional,session,code,variant,always,starts,the,underlying,jms,connection,assuming,that,the,session,will,be,used,for,receiving,messages,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,return,the,transactional,session,or,code,null,code,if,none,found,throws,jmsexception,in,case,of,jms,failure,see,do,get,transactional,session,javax,jms,connection,factory,resource,factory,boolean;public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,throws,jmsexception,return,do,get,transactional,session,connection,factory,resource,factory,true
ConnectionFactoryUtils -> public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException;1356735495;Obtain a JMS Session that is synchronized with the current transaction, if any._<p>This {@code doGetTransactionalSession} variant always starts the underlying_JMS Connection, assuming that the Session will be used for receiving messages._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure_@see #doGetTransactionalSession(javax.jms.ConnectionFactory, ResourceFactory, boolean);public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {__		return doGetTransactionalSession(connectionFactory, resourceFactory, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,p,this,code,do,get,transactional,session,variant,always,starts,the,underlying,jms,connection,assuming,that,the,session,will,be,used,for,receiving,messages,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure,see,do,get,transactional,session,javax,jms,connection,factory,resource,factory,boolean;public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,throws,jmsexception,return,do,get,transactional,session,connection,factory,resource,factory,true
ConnectionFactoryUtils -> public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException;1357119239;Obtain a JMS Session that is synchronized with the current transaction, if any._<p>This {@code doGetTransactionalSession} variant always starts the underlying_JMS Connection, assuming that the Session will be used for receiving messages._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure_@see #doGetTransactionalSession(javax.jms.ConnectionFactory, ResourceFactory, boolean);public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {__		return doGetTransactionalSession(connectionFactory, resourceFactory, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,p,this,code,do,get,transactional,session,variant,always,starts,the,underlying,jms,connection,assuming,that,the,session,will,be,used,for,receiving,messages,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure,see,do,get,transactional,session,javax,jms,connection,factory,resource,factory,boolean;public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,throws,jmsexception,return,do,get,transactional,session,connection,factory,resource,factory,true
ConnectionFactoryUtils -> public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException;1368482696;Obtain a JMS Session that is synchronized with the current transaction, if any._<p>This {@code doGetTransactionalSession} variant always starts the underlying_JMS Connection, assuming that the Session will be used for receiving messages._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure_@see #doGetTransactionalSession(javax.jms.ConnectionFactory, ResourceFactory, boolean);public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {__		return doGetTransactionalSession(connectionFactory, resourceFactory, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,p,this,code,do,get,transactional,session,variant,always,starts,the,underlying,jms,connection,assuming,that,the,session,will,be,used,for,receiving,messages,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure,see,do,get,transactional,session,javax,jms,connection,factory,resource,factory,boolean;public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,throws,jmsexception,return,do,get,transactional,session,connection,factory,resource,factory,true
ConnectionFactoryUtils -> public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException;1486720600;Obtain a JMS Session that is synchronized with the current transaction, if any._<p>This {@code doGetTransactionalSession} variant always starts the underlying_JMS Connection, assuming that the Session will be used for receiving messages._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure_@see #doGetTransactionalSession(javax.jms.ConnectionFactory, ResourceFactory, boolean);public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {__		return doGetTransactionalSession(connectionFactory, resourceFactory, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,p,this,code,do,get,transactional,session,variant,always,starts,the,underlying,jms,connection,assuming,that,the,session,will,be,used,for,receiving,messages,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure,see,do,get,transactional,session,javax,jms,connection,factory,resource,factory,boolean;public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,throws,jmsexception,return,do,get,transactional,session,connection,factory,resource,factory,true
ConnectionFactoryUtils -> ResourceFactory -> boolean isSynchedLocalTransactionAllowed()_;1328020251;Return whether to allow for a local JMS transaction that is synchronized with_a Spring-managed transaction (where the main transaction might be a JDBC-based_one for a specific DataSource, for example), with the JMS transaction_committing right after the main transaction._@return whether to allow for synchronizing a local JMS transaction;boolean isSynchedLocalTransactionAllowed()_;return,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,return,whether,to,allow,for,synchronizing,a,local,jms,transaction;boolean,is,synched,local,transaction,allowed
ConnectionFactoryUtils -> ResourceFactory -> boolean isSynchedLocalTransactionAllowed()_;1356735495;Return whether to allow for a local JMS transaction that is synchronized with_a Spring-managed transaction (where the main transaction might be a JDBC-based_one for a specific DataSource, for example), with the JMS transaction_committing right after the main transaction._@return whether to allow for synchronizing a local JMS transaction;boolean isSynchedLocalTransactionAllowed()_;return,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,return,whether,to,allow,for,synchronizing,a,local,jms,transaction;boolean,is,synched,local,transaction,allowed
ConnectionFactoryUtils -> ResourceFactory -> boolean isSynchedLocalTransactionAllowed()_;1357119239;Return whether to allow for a local JMS transaction that is synchronized with_a Spring-managed transaction (where the main transaction might be a JDBC-based_one for a specific DataSource, for example), with the JMS transaction_committing right after the main transaction._@return whether to allow for synchronizing a local JMS transaction;boolean isSynchedLocalTransactionAllowed()_;return,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,return,whether,to,allow,for,synchronizing,a,local,jms,transaction;boolean,is,synched,local,transaction,allowed
ConnectionFactoryUtils -> ResourceFactory -> boolean isSynchedLocalTransactionAllowed()_;1368482696;Return whether to allow for a local JMS transaction that is synchronized with_a Spring-managed transaction (where the main transaction might be a JDBC-based_one for a specific DataSource, for example), with the JMS transaction_committing right after the main transaction._@return whether to allow for synchronizing a local JMS transaction;boolean isSynchedLocalTransactionAllowed()_;return,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,return,whether,to,allow,for,synchronizing,a,local,jms,transaction;boolean,is,synched,local,transaction,allowed
ConnectionFactoryUtils -> ResourceFactory -> boolean isSynchedLocalTransactionAllowed()_;1486720600;Return whether to allow for a local JMS transaction that is synchronized with_a Spring-managed transaction (where the main transaction might be a JDBC-based_one for a specific DataSource, for example), with the JMS transaction_committing right after the main transaction._@return whether to allow for synchronizing a local JMS transaction;boolean isSynchedLocalTransactionAllowed()_;return,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,return,whether,to,allow,for,synchronizing,a,local,jms,transaction;boolean,is,synched,local,transaction,allowed
ConnectionFactoryUtils -> ResourceFactory -> boolean isSynchedLocalTransactionAllowed()_;1495868221;Return whether to allow for a local JMS transaction that is synchronized with_a Spring-managed transaction (where the main transaction might be a JDBC-based_one for a specific DataSource, for example), with the JMS transaction_committing right after the main transaction._@return whether to allow for synchronizing a local JMS transaction;boolean isSynchedLocalTransactionAllowed()_;return,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,return,whether,to,allow,for,synchronizing,a,local,jms,transaction;boolean,is,synched,local,transaction,allowed
ConnectionFactoryUtils -> ResourceFactory -> boolean isSynchedLocalTransactionAllowed()_;1496837955;Return whether to allow for a local JMS transaction that is synchronized with_a Spring-managed transaction (where the main transaction might be a JDBC-based_one for a specific DataSource, for example), with the JMS transaction_committing right after the main transaction._@return whether to allow for synchronizing a local JMS transaction;boolean isSynchedLocalTransactionAllowed()_;return,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,return,whether,to,allow,for,synchronizing,a,local,jms,transaction;boolean,is,synched,local,transaction,allowed
ConnectionFactoryUtils -> ResourceFactory -> boolean isSynchedLocalTransactionAllowed()_;1502974979;Return whether to allow for a local JMS transaction that is synchronized with_a Spring-managed transaction (where the main transaction might be a JDBC-based_one for a specific DataSource, for example), with the JMS transaction_committing right after the main transaction._@return whether to allow for synchronizing a local JMS transaction;boolean isSynchedLocalTransactionAllowed()_;return,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,return,whether,to,allow,for,synchronizing,a,local,jms,transaction;boolean,is,synched,local,transaction,allowed
ConnectionFactoryUtils -> public static boolean isSessionTransactional(Session session, ConnectionFactory cf);1328020251;Determine whether the given JMS Session is transactional, that is,_bound to the current thread by Spring's transaction facilities._@param session the JMS Session to check_@param cf the JMS ConnectionFactory that the Session originated from_@return whether the Session is transactional;public static boolean isSessionTransactional(Session session, ConnectionFactory cf) {_		if (session == null || cf == null) {_			return false__		}_		JmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf)__		return (resourceHolder != null && resourceHolder.containsSession(session))__	};determine,whether,the,given,jms,session,is,transactional,that,is,bound,to,the,current,thread,by,spring,s,transaction,facilities,param,session,the,jms,session,to,check,param,cf,the,jms,connection,factory,that,the,session,originated,from,return,whether,the,session,is,transactional;public,static,boolean,is,session,transactional,session,session,connection,factory,cf,if,session,null,cf,null,return,false,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,cf,return,resource,holder,null,resource,holder,contains,session,session
ConnectionFactoryUtils -> public static boolean isSessionTransactional(Session session, ConnectionFactory cf);1356735495;Determine whether the given JMS Session is transactional, that is,_bound to the current thread by Spring's transaction facilities._@param session the JMS Session to check_@param cf the JMS ConnectionFactory that the Session originated from_@return whether the Session is transactional;public static boolean isSessionTransactional(Session session, ConnectionFactory cf) {_		if (session == null || cf == null) {_			return false__		}_		JmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf)__		return (resourceHolder != null && resourceHolder.containsSession(session))__	};determine,whether,the,given,jms,session,is,transactional,that,is,bound,to,the,current,thread,by,spring,s,transaction,facilities,param,session,the,jms,session,to,check,param,cf,the,jms,connection,factory,that,the,session,originated,from,return,whether,the,session,is,transactional;public,static,boolean,is,session,transactional,session,session,connection,factory,cf,if,session,null,cf,null,return,false,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,cf,return,resource,holder,null,resource,holder,contains,session,session
ConnectionFactoryUtils -> public static boolean isSessionTransactional(Session session, ConnectionFactory cf);1357119239;Determine whether the given JMS Session is transactional, that is,_bound to the current thread by Spring's transaction facilities._@param session the JMS Session to check_@param cf the JMS ConnectionFactory that the Session originated from_@return whether the Session is transactional;public static boolean isSessionTransactional(Session session, ConnectionFactory cf) {_		if (session == null || cf == null) {_			return false__		}_		JmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf)__		return (resourceHolder != null && resourceHolder.containsSession(session))__	};determine,whether,the,given,jms,session,is,transactional,that,is,bound,to,the,current,thread,by,spring,s,transaction,facilities,param,session,the,jms,session,to,check,param,cf,the,jms,connection,factory,that,the,session,originated,from,return,whether,the,session,is,transactional;public,static,boolean,is,session,transactional,session,session,connection,factory,cf,if,session,null,cf,null,return,false,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,cf,return,resource,holder,null,resource,holder,contains,session,session
ConnectionFactoryUtils -> public static boolean isSessionTransactional(Session session, ConnectionFactory cf);1368482696;Determine whether the given JMS Session is transactional, that is,_bound to the current thread by Spring's transaction facilities._@param session the JMS Session to check_@param cf the JMS ConnectionFactory that the Session originated from_@return whether the Session is transactional;public static boolean isSessionTransactional(Session session, ConnectionFactory cf) {_		if (session == null || cf == null) {_			return false__		}_		JmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf)__		return (resourceHolder != null && resourceHolder.containsSession(session))__	};determine,whether,the,given,jms,session,is,transactional,that,is,bound,to,the,current,thread,by,spring,s,transaction,facilities,param,session,the,jms,session,to,check,param,cf,the,jms,connection,factory,that,the,session,originated,from,return,whether,the,session,is,transactional;public,static,boolean,is,session,transactional,session,session,connection,factory,cf,if,session,null,cf,null,return,false,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,cf,return,resource,holder,null,resource,holder,contains,session,session
ConnectionFactoryUtils -> public static boolean isSessionTransactional(Session session, ConnectionFactory cf);1486720600;Determine whether the given JMS Session is transactional, that is,_bound to the current thread by Spring's transaction facilities._@param session the JMS Session to check_@param cf the JMS ConnectionFactory that the Session originated from_@return whether the Session is transactional;public static boolean isSessionTransactional(Session session, ConnectionFactory cf) {_		if (session == null || cf == null) {_			return false__		}_		JmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf)__		return (resourceHolder != null && resourceHolder.containsSession(session))__	};determine,whether,the,given,jms,session,is,transactional,that,is,bound,to,the,current,thread,by,spring,s,transaction,facilities,param,session,the,jms,session,to,check,param,cf,the,jms,connection,factory,that,the,session,originated,from,return,whether,the,session,is,transactional;public,static,boolean,is,session,transactional,session,session,connection,factory,cf,if,session,null,cf,null,return,false,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,cf,return,resource,holder,null,resource,holder,contains,session,session
ConnectionFactoryUtils -> public static boolean isSessionTransactional(Session session, ConnectionFactory cf);1495868221;Determine whether the given JMS Session is transactional, that is,_bound to the current thread by Spring's transaction facilities._@param session the JMS Session to check_@param cf the JMS ConnectionFactory that the Session originated from_@return whether the Session is transactional;public static boolean isSessionTransactional(Session session, ConnectionFactory cf) {_		if (session == null || cf == null) {_			return false__		}_		JmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf)__		return (resourceHolder != null && resourceHolder.containsSession(session))__	};determine,whether,the,given,jms,session,is,transactional,that,is,bound,to,the,current,thread,by,spring,s,transaction,facilities,param,session,the,jms,session,to,check,param,cf,the,jms,connection,factory,that,the,session,originated,from,return,whether,the,session,is,transactional;public,static,boolean,is,session,transactional,session,session,connection,factory,cf,if,session,null,cf,null,return,false,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,cf,return,resource,holder,null,resource,holder,contains,session,session
ConnectionFactoryUtils -> @Nullable 	public static Session getTransactionalSession(final ConnectionFactory cf, 			@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1495868221;Obtain a JMS Session that is synchronized with the current transaction, if any._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static Session getTransactionalSession(final ConnectionFactory cf,_			@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(Session.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection())__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,session,get,transactional,session,final,connection,factory,cf,nullable,final,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,override,public,connection,create,connection,throws,jmsexception,return,cf,create,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,con,create,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> @Nullable 	public static Session getTransactionalSession(final ConnectionFactory cf, 			@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1496837955;Obtain a JMS Session that is synchronized with the current transaction, if any._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static Session getTransactionalSession(final ConnectionFactory cf,_			@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(Session.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection())__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,session,get,transactional,session,final,connection,factory,cf,nullable,final,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,override,public,connection,create,connection,throws,jmsexception,return,cf,create,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,con,create,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> @Nullable 	public static Session getTransactionalSession(final ConnectionFactory cf, 			@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1502974979;Obtain a JMS Session that is synchronized with the current transaction, if any._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static Session getTransactionalSession(final ConnectionFactory cf,_			@Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			@Nullable_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(Session.class, existingCon)__			}_			@Override_			@Nullable_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection())__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,session,get,transactional,session,final,connection,factory,cf,nullable,final,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,do,get,transactional,session,cf,new,resource,factory,override,nullable,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,session,class,existing,con,override,nullable,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,override,public,connection,create,connection,throws,jmsexception,return,cf,create,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,con,create,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> ResourceFactory -> Session createSession(Connection con) throws JMSException_;1328020251;Create a new JMS Session for registration with a JmsResourceHolder._@param con the JMS Connection to create a Session for_@return the new JMS Session_@throws JMSException if thrown by JMS API methods;Session createSession(Connection con) throws JMSException_;create,a,new,jms,session,for,registration,with,a,jms,resource,holder,param,con,the,jms,connection,to,create,a,session,for,return,the,new,jms,session,throws,jmsexception,if,thrown,by,jms,api,methods;session,create,session,connection,con,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Session createSession(Connection con) throws JMSException_;1356735495;Create a new JMS Session for registration with a JmsResourceHolder._@param con the JMS Connection to create a Session for_@return the new JMS Session_@throws JMSException if thrown by JMS API methods;Session createSession(Connection con) throws JMSException_;create,a,new,jms,session,for,registration,with,a,jms,resource,holder,param,con,the,jms,connection,to,create,a,session,for,return,the,new,jms,session,throws,jmsexception,if,thrown,by,jms,api,methods;session,create,session,connection,con,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Session createSession(Connection con) throws JMSException_;1357119239;Create a new JMS Session for registration with a JmsResourceHolder._@param con the JMS Connection to create a Session for_@return the new JMS Session_@throws JMSException if thrown by JMS API methods;Session createSession(Connection con) throws JMSException_;create,a,new,jms,session,for,registration,with,a,jms,resource,holder,param,con,the,jms,connection,to,create,a,session,for,return,the,new,jms,session,throws,jmsexception,if,thrown,by,jms,api,methods;session,create,session,connection,con,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Session createSession(Connection con) throws JMSException_;1368482696;Create a new JMS Session for registration with a JmsResourceHolder._@param con the JMS Connection to create a Session for_@return the new JMS Session_@throws JMSException if thrown by JMS API methods;Session createSession(Connection con) throws JMSException_;create,a,new,jms,session,for,registration,with,a,jms,resource,holder,param,con,the,jms,connection,to,create,a,session,for,return,the,new,jms,session,throws,jmsexception,if,thrown,by,jms,api,methods;session,create,session,connection,con,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Session createSession(Connection con) throws JMSException_;1486720600;Create a new JMS Session for registration with a JmsResourceHolder._@param con the JMS Connection to create a Session for_@return the new JMS Session_@throws JMSException if thrown by JMS API methods;Session createSession(Connection con) throws JMSException_;create,a,new,jms,session,for,registration,with,a,jms,resource,holder,param,con,the,jms,connection,to,create,a,session,for,return,the,new,jms,session,throws,jmsexception,if,thrown,by,jms,api,methods;session,create,session,connection,con,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Session createSession(Connection con) throws JMSException_;1495868221;Create a new JMS Session for registration with a JmsResourceHolder._@param con the JMS Connection to create a Session for_@return the new JMS Session_@throws JMSException if thrown by JMS API methods;Session createSession(Connection con) throws JMSException_;create,a,new,jms,session,for,registration,with,a,jms,resource,holder,param,con,the,jms,connection,to,create,a,session,for,return,the,new,jms,session,throws,jmsexception,if,thrown,by,jms,api,methods;session,create,session,connection,con,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Session createSession(Connection con) throws JMSException_;1496837955;Create a new JMS Session for registration with a JmsResourceHolder._@param con the JMS Connection to create a Session for_@return the new JMS Session_@throws JMSException if thrown by JMS API methods;Session createSession(Connection con) throws JMSException_;create,a,new,jms,session,for,registration,with,a,jms,resource,holder,param,con,the,jms,connection,to,create,a,session,for,return,the,new,jms,session,throws,jmsexception,if,thrown,by,jms,api,methods;session,create,session,connection,con,throws,jmsexception
ConnectionFactoryUtils -> ResourceFactory -> Session createSession(Connection con) throws JMSException_;1502974979;Create a new JMS Session for registration with a JmsResourceHolder._@param con the JMS Connection to create a Session for_@return the new JMS Session_@throws JMSException if thrown by JMS API methods;Session createSession(Connection con) throws JMSException_;create,a,new,jms,session,for,registration,with,a,jms,resource,holder,param,con,the,jms,connection,to,create,a,session,for,return,the,new,jms,session,throws,jmsexception,if,thrown,by,jms,api,methods;session,create,session,connection,con,throws,jmsexception
ConnectionFactoryUtils -> @Nullable 	public static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf, 			@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1495868221;Obtain a JMS QueueSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,_			@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(QueueSession.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class))__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createQueueConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,queue,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,queue,session,get,transactional,queue,session,final,queue,connection,factory,cf,nullable,final,queue,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,queue,session,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,queue,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,queue,connection,class,override,public,connection,create,connection,throws,jmsexception,return,cf,create,queue,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,queue,connection,con,create,queue,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> @Nullable 	public static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf, 			@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1496837955;Obtain a JMS QueueSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,_			@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(QueueSession.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class))__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createQueueConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,queue,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,queue,session,get,transactional,queue,session,final,queue,connection,factory,cf,nullable,final,queue,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,queue,session,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,queue,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,queue,connection,class,override,public,connection,create,connection,throws,jmsexception,return,cf,create,queue,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,queue,connection,con,create,queue,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> @Nullable 	public static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf, 			@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1502974979;Obtain a JMS QueueSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf,_			@Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			@Nullable_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(QueueSession.class, existingCon)__			}_			@Override_			@Nullable_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class))__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createQueueConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,queue,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,queue,session,get,transactional,queue,session,final,queue,connection,factory,cf,nullable,final,queue,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,queue,session,do,get,transactional,session,cf,new,resource,factory,override,nullable,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,queue,session,class,existing,con,override,nullable,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,queue,connection,class,override,public,connection,create,connection,throws,jmsexception,return,cf,create,queue,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,queue,connection,con,create,queue,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> @Nullable 	public static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf, 			@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1495868221;Obtain a JMS TopicSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,_			@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(TopicSession.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class))__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createTopicConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return ((TopicConnection) con).createTopicSession(_						synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,topic,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,topic,session,get,transactional,topic,session,final,topic,connection,factory,cf,nullable,final,topic,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,topic,session,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,topic,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,topic,connection,class,override,public,connection,create,connection,throws,jmsexception,return,cf,create,topic,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,topic,connection,con,create,topic,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> @Nullable 	public static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf, 			@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1496837955;Obtain a JMS TopicSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,_			@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(TopicSession.class, existingCon)__			}_			@Override_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class))__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createTopicConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return ((TopicConnection) con).createTopicSession(_						synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,topic,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,topic,session,get,transactional,topic,session,final,topic,connection,factory,cf,nullable,final,topic,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,topic,session,do,get,transactional,session,cf,new,resource,factory,override,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,topic,session,class,existing,con,override,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,topic,connection,class,override,public,connection,create,connection,throws,jmsexception,return,cf,create,topic,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,topic,connection,con,create,topic,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> @Nullable 	public static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf, 			@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed) 			throws JMSException;1502974979;Obtain a JMS TopicSession that is synchronized with the current transaction, if any._<p>Mainly intended for use with the JMS 1.0.2 API._@param cf the ConnectionFactory to obtain a Session for_@param existingCon the existing JMS Connection to obtain a Session for_(may be {@code null})_@param synchedLocalTransactionAllowed whether to allow for a local JMS transaction_that is synchronized with a Spring-managed transaction (where the main transaction_might be a JDBC-based one for a specific DataSource, for example), with the JMS_transaction committing right after the main transaction. If not allowed, the given_ConnectionFactory needs to handle transaction enlistment underneath the covers._@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure;@Nullable_	public static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf,_			@Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed)_			throws JMSException {__		return (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {_			@Override_			@Nullable_			public Session getSession(JmsResourceHolder holder) {_				return holder.getSession(TopicSession.class, existingCon)__			}_			@Override_			@Nullable_			public Connection getConnection(JmsResourceHolder holder) {_				return (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class))__			}_			@Override_			public Connection createConnection() throws JMSException {_				return cf.createTopicConnection()__			}_			@Override_			public Session createSession(Connection con) throws JMSException {_				return ((TopicConnection) con).createTopicSession(_						synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE)__			}_			@Override_			public boolean isSynchedLocalTransactionAllowed() {_				return synchedLocalTransactionAllowed__			}_		}, true)__	};obtain,a,jms,topic,session,that,is,synchronized,with,the,current,transaction,if,any,p,mainly,intended,for,use,with,the,jms,1,0,2,api,param,cf,the,connection,factory,to,obtain,a,session,for,param,existing,con,the,existing,jms,connection,to,obtain,a,session,for,may,be,code,null,param,synched,local,transaction,allowed,whether,to,allow,for,a,local,jms,transaction,that,is,synchronized,with,a,spring,managed,transaction,where,the,main,transaction,might,be,a,jdbc,based,one,for,a,specific,data,source,for,example,with,the,jms,transaction,committing,right,after,the,main,transaction,if,not,allowed,the,given,connection,factory,needs,to,handle,transaction,enlistment,underneath,the,covers,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure;nullable,public,static,topic,session,get,transactional,topic,session,final,topic,connection,factory,cf,nullable,final,topic,connection,existing,con,final,boolean,synched,local,transaction,allowed,throws,jmsexception,return,topic,session,do,get,transactional,session,cf,new,resource,factory,override,nullable,public,session,get,session,jms,resource,holder,holder,return,holder,get,session,topic,session,class,existing,con,override,nullable,public,connection,get,connection,jms,resource,holder,holder,return,existing,con,null,existing,con,holder,get,connection,topic,connection,class,override,public,connection,create,connection,throws,jmsexception,return,cf,create,topic,connection,override,public,session,create,session,connection,con,throws,jmsexception,return,topic,connection,con,create,topic,session,synched,local,transaction,allowed,session,override,public,boolean,is,synched,local,transaction,allowed,return,synched,local,transaction,allowed,true
ConnectionFactoryUtils -> public static void releaseConnection(Connection con, ConnectionFactory cf, boolean started);1328020251;Release the given Connection, stopping it (if necessary) and eventually closing it._<p>Checks {@link SmartConnectionFactory#shouldStop}, if available._This is essentially a more sophisticated version of_{@link org.springframework.jms.support.JmsUtils#closeConnection}._@param con the Connection to release_(if this is <code>null</code>, the call will be ignored)_@param cf the ConnectionFactory that the Connection was obtained from_(may be <code>null</code>)_@param started whether the Connection might have been started by the application_@see SmartConnectionFactory#shouldStop_@see org.springframework.jms.support.JmsUtils#closeConnection;public static void releaseConnection(Connection con, ConnectionFactory cf, boolean started) {_		if (con == null) {_			return__		}_		if (started && cf instanceof SmartConnectionFactory && ((SmartConnectionFactory) cf).shouldStop(con)) {_			try {_				con.stop()__			}_			catch (Throwable ex) {_				logger.debug("Could not stop JMS Connection before closing it", ex)__			}_		}_		try {_			con.close()__		}_		catch (Throwable ex) {_			logger.debug("Could not close JMS Connection", ex)__		}_	};release,the,given,connection,stopping,it,if,necessary,and,eventually,closing,it,p,checks,link,smart,connection,factory,should,stop,if,available,this,is,essentially,a,more,sophisticated,version,of,link,org,springframework,jms,support,jms,utils,close,connection,param,con,the,connection,to,release,if,this,is,code,null,code,the,call,will,be,ignored,param,cf,the,connection,factory,that,the,connection,was,obtained,from,may,be,code,null,code,param,started,whether,the,connection,might,have,been,started,by,the,application,see,smart,connection,factory,should,stop,see,org,springframework,jms,support,jms,utils,close,connection;public,static,void,release,connection,connection,con,connection,factory,cf,boolean,started,if,con,null,return,if,started,cf,instanceof,smart,connection,factory,smart,connection,factory,cf,should,stop,con,try,con,stop,catch,throwable,ex,logger,debug,could,not,stop,jms,connection,before,closing,it,ex,try,con,close,catch,throwable,ex,logger,debug,could,not,close,jms,connection,ex
ConnectionFactoryUtils -> public static void releaseConnection(Connection con, ConnectionFactory cf, boolean started);1356735495;Release the given Connection, stopping it (if necessary) and eventually closing it._<p>Checks {@link SmartConnectionFactory#shouldStop}, if available._This is essentially a more sophisticated version of_{@link org.springframework.jms.support.JmsUtils#closeConnection}._@param con the Connection to release_(if this is {@code null}, the call will be ignored)_@param cf the ConnectionFactory that the Connection was obtained from_(may be {@code null})_@param started whether the Connection might have been started by the application_@see SmartConnectionFactory#shouldStop_@see org.springframework.jms.support.JmsUtils#closeConnection;public static void releaseConnection(Connection con, ConnectionFactory cf, boolean started) {_		if (con == null) {_			return__		}_		if (started && cf instanceof SmartConnectionFactory && ((SmartConnectionFactory) cf).shouldStop(con)) {_			try {_				con.stop()__			}_			catch (Throwable ex) {_				logger.debug("Could not stop JMS Connection before closing it", ex)__			}_		}_		try {_			con.close()__		}_		catch (Throwable ex) {_			logger.debug("Could not close JMS Connection", ex)__		}_	};release,the,given,connection,stopping,it,if,necessary,and,eventually,closing,it,p,checks,link,smart,connection,factory,should,stop,if,available,this,is,essentially,a,more,sophisticated,version,of,link,org,springframework,jms,support,jms,utils,close,connection,param,con,the,connection,to,release,if,this,is,code,null,the,call,will,be,ignored,param,cf,the,connection,factory,that,the,connection,was,obtained,from,may,be,code,null,param,started,whether,the,connection,might,have,been,started,by,the,application,see,smart,connection,factory,should,stop,see,org,springframework,jms,support,jms,utils,close,connection;public,static,void,release,connection,connection,con,connection,factory,cf,boolean,started,if,con,null,return,if,started,cf,instanceof,smart,connection,factory,smart,connection,factory,cf,should,stop,con,try,con,stop,catch,throwable,ex,logger,debug,could,not,stop,jms,connection,before,closing,it,ex,try,con,close,catch,throwable,ex,logger,debug,could,not,close,jms,connection,ex
ConnectionFactoryUtils -> public static void releaseConnection(Connection con, ConnectionFactory cf, boolean started);1357119239;Release the given Connection, stopping it (if necessary) and eventually closing it._<p>Checks {@link SmartConnectionFactory#shouldStop}, if available._This is essentially a more sophisticated version of_{@link org.springframework.jms.support.JmsUtils#closeConnection}._@param con the Connection to release_(if this is {@code null}, the call will be ignored)_@param cf the ConnectionFactory that the Connection was obtained from_(may be {@code null})_@param started whether the Connection might have been started by the application_@see SmartConnectionFactory#shouldStop_@see org.springframework.jms.support.JmsUtils#closeConnection;public static void releaseConnection(Connection con, ConnectionFactory cf, boolean started) {_		if (con == null) {_			return__		}_		if (started && cf instanceof SmartConnectionFactory && ((SmartConnectionFactory) cf).shouldStop(con)) {_			try {_				con.stop()__			}_			catch (Throwable ex) {_				logger.debug("Could not stop JMS Connection before closing it", ex)__			}_		}_		try {_			con.close()__		}_		catch (Throwable ex) {_			logger.debug("Could not close JMS Connection", ex)__		}_	};release,the,given,connection,stopping,it,if,necessary,and,eventually,closing,it,p,checks,link,smart,connection,factory,should,stop,if,available,this,is,essentially,a,more,sophisticated,version,of,link,org,springframework,jms,support,jms,utils,close,connection,param,con,the,connection,to,release,if,this,is,code,null,the,call,will,be,ignored,param,cf,the,connection,factory,that,the,connection,was,obtained,from,may,be,code,null,param,started,whether,the,connection,might,have,been,started,by,the,application,see,smart,connection,factory,should,stop,see,org,springframework,jms,support,jms,utils,close,connection;public,static,void,release,connection,connection,con,connection,factory,cf,boolean,started,if,con,null,return,if,started,cf,instanceof,smart,connection,factory,smart,connection,factory,cf,should,stop,con,try,con,stop,catch,throwable,ex,logger,debug,could,not,stop,jms,connection,before,closing,it,ex,try,con,close,catch,throwable,ex,logger,debug,could,not,close,jms,connection,ex
ConnectionFactoryUtils -> public static void releaseConnection(Connection con, ConnectionFactory cf, boolean started);1368482696;Release the given Connection, stopping it (if necessary) and eventually closing it._<p>Checks {@link SmartConnectionFactory#shouldStop}, if available._This is essentially a more sophisticated version of_{@link org.springframework.jms.support.JmsUtils#closeConnection}._@param con the Connection to release_(if this is {@code null}, the call will be ignored)_@param cf the ConnectionFactory that the Connection was obtained from_(may be {@code null})_@param started whether the Connection might have been started by the application_@see SmartConnectionFactory#shouldStop_@see org.springframework.jms.support.JmsUtils#closeConnection;public static void releaseConnection(Connection con, ConnectionFactory cf, boolean started) {_		if (con == null) {_			return__		}_		if (started && cf instanceof SmartConnectionFactory && ((SmartConnectionFactory) cf).shouldStop(con)) {_			try {_				con.stop()__			}_			catch (Throwable ex) {_				logger.debug("Could not stop JMS Connection before closing it", ex)__			}_		}_		try {_			con.close()__		}_		catch (Throwable ex) {_			logger.debug("Could not close JMS Connection", ex)__		}_	};release,the,given,connection,stopping,it,if,necessary,and,eventually,closing,it,p,checks,link,smart,connection,factory,should,stop,if,available,this,is,essentially,a,more,sophisticated,version,of,link,org,springframework,jms,support,jms,utils,close,connection,param,con,the,connection,to,release,if,this,is,code,null,the,call,will,be,ignored,param,cf,the,connection,factory,that,the,connection,was,obtained,from,may,be,code,null,param,started,whether,the,connection,might,have,been,started,by,the,application,see,smart,connection,factory,should,stop,see,org,springframework,jms,support,jms,utils,close,connection;public,static,void,release,connection,connection,con,connection,factory,cf,boolean,started,if,con,null,return,if,started,cf,instanceof,smart,connection,factory,smart,connection,factory,cf,should,stop,con,try,con,stop,catch,throwable,ex,logger,debug,could,not,stop,jms,connection,before,closing,it,ex,try,con,close,catch,throwable,ex,logger,debug,could,not,close,jms,connection,ex
ConnectionFactoryUtils -> public static void releaseConnection(Connection con, ConnectionFactory cf, boolean started);1486720600;Release the given Connection, stopping it (if necessary) and eventually closing it._<p>Checks {@link SmartConnectionFactory#shouldStop}, if available._This is essentially a more sophisticated version of_{@link org.springframework.jms.support.JmsUtils#closeConnection}._@param con the Connection to release_(if this is {@code null}, the call will be ignored)_@param cf the ConnectionFactory that the Connection was obtained from_(may be {@code null})_@param started whether the Connection might have been started by the application_@see SmartConnectionFactory#shouldStop_@see org.springframework.jms.support.JmsUtils#closeConnection;public static void releaseConnection(Connection con, ConnectionFactory cf, boolean started) {_		if (con == null) {_			return__		}_		if (started && cf instanceof SmartConnectionFactory && ((SmartConnectionFactory) cf).shouldStop(con)) {_			try {_				con.stop()__			}_			catch (Throwable ex) {_				logger.debug("Could not stop JMS Connection before closing it", ex)__			}_		}_		try {_			con.close()__		}_		catch (Throwable ex) {_			logger.debug("Could not close JMS Connection", ex)__		}_	};release,the,given,connection,stopping,it,if,necessary,and,eventually,closing,it,p,checks,link,smart,connection,factory,should,stop,if,available,this,is,essentially,a,more,sophisticated,version,of,link,org,springframework,jms,support,jms,utils,close,connection,param,con,the,connection,to,release,if,this,is,code,null,the,call,will,be,ignored,param,cf,the,connection,factory,that,the,connection,was,obtained,from,may,be,code,null,param,started,whether,the,connection,might,have,been,started,by,the,application,see,smart,connection,factory,should,stop,see,org,springframework,jms,support,jms,utils,close,connection;public,static,void,release,connection,connection,con,connection,factory,cf,boolean,started,if,con,null,return,if,started,cf,instanceof,smart,connection,factory,smart,connection,factory,cf,should,stop,con,try,con,stop,catch,throwable,ex,logger,debug,could,not,stop,jms,connection,before,closing,it,ex,try,con,close,catch,throwable,ex,logger,debug,could,not,close,jms,connection,ex
ConnectionFactoryUtils -> ResourceFactory -> @Nullable 		Session getSession(JmsResourceHolder holder)_;1495868221;Fetch an appropriate Session from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Session fetched from the holder,_or {@code null} if none found;@Nullable_		Session getSession(JmsResourceHolder holder)_;fetch,an,appropriate,session,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,session,fetched,from,the,holder,or,code,null,if,none,found;nullable,session,get,session,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> @Nullable 		Session getSession(JmsResourceHolder holder)_;1496837955;Fetch an appropriate Session from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Session fetched from the holder,_or {@code null} if none found;@Nullable_		Session getSession(JmsResourceHolder holder)_;fetch,an,appropriate,session,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,session,fetched,from,the,holder,or,code,null,if,none,found;nullable,session,get,session,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> @Nullable 		Session getSession(JmsResourceHolder holder)_;1502974979;Fetch an appropriate Session from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Session fetched from the holder,_or {@code null} if none found;@Nullable_		Session getSession(JmsResourceHolder holder)_;fetch,an,appropriate,session,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,session,fetched,from,the,holder,or,code,null,if,none,found;nullable,session,get,session,jms,resource,holder,holder
ConnectionFactoryUtils -> public static Session getTargetSession(Session session);1328020251;Return the innermost target Session of the given Session. If the given_Session is a proxy, it will be unwrapped until a non-proxy Session is_found. Otherwise, the passed-in Session will be returned as-is._@param session the Session proxy to unwrap_@return the innermost target Session, or the passed-in one if no proxy_@see SessionProxy#getTargetSession();public static Session getTargetSession(Session session) {_		Session sessionToUse = session__		while (sessionToUse instanceof SessionProxy) {_			sessionToUse = ((SessionProxy) sessionToUse).getTargetSession()__		}_		return sessionToUse__	};return,the,innermost,target,session,of,the,given,session,if,the,given,session,is,a,proxy,it,will,be,unwrapped,until,a,non,proxy,session,is,found,otherwise,the,passed,in,session,will,be,returned,as,is,param,session,the,session,proxy,to,unwrap,return,the,innermost,target,session,or,the,passed,in,one,if,no,proxy,see,session,proxy,get,target,session;public,static,session,get,target,session,session,session,session,session,to,use,session,while,session,to,use,instanceof,session,proxy,session,to,use,session,proxy,session,to,use,get,target,session,return,session,to,use
ConnectionFactoryUtils -> public static Session getTargetSession(Session session);1356735495;Return the innermost target Session of the given Session. If the given_Session is a proxy, it will be unwrapped until a non-proxy Session is_found. Otherwise, the passed-in Session will be returned as-is._@param session the Session proxy to unwrap_@return the innermost target Session, or the passed-in one if no proxy_@see SessionProxy#getTargetSession();public static Session getTargetSession(Session session) {_		Session sessionToUse = session__		while (sessionToUse instanceof SessionProxy) {_			sessionToUse = ((SessionProxy) sessionToUse).getTargetSession()__		}_		return sessionToUse__	};return,the,innermost,target,session,of,the,given,session,if,the,given,session,is,a,proxy,it,will,be,unwrapped,until,a,non,proxy,session,is,found,otherwise,the,passed,in,session,will,be,returned,as,is,param,session,the,session,proxy,to,unwrap,return,the,innermost,target,session,or,the,passed,in,one,if,no,proxy,see,session,proxy,get,target,session;public,static,session,get,target,session,session,session,session,session,to,use,session,while,session,to,use,instanceof,session,proxy,session,to,use,session,proxy,session,to,use,get,target,session,return,session,to,use
ConnectionFactoryUtils -> public static Session getTargetSession(Session session);1357119239;Return the innermost target Session of the given Session. If the given_Session is a proxy, it will be unwrapped until a non-proxy Session is_found. Otherwise, the passed-in Session will be returned as-is._@param session the Session proxy to unwrap_@return the innermost target Session, or the passed-in one if no proxy_@see SessionProxy#getTargetSession();public static Session getTargetSession(Session session) {_		Session sessionToUse = session__		while (sessionToUse instanceof SessionProxy) {_			sessionToUse = ((SessionProxy) sessionToUse).getTargetSession()__		}_		return sessionToUse__	};return,the,innermost,target,session,of,the,given,session,if,the,given,session,is,a,proxy,it,will,be,unwrapped,until,a,non,proxy,session,is,found,otherwise,the,passed,in,session,will,be,returned,as,is,param,session,the,session,proxy,to,unwrap,return,the,innermost,target,session,or,the,passed,in,one,if,no,proxy,see,session,proxy,get,target,session;public,static,session,get,target,session,session,session,session,session,to,use,session,while,session,to,use,instanceof,session,proxy,session,to,use,session,proxy,session,to,use,get,target,session,return,session,to,use
ConnectionFactoryUtils -> public static Session getTargetSession(Session session);1368482696;Return the innermost target Session of the given Session. If the given_Session is a proxy, it will be unwrapped until a non-proxy Session is_found. Otherwise, the passed-in Session will be returned as-is._@param session the Session proxy to unwrap_@return the innermost target Session, or the passed-in one if no proxy_@see SessionProxy#getTargetSession();public static Session getTargetSession(Session session) {_		Session sessionToUse = session__		while (sessionToUse instanceof SessionProxy) {_			sessionToUse = ((SessionProxy) sessionToUse).getTargetSession()__		}_		return sessionToUse__	};return,the,innermost,target,session,of,the,given,session,if,the,given,session,is,a,proxy,it,will,be,unwrapped,until,a,non,proxy,session,is,found,otherwise,the,passed,in,session,will,be,returned,as,is,param,session,the,session,proxy,to,unwrap,return,the,innermost,target,session,or,the,passed,in,one,if,no,proxy,see,session,proxy,get,target,session;public,static,session,get,target,session,session,session,session,session,to,use,session,while,session,to,use,instanceof,session,proxy,session,to,use,session,proxy,session,to,use,get,target,session,return,session,to,use
ConnectionFactoryUtils -> public static Session getTargetSession(Session session);1486720600;Return the innermost target Session of the given Session. If the given_Session is a proxy, it will be unwrapped until a non-proxy Session is_found. Otherwise, the passed-in Session will be returned as-is._@param session the Session proxy to unwrap_@return the innermost target Session, or the passed-in one if no proxy_@see SessionProxy#getTargetSession();public static Session getTargetSession(Session session) {_		Session sessionToUse = session__		while (sessionToUse instanceof SessionProxy) {_			sessionToUse = ((SessionProxy) sessionToUse).getTargetSession()__		}_		return sessionToUse__	};return,the,innermost,target,session,of,the,given,session,if,the,given,session,is,a,proxy,it,will,be,unwrapped,until,a,non,proxy,session,is,found,otherwise,the,passed,in,session,will,be,returned,as,is,param,session,the,session,proxy,to,unwrap,return,the,innermost,target,session,or,the,passed,in,one,if,no,proxy,see,session,proxy,get,target,session;public,static,session,get,target,session,session,session,session,session,to,use,session,while,session,to,use,instanceof,session,proxy,session,to,use,session,proxy,session,to,use,get,target,session,return,session,to,use
ConnectionFactoryUtils -> public static Session getTargetSession(Session session);1495868221;Return the innermost target Session of the given Session. If the given_Session is a proxy, it will be unwrapped until a non-proxy Session is_found. Otherwise, the passed-in Session will be returned as-is._@param session the Session proxy to unwrap_@return the innermost target Session, or the passed-in one if no proxy_@see SessionProxy#getTargetSession();public static Session getTargetSession(Session session) {_		Session sessionToUse = session__		while (sessionToUse instanceof SessionProxy) {_			sessionToUse = ((SessionProxy) sessionToUse).getTargetSession()__		}_		return sessionToUse__	};return,the,innermost,target,session,of,the,given,session,if,the,given,session,is,a,proxy,it,will,be,unwrapped,until,a,non,proxy,session,is,found,otherwise,the,passed,in,session,will,be,returned,as,is,param,session,the,session,proxy,to,unwrap,return,the,innermost,target,session,or,the,passed,in,one,if,no,proxy,see,session,proxy,get,target,session;public,static,session,get,target,session,session,session,session,session,to,use,session,while,session,to,use,instanceof,session,proxy,session,to,use,session,proxy,session,to,use,get,target,session,return,session,to,use
ConnectionFactoryUtils -> public static Session getTargetSession(Session session);1496837955;Return the innermost target Session of the given Session. If the given_Session is a proxy, it will be unwrapped until a non-proxy Session is_found. Otherwise, the passed-in Session will be returned as-is._@param session the Session proxy to unwrap_@return the innermost target Session, or the passed-in one if no proxy_@see SessionProxy#getTargetSession();public static Session getTargetSession(Session session) {_		Session sessionToUse = session__		while (sessionToUse instanceof SessionProxy) {_			sessionToUse = ((SessionProxy) sessionToUse).getTargetSession()__		}_		return sessionToUse__	};return,the,innermost,target,session,of,the,given,session,if,the,given,session,is,a,proxy,it,will,be,unwrapped,until,a,non,proxy,session,is,found,otherwise,the,passed,in,session,will,be,returned,as,is,param,session,the,session,proxy,to,unwrap,return,the,innermost,target,session,or,the,passed,in,one,if,no,proxy,see,session,proxy,get,target,session;public,static,session,get,target,session,session,session,session,session,to,use,session,while,session,to,use,instanceof,session,proxy,session,to,use,session,proxy,session,to,use,get,target,session,return,session,to,use
ConnectionFactoryUtils -> public static Session getTargetSession(Session session);1502974979;Return the innermost target Session of the given Session. If the given_Session is a proxy, it will be unwrapped until a non-proxy Session is_found. Otherwise, the passed-in Session will be returned as-is._@param session the Session proxy to unwrap_@return the innermost target Session, or the passed-in one if no proxy_@see SessionProxy#getTargetSession();public static Session getTargetSession(Session session) {_		Session sessionToUse = session__		while (sessionToUse instanceof SessionProxy) {_			sessionToUse = ((SessionProxy) sessionToUse).getTargetSession()__		}_		return sessionToUse__	};return,the,innermost,target,session,of,the,given,session,if,the,given,session,is,a,proxy,it,will,be,unwrapped,until,a,non,proxy,session,is,found,otherwise,the,passed,in,session,will,be,returned,as,is,param,session,the,session,proxy,to,unwrap,return,the,innermost,target,session,or,the,passed,in,one,if,no,proxy,see,session,proxy,get,target,session;public,static,session,get,target,session,session,session,session,session,to,use,session,while,session,to,use,instanceof,session,proxy,session,to,use,session,proxy,session,to,use,get,target,session,return,session,to,use
ConnectionFactoryUtils -> ResourceFactory -> Session getSession(JmsResourceHolder holder)_;1328020251;Fetch an appropriate Session from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Session fetched from the holder,_or <code>null</code> if none found;Session getSession(JmsResourceHolder holder)_;fetch,an,appropriate,session,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,session,fetched,from,the,holder,or,code,null,code,if,none,found;session,get,session,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> Session getSession(JmsResourceHolder holder)_;1356735495;Fetch an appropriate Session from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Session fetched from the holder,_or {@code null} if none found;Session getSession(JmsResourceHolder holder)_;fetch,an,appropriate,session,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,session,fetched,from,the,holder,or,code,null,if,none,found;session,get,session,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> Session getSession(JmsResourceHolder holder)_;1357119239;Fetch an appropriate Session from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Session fetched from the holder,_or {@code null} if none found;Session getSession(JmsResourceHolder holder)_;fetch,an,appropriate,session,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,session,fetched,from,the,holder,or,code,null,if,none,found;session,get,session,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> Session getSession(JmsResourceHolder holder)_;1368482696;Fetch an appropriate Session from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Session fetched from the holder,_or {@code null} if none found;Session getSession(JmsResourceHolder holder)_;fetch,an,appropriate,session,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,session,fetched,from,the,holder,or,code,null,if,none,found;session,get,session,jms,resource,holder,holder
ConnectionFactoryUtils -> ResourceFactory -> Session getSession(JmsResourceHolder holder)_;1486720600;Fetch an appropriate Session from the given JmsResourceHolder._@param holder the JmsResourceHolder_@return an appropriate Session fetched from the holder,_or {@code null} if none found;Session getSession(JmsResourceHolder holder)_;fetch,an,appropriate,session,from,the,given,jms,resource,holder,param,holder,the,jms,resource,holder,return,an,appropriate,session,fetched,from,the,holder,or,code,null,if,none,found;session,get,session,jms,resource,holder,holder
ConnectionFactoryUtils -> @Nullable 	public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException;1495868221;Obtain a JMS Session that is synchronized with the current transaction, if any._<p>This {@code doGetTransactionalSession} variant always starts the underlying_JMS Connection, assuming that the Session will be used for receiving messages._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure_@see #doGetTransactionalSession(javax.jms.ConnectionFactory, ResourceFactory, boolean);@Nullable_	public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {__		return doGetTransactionalSession(connectionFactory, resourceFactory, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,p,this,code,do,get,transactional,session,variant,always,starts,the,underlying,jms,connection,assuming,that,the,session,will,be,used,for,receiving,messages,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure,see,do,get,transactional,session,javax,jms,connection,factory,resource,factory,boolean;nullable,public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,throws,jmsexception,return,do,get,transactional,session,connection,factory,resource,factory,true
ConnectionFactoryUtils -> @Nullable 	public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException;1496837955;Obtain a JMS Session that is synchronized with the current transaction, if any._<p>This {@code doGetTransactionalSession} variant always starts the underlying_JMS Connection, assuming that the Session will be used for receiving messages._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure_@see #doGetTransactionalSession(javax.jms.ConnectionFactory, ResourceFactory, boolean);@Nullable_	public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {__		return doGetTransactionalSession(connectionFactory, resourceFactory, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,p,this,code,do,get,transactional,session,variant,always,starts,the,underlying,jms,connection,assuming,that,the,session,will,be,used,for,receiving,messages,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure,see,do,get,transactional,session,javax,jms,connection,factory,resource,factory,boolean;nullable,public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,throws,jmsexception,return,do,get,transactional,session,connection,factory,resource,factory,true
ConnectionFactoryUtils -> @Nullable 	public static Session doGetTransactionalSession( 			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException;1502974979;Obtain a JMS Session that is synchronized with the current transaction, if any._<p>This {@code doGetTransactionalSession} variant always starts the underlying_JMS Connection, assuming that the Session will be used for receiving messages._@param connectionFactory the JMS ConnectionFactory to bind for_(used as TransactionSynchronizationManager key)_@param resourceFactory the ResourceFactory to use for extracting or creating_JMS resources_@return the transactional Session, or {@code null} if none found_@throws JMSException in case of JMS failure_@see #doGetTransactionalSession(javax.jms.ConnectionFactory, ResourceFactory, boolean);@Nullable_	public static Session doGetTransactionalSession(_			ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {__		return doGetTransactionalSession(connectionFactory, resourceFactory, true)__	};obtain,a,jms,session,that,is,synchronized,with,the,current,transaction,if,any,p,this,code,do,get,transactional,session,variant,always,starts,the,underlying,jms,connection,assuming,that,the,session,will,be,used,for,receiving,messages,param,connection,factory,the,jms,connection,factory,to,bind,for,used,as,transaction,synchronization,manager,key,param,resource,factory,the,resource,factory,to,use,for,extracting,or,creating,jms,resources,return,the,transactional,session,or,code,null,if,none,found,throws,jmsexception,in,case,of,jms,failure,see,do,get,transactional,session,javax,jms,connection,factory,resource,factory,boolean;nullable,public,static,session,do,get,transactional,session,connection,factory,connection,factory,resource,factory,resource,factory,throws,jmsexception,return,do,get,transactional,session,connection,factory,resource,factory,true
ConnectionFactoryUtils -> public static boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf);1496837955;Determine whether the given JMS Session is transactional, that is,_bound to the current thread by Spring's transaction facilities._@param session the JMS Session to check_@param cf the JMS ConnectionFactory that the Session originated from_@return whether the Session is transactional;public static boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf) {_		if (session == null || cf == null) {_			return false__		}_		JmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf)__		return (resourceHolder != null && resourceHolder.containsSession(session))__	};determine,whether,the,given,jms,session,is,transactional,that,is,bound,to,the,current,thread,by,spring,s,transaction,facilities,param,session,the,jms,session,to,check,param,cf,the,jms,connection,factory,that,the,session,originated,from,return,whether,the,session,is,transactional;public,static,boolean,is,session,transactional,nullable,session,session,nullable,connection,factory,cf,if,session,null,cf,null,return,false,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,cf,return,resource,holder,null,resource,holder,contains,session,session
ConnectionFactoryUtils -> public static boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf);1502974979;Determine whether the given JMS Session is transactional, that is,_bound to the current thread by Spring's transaction facilities._@param session the JMS Session to check_@param cf the JMS ConnectionFactory that the Session originated from_@return whether the Session is transactional;public static boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf) {_		if (session == null || cf == null) {_			return false__		}_		JmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf)__		return (resourceHolder != null && resourceHolder.containsSession(session))__	};determine,whether,the,given,jms,session,is,transactional,that,is,bound,to,the,current,thread,by,spring,s,transaction,facilities,param,session,the,jms,session,to,check,param,cf,the,jms,connection,factory,that,the,session,originated,from,return,whether,the,session,is,transactional;public,static,boolean,is,session,transactional,nullable,session,session,nullable,connection,factory,cf,if,session,null,cf,null,return,false,jms,resource,holder,resource,holder,jms,resource,holder,transaction,synchronization,manager,get,resource,cf,return,resource,holder,null,resource,holder,contains,session,session
