commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;19;/**  * Release the given Connection, stopping it (if necessary) and eventually closing it.  * <p>Checks {@link SmartConnectionFactory#shouldStop}, if available.  * This is essentially a more sophisticated version of  * {@link org.springframework.jms.support.JmsUtils#closeConnection}.  * @param con the Connection to release  * (if this is {@code null}, the call will be ignored)  * @param cf the ConnectionFactory that the Connection was obtained from  * (may be {@code null})  * @param started whether the Connection might have been started by the application  * @see SmartConnectionFactory#shouldStop  * @see org.springframework.jms.support.JmsUtils#closeConnection  */ ;/**  * Release the given Connection, stopping it (if necessary) and eventually closing it.  * <p>Checks {@link SmartConnectionFactory#shouldStop}, if available.  * This is essentially a more sophisticated version of  * {@link org.springframework.jms.support.JmsUtils#closeConnection}.  * @param con the Connection to release  * (if this is {@code null}, the call will be ignored)  * @param cf the ConnectionFactory that the Connection was obtained from  * (may be {@code null})  * @param started whether the Connection might have been started by the application  * @see SmartConnectionFactory#shouldStop  * @see org.springframework.jms.support.JmsUtils#closeConnection  */ public static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf, boolean started) {     if (con == null) {         return.     }     if (started && cf instanceof SmartConnectionFactory && ((SmartConnectionFactory) cf).shouldStop(con)) {         try {             con.stop().         } catch (Throwable ex) {             logger.debug("Could not stop JMS Connection before closing it", ex).         }     }     try {         con.close().     } catch (Throwable ex) {         logger.debug("Could not close JMS Connection", ex).     } }
true;public,static;1;7;/**  * Return the innermost target Session of the given Session. If the given  * Session is a proxy, it will be unwrapped until a non-proxy Session is  * found. Otherwise, the passed-in Session will be returned as-is.  * @param session the Session proxy to unwrap  * @return the innermost target Session, or the passed-in one if no proxy  * @see SessionProxy#getTargetSession()  */ ;/**  * Return the innermost target Session of the given Session. If the given  * Session is a proxy, it will be unwrapped until a non-proxy Session is  * found. Otherwise, the passed-in Session will be returned as-is.  * @param session the Session proxy to unwrap  * @return the innermost target Session, or the passed-in one if no proxy  * @see SessionProxy#getTargetSession()  */ public static Session getTargetSession(Session session) {     Session sessionToUse = session.     while (sessionToUse instanceof SessionProxy) {         sessionToUse = ((SessionProxy) sessionToUse).getTargetSession().     }     return sessionToUse. }
true;public,static;2;7;/**  * Determine whether the given JMS Session is transactional, that is,  * bound to the current thread by Spring's transaction facilities.  * @param session the JMS Session to check  * @param cf the JMS ConnectionFactory that the Session originated from  * @return whether the Session is transactional  */ ;/**  * Determine whether the given JMS Session is transactional, that is,  * bound to the current thread by Spring's transaction facilities.  * @param session the JMS Session to check  * @param cf the JMS ConnectionFactory that the Session originated from  * @return whether the Session is transactional  */ public static boolean isSessionTransactional(@Nullable Session session, @Nullable ConnectionFactory cf) {     if (session == null || cf == null) {         return false.     }     JmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(cf).     return (resourceHolder != null && resourceHolder.containsSession(session)). }
false;public;1;5;;@Override @Nullable public Session getSession(JmsResourceHolder holder) {     return holder.getSession(Session.class, existingCon). }
false;public;1;5;;@Override @Nullable public Connection getConnection(JmsResourceHolder holder) {     return (existingCon != null ? existingCon : holder.getConnection()). }
false;public;0;4;;@Override public Connection createConnection() throws JMSException {     return cf.createConnection(). }
false;public;1;4;;@Override public Session createSession(Connection con) throws JMSException {     return con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE). }
false;public;0;4;;@Override public boolean isSynchedLocalTransactionAllowed() {     return synchedLocalTransactionAllowed. }
true;public,static;3;30;/**  * Obtain a JMS Session that is synchronized with the current transaction, if any.  * @param cf the ConnectionFactory to obtain a Session for  * @param existingCon the existing JMS Connection to obtain a Session for  * (may be {@code null})  * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction  * that is synchronized with a Spring-managed transaction (where the main transaction  * might be a JDBC-based one for a specific DataSource, for example), with the JMS  * transaction committing right after the main transaction. If not allowed, the given  * ConnectionFactory needs to handle transaction enlistment underneath the covers.  * @return the transactional Session, or {@code null} if none found  * @throws JMSException in case of JMS failure  */ ;/**  * Obtain a JMS Session that is synchronized with the current transaction, if any.  * @param cf the ConnectionFactory to obtain a Session for  * @param existingCon the existing JMS Connection to obtain a Session for  * (may be {@code null})  * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction  * that is synchronized with a Spring-managed transaction (where the main transaction  * might be a JDBC-based one for a specific DataSource, for example), with the JMS  * transaction committing right after the main transaction. If not allowed, the given  * ConnectionFactory needs to handle transaction enlistment underneath the covers.  * @return the transactional Session, or {@code null} if none found  * @throws JMSException in case of JMS failure  */ @Nullable public static Session getTransactionalSession(final ConnectionFactory cf, @Nullable final Connection existingCon, final boolean synchedLocalTransactionAllowed) throws JMSException {     return doGetTransactionalSession(cf, new ResourceFactory() {          @Override         @Nullable         public Session getSession(JmsResourceHolder holder) {             return holder.getSession(Session.class, existingCon).         }          @Override         @Nullable         public Connection getConnection(JmsResourceHolder holder) {             return (existingCon != null ? existingCon : holder.getConnection()).         }          @Override         public Connection createConnection() throws JMSException {             return cf.createConnection().         }          @Override         public Session createSession(Connection con) throws JMSException {             return con.createSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE).         }          @Override         public boolean isSynchedLocalTransactionAllowed() {             return synchedLocalTransactionAllowed.         }     }, true). }
false;public;1;5;;@Override @Nullable public Session getSession(JmsResourceHolder holder) {     return holder.getSession(QueueSession.class, existingCon). }
false;public;1;5;;@Override @Nullable public Connection getConnection(JmsResourceHolder holder) {     return (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class)). }
false;public;0;4;;@Override public Connection createConnection() throws JMSException {     return cf.createQueueConnection(). }
false;public;1;4;;@Override public Session createSession(Connection con) throws JMSException {     return ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE). }
false;public;0;4;;@Override public boolean isSynchedLocalTransactionAllowed() {     return synchedLocalTransactionAllowed. }
true;public,static;3;30;/**  * Obtain a JMS QueueSession that is synchronized with the current transaction, if any.  * <p>Mainly intended for use with the JMS 1.0.2 API.  * @param cf the ConnectionFactory to obtain a Session for  * @param existingCon the existing JMS Connection to obtain a Session for  * (may be {@code null})  * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction  * that is synchronized with a Spring-managed transaction (where the main transaction  * might be a JDBC-based one for a specific DataSource, for example), with the JMS  * transaction committing right after the main transaction. If not allowed, the given  * ConnectionFactory needs to handle transaction enlistment underneath the covers.  * @return the transactional Session, or {@code null} if none found  * @throws JMSException in case of JMS failure  */ ;/**  * Obtain a JMS QueueSession that is synchronized with the current transaction, if any.  * <p>Mainly intended for use with the JMS 1.0.2 API.  * @param cf the ConnectionFactory to obtain a Session for  * @param existingCon the existing JMS Connection to obtain a Session for  * (may be {@code null})  * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction  * that is synchronized with a Spring-managed transaction (where the main transaction  * might be a JDBC-based one for a specific DataSource, for example), with the JMS  * transaction committing right after the main transaction. If not allowed, the given  * ConnectionFactory needs to handle transaction enlistment underneath the covers.  * @return the transactional Session, or {@code null} if none found  * @throws JMSException in case of JMS failure  */ @Nullable public static QueueSession getTransactionalQueueSession(final QueueConnectionFactory cf, @Nullable final QueueConnection existingCon, final boolean synchedLocalTransactionAllowed) throws JMSException {     return (QueueSession) doGetTransactionalSession(cf, new ResourceFactory() {          @Override         @Nullable         public Session getSession(JmsResourceHolder holder) {             return holder.getSession(QueueSession.class, existingCon).         }          @Override         @Nullable         public Connection getConnection(JmsResourceHolder holder) {             return (existingCon != null ? existingCon : holder.getConnection(QueueConnection.class)).         }          @Override         public Connection createConnection() throws JMSException {             return cf.createQueueConnection().         }          @Override         public Session createSession(Connection con) throws JMSException {             return ((QueueConnection) con).createQueueSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE).         }          @Override         public boolean isSynchedLocalTransactionAllowed() {             return synchedLocalTransactionAllowed.         }     }, true). }
false;public;1;5;;@Override @Nullable public Session getSession(JmsResourceHolder holder) {     return holder.getSession(TopicSession.class, existingCon). }
false;public;1;5;;@Override @Nullable public Connection getConnection(JmsResourceHolder holder) {     return (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class)). }
false;public;0;4;;@Override public Connection createConnection() throws JMSException {     return cf.createTopicConnection(). }
false;public;1;5;;@Override public Session createSession(Connection con) throws JMSException {     return ((TopicConnection) con).createTopicSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE). }
false;public;0;4;;@Override public boolean isSynchedLocalTransactionAllowed() {     return synchedLocalTransactionAllowed. }
true;public,static;3;31;/**  * Obtain a JMS TopicSession that is synchronized with the current transaction, if any.  * <p>Mainly intended for use with the JMS 1.0.2 API.  * @param cf the ConnectionFactory to obtain a Session for  * @param existingCon the existing JMS Connection to obtain a Session for  * (may be {@code null})  * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction  * that is synchronized with a Spring-managed transaction (where the main transaction  * might be a JDBC-based one for a specific DataSource, for example), with the JMS  * transaction committing right after the main transaction. If not allowed, the given  * ConnectionFactory needs to handle transaction enlistment underneath the covers.  * @return the transactional Session, or {@code null} if none found  * @throws JMSException in case of JMS failure  */ ;/**  * Obtain a JMS TopicSession that is synchronized with the current transaction, if any.  * <p>Mainly intended for use with the JMS 1.0.2 API.  * @param cf the ConnectionFactory to obtain a Session for  * @param existingCon the existing JMS Connection to obtain a Session for  * (may be {@code null})  * @param synchedLocalTransactionAllowed whether to allow for a local JMS transaction  * that is synchronized with a Spring-managed transaction (where the main transaction  * might be a JDBC-based one for a specific DataSource, for example), with the JMS  * transaction committing right after the main transaction. If not allowed, the given  * ConnectionFactory needs to handle transaction enlistment underneath the covers.  * @return the transactional Session, or {@code null} if none found  * @throws JMSException in case of JMS failure  */ @Nullable public static TopicSession getTransactionalTopicSession(final TopicConnectionFactory cf, @Nullable final TopicConnection existingCon, final boolean synchedLocalTransactionAllowed) throws JMSException {     return (TopicSession) doGetTransactionalSession(cf, new ResourceFactory() {          @Override         @Nullable         public Session getSession(JmsResourceHolder holder) {             return holder.getSession(TopicSession.class, existingCon).         }          @Override         @Nullable         public Connection getConnection(JmsResourceHolder holder) {             return (existingCon != null ? existingCon : holder.getConnection(TopicConnection.class)).         }          @Override         public Connection createConnection() throws JMSException {             return cf.createTopicConnection().         }          @Override         public Session createSession(Connection con) throws JMSException {             return ((TopicConnection) con).createTopicSession(synchedLocalTransactionAllowed, Session.AUTO_ACKNOWLEDGE).         }          @Override         public boolean isSynchedLocalTransactionAllowed() {             return synchedLocalTransactionAllowed.         }     }, true). }
true;public,static;2;6;/**  * Obtain a JMS Session that is synchronized with the current transaction, if any.  * <p>This {@code doGetTransactionalSession} variant always starts the underlying  * JMS Connection, assuming that the Session will be used for receiving messages.  * @param connectionFactory the JMS ConnectionFactory to bind for  * (used as TransactionSynchronizationManager key)  * @param resourceFactory the ResourceFactory to use for extracting or creating  * JMS resources  * @return the transactional Session, or {@code null} if none found  * @throws JMSException in case of JMS failure  * @see #doGetTransactionalSession(javax.jms.ConnectionFactory, ResourceFactory, boolean)  */ ;/**  * Obtain a JMS Session that is synchronized with the current transaction, if any.  * <p>This {@code doGetTransactionalSession} variant always starts the underlying  * JMS Connection, assuming that the Session will be used for receiving messages.  * @param connectionFactory the JMS ConnectionFactory to bind for  * (used as TransactionSynchronizationManager key)  * @param resourceFactory the ResourceFactory to use for extracting or creating  * JMS resources  * @return the transactional Session, or {@code null} if none found  * @throws JMSException in case of JMS failure  * @see #doGetTransactionalSession(javax.jms.ConnectionFactory, ResourceFactory, boolean)  */ @Nullable public static Session doGetTransactionalSession(ConnectionFactory connectionFactory, ResourceFactory resourceFactory) throws JMSException {     return doGetTransactionalSession(connectionFactory, resourceFactory, true). }
true;public,static;3;74;/**  * Obtain a JMS Session that is synchronized with the current transaction, if any.  * @param connectionFactory the JMS ConnectionFactory to bind for  * (used as TransactionSynchronizationManager key)  * @param resourceFactory the ResourceFactory to use for extracting or creating  * JMS resources  * @param startConnection whether the underlying JMS Connection approach should be  * started in order to allow for receiving messages. Note that a reused Connection  * may already have been started before, even if this flag is {@code false}.  * @return the transactional Session, or {@code null} if none found  * @throws JMSException in case of JMS failure  */ ;/**  * Obtain a JMS Session that is synchronized with the current transaction, if any.  * @param connectionFactory the JMS ConnectionFactory to bind for  * (used as TransactionSynchronizationManager key)  * @param resourceFactory the ResourceFactory to use for extracting or creating  * JMS resources  * @param startConnection whether the underlying JMS Connection approach should be  * started in order to allow for receiving messages. Note that a reused Connection  * may already have been started before, even if this flag is {@code false}.  * @return the transactional Session, or {@code null} if none found  * @throws JMSException in case of JMS failure  */ @Nullable public static Session doGetTransactionalSession(ConnectionFactory connectionFactory, ResourceFactory resourceFactory, boolean startConnection) throws JMSException {     Assert.notNull(connectionFactory, "ConnectionFactory must not be null").     Assert.notNull(resourceFactory, "ResourceFactory must not be null").     JmsResourceHolder resourceHolder = (JmsResourceHolder) TransactionSynchronizationManager.getResource(connectionFactory).     if (resourceHolder != null) {         Session session = resourceFactory.getSession(resourceHolder).         if (session != null) {             if (startConnection) {                 Connection con = resourceFactory.getConnection(resourceHolder).                 if (con != null) {                     con.start().                 }             }             return session.         }         if (resourceHolder.isFrozen()) {             return null.         }     }     if (!TransactionSynchronizationManager.isSynchronizationActive()) {         return null.     }     JmsResourceHolder resourceHolderToUse = resourceHolder.     if (resourceHolderToUse == null) {         resourceHolderToUse = new JmsResourceHolder(connectionFactory).     }     Connection con = resourceFactory.getConnection(resourceHolderToUse).     Session session = null.     try {         boolean isExistingCon = (con != null).         if (!isExistingCon) {             con = resourceFactory.createConnection().             resourceHolderToUse.addConnection(con).         }         session = resourceFactory.createSession(con).         resourceHolderToUse.addSession(session, con).         if (startConnection) {             con.start().         }     } catch (JMSException ex) {         if (session != null) {             try {                 session.close().             } catch (Throwable ex2) {             // ignore             }         }         if (con != null) {             try {                 con.close().             } catch (Throwable ex2) {             // ignore             }         }         throw ex.     }     if (resourceHolderToUse != resourceHolder) {         TransactionSynchronizationManager.registerSynchronization(new JmsResourceSynchronization(resourceHolderToUse, connectionFactory, resourceFactory.isSynchedLocalTransactionAllowed())).         resourceHolderToUse.setSynchronizedWithTransaction(true).         TransactionSynchronizationManager.bindResource(connectionFactory, resourceHolderToUse).     }     return session. }
true;;1;2;/**  * Fetch an appropriate Session from the given JmsResourceHolder.  * @param holder the JmsResourceHolder  * @return an appropriate Session fetched from the holder,  * or {@code null} if none found  */ ;/**  * Fetch an appropriate Session from the given JmsResourceHolder.  * @param holder the JmsResourceHolder  * @return an appropriate Session fetched from the holder,  * or {@code null} if none found  */ @Nullable Session getSession(JmsResourceHolder holder).
true;;1;2;/**  * Fetch an appropriate Connection from the given JmsResourceHolder.  * @param holder the JmsResourceHolder  * @return an appropriate Connection fetched from the holder,  * or {@code null} if none found  */ ;/**  * Fetch an appropriate Connection from the given JmsResourceHolder.  * @param holder the JmsResourceHolder  * @return an appropriate Connection fetched from the holder,  * or {@code null} if none found  */ @Nullable Connection getConnection(JmsResourceHolder holder).
true;;0;1;/**  * Create a new JMS Connection for registration with a JmsResourceHolder.  * @return the new JMS Connection  * @throws JMSException if thrown by JMS API methods  */ ;/**  * Create a new JMS Connection for registration with a JmsResourceHolder.  * @return the new JMS Connection  * @throws JMSException if thrown by JMS API methods  */ Connection createConnection() throws JMSException.
true;;1;1;/**  * Create a new JMS Session for registration with a JmsResourceHolder.  * @param con the JMS Connection to create a Session for  * @return the new JMS Session  * @throws JMSException if thrown by JMS API methods  */ ;/**  * Create a new JMS Session for registration with a JmsResourceHolder.  * @param con the JMS Connection to create a Session for  * @return the new JMS Session  * @throws JMSException if thrown by JMS API methods  */ Session createSession(Connection con) throws JMSException.
true;;0;1;/**  * Return whether to allow for a local JMS transaction that is synchronized with  * a Spring-managed transaction (where the main transaction might be a JDBC-based  * one for a specific DataSource, for example), with the JMS transaction  * committing right after the main transaction.  * @return whether to allow for synchronizing a local JMS transaction  */ ;/**  * Return whether to allow for a local JMS transaction that is synchronized with  * a Spring-managed transaction (where the main transaction might be a JDBC-based  * one for a specific DataSource, for example), with the JMS transaction  * committing right after the main transaction.  * @return whether to allow for synchronizing a local JMS transaction  */ boolean isSynchedLocalTransactionAllowed().
false;protected;0;4;;@Override protected boolean shouldReleaseBeforeCompletion() {     return !this.transacted. }
false;protected;1;9;;@Override protected void processResourceAfterCommit(JmsResourceHolder resourceHolder) {     try {         resourceHolder.commitAll().     } catch (JMSException ex) {         throw new SynchedLocalTransactionFailedException("Local JMS transaction failed to commit", ex).     } }
false;protected;2;4;;@Override protected void releaseResource(JmsResourceHolder resourceHolder, Object resourceKey) {     resourceHolder.closeAll(). }
