commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@After public void closeContext() {     if (this.context != null) {         this.context.close().     } }
false;public;0;13;;@Test public void immediately() {     load(ImmediateTestListener.class).     this.transactionTemplate.execute(status -> {         getContext().publishEvent("test").         getEventCollector().assertEvents(EventCollector.IMMEDIATELY, "test").         getEventCollector().assertTotalEventsCount(1).         return null.     }).     getEventCollector().assertEvents(EventCollector.IMMEDIATELY, "test").     getEventCollector().assertTotalEventsCount(1). }
false;public;0;17;;@Test public void immediatelyImpactsCurrentTransaction() {     load(ImmediateTestListener.class, BeforeCommitTestListener.class).     try {         this.transactionTemplate.execute(status -> {             getContext().publishEvent("FAIL").             fail("Should have thrown an exception at this point").             return null.         }).     } catch (IllegalStateException e) {         assertTrue(e.getMessage().contains("Test exception")).         assertTrue(e.getMessage().contains(EventCollector.IMMEDIATELY)).     }     getEventCollector().assertEvents(EventCollector.IMMEDIATELY, "FAIL").     getEventCollector().assertTotalEventsCount(1). }
false;public;0;12;;@Test public void afterCompletionCommit() {     load(AfterCompletionTestListener.class).     this.transactionTemplate.execute(status -> {         getContext().publishEvent("test").         getEventCollector().assertNoEventReceived().         return null.     }).     getEventCollector().assertEvents(EventCollector.AFTER_COMPLETION, "test").     // After rollback not invoked     getEventCollector().assertTotalEventsCount(1). }
false;public;0;13;;@Test public void afterCompletionRollback() {     load(AfterCompletionTestListener.class).     this.transactionTemplate.execute(status -> {         getContext().publishEvent("test").         getEventCollector().assertNoEventReceived().         status.setRollbackOnly().         return null.     }).     getEventCollector().assertEvents(EventCollector.AFTER_COMPLETION, "test").     // After rollback not invoked     getEventCollector().assertTotalEventsCount(1). }
false;public;0;12;;@Test public void afterCommit() {     load(AfterCompletionExplicitTestListener.class).     this.transactionTemplate.execute(status -> {         getContext().publishEvent("test").         getEventCollector().assertNoEventReceived().         return null.     }).     getEventCollector().assertEvents(EventCollector.AFTER_COMMIT, "test").     // After rollback not invoked     getEventCollector().assertTotalEventsCount(1). }
false;public;0;10;;@Test public void afterCommitWithTransactionalComponentListenerProxiedViaDynamicProxy() {     load(TransactionalConfiguration.class, TransactionalComponentTestListener.class).     this.transactionTemplate.execute(status -> {         getContext().publishEvent("SKIP").         getEventCollector().assertNoEventReceived().         return null.     }).     getEventCollector().assertNoEventReceived(). }
false;public;0;12;;@Test public void afterRollback() {     load(AfterCompletionExplicitTestListener.class).     this.transactionTemplate.execute(status -> {         getContext().publishEvent("test").         getEventCollector().assertNoEventReceived().         status.setRollbackOnly().         return null.     }).     getEventCollector().assertEvents(EventCollector.AFTER_ROLLBACK, "test").     // After commit not invoked     getEventCollector().assertTotalEventsCount(1). }
false;public;1;4;;@Override public void beforeCommit(boolean readOnly) {     // Not seen yet     getEventCollector().assertNoEventReceived(). }
false;public;1;5;;@Override public void beforeCommit(boolean readOnly) {     getEventCollector().assertEvents(EventCollector.BEFORE_COMMIT, "test").     getEventCollector().assertTotalEventsCount(1). }
false;public;0;25;;@Test public void beforeCommit() {     load(BeforeCommitTestListener.class).     this.transactionTemplate.execute(status -> {         TransactionSynchronizationManager.registerSynchronization(new EventTransactionSynchronization(10) {              @Override             public void beforeCommit(boolean readOnly) {                 // Not seen yet                 getEventCollector().assertNoEventReceived().             }         }).         TransactionSynchronizationManager.registerSynchronization(new EventTransactionSynchronization(20) {              @Override             public void beforeCommit(boolean readOnly) {                 getEventCollector().assertEvents(EventCollector.BEFORE_COMMIT, "test").                 getEventCollector().assertTotalEventsCount(1).             }         }).         getContext().publishEvent("test").         getEventCollector().assertNoEventReceived().         return null.     }).     getEventCollector().assertEvents(EventCollector.BEFORE_COMMIT, "test").     getEventCollector().assertTotalEventsCount(1). }
false;public;1;4;;@Override public void beforeCommit(boolean readOnly) {     throw new IllegalStateException("test"). }
false;public;0;23;;@Test public void beforeCommitWithException() {     // Validates the custom synchronization is invoked     load(BeforeCommitTestListener.class).     try {         this.transactionTemplate.execute(status -> {             TransactionSynchronizationManager.registerSynchronization(new EventTransactionSynchronization(10) {                  @Override                 public void beforeCommit(boolean readOnly) {                     throw new IllegalStateException("test").                 }             }).             getContext().publishEvent("test").             getEventCollector().assertNoEventReceived().             return null.         }).         fail("Should have thrown an exception").     } catch (IllegalStateException e) {     // Test exception - ignore     }     // Before commit not invoked     getEventCollector().assertNoEventReceived(). }
false;public;1;5;;@Override public void beforeCommit(boolean readOnly) {     // Immediate event     getEventCollector().assertTotalEventsCount(1).     getEventCollector().assertEvents(EventCollector.IMMEDIATELY, "test"). }
false;public;1;5;;@Override public void beforeCommit(boolean readOnly) {     getEventCollector().assertEvents(EventCollector.BEFORE_COMMIT, "test").     getEventCollector().assertTotalEventsCount(2). }
false;public;0;26;;@Test public void regularTransaction() {     load(ImmediateTestListener.class, BeforeCommitTestListener.class, AfterCompletionExplicitTestListener.class).     this.transactionTemplate.execute(status -> {         TransactionSynchronizationManager.registerSynchronization(new EventTransactionSynchronization(10) {              @Override             public void beforeCommit(boolean readOnly) {                 // Immediate event                 getEventCollector().assertTotalEventsCount(1).                 getEventCollector().assertEvents(EventCollector.IMMEDIATELY, "test").             }         }).         TransactionSynchronizationManager.registerSynchronization(new EventTransactionSynchronization(20) {              @Override             public void beforeCommit(boolean readOnly) {                 getEventCollector().assertEvents(EventCollector.BEFORE_COMMIT, "test").                 getEventCollector().assertTotalEventsCount(2).             }         }).         getContext().publishEvent("test").         getEventCollector().assertTotalEventsCount(1).         return null.     }).     getEventCollector().assertEvents(EventCollector.AFTER_COMMIT, "test").     // Immediate, before commit, after commit     getEventCollector().assertTotalEventsCount(3). }
false;public;0;7;;@Test public void noTransaction() {     load(BeforeCommitTestListener.class, AfterCompletionTestListener.class, AfterCompletionExplicitTestListener.class).     this.context.publishEvent("test").     getEventCollector().assertTotalEventsCount(0). }
false;public;0;10;;@Test public void noTransactionWithFallbackExecution() {     load(FallbackExecutionTestListener.class).     this.context.publishEvent("test").     this.eventCollector.assertEvents(EventCollector.BEFORE_COMMIT, "test").     this.eventCollector.assertEvents(EventCollector.AFTER_COMMIT, "test").     this.eventCollector.assertEvents(EventCollector.AFTER_ROLLBACK, "test").     this.eventCollector.assertEvents(EventCollector.AFTER_COMPLETION, "test").     getEventCollector().assertTotalEventsCount(4). }
false;public;0;10;;@Test public void conditionFoundOnTransactionalEventListener() {     load(ImmediateTestListener.class).     this.transactionTemplate.execute(status -> {         getContext().publishEvent("SKIP").         getEventCollector().assertNoEventReceived().         return null.     }).     getEventCollector().assertNoEventReceived(). }
false;public;0;12;;@Test public void afterCommitMetaAnnotation() throws Exception {     load(AfterCommitMetaAnnotationTestListener.class).     this.transactionTemplate.execute(status -> {         getContext().publishEvent("test").         getEventCollector().assertNoEventReceived().         return null.     }).     getEventCollector().assertEvents(EventCollector.AFTER_COMMIT, "test").     getEventCollector().assertTotalEventsCount(1). }
false;public;0;11;;@Test public void conditionFoundOnMetaAnnotation() {     load(AfterCommitMetaAnnotationTestListener.class).     this.transactionTemplate.execute(status -> {         getContext().publishEvent("SKIP").         getEventCollector().assertNoEventReceived().         return null.     }).     getEventCollector().assertNoEventReceived(). }
false;protected;0;3;;protected EventCollector getEventCollector() {     return eventCollector. }
false;protected;0;3;;protected ConfigurableApplicationContext getContext() {     return context. }
false;private;1;6;;private void load(Class<?>... classes) {     List<Class<?>> allClasses = new ArrayList<>().     allClasses.add(BasicConfiguration.class).     allClasses.addAll(Arrays.asList(classes)).     doLoad(allClasses.toArray(new Class<?>[allClasses.size()])). }
false;private;1;4;;private void doLoad(Class<?>... classes) {     this.context = new AnnotationConfigApplicationContext(classes).     this.eventCollector = this.context.getBean(EventCollector.class). }
false;public;0;4;;// set automatically with tx management @Bean public TransactionalEventListenerFactory transactionalEventListenerFactory() {     return new TransactionalEventListenerFactory(). }
false;public;0;4;;@Bean public EventCollector eventCollector() {     return new EventCollector(). }
false;public;0;4;;@Bean public CallCountingTransactionManager transactionManager() {     return new CallCountingTransactionManager(). }
false;public;2;3;;public void addEvent(String phase, Object event) {     this.events.add(phase, event). }
false;public;1;3;;public List<Object> getEvents(String phase) {     return this.events.getOrDefault(phase, Collections.emptyList()). }
false;public;1;10;;public void assertNoEventReceived(String... phases) {     if (phases.length == 0) {         // All values if none set         phases = ALL_PHASES.     }     for (String phase : phases) {         List<Object> eventsForPhase = getEvents(phase).         assertEquals("Expected no events for phase '" + phase + "' " + "but got " + eventsForPhase + ":", 0, eventsForPhase.size()).     } }
false;public;2;7;;public void assertEvents(String phase, Object... expected) {     List<Object> actual = getEvents(phase).     assertEquals("wrong number of events for phase '" + phase + "'", expected.length, actual.size()).     for (int i = 0. i < expected.length. i++) {         assertEquals("Wrong event for phase '" + phase + "' at index " + i, expected[i], actual.get(i)).     } }
false;public;1;8;;public void assertTotalEventsCount(int number) {     int size = 0.     for (Map.Entry<String, List<Object>> entry : this.events.entrySet()) {         size += entry.getValue().size().     }     assertEquals("Wrong number of total events (" + this.events.size() + ") " + "registered phase(s)", number, size). }
false;public;2;6;;public void handleEvent(String phase, String data) {     this.eventCollector.addEvent(phase, data).     if (FAIL_MSG.equals(data)) {         throw new IllegalStateException("Test exception on phase '" + phase + "'").     } }
false;public;1;4;;@EventListener(condition = "!'SKIP'.equals(#data)") public void handleImmediately(String data) {     handleEvent(EventCollector.IMMEDIATELY, data). }
false;public;1;4;;@TransactionalEventListener(phase = AFTER_COMPLETION) public void handleAfterCompletion(String data) {     handleEvent(EventCollector.AFTER_COMPLETION, data). }
false;public;1;4;;@TransactionalEventListener(phase = AFTER_COMMIT) public void handleAfterCommit(String data) {     handleEvent(EventCollector.AFTER_COMMIT, data). }
false;public;1;4;;@TransactionalEventListener(phase = AFTER_ROLLBACK) public void handleAfterRollback(String data) {     handleEvent(EventCollector.AFTER_ROLLBACK, data). }
true;;1;2;// Cannot use #data in condition due to dynamic proxy. ;// Cannot use #data in condition due to dynamic proxy. @TransactionalEventListener(condition = "!'SKIP'.equals(#p0)") void handleAfterCommit(String data).
false;public;1;4;;@Override public void handleAfterCommit(String data) {     handleEvent(EventCollector.AFTER_COMMIT, data). }
false;public;1;5;;@TransactionalEventListener(phase = BEFORE_COMMIT) @Order(15) public void handleBeforeCommit(String data) {     handleEvent(EventCollector.BEFORE_COMMIT, data). }
false;public;1;4;;@TransactionalEventListener(phase = BEFORE_COMMIT, fallbackExecution = true) public void handleBeforeCommit(String data) {     handleEvent(EventCollector.BEFORE_COMMIT, data). }
false;public;1;4;;@TransactionalEventListener(phase = AFTER_COMMIT, fallbackExecution = true) public void handleAfterCommit(String data) {     handleEvent(EventCollector.AFTER_COMMIT, data). }
false;public;1;4;;@TransactionalEventListener(phase = AFTER_ROLLBACK, fallbackExecution = true) public void handleAfterRollback(String data) {     handleEvent(EventCollector.AFTER_ROLLBACK, data). }
false;public;1;4;;@TransactionalEventListener(phase = AFTER_COMPLETION, fallbackExecution = true) public void handleAfterCompletion(String data) {     handleEvent(EventCollector.AFTER_COMPLETION, data). }
false;public;1;4;;@AfterCommitEventListener public void handleAfterCommit(String data) {     handleEvent(EventCollector.AFTER_COMMIT, data). }
false;public;0;4;;@Override public int getOrder() {     return order. }
