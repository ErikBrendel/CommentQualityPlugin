commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Test public void testDefaultRule() {     RuleBasedTransactionAttribute rta = new RuleBasedTransactionAttribute().     assertTrue(rta.rollbackOn(new RuntimeException())).     assertTrue(rta.rollbackOn(new MyRuntimeException(""))).     assertFalse(rta.rollbackOn(new Exception())).     assertFalse(rta.rollbackOn(new IOException())). }
true;public;0;12;/**  * Test one checked exception that should roll back.  */ ;/**  * Test one checked exception that should roll back.  */ @Test public void testRuleForRollbackOnChecked() {     List<RollbackRuleAttribute> list = new LinkedList<>().     list.add(new RollbackRuleAttribute(IOException.class.getName())).     RuleBasedTransactionAttribute rta = new RuleBasedTransactionAttribute(TransactionDefinition.PROPAGATION_REQUIRED, list).     assertTrue(rta.rollbackOn(new RuntimeException())).     assertTrue(rta.rollbackOn(new MyRuntimeException(""))).     assertFalse(rta.rollbackOn(new Exception())).     // Check that default behaviour is overridden     assertTrue(rta.rollbackOn(new IOException())). }
false;public;0;14;;@Test public void testRuleForCommitOnUnchecked() {     List<RollbackRuleAttribute> list = new LinkedList<>().     list.add(new NoRollbackRuleAttribute(MyRuntimeException.class.getName())).     list.add(new RollbackRuleAttribute(IOException.class.getName())).     RuleBasedTransactionAttribute rta = new RuleBasedTransactionAttribute(TransactionDefinition.PROPAGATION_REQUIRED, list).     assertTrue(rta.rollbackOn(new RuntimeException())).     // Check default behaviour is overridden     assertFalse(rta.rollbackOn(new MyRuntimeException(""))).     assertFalse(rta.rollbackOn(new Exception())).     // Check that default behaviour is overridden     assertTrue(rta.rollbackOn(new IOException())). }
false;public;0;7;;@Test public void testRuleForSelectiveRollbackOnCheckedWithString() {     List<RollbackRuleAttribute> l = new LinkedList<>().     l.add(new RollbackRuleAttribute(java.rmi.RemoteException.class.getName())).     RuleBasedTransactionAttribute rta = new RuleBasedTransactionAttribute(TransactionDefinition.PROPAGATION_REQUIRED, l).     doTestRuleForSelectiveRollbackOnChecked(rta). }
false;public;0;6;;@Test public void testRuleForSelectiveRollbackOnCheckedWithClass() {     List<RollbackRuleAttribute> l = Collections.singletonList(new RollbackRuleAttribute(RemoteException.class)).     RuleBasedTransactionAttribute rta = new RuleBasedTransactionAttribute(TransactionDefinition.PROPAGATION_REQUIRED, l).     doTestRuleForSelectiveRollbackOnChecked(rta). }
false;private;1;7;;private void doTestRuleForSelectiveRollbackOnChecked(RuleBasedTransactionAttribute rta) {     assertTrue(rta.rollbackOn(new RuntimeException())).     // Check default behaviour is overridden     assertFalse(rta.rollbackOn(new Exception())).     // Check that default behaviour is overridden     assertTrue(rta.rollbackOn(new RemoteException())). }
true;public;0;14;/**  * Check that a rule can cause commit on a IOException  * when Exception prompts a rollback.  */ ;/**  * Check that a rule can cause commit on a IOException  * when Exception prompts a rollback.  */ @Test public void testRuleForCommitOnSubclassOfChecked() {     List<RollbackRuleAttribute> list = new LinkedList<>().     // Note that it's important to ensure that we have this as     // a FQN: otherwise it will match everything!     list.add(new RollbackRuleAttribute("java.lang.Exception")).     list.add(new NoRollbackRuleAttribute("IOException")).     RuleBasedTransactionAttribute rta = new RuleBasedTransactionAttribute(TransactionDefinition.PROPAGATION_REQUIRED, list).     assertTrue(rta.rollbackOn(new RuntimeException())).     assertTrue(rta.rollbackOn(new Exception())).     // Check that default behaviour is overridden     assertFalse(rta.rollbackOn(new IOException())). }
false;public;0;12;;@Test public void testRollbackNever() {     List<RollbackRuleAttribute> list = new LinkedList<>().     list.add(new NoRollbackRuleAttribute("Throwable")).     RuleBasedTransactionAttribute rta = new RuleBasedTransactionAttribute(TransactionDefinition.PROPAGATION_REQUIRED, list).     assertFalse(rta.rollbackOn(new Throwable())).     assertFalse(rta.rollbackOn(new RuntimeException())).     assertFalse(rta.rollbackOn(new MyRuntimeException(""))).     assertFalse(rta.rollbackOn(new Exception())).     assertFalse(rta.rollbackOn(new IOException())). }
false;public;0;16;;@Test public void testToStringMatchesEditor() {     List<RollbackRuleAttribute> list = new LinkedList<>().     list.add(new NoRollbackRuleAttribute("Throwable")).     RuleBasedTransactionAttribute rta = new RuleBasedTransactionAttribute(TransactionDefinition.PROPAGATION_REQUIRED, list).     TransactionAttributeEditor tae = new TransactionAttributeEditor().     tae.setAsText(rta.toString()).     rta = (RuleBasedTransactionAttribute) tae.getValue().     assertFalse(rta.rollbackOn(new Throwable())).     assertFalse(rta.rollbackOn(new RuntimeException())).     assertFalse(rta.rollbackOn(new MyRuntimeException(""))).     assertFalse(rta.rollbackOn(new Exception())).     assertFalse(rta.rollbackOn(new IOException())). }
true;public;0;10;/**  * See <a href="http://forum.springframework.org/showthread.php?t=41350">this forum post</a>.  */ ;/**  * See <a href="http://forum.springframework.org/showthread.php?t=41350">this forum post</a>.  */ @Test public void testConflictingRulesToDetermineExactContract() {     List<RollbackRuleAttribute> list = new LinkedList<>().     list.add(new NoRollbackRuleAttribute(MyBusinessWarningException.class)).     list.add(new RollbackRuleAttribute(MyBusinessException.class)).     RuleBasedTransactionAttribute rta = new RuleBasedTransactionAttribute(TransactionDefinition.PROPAGATION_REQUIRED, list).     assertTrue(rta.rollbackOn(new MyBusinessException())).     assertFalse(rta.rollbackOn(new MyBusinessWarningException())). }
