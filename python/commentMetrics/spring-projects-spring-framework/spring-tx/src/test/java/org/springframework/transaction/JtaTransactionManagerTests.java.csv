commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;8;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     assertEquals("txName", TransactionSynchronizationManager.getCurrentTransactionName()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()). }
false;public;0;36;;@Test public void jtaTransactionManagerWithCommit() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setName("txName").     assertEquals(JtaTransactionManager.SYNCHRONIZATION_ALWAYS, ptm.getTransactionSynchronization()).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     assertNull(TransactionSynchronizationManager.getCurrentTransactionName()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             TransactionSynchronizationManager.registerSynchronization(synch).             assertEquals("txName", TransactionSynchronizationManager.getCurrentTransactionName()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     assertNull(TransactionSynchronizationManager.getCurrentTransactionName()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     verify(ut).begin().     verify(ut).commit().     verify(synch).beforeCommit(false).     verify(synch).beforeCompletion().     verify(synch).afterCommit().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_COMMITTED). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch). }
false;public;0;28;;@Test public void jtaTransactionManagerWithCommitAndSynchronizationOnActual() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     ptm.setTransactionSynchronization(JtaTransactionManager.SYNCHRONIZATION_ON_ACTUAL_TRANSACTION).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             TransactionSynchronizationManager.registerSynchronization(synch).         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).begin().     verify(ut).commit().     verify(synch).beforeCommit(false).     verify(synch).beforeCompletion().     verify(synch).afterCommit().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_COMMITTED). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()). }
false;public;0;23;;@Test public void jtaTransactionManagerWithCommitAndSynchronizationNever() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     ptm.setTransactionSynchronization(JtaTransactionManager.SYNCHRONIZATION_NEVER).     ptm.afterPropertiesSet().     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).begin().     verify(ut).commit(). }
false;protected;1;8;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     assertEquals("txName", TransactionSynchronizationManager.getCurrentTransactionName()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     status.setRollbackOnly(). }
false;public;0;34;;@Test public void jtaTransactionManagerWithRollback() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setTimeout(10).     tt.setName("txName").     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     assertNull(TransactionSynchronizationManager.getCurrentTransactionName()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             TransactionSynchronizationManager.registerSynchronization(synch).             assertEquals("txName", TransactionSynchronizationManager.getCurrentTransactionName()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     assertNull(TransactionSynchronizationManager.getCurrentTransactionName()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     verify(ut).setTransactionTimeout(10).     verify(ut).begin().     verify(ut).rollback().     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     status.setRollbackOnly(). }
false;public;0;27;;@Test public void jtaTransactionManagerWithRollbackAndSynchronizationOnActual() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     ptm.setTransactionSynchronization(JtaTransactionManager.SYNCHRONIZATION_ON_ACTUAL_TRANSACTION).     tt.setTimeout(10).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             TransactionSynchronizationManager.registerSynchronization(synch).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).setTransactionTimeout(10).     verify(ut).begin().     verify(ut).rollback().     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK). }
false;protected;1;5;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     status.setRollbackOnly(). }
false;public;0;26;;@Test public void jtaTransactionManagerWithRollbackAndSynchronizationNever() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     ptm.setTransactionSynchronizationName("SYNCHRONIZATION_NEVER").     tt.setTimeout(10).     ptm.afterPropertiesSet().     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).setTransactionTimeout(10).     verify(ut).begin().     verify(ut, atLeastOnce()).getStatus().     verify(ut).rollback(). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     status.setRollbackOnly(). }
false;public;0;24;;@Test public void jtaTransactionManagerWithExistingTransactionAndRollbackOnly() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             TransactionSynchronizationManager.registerSynchronization(synch).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).setRollbackOnly().     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     throw new IllegalStateException("I want a rollback"). }
false;public;0;30;;@Test public void jtaTransactionManagerWithExistingTransactionAndException() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).                 TransactionSynchronizationManager.registerSynchronization(synch).                 throw new IllegalStateException("I want a rollback").             }         }).         fail("Should have thrown IllegalStateException").     } catch (IllegalStateException ex) {     // expected     }     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).setRollbackOnly().     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;5;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch). }
false;public;0;30;;@Test public void jtaTransactionManagerWithExistingTransactionAndCommitException() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     willThrow(new OptimisticLockingFailureException("")).given(synch).beforeCommit(false).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).                 TransactionSynchronizationManager.registerSynchronization(synch).             }         }).         fail("Should have thrown OptimisticLockingFailureException").     } catch (OptimisticLockingFailureException ex) {     // expected     }     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).setRollbackOnly().     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     status.setRollbackOnly(). }
false;public;0;25;;@Test public void jtaTransactionManagerWithExistingTransactionAndRollbackOnlyAndNoGlobalRollback() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     ptm.setGlobalRollbackOnParticipationFailure(false).     TransactionTemplate tt = new TransactionTemplate(ptm).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             TransactionSynchronizationManager.registerSynchronization(synch).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).setRollbackOnly().     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     throw new IllegalStateException("I want a rollback"). }
false;public;0;29;;@Test public void jtaTransactionManagerWithExistingTransactionAndExceptionAndNoGlobalRollback() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     ptm.setGlobalRollbackOnParticipationFailure(false).     TransactionTemplate tt = new TransactionTemplate(ptm).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).                 TransactionSynchronizationManager.registerSynchronization(synch).                 throw new IllegalStateException("I want a rollback").             }         }).         fail("Should have thrown IllegalStateException").     } catch (IllegalStateException ex) {     // expected     }     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     status.setRollbackOnly(). }
false;public;0;31;;@Test public void jtaTransactionManagerWithExistingTransactionAndJtaSynchronization() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     TransactionManager tm = mock(TransactionManager.class).     MockJtaTransaction tx = new MockJtaTransaction().     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     given(tm.getTransaction()).willReturn(tx).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut, tm).     TransactionTemplate tt = new TransactionTemplate(ptm).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             TransactionSynchronizationManager.registerSynchronization(synch).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     assertNotNull(tx.getSynchronization()).     tx.getSynchronization().beforeCompletion().     tx.getSynchronization().afterCompletion(Status.STATUS_ROLLEDBACK).     verify(ut).setRollbackOnly().     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     status.setRollbackOnly(). }
false;public;0;25;;@Test public void jtaTransactionManagerWithExistingTransactionAndSynchronizationOnActual() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     ptm.setTransactionSynchronization(JtaTransactionManager.SYNCHRONIZATION_ON_ACTUAL_TRANSACTION).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             TransactionSynchronizationManager.registerSynchronization(synch).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).setRollbackOnly().     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;5;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     status.setRollbackOnly(). }
false;public;0;22;;@Test public void jtaTransactionManagerWithExistingTransactionAndSynchronizationNever() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     ptm.setTransactionSynchronization(JtaTransactionManager.SYNCHRONIZATION_NEVER).     ptm.afterPropertiesSet().     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).setRollbackOnly(). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     status.setRollbackOnly(). }
false;public;0;25;;@Test public void jtaTransactionManagerWithExistingAndPropagationSupports() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             TransactionSynchronizationManager.registerSynchronization(synch).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).setRollbackOnly().     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionSynchronizationManager.registerSynchronization(synch).     status.setRollbackOnly(). }
false;public;0;24;;@Test public void jtaTransactionManagerWithPropagationSupports() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION).     final TransactionSynchronization synch = mock(TransactionSynchronization.class).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             TransactionSynchronizationManager.registerSynchronization(synch).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(synch).beforeCompletion().     verify(synch).afterCompletion(TransactionSynchronization.STATUS_ROLLED_BACK). }
false;protected;1;5;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     status.setRollbackOnly(). }
false;public;0;21;;@Test public void jtaTransactionManagerWithPropagationSupportsAndSynchronizationOnActual() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     ptm.setTransactionSynchronization(JtaTransactionManager.SYNCHRONIZATION_ON_ACTUAL_TRANSACTION).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     ptm.afterPropertiesSet().     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()). }
false;protected;1;5;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     status.setRollbackOnly(). }
false;public;0;21;;@Test public void jtaTransactionManagerWithPropagationSupportsAndSynchronizationNever() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     ptm.setTransactionSynchronization(JtaTransactionManager.SYNCHRONIZATION_NEVER).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     ptm.afterPropertiesSet().     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()). }
false;protected;1;5;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     status.setRollbackOnly(). }
false;public;0;23;;@Test public void jtaTransactionManagerWithPropagationNotSupported() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     TransactionManager tm = mock(TransactionManager.class).     Transaction tx = mock(Transaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     given(tm.suspend()).willReturn(tx).     JtaTransactionManager ptm = newJtaTransactionManager(ut, tm).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NOT_SUPPORTED).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             status.setRollbackOnly().         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(tm).resume(tx). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     assertEquals("txName2", TransactionSynchronizationManager.getCurrentTransactionName()).     assertTrue(TransactionSynchronizationManager.isCurrentTransactionReadOnly()). }
false;protected;1;23;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     assertEquals("txName", TransactionSynchronizationManager.getCurrentTransactionName()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     TransactionTemplate tt2 = new TransactionTemplate(ptm).     tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     tt2.setReadOnly(true).     tt2.setName("txName2").     tt2.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             assertEquals("txName2", TransactionSynchronizationManager.getCurrentTransactionName()).             assertTrue(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).         }     }).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     assertEquals("txName", TransactionSynchronizationManager.getCurrentTransactionName()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()). }
false;public;0;47;;@Test public void jtaTransactionManagerWithPropagationRequiresNew() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     TransactionManager tm = mock(TransactionManager.class).     Transaction tx = mock(Transaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE).     given(tm.suspend()).willReturn(tx).     final JtaTransactionManager ptm = newJtaTransactionManager(ut, tm).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     tt.setName("txName").     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             assertEquals("txName", TransactionSynchronizationManager.getCurrentTransactionName()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             TransactionTemplate tt2 = new TransactionTemplate(ptm).             tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).             tt2.setReadOnly(true).             tt2.setName("txName2").             tt2.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) {                     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).                     assertEquals("txName2", TransactionSynchronizationManager.getCurrentTransactionName()).                     assertTrue(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).                 }             }).             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             assertEquals("txName", TransactionSynchronizationManager.getCurrentTransactionName()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut, times(2)).begin().     verify(ut, times(2)).commit().     verify(tm).resume(tx). }
false;protected;1;6;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()). }
false;protected;1;21;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertFalse(TransactionSynchronizationManager.isActualTransactionActive()).     TransactionTemplate tt2 = new TransactionTemplate(ptm).     tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     tt2.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).         }     }).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertFalse(TransactionSynchronizationManager.isActualTransactionActive()). }
false;public;0;39;;@Test public void jtaTransactionManagerWithPropagationRequiresNewWithinSupports() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE).     final JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_SUPPORTS).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertFalse(TransactionSynchronizationManager.isActualTransactionActive()).             TransactionTemplate tt2 = new TransactionTemplate(ptm).             tt2.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).             tt2.execute(new TransactionCallbackWithoutResult() {                  @Override                 protected void doInTransactionWithoutResult(TransactionStatus status) {                     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).                     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).                     assertTrue(TransactionSynchronizationManager.isActualTransactionActive()).                 }             }).             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).             assertFalse(TransactionSynchronizationManager.isActualTransactionActive()).         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).begin().     verify(ut).commit(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()). }
false;public;0;24;;@Test public void jtaTransactionManagerWithPropagationRequiresNewAndExisting() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     TransactionManager tm = mock(TransactionManager.class).     Transaction tx = mock(Transaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     given(tm.suspend()).willReturn(tx).     JtaTransactionManager ptm = newJtaTransactionManager(ut, tm).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(ut).begin().     verify(ut).commit().     verify(tm).resume(tx). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()). }
false;public;0;25;;@Test public void jtaTransactionManagerWithPropagationRequiresNewAndExistingWithSuspendException() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     TransactionManager tm = mock(TransactionManager.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     willThrow(new SystemException()).given(tm).suspend().     JtaTransactionManager ptm = newJtaTransactionManager(ut, tm).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             }         }).         fail("Should have thrown TransactionSystemException").     } catch (TransactionSystemException ex) {     // expected     }     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()). }
false;public;0;28;;@Test public void jtaTransactionManagerWithPropagationRequiresNewAndExistingWithBeginException() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     TransactionManager tm = mock(TransactionManager.class).     Transaction tx = mock(Transaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     given(tm.suspend()).willReturn(tx).     willThrow(new SystemException()).given(ut).begin().     JtaTransactionManager ptm = newJtaTransactionManager(ut, tm).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).             }         }).         fail("Should have thrown CannotCreateTransactionException").     } catch (CannotCreateTransactionException ex) {     // expected     }     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(tm).resume(tx). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()). }
false;public;0;23;;@Test public void jtaTransactionManagerWithPropagationRequiresNewAndAdapter() throws Exception {     TransactionManager tm = mock(TransactionManager.class).     Transaction tx = mock(Transaction.class).     given(tm.getStatus()).willReturn(Status.STATUS_ACTIVE).     given(tm.suspend()).willReturn(tx).     JtaTransactionManager ptm = newJtaTransactionManager(tm).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {             assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).         }     }).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     verify(tm).begin().     verify(tm).commit().     verify(tm).resume(tx). }
false;protected;1;3;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { }
false;public;0;22;;@Test public void jtaTransactionManagerWithPropagationRequiresNewAndSuspensionNotSupported() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRES_NEW).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     try {         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {             }         }).         fail("Should have thrown TransactionSuspensionNotSupportedException").     } catch (TransactionSuspensionNotSupportedException ex) {     // expected     }     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { // something transactional }
false;public;0;21;;@Test public void jtaTransactionManagerWithIsolationLevel() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION).     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.setIsolationLevel(TransactionDefinition.ISOLATION_SERIALIZABLE).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             }         }).         fail("Should have thrown InvalidIsolationLevelException").     } catch (InvalidIsolationLevelException ex) {     // expected     } }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { // something transactional }
false;public;0;20;;@Test public void jtaTransactionManagerWithSystemExceptionOnIsExisting() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willThrow(new SystemException("system exception")).     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             }         }).         fail("Should have thrown TransactionSystemException").     } catch (TransactionSystemException ex) {     // expected     } }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { // something transactional }
false;public;0;18;;@Test public void jtaTransactionManagerWithNestedBegin() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     TransactionTemplate tt = new TransactionTemplate(ptm).     tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).     tt.execute(new TransactionCallbackWithoutResult() {          @Override         protected void doInTransactionWithoutResult(TransactionStatus status) {         // something transactional         }     }).     verify(ut).begin().     verify(ut).commit(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { // something transactional }
false;public;0;22;;@Test public void jtaTransactionManagerWithNotSupportedExceptionOnNestedBegin() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     willThrow(new NotSupportedException("not supported")).given(ut).begin().     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             }         }).         fail("Should have thrown NestedTransactionNotSupportedException").     } catch (NestedTransactionNotSupportedException ex) {     // expected     } }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { // something transactional }
false;public;0;22;;@Test public void jtaTransactionManagerWithUnsupportedOperationExceptionOnNestedBegin() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     willThrow(new UnsupportedOperationException("not supported")).given(ut).begin().     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.setPropagationBehavior(TransactionDefinition.PROPAGATION_NESTED).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             }         }).         fail("Should have thrown NestedTransactionNotSupportedException").     } catch (NestedTransactionNotSupportedException ex) {     // expected     } }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) { // something transactional }
false;public;0;21;;@Test public void jtaTransactionManagerWithSystemExceptionOnBegin() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION).     willThrow(new SystemException("system exception")).given(ut).begin().     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {             // something transactional             }         }).         fail("Should have thrown CannotCreateTransactionException").     } catch (CannotCreateTransactionException ex) {     // expected     } }
false;public;1;4;;@Override public void afterCompletion(int status) {     assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_ROLLED_BACK). }
false;protected;1;10;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {          @Override         public void afterCompletion(int status) {             assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_ROLLED_BACK).         }     }). }
false;public;0;30;;@Test public void jtaTransactionManagerWithRollbackExceptionOnCommit() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE).     willThrow(new RollbackException("unexpected rollback")).given(ut).commit().     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 // something transactional                 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                      @Override                     public void afterCompletion(int status) {                         assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_ROLLED_BACK).                     }                 }).             }         }).         fail("Should have thrown UnexpectedRollbackException").     } catch (UnexpectedRollbackException ex) {     // expected     }     verify(ut).begin(). }
false;public;0;4;;@Test public void jtaTransactionManagerWithNoExceptionOnGlobalRollbackOnly() throws Exception {     doTestJtaTransactionManagerWithNoExceptionOnGlobalRollbackOnly(false). }
false;public;0;4;;@Test public void jtaTransactionManagerWithNoExceptionOnGlobalRollbackOnlyAndFailEarly() throws Exception {     doTestJtaTransactionManagerWithNoExceptionOnGlobalRollbackOnly(true). }
false;public;1;4;;@Override public void afterCompletion(int status) {     assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_ROLLED_BACK). }
false;protected;1;10;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {          @Override         public void afterCompletion(int status) {             assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_ROLLED_BACK).         }     }). }
false;private;1;56;;private void doTestJtaTransactionManagerWithNoExceptionOnGlobalRollbackOnly(boolean failEarly) throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_MARKED_ROLLBACK, Status.STATUS_MARKED_ROLLBACK, Status.STATUS_MARKED_ROLLBACK).     JtaTransactionManager tm = newJtaTransactionManager(ut).     if (failEarly) {         tm.setFailEarlyOnGlobalRollbackOnly(true).     }     TransactionStatus ts = tm.getTransaction(new DefaultTransactionDefinition()).     boolean outerTransactionBoundaryReached = false.     try {         assertTrue("Is new transaction", ts.isNewTransaction()).         TransactionTemplate tt = new TransactionTemplate(tm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 // something transactional                 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                      @Override                     public void afterCompletion(int status) {                         assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_ROLLED_BACK).                     }                 }).             }         }).         outerTransactionBoundaryReached = true.         tm.commit(ts).         fail("Should have thrown UnexpectedRollbackException").     } catch (UnexpectedRollbackException ex) {         // expected         if (!outerTransactionBoundaryReached) {             tm.rollback(ts).         }         if (failEarly) {             assertFalse(outerTransactionBoundaryReached).         } else {             assertTrue(outerTransactionBoundaryReached).         }     }     verify(ut).begin().     if (failEarly) {         verify(ut).rollback().     } else {         verify(ut).commit().     } }
false;public;1;4;;@Override public void afterCompletion(int status) {     assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;10;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {          @Override         public void afterCompletion(int status) {             assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN).         }     }). }
false;public;0;31;;@Test public void jtaTransactionManagerWithHeuristicMixedExceptionOnCommit() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE).     willThrow(new HeuristicMixedException("heuristic exception")).given(ut).commit().     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 // something transactional                 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                      @Override                     public void afterCompletion(int status) {                         assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN).                     }                 }).             }         }).         fail("Should have thrown HeuristicCompletionException").     } catch (HeuristicCompletionException ex) {         // expected         assertTrue(ex.getOutcomeState() == HeuristicCompletionException.STATE_MIXED).     }     verify(ut).begin(). }
false;public;1;4;;@Override public void afterCompletion(int status) {     assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;10;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {          @Override         public void afterCompletion(int status) {             assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN).         }     }). }
false;public;0;31;;@Test public void jtaTransactionManagerWithHeuristicRollbackExceptionOnCommit() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE).     willThrow(new HeuristicRollbackException("heuristic exception")).given(ut).commit().     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 // something transactional                 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                      @Override                     public void afterCompletion(int status) {                         assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN).                     }                 }).             }         }).         fail("Should have thrown HeuristicCompletionException").     } catch (HeuristicCompletionException ex) {         // expected         assertTrue(ex.getOutcomeState() == HeuristicCompletionException.STATE_ROLLED_BACK).     }     verify(ut).begin(). }
false;public;1;4;;@Override public void afterCompletion(int status) {     assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;10;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     // something transactional     TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {          @Override         public void afterCompletion(int status) {             assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN).         }     }). }
false;public;0;30;;@Test public void jtaTransactionManagerWithSystemExceptionOnCommit() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE).     willThrow(new SystemException("system exception")).given(ut).commit().     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 // something transactional                 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                      @Override                     public void afterCompletion(int status) {                         assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN).                     }                 }).             }         }).         fail("Should have thrown TransactionSystemException").     } catch (TransactionSystemException ex) {     // expected     }     verify(ut).begin(). }
false;public;1;4;;@Override public void afterCompletion(int status) {     assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;10;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {          @Override         public void afterCompletion(int status) {             assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN).         }     }).     status.setRollbackOnly(). }
false;public;0;29;;@Test public void jtaTransactionManagerWithSystemExceptionOnRollback() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE).     willThrow(new SystemException("system exception")).given(ut).rollback().     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                      @Override                     public void afterCompletion(int status) {                         assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN).                     }                 }).                 status.setRollbackOnly().             }         }).         fail("Should have thrown TransactionSystemException").     } catch (TransactionSystemException ex) {     // expected     }     verify(ut).begin(). }
false;protected;1;4;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     status.setRollbackOnly(). }
false;public;0;21;;@Test public void jtaTransactionManagerWithIllegalStateExceptionOnRollbackOnly() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     willThrow(new IllegalStateException("no existing transaction")).given(ut).setRollbackOnly().     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 status.setRollbackOnly().             }         }).         fail("Should have thrown TransactionSystemException").     } catch (TransactionSystemException ex) {     // expected     } }
false;public;1;4;;@Override public void afterCompletion(int status) {     assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN). }
false;protected;1;10;;@Override protected void doInTransactionWithoutResult(TransactionStatus status) {     status.setRollbackOnly().     TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {          @Override         public void afterCompletion(int status) {             assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN).         }     }). }
false;public;0;27;;@Test public void jtaTransactionManagerWithSystemExceptionOnRollbackOnly() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_ACTIVE).     willThrow(new SystemException("system exception")).given(ut).setRollbackOnly().     try {         JtaTransactionManager ptm = newJtaTransactionManager(ut).         TransactionTemplate tt = new TransactionTemplate(ptm).         tt.execute(new TransactionCallbackWithoutResult() {              @Override             protected void doInTransactionWithoutResult(TransactionStatus status) {                 status.setRollbackOnly().                 TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {                      @Override                     public void afterCompletion(int status) {                         assertTrue("Correct completion status", status == TransactionSynchronization.STATUS_UNKNOWN).                     }                 }).             }         }).         fail("Should have thrown TransactionSystemException").     } catch (TransactionSystemException ex) {     // expected     } }
false;public;0;25;;@Test public void jtaTransactionManagerWithDoubleCommit() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE, Status.STATUS_ACTIVE).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionStatus status = ptm.getTransaction(new DefaultTransactionDefinition()).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     // first commit     ptm.commit(status).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     try {         // second commit attempt         ptm.commit(status).         fail("Should have thrown IllegalTransactionStateException").     } catch (IllegalTransactionStateException ex) {     // expected     }     verify(ut).begin().     verify(ut).commit(). }
false;public;0;24;;@Test public void jtaTransactionManagerWithDoubleRollback() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionStatus status = ptm.getTransaction(new DefaultTransactionDefinition()).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     // first rollback     ptm.rollback(status).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     try {         // second rollback attempt         ptm.rollback(status).         fail("Should have thrown IllegalTransactionStateException").     } catch (IllegalTransactionStateException ex) {     // expected     }     verify(ut).begin().     verify(ut).rollback(). }
false;public;0;24;;@Test public void jtaTransactionManagerWithRollbackAndCommit() throws Exception {     UserTransaction ut = mock(UserTransaction.class).     given(ut.getStatus()).willReturn(Status.STATUS_NO_TRANSACTION, Status.STATUS_ACTIVE).     JtaTransactionManager ptm = newJtaTransactionManager(ut).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     TransactionStatus status = ptm.getTransaction(new DefaultTransactionDefinition()).     assertTrue(TransactionSynchronizationManager.isSynchronizationActive()).     // first: rollback     ptm.rollback(status).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     try {         // second: commit attempt         ptm.commit(status).         fail("Should have thrown IllegalTransactionStateException").     } catch (IllegalTransactionStateException ex) {     // expected     }     verify(ut).begin().     verify(ut).rollback(). }
false;protected;1;3;;protected JtaTransactionManager newJtaTransactionManager(UserTransaction ut) {     return new JtaTransactionManager(ut). }
false;protected;1;3;;protected JtaTransactionManager newJtaTransactionManager(TransactionManager tm) {     return new JtaTransactionManager(tm). }
false;protected;2;3;;protected JtaTransactionManager newJtaTransactionManager(UserTransaction ut, TransactionManager tm) {     return new JtaTransactionManager(ut, tm). }
true;public;0;9;/**  * Prevent any side-effects due to this test modifying ThreadLocals that might  * affect subsequent tests when all tests are run in the same JVM, as with Eclipse.  */ ;/**  * Prevent any side-effects due to this test modifying ThreadLocals that might  * affect subsequent tests when all tests are run in the same JVM, as with Eclipse.  */ @After public void tearDown() {     assertTrue(TransactionSynchronizationManager.getResourceMap().isEmpty()).     assertFalse(TransactionSynchronizationManager.isSynchronizationActive()).     assertNull(TransactionSynchronizationManager.getCurrentTransactionName()).     assertFalse(TransactionSynchronizationManager.isCurrentTransactionReadOnly()).     assertNull(TransactionSynchronizationManager.getCurrentTransactionIsolationLevel()).     assertFalse(TransactionSynchronizationManager.isActualTransactionActive()). }
