commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;// --------------------------------------------------------------------- // Handling of current transaction state // --------------------------------------------------------------------- @Override public void setRollbackOnly() {     this.rollbackOnly = true. }
true;public;0;4;/**  * Determine the rollback-only flag via checking both the local rollback-only flag  * of this TransactionStatus and the global rollback-only flag of the underlying  * transaction, if any.  * @see #isLocalRollbackOnly()  * @see #isGlobalRollbackOnly()  */ ;/**  * Determine the rollback-only flag via checking both the local rollback-only flag  * of this TransactionStatus and the global rollback-only flag of the underlying  * transaction, if any.  * @see #isLocalRollbackOnly()  * @see #isGlobalRollbackOnly()  */ @Override public boolean isRollbackOnly() {     return (isLocalRollbackOnly() || isGlobalRollbackOnly()). }
true;public;0;3;/**  * Determine the rollback-only flag via checking this TransactionStatus.  * <p>Will only return "true" if the application called {@code setRollbackOnly}  * on this TransactionStatus object.  */ ;/**  * Determine the rollback-only flag via checking this TransactionStatus.  * <p>Will only return "true" if the application called {@code setRollbackOnly}  * on this TransactionStatus object.  */ public boolean isLocalRollbackOnly() {     return this.rollbackOnly. }
true;public;0;3;/**  * Template method for determining the global rollback-only flag of the  * underlying transaction, if any.  * <p>This implementation always returns {@code false}.  */ ;/**  * Template method for determining the global rollback-only flag of the  * underlying transaction, if any.  * <p>This implementation always returns {@code false}.  */ public boolean isGlobalRollbackOnly() {     return false. }
true;public;0;3;/**  * This implementations is empty, considering flush as a no-op.  */ ;/**  * This implementations is empty, considering flush as a no-op.  */ @Override public void flush() { }
true;public;0;3;/**  * Mark this transaction as completed, that is, committed or rolled back.  */ ;/**  * Mark this transaction as completed, that is, committed or rolled back.  */ public void setCompleted() {     this.completed = true. }
false;public;0;4;;@Override public boolean isCompleted() {     return this.completed. }
true;protected;1;3;/**  * Set a savepoint for this transaction. Useful for PROPAGATION_NESTED.  * @see org.springframework.transaction.TransactionDefinition#PROPAGATION_NESTED  */ ;// --------------------------------------------------------------------- // Handling of current savepoint state // --------------------------------------------------------------------- /**  * Set a savepoint for this transaction. Useful for PROPAGATION_NESTED.  * @see org.springframework.transaction.TransactionDefinition#PROPAGATION_NESTED  */ protected void setSavepoint(@Nullable Object savepoint) {     this.savepoint = savepoint. }
true;protected;0;4;/**  * Get the savepoint for this transaction, if any.  */ ;/**  * Get the savepoint for this transaction, if any.  */ @Nullable protected Object getSavepoint() {     return this.savepoint. }
false;public;0;4;;@Override public boolean hasSavepoint() {     return (this.savepoint != null). }
true;public;0;3;/**  * Create a savepoint and hold it for the transaction.  * @throws org.springframework.transaction.NestedTransactionNotSupportedException  * if the underlying transaction does not support savepoints  */ ;/**  * Create a savepoint and hold it for the transaction.  * @throws org.springframework.transaction.NestedTransactionNotSupportedException  * if the underlying transaction does not support savepoints  */ public void createAndHoldSavepoint() throws TransactionException {     setSavepoint(getSavepointManager().createSavepoint()). }
true;public;0;10;/**  * Roll back to the savepoint that is held for the transaction  * and release the savepoint right afterwards.  */ ;/**  * Roll back to the savepoint that is held for the transaction  * and release the savepoint right afterwards.  */ public void rollbackToHeldSavepoint() throws TransactionException {     Object savepoint = getSavepoint().     if (savepoint == null) {         throw new TransactionUsageException("Cannot roll back to savepoint - no savepoint associated with current transaction").     }     getSavepointManager().rollbackToSavepoint(savepoint).     getSavepointManager().releaseSavepoint(savepoint).     setSavepoint(null). }
true;public;0;9;/**  * Release the savepoint that is held for the transaction.  */ ;/**  * Release the savepoint that is held for the transaction.  */ public void releaseHeldSavepoint() throws TransactionException {     Object savepoint = getSavepoint().     if (savepoint == null) {         throw new TransactionUsageException("Cannot release savepoint - no savepoint associated with current transaction").     }     getSavepointManager().releaseSavepoint(savepoint).     setSavepoint(null). }
true;public;0;4;/**  * This implementation delegates to a SavepointManager for the  * underlying transaction, if possible.  * @see #getSavepointManager()  * @see SavepointManager#createSavepoint()  */ ;// --------------------------------------------------------------------- // Implementation of SavepointManager // --------------------------------------------------------------------- /**  * This implementation delegates to a SavepointManager for the  * underlying transaction, if possible.  * @see #getSavepointManager()  * @see SavepointManager#createSavepoint()  */ @Override public Object createSavepoint() throws TransactionException {     return getSavepointManager().createSavepoint(). }
true;public;1;4;/**  * This implementation delegates to a SavepointManager for the  * underlying transaction, if possible.  * @see #getSavepointManager()  * @see SavepointManager#rollbackToSavepoint(Object)  */ ;/**  * This implementation delegates to a SavepointManager for the  * underlying transaction, if possible.  * @see #getSavepointManager()  * @see SavepointManager#rollbackToSavepoint(Object)  */ @Override public void rollbackToSavepoint(Object savepoint) throws TransactionException {     getSavepointManager().rollbackToSavepoint(savepoint). }
true;public;1;4;/**  * This implementation delegates to a SavepointManager for the  * underlying transaction, if possible.  * @see #getSavepointManager()  * @see SavepointManager#releaseSavepoint(Object)  */ ;/**  * This implementation delegates to a SavepointManager for the  * underlying transaction, if possible.  * @see #getSavepointManager()  * @see SavepointManager#releaseSavepoint(Object)  */ @Override public void releaseSavepoint(Object savepoint) throws TransactionException {     getSavepointManager().releaseSavepoint(savepoint). }
true;protected;0;3;/**  * Return a SavepointManager for the underlying transaction, if possible.  * <p>Default implementation always throws a NestedTransactionNotSupportedException.  * @throws org.springframework.transaction.NestedTransactionNotSupportedException  * if the underlying transaction does not support savepoints  */ ;/**  * Return a SavepointManager for the underlying transaction, if possible.  * <p>Default implementation always throws a NestedTransactionNotSupportedException.  * @throws org.springframework.transaction.NestedTransactionNotSupportedException  * if the underlying transaction does not support savepoints  */ protected SavepointManager getSavepointManager() {     throw new NestedTransactionNotSupportedException("This transaction does not support savepoints"). }
