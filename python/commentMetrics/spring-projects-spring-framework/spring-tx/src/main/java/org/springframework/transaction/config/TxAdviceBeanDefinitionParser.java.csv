commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected Class<?> getBeanClass(Element element) {     return TransactionInterceptor.class. }
false;protected;3;21;;@Override protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) {     builder.addPropertyReference("transactionManager", TxNamespaceHandler.getTransactionManagerName(element)).     List<Element> txAttributes = DomUtils.getChildElementsByTagName(element, ATTRIBUTES_ELEMENT).     if (txAttributes.size() > 1) {         parserContext.getReaderContext().error("Element <attributes> is allowed at most once inside element <advice>", element).     } else if (txAttributes.size() == 1) {         // Using attributes source.         Element attributeSourceElement = txAttributes.get(0).         RootBeanDefinition attributeSourceDefinition = parseAttributeSource(attributeSourceElement, parserContext).         builder.addPropertyValue("transactionAttributeSource", attributeSourceDefinition).     } else {         // Assume annotations source.         builder.addPropertyValue("transactionAttributeSource", new RootBeanDefinition("org.springframework.transaction.annotation.AnnotationTransactionAttributeSource")).     } }
false;private;2;53;;private RootBeanDefinition parseAttributeSource(Element attrEle, ParserContext parserContext) {     List<Element> methods = DomUtils.getChildElementsByTagName(attrEle, METHOD_ELEMENT).     ManagedMap<TypedStringValue, RuleBasedTransactionAttribute> transactionAttributeMap = new ManagedMap<>(methods.size()).     transactionAttributeMap.setSource(parserContext.extractSource(attrEle)).     for (Element methodEle : methods) {         String name = methodEle.getAttribute(METHOD_NAME_ATTRIBUTE).         TypedStringValue nameHolder = new TypedStringValue(name).         nameHolder.setSource(parserContext.extractSource(methodEle)).         RuleBasedTransactionAttribute attribute = new RuleBasedTransactionAttribute().         String propagation = methodEle.getAttribute(PROPAGATION_ATTRIBUTE).         String isolation = methodEle.getAttribute(ISOLATION_ATTRIBUTE).         String timeout = methodEle.getAttribute(TIMEOUT_ATTRIBUTE).         String readOnly = methodEle.getAttribute(READ_ONLY_ATTRIBUTE).         if (StringUtils.hasText(propagation)) {             attribute.setPropagationBehaviorName(RuleBasedTransactionAttribute.PREFIX_PROPAGATION + propagation).         }         if (StringUtils.hasText(isolation)) {             attribute.setIsolationLevelName(RuleBasedTransactionAttribute.PREFIX_ISOLATION + isolation).         }         if (StringUtils.hasText(timeout)) {             try {                 attribute.setTimeout(Integer.parseInt(timeout)).             } catch (NumberFormatException ex) {                 parserContext.getReaderContext().error("Timeout must be an integer value: [" + timeout + "]", methodEle).             }         }         if (StringUtils.hasText(readOnly)) {             attribute.setReadOnly(Boolean.valueOf(methodEle.getAttribute(READ_ONLY_ATTRIBUTE))).         }         List<RollbackRuleAttribute> rollbackRules = new LinkedList<>().         if (methodEle.hasAttribute(ROLLBACK_FOR_ATTRIBUTE)) {             String rollbackForValue = methodEle.getAttribute(ROLLBACK_FOR_ATTRIBUTE).             addRollbackRuleAttributesTo(rollbackRules, rollbackForValue).         }         if (methodEle.hasAttribute(NO_ROLLBACK_FOR_ATTRIBUTE)) {             String noRollbackForValue = methodEle.getAttribute(NO_ROLLBACK_FOR_ATTRIBUTE).             addNoRollbackRuleAttributesTo(rollbackRules, noRollbackForValue).         }         attribute.setRollbackRules(rollbackRules).         transactionAttributeMap.put(nameHolder, attribute).     }     RootBeanDefinition attributeSourceDefinition = new RootBeanDefinition(NameMatchTransactionAttributeSource.class).     attributeSourceDefinition.setSource(parserContext.extractSource(attrEle)).     attributeSourceDefinition.getPropertyValues().add("nameMap", transactionAttributeMap).     return attributeSourceDefinition. }
false;private;2;6;;private void addRollbackRuleAttributesTo(List<RollbackRuleAttribute> rollbackRules, String rollbackForValue) {     String[] exceptionTypeNames = StringUtils.commaDelimitedListToStringArray(rollbackForValue).     for (String typeName : exceptionTypeNames) {         rollbackRules.add(new RollbackRuleAttribute(StringUtils.trimWhitespace(typeName))).     } }
false;private;2;6;;private void addNoRollbackRuleAttributesTo(List<RollbackRuleAttribute> rollbackRules, String noRollbackForValue) {     String[] exceptionTypeNames = StringUtils.commaDelimitedListToStringArray(noRollbackForValue).     for (String typeName : exceptionTypeNames) {         rollbackRules.add(new NoRollbackRuleAttribute(StringUtils.trimWhitespace(typeName))).     } }
