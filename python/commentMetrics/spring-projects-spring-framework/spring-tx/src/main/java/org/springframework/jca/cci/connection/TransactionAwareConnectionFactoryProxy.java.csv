commented;modifiers;parameterAmount;loc;comment;code
true;public;0;6;/**  * Delegate to ConnectionFactoryUtils for automatically participating in Spring-managed  * transactions. Throws the original ResourceException, if any.  * @return a transactional Connection if any, a new one else  * @see org.springframework.jca.cci.connection.ConnectionFactoryUtils#doGetConnection  */ ;/**  * Delegate to ConnectionFactoryUtils for automatically participating in Spring-managed  * transactions. Throws the original ResourceException, if any.  * @return a transactional Connection if any, a new one else  * @see org.springframework.jca.cci.connection.ConnectionFactoryUtils#doGetConnection  */ @Override public Connection getConnection() throws ResourceException {     ConnectionFactory targetConnectionFactory = obtainTargetConnectionFactory().     Connection con = ConnectionFactoryUtils.doGetConnection(targetConnectionFactory).     return getTransactionAwareConnectionProxy(con, targetConnectionFactory). }
true;protected;2;6;/**  * Wrap the given Connection with a proxy that delegates every method call to it  * but delegates {@code close} calls to ConnectionFactoryUtils.  * @param target the original Connection to wrap  * @param cf the ConnectionFactory that the Connection came from  * @return the wrapped Connection  * @see javax.resource.cci.Connection#close()  * @see ConnectionFactoryUtils#doReleaseConnection  */ ;/**  * Wrap the given Connection with a proxy that delegates every method call to it  * but delegates {@code close} calls to ConnectionFactoryUtils.  * @param target the original Connection to wrap  * @param cf the ConnectionFactory that the Connection came from  * @return the wrapped Connection  * @see javax.resource.cci.Connection#close()  * @see ConnectionFactoryUtils#doReleaseConnection  */ protected Connection getTransactionAwareConnectionProxy(Connection target, ConnectionFactory cf) {     return (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), new Class<?>[] { Connection.class }, new TransactionAwareInvocationHandler(target, cf)). }
false;public;3;33;;@Override @Nullable public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (method.getName().equals("equals")) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (method.getName().equals("hashCode")) {         // Use hashCode of Connection proxy.         return System.identityHashCode(proxy).     } else if (method.getName().equals("getLocalTransaction")) {         if (ConnectionFactoryUtils.isConnectionTransactional(this.target, this.connectionFactory)) {             throw new javax.resource.spi.IllegalStateException("Local transaction handling not allowed within a managed transaction").         }     } else if (method.getName().equals("close")) {         // Handle close method: only close if not within a transaction.         ConnectionFactoryUtils.doReleaseConnection(this.target, this.connectionFactory).         return null.     }     // Invoke method on target Connection.     try {         return method.invoke(this.target, args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
