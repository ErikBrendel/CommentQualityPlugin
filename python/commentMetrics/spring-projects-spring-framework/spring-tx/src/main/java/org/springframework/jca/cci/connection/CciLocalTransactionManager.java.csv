commented;modifiers;parameterAmount;loc;comment;code
true;public;1;11;/**  * Set the CCI ConnectionFactory that this instance should manage local  * transactions for.  */ ;/**  * Set the CCI ConnectionFactory that this instance should manage local  * transactions for.  */ public void setConnectionFactory(@Nullable ConnectionFactory cf) {     if (cf instanceof TransactionAwareConnectionFactoryProxy) {         // If we got a TransactionAwareConnectionFactoryProxy, we need to perform transactions         // for its underlying target ConnectionFactory, else JMS access code won't see         // properly exposed transactions (i.e. transactions for the target ConnectionFactory).         this.connectionFactory = ((TransactionAwareConnectionFactoryProxy) cf).getTargetConnectionFactory().     } else {         this.connectionFactory = cf.     } }
true;public;0;4;/**  * Return the CCI ConnectionFactory that this instance manages local  * transactions for.  */ ;/**  * Return the CCI ConnectionFactory that this instance manages local  * transactions for.  */ @Nullable public ConnectionFactory getConnectionFactory() {     return this.connectionFactory. }
false;private;0;5;;private ConnectionFactory obtainConnectionFactory() {     ConnectionFactory connectionFactory = getConnectionFactory().     Assert.state(connectionFactory != null, "No ConnectionFactory set").     return connectionFactory. }
false;public;0;6;;@Override public void afterPropertiesSet() {     if (getConnectionFactory() == null) {         throw new IllegalArgumentException("Property 'connectionFactory' is required").     } }
false;public;0;4;;@Override public Object getResourceFactory() {     return obtainConnectionFactory(). }
false;protected;0;8;;@Override protected Object doGetTransaction() {     CciLocalTransactionObject txObject = new CciLocalTransactionObject().     ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(obtainConnectionFactory()).     txObject.setConnectionHolder(conHolder).     return txObject. }
false;protected;1;6;;@Override protected boolean isExistingTransaction(Object transaction) {     CciLocalTransactionObject txObject = (CciLocalTransactionObject) transaction.     // Consider a pre-bound connection as transaction.     return txObject.hasConnectionHolder(). }
false;protected;2;37;;@Override protected void doBegin(Object transaction, TransactionDefinition definition) {     CciLocalTransactionObject txObject = (CciLocalTransactionObject) transaction.     ConnectionFactory connectionFactory = obtainConnectionFactory().     Connection con = null.     try {         con = connectionFactory.getConnection().         if (logger.isDebugEnabled()) {             logger.debug("Acquired Connection [" + con + "] for local CCI transaction").         }         ConnectionHolder connectionHolder = new ConnectionHolder(con).         connectionHolder.setSynchronizedWithTransaction(true).         con.getLocalTransaction().begin().         int timeout = determineTimeout(definition).         if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {             connectionHolder.setTimeoutInSeconds(timeout).         }         txObject.setConnectionHolder(connectionHolder).         TransactionSynchronizationManager.bindResource(connectionFactory, connectionHolder).     } catch (NotSupportedException ex) {         ConnectionFactoryUtils.releaseConnection(con, connectionFactory).         throw new CannotCreateTransactionException("CCI Connection does not support local transactions", ex).     } catch (LocalTransactionException ex) {         ConnectionFactoryUtils.releaseConnection(con, connectionFactory).         throw new CannotCreateTransactionException("Could not begin local CCI transaction", ex).     } catch (Throwable ex) {         ConnectionFactoryUtils.releaseConnection(con, connectionFactory).         throw new TransactionSystemException("Unexpected failure on begin of CCI local transaction", ex).     } }
false;protected;1;6;;@Override protected Object doSuspend(Object transaction) {     CciLocalTransactionObject txObject = (CciLocalTransactionObject) transaction.     txObject.setConnectionHolder(null).     return TransactionSynchronizationManager.unbindResource(obtainConnectionFactory()). }
false;protected;2;5;;@Override protected void doResume(@Nullable Object transaction, Object suspendedResources) {     ConnectionHolder conHolder = (ConnectionHolder) suspendedResources.     TransactionSynchronizationManager.bindResource(obtainConnectionFactory(), conHolder). }
false;protected;1;4;;protected boolean isRollbackOnly(Object transaction) throws TransactionException {     CciLocalTransactionObject txObject = (CciLocalTransactionObject) transaction.     return txObject.getConnectionHolder().isRollbackOnly(). }
false;protected;1;17;;@Override protected void doCommit(DefaultTransactionStatus status) {     CciLocalTransactionObject txObject = (CciLocalTransactionObject) status.getTransaction().     Connection con = txObject.getConnectionHolder().getConnection().     if (status.isDebug()) {         logger.debug("Committing CCI local transaction on Connection [" + con + "]").     }     try {         con.getLocalTransaction().commit().     } catch (LocalTransactionException ex) {         throw new TransactionSystemException("Could not commit CCI local transaction", ex).     } catch (ResourceException ex) {         throw new TransactionSystemException("Unexpected failure on commit of CCI local transaction", ex).     } }
false;protected;1;17;;@Override protected void doRollback(DefaultTransactionStatus status) {     CciLocalTransactionObject txObject = (CciLocalTransactionObject) status.getTransaction().     Connection con = txObject.getConnectionHolder().getConnection().     if (status.isDebug()) {         logger.debug("Rolling back CCI local transaction on Connection [" + con + "]").     }     try {         con.getLocalTransaction().rollback().     } catch (LocalTransactionException ex) {         throw new TransactionSystemException("Could not roll back CCI local transaction", ex).     } catch (ResourceException ex) {         throw new TransactionSystemException("Unexpected failure on rollback of CCI local transaction", ex).     } }
false;protected;1;9;;@Override protected void doSetRollbackOnly(DefaultTransactionStatus status) {     CciLocalTransactionObject txObject = (CciLocalTransactionObject) status.getTransaction().     if (status.isDebug()) {         logger.debug("Setting CCI local transaction [" + txObject.getConnectionHolder().getConnection() + "] rollback-only").     }     txObject.getConnectionHolder().setRollbackOnly(). }
false;protected;1;15;;@Override protected void doCleanupAfterCompletion(Object transaction) {     CciLocalTransactionObject txObject = (CciLocalTransactionObject) transaction.     ConnectionFactory connectionFactory = obtainConnectionFactory().     // Remove the connection holder from the thread.     TransactionSynchronizationManager.unbindResource(connectionFactory).     txObject.getConnectionHolder().clear().     Connection con = txObject.getConnectionHolder().getConnection().     if (logger.isDebugEnabled()) {         logger.debug("Releasing CCI Connection [" + con + "] after transaction").     }     ConnectionFactoryUtils.releaseConnection(con, connectionFactory). }
false;public;1;3;;public void setConnectionHolder(@Nullable ConnectionHolder connectionHolder) {     this.connectionHolder = connectionHolder. }
false;public;0;4;;public ConnectionHolder getConnectionHolder() {     Assert.state(this.connectionHolder != null, "No ConnectionHolder available").     return this.connectionHolder. }
false;public;0;3;;public boolean hasConnectionHolder() {     return (this.connectionHolder != null). }
