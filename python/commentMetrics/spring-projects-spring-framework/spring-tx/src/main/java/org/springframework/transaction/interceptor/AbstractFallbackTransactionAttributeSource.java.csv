commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "null". }
true;public;2;40;/**  * Determine the transaction attribute for this method invocation.  * <p>Defaults to the class's transaction attribute if no method attribute is found.  * @param method the method for the current invocation (never {@code null})  * @param targetClass the target class for this invocation (may be {@code null})  * @return a TransactionAttribute for this method, or {@code null} if the method  * is not transactional  */ ;/**  * Determine the transaction attribute for this method invocation.  * <p>Defaults to the class's transaction attribute if no method attribute is found.  * @param method the method for the current invocation (never {@code null})  * @param targetClass the target class for this invocation (may be {@code null})  * @return a TransactionAttribute for this method, or {@code null} if the method  * is not transactional  */ @Override @Nullable public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {     if (method.getDeclaringClass() == Object.class) {         return null.     }     // First, see if we have a cached value.     Object cacheKey = getCacheKey(method, targetClass).     TransactionAttribute cached = this.attributeCache.get(cacheKey).     if (cached != null) {         // or an actual transaction attribute.         if (cached == NULL_TRANSACTION_ATTRIBUTE) {             return null.         } else {             return cached.         }     } else {         // We need to work it out.         TransactionAttribute txAttr = computeTransactionAttribute(method, targetClass).         // Put it in the cache.         if (txAttr == null) {             this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE).         } else {             String methodIdentification = ClassUtils.getQualifiedMethodName(method, targetClass).             if (txAttr instanceof DefaultTransactionAttribute) {                 ((DefaultTransactionAttribute) txAttr).setDescriptor(methodIdentification).             }             if (logger.isTraceEnabled()) {                 logger.trace("Adding transactional method '" + methodIdentification + "' with attribute: " + txAttr).             }             this.attributeCache.put(cacheKey, txAttr).         }         return txAttr.     } }
true;protected;2;3;/**  * Determine a cache key for the given method and target class.  * <p>Must not produce same key for overloaded methods.  * Must produce same key for different instances of the same method.  * @param method the method (never {@code null})  * @param targetClass the target class (may be {@code null})  * @return the cache key (never {@code null})  */ ;/**  * Determine a cache key for the given method and target class.  * <p>Must not produce same key for overloaded methods.  * Must produce same key for different instances of the same method.  * @param method the method (never {@code null})  * @param targetClass the target class (may be {@code null})  * @return the cache key (never {@code null})  */ protected Object getCacheKey(Method method, @Nullable Class<?> targetClass) {     return new MethodClassKey(method, targetClass). }
true;protected;2;38;/**  * Same signature as {@link #getTransactionAttribute}, but doesn't cache the result.  * {@link #getTransactionAttribute} is effectively a caching decorator for this method.  * <p>As of 4.1.8, this method can be overridden.  * @since 4.1.8  * @see #getTransactionAttribute  */ ;/**  * Same signature as {@link #getTransactionAttribute}, but doesn't cache the result.  * {@link #getTransactionAttribute} is effectively a caching decorator for this method.  * <p>As of 4.1.8, this method can be overridden.  * @since 4.1.8  * @see #getTransactionAttribute  */ @Nullable protected TransactionAttribute computeTransactionAttribute(Method method, @Nullable Class<?> targetClass) {     // Don't allow no-public methods as required.     if (allowPublicMethodsOnly() && !Modifier.isPublic(method.getModifiers())) {         return null.     }     // The method may be on an interface, but we need attributes from the target class.     // If the target class is null, the method will be unchanged.     Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass).     // First try is the method in the target class.     TransactionAttribute txAttr = findTransactionAttribute(specificMethod).     if (txAttr != null) {         return txAttr.     }     // Second try is the transaction attribute on the target class.     txAttr = findTransactionAttribute(specificMethod.getDeclaringClass()).     if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {         return txAttr.     }     if (specificMethod != method) {         // Fallback is to look at the original method.         txAttr = findTransactionAttribute(method).         if (txAttr != null) {             return txAttr.         }         // Last fallback is the class of the original method.         txAttr = findTransactionAttribute(method.getDeclaringClass()).         if (txAttr != null && ClassUtils.isUserLevelMethod(method)) {             return txAttr.         }     }     return null. }
true;protected,abstract;1;2;/**  * Subclasses need to implement this to return the transaction attribute for the  * given class, if any.  * @param clazz the class to retrieve the attribute for  * @return all transaction attribute associated with this class, or {@code null} if none  */ ;/**  * Subclasses need to implement this to return the transaction attribute for the  * given class, if any.  * @param clazz the class to retrieve the attribute for  * @return all transaction attribute associated with this class, or {@code null} if none  */ @Nullable protected abstract TransactionAttribute findTransactionAttribute(Class<?> clazz).
true;protected,abstract;1;2;/**  * Subclasses need to implement this to return the transaction attribute for the  * given method, if any.  * @param method the method to retrieve the attribute for  * @return all transaction attribute associated with this method, or {@code null} if none  */ ;/**  * Subclasses need to implement this to return the transaction attribute for the  * given method, if any.  * @param method the method to retrieve the attribute for  * @return all transaction attribute associated with this method, or {@code null} if none  */ @Nullable protected abstract TransactionAttribute findTransactionAttribute(Method method).
true;protected;0;3;/**  * Should only public methods be allowed to have transactional semantics?  * <p>The default implementation returns {@code false}.  */ ;/**  * Should only public methods be allowed to have transactional semantics?  * <p>The default implementation returns {@code false}.  */ protected boolean allowPublicMethodsOnly() {     return false. }
