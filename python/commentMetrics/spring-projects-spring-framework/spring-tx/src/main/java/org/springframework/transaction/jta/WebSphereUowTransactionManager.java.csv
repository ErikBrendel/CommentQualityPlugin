commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the WebSphere UOWManager to use as direct reference.  * <p>Typically just used for test setups. in a Java EE environment,  * the UOWManager will always be fetched from JNDI.  * @see #setUserTransactionName  */ ;/**  * Set the WebSphere UOWManager to use as direct reference.  * <p>Typically just used for test setups. in a Java EE environment,  * the UOWManager will always be fetched from JNDI.  * @see #setUserTransactionName  */ public void setUowManager(UOWManager uowManager) {     this.uowManager = uowManager. }
true;public;1;3;/**  * Set the JNDI name of the WebSphere UOWManager.  * The default "java:comp/websphere/UOWManager" is used if not set.  * @see #DEFAULT_USER_TRANSACTION_NAME  * @see #setUowManager  */ ;/**  * Set the JNDI name of the WebSphere UOWManager.  * The default "java:comp/websphere/UOWManager" is used if not set.  * @see #DEFAULT_USER_TRANSACTION_NAME  * @see #setUowManager  */ public void setUowManagerName(String uowManagerName) {     this.uowManagerName = uowManagerName. }
false;public;0;14;;@Override public void afterPropertiesSet() throws TransactionSystemException {     initUserTransactionAndTransactionManager().     // Fetch UOWManager handle from JNDI, if necessary.     if (this.uowManager == null) {         if (this.uowManagerName != null) {             this.uowManager = lookupUowManager(this.uowManagerName).         } else {             this.uowManager = lookupDefaultUowManager().         }     } }
true;protected;1;12;/**  * Look up the WebSphere UOWManager in JNDI via the configured name.  * @param uowManagerName the JNDI name of the UOWManager  * @return the UOWManager object  * @throws TransactionSystemException if the JNDI lookup failed  * @see #setJndiTemplate  * @see #setUowManagerName  */ ;/**  * Look up the WebSphere UOWManager in JNDI via the configured name.  * @param uowManagerName the JNDI name of the UOWManager  * @return the UOWManager object  * @throws TransactionSystemException if the JNDI lookup failed  * @see #setJndiTemplate  * @see #setUowManagerName  */ protected UOWManager lookupUowManager(String uowManagerName) throws TransactionSystemException {     try {         if (logger.isDebugEnabled()) {             logger.debug("Retrieving WebSphere UOWManager from JNDI location [" + uowManagerName + "]").         }         return getJndiTemplate().lookup(uowManagerName, UOWManager.class).     } catch (NamingException ex) {         throw new TransactionSystemException("WebSphere UOWManager is not available at JNDI location [" + uowManagerName + "]", ex).     } }
true;protected;0;11;/**  * Obtain the WebSphere UOWManager from the default JNDI location  * "java:comp/websphere/UOWManager".  * @return the UOWManager object  * @throws TransactionSystemException if the JNDI lookup failed  * @see #setJndiTemplate  */ ;/**  * Obtain the WebSphere UOWManager from the default JNDI location  * "java:comp/websphere/UOWManager".  * @return the UOWManager object  * @throws TransactionSystemException if the JNDI lookup failed  * @see #setJndiTemplate  */ protected UOWManager lookupDefaultUowManager() throws TransactionSystemException {     try {         logger.debug("Retrieving WebSphere UOWManager from default JNDI location [" + DEFAULT_UOW_MANAGER_NAME + "]").         return getJndiTemplate().lookup(DEFAULT_UOW_MANAGER_NAME, UOWManager.class).     } catch (NamingException ex) {         logger.debug("WebSphere UOWManager is not available at default JNDI location [" + DEFAULT_UOW_MANAGER_NAME + "] - falling back to UOWManagerFactory lookup").         return UOWManagerFactory.getUOWManager().     } }
false;private;0;4;;private UOWManager obtainUOWManager() {     Assert.state(this.uowManager != null, "No UOWManager set").     return this.uowManager. }
true;protected;2;6;/**  * Registers the synchronizations as interposed JTA Synchronization on the UOWManager.  */ ;/**  * Registers the synchronizations as interposed JTA Synchronization on the UOWManager.  */ @Override protected void doRegisterAfterCompletionWithJtaTransaction(JtaTransactionObject txObject, List<TransactionSynchronization> synchronizations) {     obtainUOWManager().registerInterposedSynchronization(new JtaAfterCompletionSynchronization(synchronizations)). }
true;public;0;4;/**  * Returns {@code true} since WebSphere ResourceAdapters (as exposed in JNDI)  * implicitly perform transaction enlistment if the MessageEndpointFactory's  * {@code isDeliveryTransacted} method returns {@code true}.  * In that case we'll simply skip the {@link #createTransaction} call.  * @see javax.resource.spi.endpoint.MessageEndpointFactory#isDeliveryTransacted  * @see org.springframework.jca.endpoint.AbstractMessageEndpointFactory  * @see TransactionFactory#createTransaction  */ ;/**  * Returns {@code true} since WebSphere ResourceAdapters (as exposed in JNDI)  * implicitly perform transaction enlistment if the MessageEndpointFactory's  * {@code isDeliveryTransacted} method returns {@code true}.  * In that case we'll simply skip the {@link #createTransaction} call.  * @see javax.resource.spi.endpoint.MessageEndpointFactory#isDeliveryTransacted  * @see org.springframework.jca.endpoint.AbstractMessageEndpointFactory  * @see TransactionFactory#createTransaction  */ @Override public boolean supportsResourceAdapterManagedTransactions() {     return true. }
false;public;2;99;;@Override @Nullable public <T> T execute(@Nullable TransactionDefinition definition, TransactionCallback<T> callback) throws TransactionException {     if (definition == null) {         // Use defaults if no transaction definition given.         definition = new DefaultTransactionDefinition().     }     if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {         throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout()).     }     UOWManager uowManager = obtainUOWManager().     int pb = definition.getPropagationBehavior().     boolean existingTx = (uowManager.getUOWStatus() != UOWSynchronizationRegistry.UOW_STATUS_NONE && uowManager.getUOWType() != UOWSynchronizationRegistry.UOW_TYPE_LOCAL_TRANSACTION).     int uowType = UOWSynchronizationRegistry.UOW_TYPE_GLOBAL_TRANSACTION.     boolean joinTx = false.     boolean newSynch = false.     if (existingTx) {         if (pb == TransactionDefinition.PROPAGATION_NEVER) {             throw new IllegalTransactionStateException("Transaction propagation 'never' but existing transaction found").         }         if (pb == TransactionDefinition.PROPAGATION_NESTED) {             throw new NestedTransactionNotSupportedException("Transaction propagation 'nested' not supported for WebSphere UOW transactions").         }         if (pb == TransactionDefinition.PROPAGATION_SUPPORTS || pb == TransactionDefinition.PROPAGATION_REQUIRED || pb == TransactionDefinition.PROPAGATION_MANDATORY) {             joinTx = true.             newSynch = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER).         } else if (pb == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {             uowType = UOWSynchronizationRegistry.UOW_TYPE_LOCAL_TRANSACTION.             newSynch = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS).         } else {             newSynch = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER).         }     } else {         if (pb == TransactionDefinition.PROPAGATION_MANDATORY) {             throw new IllegalTransactionStateException("Transaction propagation 'mandatory' but no existing transaction found").         }         if (pb == TransactionDefinition.PROPAGATION_SUPPORTS || pb == TransactionDefinition.PROPAGATION_NOT_SUPPORTED || pb == TransactionDefinition.PROPAGATION_NEVER) {             uowType = UOWSynchronizationRegistry.UOW_TYPE_LOCAL_TRANSACTION.             newSynch = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS).         } else {             newSynch = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER).         }     }     boolean debug = logger.isDebugEnabled().     if (debug) {         logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition).     }     SuspendedResourcesHolder suspendedResources = (!joinTx ? suspend(null) : null).     UOWActionAdapter<T> action = null.     try {         if (definition.getTimeout() > TransactionDefinition.TIMEOUT_DEFAULT) {             uowManager.setUOWTimeout(uowType, definition.getTimeout()).         }         if (debug) {             logger.debug("Invoking WebSphere UOW action: type=" + uowType + ", join=" + joinTx).         }         action = new UOWActionAdapter<>(definition, callback, (uowType == UOWManager.UOW_TYPE_GLOBAL_TRANSACTION), !joinTx, newSynch, debug).         uowManager.runUnderUOW(uowType, joinTx, action).         if (debug) {             logger.debug("Returned from WebSphere UOW action: type=" + uowType + ", join=" + joinTx).         }         return action.getResult().     } catch (UOWException | UOWActionException ex) {         TransactionSystemException tse = new TransactionSystemException("UOWManager transaction processing failed", ex).         Throwable appEx = action.getException().         if (appEx != null) {             logger.error("Application exception overridden by rollback exception", appEx).             tse.initApplicationException(appEx).         }         throw tse.     } finally {         if (suspendedResources != null) {             resume(null, suspendedResources).         }     } }
false;public;0;34;;@Override public void run() {     UOWManager uowManager = obtainUOWManager().     DefaultTransactionStatus status = prepareTransactionStatus(this.definition, (this.actualTransaction ? this : null), this.newTransaction, this.newSynchronization, this.debug, null).     try {         this.result = this.callback.doInTransaction(status).         triggerBeforeCommit(status).     } catch (Throwable ex) {         this.exception = ex.         if (status.isDebug()) {             logger.debug("Rolling back on application exception from transaction callback", ex).         }         uowManager.setRollbackOnly().     } finally {         if (status.isLocalRollbackOnly()) {             if (status.isDebug()) {                 logger.debug("Transaction callback has explicitly requested rollback").             }             uowManager.setRollbackOnly().         }         triggerBeforeCompletion(status).         if (status.isNewSynchronization()) {             List<TransactionSynchronization> synchronizations = TransactionSynchronizationManager.getSynchronizations().             TransactionSynchronizationManager.clear().             if (!synchronizations.isEmpty()) {                 uowManager.registerInterposedSynchronization(new JtaAfterCompletionSynchronization(synchronizations)).             }         }     } }
false;public;0;7;;@Nullable public T getResult() {     if (this.exception != null) {         ReflectionUtils.rethrowRuntimeException(this.exception).     }     return this.result. }
false;public;0;4;;@Nullable public Throwable getException() {     return this.exception. }
false;public;0;4;;@Override public boolean isRollbackOnly() {     return obtainUOWManager().getRollbackOnly(). }
false;public;0;4;;@Override public void flush() {     TransactionSynchronizationUtils.triggerFlush(). }
