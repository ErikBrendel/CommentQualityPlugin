commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set the CCI ConnectionFactory to obtain Connections from.  */ ;/**  * Set the CCI ConnectionFactory to obtain Connections from.  */ public void setConnectionFactory(@Nullable ConnectionFactory connectionFactory) {     this.connectionFactory = connectionFactory. }
true;public;0;4;/**  * Return the CCI ConnectionFactory used by this template.  */ ;/**  * Return the CCI ConnectionFactory used by this template.  */ @Nullable public ConnectionFactory getConnectionFactory() {     return this.connectionFactory. }
false;private;0;5;;private ConnectionFactory obtainConnectionFactory() {     ConnectionFactory connectionFactory = getConnectionFactory().     Assert.state(connectionFactory != null, "No ConnectionFactory set").     return connectionFactory. }
true;public;1;3;/**  * Set the CCI ConnectionSpec that this template instance is  * supposed to obtain Connections for.  */ ;/**  * Set the CCI ConnectionSpec that this template instance is  * supposed to obtain Connections for.  */ public void setConnectionSpec(@Nullable ConnectionSpec connectionSpec) {     this.connectionSpec = connectionSpec. }
true;public;0;4;/**  * Return the CCI ConnectionSpec used by this template, if any.  */ ;/**  * Return the CCI ConnectionSpec used by this template, if any.  */ @Nullable public ConnectionSpec getConnectionSpec() {     return this.connectionSpec. }
true;public;1;3;/**  * Set a RecordCreator that should be used for creating default output Records.  * <p>Default is none: When no explicit output Record gets passed into an  * {@code execute} method, CCI's {@code Interaction.execute} variant  * that returns an output Record will be called.  * <p>Specify a RecordCreator here if you always need to call CCI's  * {@code Interaction.execute} variant with a passed-in output Record.  * Unless there is an explicitly specified output Record, CciTemplate will  * then invoke this RecordCreator to create a default output Record instance.  * @see javax.resource.cci.Interaction#execute(javax.resource.cci.InteractionSpec, Record)  * @see javax.resource.cci.Interaction#execute(javax.resource.cci.InteractionSpec, Record, Record)  */ ;/**  * Set a RecordCreator that should be used for creating default output Records.  * <p>Default is none: When no explicit output Record gets passed into an  * {@code execute} method, CCI's {@code Interaction.execute} variant  * that returns an output Record will be called.  * <p>Specify a RecordCreator here if you always need to call CCI's  * {@code Interaction.execute} variant with a passed-in output Record.  * Unless there is an explicitly specified output Record, CciTemplate will  * then invoke this RecordCreator to create a default output Record instance.  * @see javax.resource.cci.Interaction#execute(javax.resource.cci.InteractionSpec, Record)  * @see javax.resource.cci.Interaction#execute(javax.resource.cci.InteractionSpec, Record, Record)  */ public void setOutputRecordCreator(@Nullable RecordCreator creator) {     this.outputRecordCreator = creator. }
true;public;0;4;/**  * Return a RecordCreator that should be used for creating default output Records.  */ ;/**  * Return a RecordCreator that should be used for creating default output Records.  */ @Nullable public RecordCreator getOutputRecordCreator() {     return this.outputRecordCreator. }
false;public;0;5;;public void afterPropertiesSet() {     if (getConnectionFactory() == null) {         throw new IllegalArgumentException("Property 'connectionFactory' is required").     } }
true;public;1;8;/**  * Create a template derived from this template instance,  * inheriting the ConnectionFactory and other settings but  * overriding the ConnectionSpec used for obtaining Connections.  * @param connectionSpec the CCI ConnectionSpec that the derived template  * instance is supposed to obtain Connections for  * @return the derived template instance  * @see #setConnectionSpec  */ ;/**  * Create a template derived from this template instance,  * inheriting the ConnectionFactory and other settings but  * overriding the ConnectionSpec used for obtaining Connections.  * @param connectionSpec the CCI ConnectionSpec that the derived template  * instance is supposed to obtain Connections for  * @return the derived template instance  * @see #setConnectionSpec  */ public CciTemplate getDerivedTemplate(ConnectionSpec connectionSpec) {     CciTemplate derived = new CciTemplate(obtainConnectionFactory(), connectionSpec).     RecordCreator recordCreator = getOutputRecordCreator().     if (recordCreator != null) {         derived.setOutputRecordCreator(recordCreator).     }     return derived. }
false;public;1;22;;@Override @Nullable public <T> T execute(ConnectionCallback<T> action) throws DataAccessException {     Assert.notNull(action, "Callback object must not be null").     ConnectionFactory connectionFactory = obtainConnectionFactory().     Connection con = ConnectionFactoryUtils.getConnection(connectionFactory, getConnectionSpec()).     try {         return action.doInConnection(con, connectionFactory).     } catch (NotSupportedException ex) {         throw new CciOperationNotSupportedException("CCI operation not supported by connector", ex).     } catch (ResourceException ex) {         throw new DataAccessResourceFailureException("CCI operation failed", ex).     } catch (SQLException ex) {         throw new InvalidResultSetAccessException("Parsing of CCI ResultSet failed", ex).     } finally {         ConnectionFactoryUtils.releaseConnection(con, getConnectionFactory()).     } }
false;public;1;14;;@Override @Nullable public <T> T execute(final InteractionCallback<T> action) throws DataAccessException {     Assert.notNull(action, "Callback object must not be null").     return execute((ConnectionCallback<T>) (connection, connectionFactory) -> {         Interaction interaction = connection.createInteraction().         try {             return action.doInInteraction(interaction, connectionFactory).         } finally {             closeInteraction(interaction).         }     }). }
false;public;2;5;;@Override @Nullable public Record execute(InteractionSpec spec, Record inputRecord) throws DataAccessException {     return doExecute(spec, inputRecord, null, new SimpleRecordExtractor()). }
false;public;3;4;;@Override public void execute(InteractionSpec spec, Record inputRecord, Record outputRecord) throws DataAccessException {     doExecute(spec, inputRecord, outputRecord, null). }
false;public;2;6;;@Override public Record execute(InteractionSpec spec, RecordCreator inputCreator) throws DataAccessException {     Record output = doExecute(spec, createRecord(inputCreator), null, new SimpleRecordExtractor()).     Assert.state(output != null, "Invalid output record").     return output. }
false;public;3;6;;@Override public <T> T execute(InteractionSpec spec, Record inputRecord, RecordExtractor<T> outputExtractor) throws DataAccessException {     return doExecute(spec, inputRecord, null, outputExtractor). }
false;public;3;6;;@Override public <T> T execute(InteractionSpec spec, RecordCreator inputCreator, RecordExtractor<T> outputExtractor) throws DataAccessException {     return doExecute(spec, createRecord(inputCreator), null, outputExtractor). }
true;protected;4;28;/**  * Execute the specified interaction on an EIS with CCI.  * All other interaction execution methods go through this.  * @param spec the CCI InteractionSpec instance that defines  * the interaction (connector-specific)  * @param inputRecord the input record  * @param outputRecord output record (can be {@code null})  * @param outputExtractor object to convert the output record to a result object  * @return the output data extracted with the RecordExtractor object  * @throws DataAccessException if there is any problem  */ ;/**  * Execute the specified interaction on an EIS with CCI.  * All other interaction execution methods go through this.  * @param spec the CCI InteractionSpec instance that defines  * the interaction (connector-specific)  * @param inputRecord the input record  * @param outputRecord output record (can be {@code null})  * @param outputExtractor object to convert the output record to a result object  * @return the output data extracted with the RecordExtractor object  * @throws DataAccessException if there is any problem  */ @Nullable protected <T> T doExecute(final InteractionSpec spec, final Record inputRecord, @Nullable final Record outputRecord, @Nullable final RecordExtractor<T> outputExtractor) throws DataAccessException {     return execute((InteractionCallback<T>) (interaction, connectionFactory) -> {         Record outputRecordToUse = outputRecord.         try {             if (outputRecord != null || getOutputRecordCreator() != null) {                 // Use the CCI execute method with output record as parameter.                 if (outputRecord == null) {                     RecordFactory recordFactory = getRecordFactory(connectionFactory).                     outputRecordToUse = getOutputRecordCreator().createRecord(recordFactory).                 }                 interaction.execute(spec, inputRecord, outputRecordToUse).             } else {                 outputRecordToUse = interaction.execute(spec, inputRecord).             }             return (outputExtractor != null ? outputExtractor.extractData(outputRecordToUse) : null).         } finally {             if (outputRecordToUse instanceof ResultSet) {                 closeResultSet((ResultSet) outputRecordToUse).             }         }     }). }
true;public;1;12;/**  * Create an indexed Record through the ConnectionFactory's RecordFactory.  * @param name the name of the record  * @return the Record  * @throws DataAccessException if creation of the Record failed  * @see #getRecordFactory(javax.resource.cci.ConnectionFactory)  * @see javax.resource.cci.RecordFactory#createIndexedRecord(String)  */ ;/**  * Create an indexed Record through the ConnectionFactory's RecordFactory.  * @param name the name of the record  * @return the Record  * @throws DataAccessException if creation of the Record failed  * @see #getRecordFactory(javax.resource.cci.ConnectionFactory)  * @see javax.resource.cci.RecordFactory#createIndexedRecord(String)  */ public IndexedRecord createIndexedRecord(String name) throws DataAccessException {     try {         RecordFactory recordFactory = getRecordFactory(obtainConnectionFactory()).         return recordFactory.createIndexedRecord(name).     } catch (NotSupportedException ex) {         throw new RecordTypeNotSupportedException("Creation of indexed Record not supported by connector", ex).     } catch (ResourceException ex) {         throw new CannotCreateRecordException("Creation of indexed Record failed", ex).     } }
true;public;1;12;/**  * Create a mapped Record from the ConnectionFactory's RecordFactory.  * @param name record name  * @return the Record  * @throws DataAccessException if creation of the Record failed  * @see #getRecordFactory(javax.resource.cci.ConnectionFactory)  * @see javax.resource.cci.RecordFactory#createMappedRecord(String)  */ ;/**  * Create a mapped Record from the ConnectionFactory's RecordFactory.  * @param name record name  * @return the Record  * @throws DataAccessException if creation of the Record failed  * @see #getRecordFactory(javax.resource.cci.ConnectionFactory)  * @see javax.resource.cci.RecordFactory#createMappedRecord(String)  */ public MappedRecord createMappedRecord(String name) throws DataAccessException {     try {         RecordFactory recordFactory = getRecordFactory(obtainConnectionFactory()).         return recordFactory.createMappedRecord(name).     } catch (NotSupportedException ex) {         throw new RecordTypeNotSupportedException("Creation of mapped Record not supported by connector", ex).     } catch (ResourceException ex) {         throw new CannotCreateRecordException("Creation of mapped Record failed", ex).     } }
true;protected;1;13;/**  * Invoke the given RecordCreator, converting JCA ResourceExceptions  * to Spring's DataAccessException hierarchy.  * @param recordCreator the RecordCreator to invoke  * @return the created Record  * @throws DataAccessException if creation of the Record failed  * @see #getRecordFactory(javax.resource.cci.ConnectionFactory)  * @see RecordCreator#createRecord(javax.resource.cci.RecordFactory)  */ ;/**  * Invoke the given RecordCreator, converting JCA ResourceExceptions  * to Spring's DataAccessException hierarchy.  * @param recordCreator the RecordCreator to invoke  * @return the created Record  * @throws DataAccessException if creation of the Record failed  * @see #getRecordFactory(javax.resource.cci.ConnectionFactory)  * @see RecordCreator#createRecord(javax.resource.cci.RecordFactory)  */ protected Record createRecord(RecordCreator recordCreator) throws DataAccessException {     try {         RecordFactory recordFactory = getRecordFactory(obtainConnectionFactory()).         return recordCreator.createRecord(recordFactory).     } catch (NotSupportedException ex) {         throw new RecordTypeNotSupportedException("Creation of the desired Record type not supported by connector", ex).     } catch (ResourceException ex) {         throw new CannotCreateRecordException("Creation of the desired Record failed", ex).     } }
true;protected;1;8;/**  * Return a RecordFactory for the given ConnectionFactory.  * <p>Default implementation returns the connector's RecordFactory if  * available, falling back to a NotSupportedRecordFactory placeholder.  * This allows to invoke a RecordCreator callback with a non-null  * RecordFactory reference in any case.  * @param connectionFactory the CCI ConnectionFactory  * @return the CCI RecordFactory for the ConnectionFactory  * @throws ResourceException if thrown by CCI methods  * @see org.springframework.jca.cci.connection.NotSupportedRecordFactory  */ ;/**  * Return a RecordFactory for the given ConnectionFactory.  * <p>Default implementation returns the connector's RecordFactory if  * available, falling back to a NotSupportedRecordFactory placeholder.  * This allows to invoke a RecordCreator callback with a non-null  * RecordFactory reference in any case.  * @param connectionFactory the CCI ConnectionFactory  * @return the CCI RecordFactory for the ConnectionFactory  * @throws ResourceException if thrown by CCI methods  * @see org.springframework.jca.cci.connection.NotSupportedRecordFactory  */ protected RecordFactory getRecordFactory(ConnectionFactory connectionFactory) throws ResourceException {     try {         return connectionFactory.getRecordFactory().     } catch (NotSupportedException ex) {         return new NotSupportedRecordFactory().     } }
true;private;1;14;/**  * Close the given CCI Interaction and ignore any thrown exception.  * This is useful for typical finally blocks in manual CCI code.  * @param interaction the CCI Interaction to close  * @see javax.resource.cci.Interaction#close()  */ ;/**  * Close the given CCI Interaction and ignore any thrown exception.  * This is useful for typical finally blocks in manual CCI code.  * @param interaction the CCI Interaction to close  * @see javax.resource.cci.Interaction#close()  */ private void closeInteraction(@Nullable Interaction interaction) {     if (interaction != null) {         try {             interaction.close().         } catch (ResourceException ex) {             logger.trace("Could not close CCI Interaction", ex).         } catch (Throwable ex) {             // We don't trust the CCI driver: It might throw RuntimeException or Error.             logger.trace("Unexpected exception on closing CCI Interaction", ex).         }     } }
true;private;1;14;/**  * Close the given CCI ResultSet and ignore any thrown exception.  * This is useful for typical finally blocks in manual CCI code.  * @param resultSet the CCI ResultSet to close  * @see javax.resource.cci.ResultSet#close()  */ ;/**  * Close the given CCI ResultSet and ignore any thrown exception.  * This is useful for typical finally blocks in manual CCI code.  * @param resultSet the CCI ResultSet to close  * @see javax.resource.cci.ResultSet#close()  */ private void closeResultSet(@Nullable ResultSet resultSet) {     if (resultSet != null) {         try {             resultSet.close().         } catch (SQLException ex) {             logger.trace("Could not close CCI ResultSet", ex).         } catch (Throwable ex) {             // We don't trust the CCI driver: It might throw RuntimeException or Error.             logger.trace("Unexpected exception on closing CCI ResultSet", ex).         }     } }
false;public;1;4;;@Override public Record extractData(Record record) {     return record. }
