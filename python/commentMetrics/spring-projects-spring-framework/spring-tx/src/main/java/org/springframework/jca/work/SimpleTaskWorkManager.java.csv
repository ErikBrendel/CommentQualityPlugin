commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Specify the TaskExecutor to use for <i>synchronous</i> work execution  * (i.e. {@link #doWork} calls).  * <p>Default is a {@link org.springframework.core.task.SyncTaskExecutor}.  */ ;/**  * Specify the TaskExecutor to use for <i>synchronous</i> work execution  * (i.e. {@link #doWork} calls).  * <p>Default is a {@link org.springframework.core.task.SyncTaskExecutor}.  */ public void setSyncTaskExecutor(TaskExecutor syncTaskExecutor) {     this.syncTaskExecutor = syncTaskExecutor. }
true;public;1;3;/**  * Specify the TaskExecutor to use for <i>asynchronous</i> work execution  * (i.e. {@link #startWork} and {@link #scheduleWork} calls).  * <p>This will typically (but not necessarily) be an  * {@link org.springframework.core.task.AsyncTaskExecutor} implementation.  * Default is a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}.  */ ;/**  * Specify the TaskExecutor to use for <i>asynchronous</i> work execution  * (i.e. {@link #startWork} and {@link #scheduleWork} calls).  * <p>This will typically (but not necessarily) be an  * {@link org.springframework.core.task.AsyncTaskExecutor} implementation.  * Default is a {@link org.springframework.core.task.SimpleAsyncTaskExecutor}.  */ public void setAsyncTaskExecutor(AsyncTaskExecutor asyncTaskExecutor) {     this.asyncTaskExecutor = asyncTaskExecutor. }
false;public;1;4;;@Override public void doWork(Work work) throws WorkException {     doWork(work, WorkManager.INDEFINITE, null, null). }
false;public;4;7;;@Override public void doWork(Work work, long startTimeout, @Nullable ExecutionContext executionContext, @Nullable WorkListener workListener) throws WorkException {     Assert.state(this.syncTaskExecutor != null, "No 'syncTaskExecutor' set").     executeWork(this.syncTaskExecutor, work, startTimeout, false, executionContext, workListener). }
false;public;1;4;;@Override public long startWork(Work work) throws WorkException {     return startWork(work, WorkManager.INDEFINITE, null, null). }
false;public;4;7;;@Override public long startWork(Work work, long startTimeout, @Nullable ExecutionContext executionContext, @Nullable WorkListener workListener) throws WorkException {     Assert.state(this.asyncTaskExecutor != null, "No 'asyncTaskExecutor' set").     return executeWork(this.asyncTaskExecutor, work, startTimeout, true, executionContext, workListener). }
false;public;1;4;;@Override public void scheduleWork(Work work) throws WorkException {     scheduleWork(work, WorkManager.INDEFINITE, null, null). }
false;public;4;7;;@Override public void scheduleWork(Work work, long startTimeout, @Nullable ExecutionContext executionContext, @Nullable WorkListener workListener) throws WorkException {     Assert.state(this.asyncTaskExecutor != null, "No 'asyncTaskExecutor' set").     executeWork(this.asyncTaskExecutor, work, startTimeout, false, executionContext, workListener). }
true;protected;6;60;/**  * Execute the given Work on the specified TaskExecutor.  * @param taskExecutor the TaskExecutor to use  * @param work the Work to execute  * @param startTimeout the time duration within which the Work is supposed to start  * @param blockUntilStarted whether to block until the Work has started  * @param executionContext the JCA ExecutionContext for the given Work  * @param workListener the WorkListener to clal for the given Work  * @return the time elapsed from Work acceptance until start of execution  * (or -1 if not applicable or not known)  * @throws WorkException if the TaskExecutor did not accept the Work  */ ;/**  * Execute the given Work on the specified TaskExecutor.  * @param taskExecutor the TaskExecutor to use  * @param work the Work to execute  * @param startTimeout the time duration within which the Work is supposed to start  * @param blockUntilStarted whether to block until the Work has started  * @param executionContext the JCA ExecutionContext for the given Work  * @param workListener the WorkListener to clal for the given Work  * @return the time elapsed from Work acceptance until start of execution  * (or -1 if not applicable or not known)  * @throws WorkException if the TaskExecutor did not accept the Work  */ protected long executeWork(TaskExecutor taskExecutor, Work work, long startTimeout, boolean blockUntilStarted, @Nullable ExecutionContext executionContext, @Nullable WorkListener workListener) throws WorkException {     if (executionContext != null && executionContext.getXid() != null) {         throw new WorkException("SimpleTaskWorkManager does not supported imported XIDs: " + executionContext.getXid()).     }     WorkListener workListenerToUse = workListener.     if (workListenerToUse == null) {         workListenerToUse = new WorkAdapter().     }     boolean isAsync = (taskExecutor instanceof AsyncTaskExecutor).     DelegatingWorkAdapter workHandle = new DelegatingWorkAdapter(work, workListenerToUse, !isAsync).     try {         if (isAsync) {             ((AsyncTaskExecutor) taskExecutor).execute(workHandle, startTimeout).         } else {             taskExecutor.execute(workHandle).         }     } catch (TaskTimeoutException ex) {         WorkException wex = new WorkRejectedException("TaskExecutor rejected Work because of timeout: " + work, ex).         wex.setErrorCode(WorkException.START_TIMED_OUT).         workListenerToUse.workRejected(new WorkEvent(this, WorkEvent.WORK_REJECTED, work, wex)).         throw wex.     } catch (TaskRejectedException ex) {         WorkException wex = new WorkRejectedException("TaskExecutor rejected Work: " + work, ex).         wex.setErrorCode(WorkException.INTERNAL).         workListenerToUse.workRejected(new WorkEvent(this, WorkEvent.WORK_REJECTED, work, wex)).         throw wex.     } catch (Throwable ex) {         WorkException wex = new WorkException("TaskExecutor failed to execute Work: " + work, ex).         wex.setErrorCode(WorkException.INTERNAL).         throw wex.     }     if (isAsync) {         workListenerToUse.workAccepted(new WorkEvent(this, WorkEvent.WORK_ACCEPTED, work, null)).     }     if (blockUntilStarted) {         long acceptanceTime = System.currentTimeMillis().         synchronized (workHandle.monitor) {             try {                 while (!workHandle.started) {                     workHandle.monitor.wait().                 }             } catch (InterruptedException ex) {                 Thread.currentThread().interrupt().             }         }         return (System.currentTimeMillis() - acceptanceTime).     } else {         return WorkManager.UNKNOWN.     } }
false;public;0;20;;@Override public void run() {     if (this.acceptOnExecution) {         this.workListener.workAccepted(new WorkEvent(this, WorkEvent.WORK_ACCEPTED, this.work, null)).     }     synchronized (this.monitor) {         this.started = true.         this.monitor.notify().     }     this.workListener.workStarted(new WorkEvent(this, WorkEvent.WORK_STARTED, this.work, null)).     try {         this.work.run().     } catch (RuntimeException | Error ex) {         this.workListener.workCompleted(new WorkEvent(this, WorkEvent.WORK_COMPLETED, this.work, new WorkCompletedException(ex))).         throw ex.     }     this.workListener.workCompleted(new WorkEvent(this, WorkEvent.WORK_COMPLETED, this.work, null)). }
false;public;0;4;;@Override public void release() {     this.work.release(). }
