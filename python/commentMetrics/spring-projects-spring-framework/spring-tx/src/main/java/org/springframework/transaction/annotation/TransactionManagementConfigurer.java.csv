# id;timestamp;commentText;codeText;commentWords;codeWords
TransactionManagementConfigurer -> PlatformTransactionManager annotationDrivenTransactionManager()_;1328020251;Return the transaction manager bean to use for annotation-driven database_transaction management, i.e. when processing {@code @Transactional} methods.__<p>There are two basic approaches to implementing this method:_<h3>1. Implement the method and annotate it with {@code @Bean}</h3>_In this case, the implementing {@code @Configuration} class implements this method,_marks it with {@code @Bean} and configures and returns the transaction manager_directly within the method body:_<pre class="code">_&#064_Bean_&#064_Override_public PlatformTransactionManager createTransactionManager() {_return new DataSourceTransactionManager(dataSource())__}</pre>_<h3>2. Implement the method without {@code @Bean} and delegate to another existing_{@code @Bean} method</h3>_<pre class="code">_&#064_Bean_public PlatformTransactionManager txManager() {_return new DataSourceTransactionManager(dataSource())____&#064_Override_public PlatformTransactionManager createTransactionManager() {_return txManager()_ // reference the existing {@code @Bean} method above_}</pre>__If taking approach #2, be sure that <em>only one</em> of the methods is marked with_{@code @Bean}!__<p>In either scenario #1 or #2, it is important that the_{@code PlatformTransactionManager} instance is managed as a Spring bean within the_container as all {@code PlatformTransactionManager} implementations take_advantage of Spring lifecycle callbacks such as {@code InitializingBean} and {@code_BeanFactoryAware}.;PlatformTransactionManager annotationDrivenTransactionManager()_;return,the,transaction,manager,bean,to,use,for,annotation,driven,database,transaction,management,i,e,when,processing,code,transactional,methods,p,there,are,two,basic,approaches,to,implementing,this,method,h3,1,implement,the,method,and,annotate,it,with,code,bean,h3,in,this,case,the,implementing,code,configuration,class,implements,this,method,marks,it,with,code,bean,and,configures,and,returns,the,transaction,manager,directly,within,the,method,body,pre,class,code,064,bean,064,override,public,platform,transaction,manager,create,transaction,manager,return,new,data,source,transaction,manager,data,source,pre,h3,2,implement,the,method,without,code,bean,and,delegate,to,another,existing,code,bean,method,h3,pre,class,code,064,bean,public,platform,transaction,manager,tx,manager,return,new,data,source,transaction,manager,data,source,064,override,public,platform,transaction,manager,create,transaction,manager,return,tx,manager,reference,the,existing,code,bean,method,above,pre,if,taking,approach,2,be,sure,that,em,only,one,em,of,the,methods,is,marked,with,code,bean,p,in,either,scenario,1,or,2,it,is,important,that,the,code,platform,transaction,manager,instance,is,managed,as,a,spring,bean,within,the,container,as,all,code,platform,transaction,manager,implementations,take,advantage,of,spring,lifecycle,callbacks,such,as,code,initializing,bean,and,code,bean,factory,aware;platform,transaction,manager,annotation,driven,transaction,manager
TransactionManagementConfigurer -> PlatformTransactionManager annotationDrivenTransactionManager()_;1343340295;Return the transaction manager bean to use for annotation-driven database_transaction management, i.e. when processing {@code @Transactional} methods.__<p>There are two basic approaches to implementing this method:_<h3>1. Implement the method and annotate it with {@code @Bean}</h3>_In this case, the implementing {@code @Configuration} class implements this method,_marks it with {@code @Bean} and configures and returns the transaction manager_directly within the method body:_<pre class="code">_&#064_Bean_&#064_Override_public PlatformTransactionManager annotationDrivenTransactionManager() {_return new DataSourceTransactionManager(dataSource())__}</pre>_<h3>2. Implement the method without {@code @Bean} and delegate to another existing_{@code @Bean} method</h3>_<pre class="code">_&#064_Bean_public PlatformTransactionManager txManager() {_return new DataSourceTransactionManager(dataSource())____&#064_Override_public PlatformTransactionManager annotationDrivenTransactionManager() {_return txManager()_ // reference the existing {@code @Bean} method above_}</pre>__If taking approach #2, be sure that <em>only one</em> of the methods is marked with_{@code @Bean}!__<p>In either scenario #1 or #2, it is important that the_{@code PlatformTransactionManager} instance is managed as a Spring bean within the_container as all {@code PlatformTransactionManager} implementations take_advantage of Spring lifecycle callbacks such as {@code InitializingBean} and {@code_BeanFactoryAware}.;PlatformTransactionManager annotationDrivenTransactionManager()_;return,the,transaction,manager,bean,to,use,for,annotation,driven,database,transaction,management,i,e,when,processing,code,transactional,methods,p,there,are,two,basic,approaches,to,implementing,this,method,h3,1,implement,the,method,and,annotate,it,with,code,bean,h3,in,this,case,the,implementing,code,configuration,class,implements,this,method,marks,it,with,code,bean,and,configures,and,returns,the,transaction,manager,directly,within,the,method,body,pre,class,code,064,bean,064,override,public,platform,transaction,manager,annotation,driven,transaction,manager,return,new,data,source,transaction,manager,data,source,pre,h3,2,implement,the,method,without,code,bean,and,delegate,to,another,existing,code,bean,method,h3,pre,class,code,064,bean,public,platform,transaction,manager,tx,manager,return,new,data,source,transaction,manager,data,source,064,override,public,platform,transaction,manager,annotation,driven,transaction,manager,return,tx,manager,reference,the,existing,code,bean,method,above,pre,if,taking,approach,2,be,sure,that,em,only,one,em,of,the,methods,is,marked,with,code,bean,p,in,either,scenario,1,or,2,it,is,important,that,the,code,platform,transaction,manager,instance,is,managed,as,a,spring,bean,within,the,container,as,all,code,platform,transaction,manager,implementations,take,advantage,of,spring,lifecycle,callbacks,such,as,code,initializing,bean,and,code,bean,factory,aware;platform,transaction,manager,annotation,driven,transaction,manager
TransactionManagementConfigurer -> PlatformTransactionManager annotationDrivenTransactionManager()_;1418414219;Return the default transaction manager bean to use for annotation-driven database_transaction management, i.e. when processing {@code @Transactional} methods.__<p>There are two basic approaches to implementing this method:_<h3>1. Implement the method and annotate it with {@code @Bean}</h3>_In this case, the implementing {@code @Configuration} class implements this method,_marks it with {@code @Bean} and configures and returns the transaction manager_directly within the method body:_<pre class="code">_&#064_Bean_&#064_Override_public PlatformTransactionManager annotationDrivenTransactionManager() {_return new DataSourceTransactionManager(dataSource())__}</pre>_<h3>2. Implement the method without {@code @Bean} and delegate to another existing_{@code @Bean} method</h3>_<pre class="code">_&#064_Bean_public PlatformTransactionManager txManager() {_return new DataSourceTransactionManager(dataSource())____&#064_Override_public PlatformTransactionManager annotationDrivenTransactionManager() {_return txManager()_ // reference the existing {@code @Bean} method above_}</pre>__If taking approach #2, be sure that <em>only one</em> of the methods is marked with_{@code @Bean}!__<p>In either scenario #1 or #2, it is important that the_{@code PlatformTransactionManager} instance is managed as a Spring bean within the_container as all {@code PlatformTransactionManager} implementations take_advantage of Spring lifecycle callbacks such as {@code InitializingBean} and {@code_BeanFactoryAware}.;PlatformTransactionManager annotationDrivenTransactionManager()_;return,the,default,transaction,manager,bean,to,use,for,annotation,driven,database,transaction,management,i,e,when,processing,code,transactional,methods,p,there,are,two,basic,approaches,to,implementing,this,method,h3,1,implement,the,method,and,annotate,it,with,code,bean,h3,in,this,case,the,implementing,code,configuration,class,implements,this,method,marks,it,with,code,bean,and,configures,and,returns,the,transaction,manager,directly,within,the,method,body,pre,class,code,064,bean,064,override,public,platform,transaction,manager,annotation,driven,transaction,manager,return,new,data,source,transaction,manager,data,source,pre,h3,2,implement,the,method,without,code,bean,and,delegate,to,another,existing,code,bean,method,h3,pre,class,code,064,bean,public,platform,transaction,manager,tx,manager,return,new,data,source,transaction,manager,data,source,064,override,public,platform,transaction,manager,annotation,driven,transaction,manager,return,tx,manager,reference,the,existing,code,bean,method,above,pre,if,taking,approach,2,be,sure,that,em,only,one,em,of,the,methods,is,marked,with,code,bean,p,in,either,scenario,1,or,2,it,is,important,that,the,code,platform,transaction,manager,instance,is,managed,as,a,spring,bean,within,the,container,as,all,code,platform,transaction,manager,implementations,take,advantage,of,spring,lifecycle,callbacks,such,as,code,initializing,bean,and,code,bean,factory,aware;platform,transaction,manager,annotation,driven,transaction,manager
TransactionManagementConfigurer -> PlatformTransactionManager annotationDrivenTransactionManager()_;1421948647;Return the default transaction manager bean to use for annotation-driven database_transaction management, i.e. when processing {@code @Transactional} methods._<p>There are two basic approaches to implementing this method:_<h3>1. Implement the method and annotate it with {@code @Bean}</h3>_In this case, the implementing {@code @Configuration} class implements this method,_marks it with {@code @Bean} and configures and returns the transaction manager_directly within the method body:_<pre class="code">_&#064_Bean_&#064_Override_public PlatformTransactionManager annotationDrivenTransactionManager() {_return new DataSourceTransactionManager(dataSource())__}</pre>_<h3>2. Implement the method without {@code @Bean} and delegate to another existing_{@code @Bean} method</h3>_<pre class="code">_&#064_Bean_public PlatformTransactionManager txManager() {_return new DataSourceTransactionManager(dataSource())____&#064_Override_public PlatformTransactionManager annotationDrivenTransactionManager() {_return txManager()_ // reference the existing {@code @Bean} method above_}</pre>_If taking approach #2, be sure that <em>only one</em> of the methods is marked_with {@code @Bean}!_<p>In either scenario #1 or #2, it is important that the_{@code PlatformTransactionManager} instance is managed as a Spring bean within the_container as all {@code PlatformTransactionManager} implementations take advantage_of Spring lifecycle callbacks such as {@code InitializingBean} and_{@code BeanFactoryAware}.;PlatformTransactionManager annotationDrivenTransactionManager()_;return,the,default,transaction,manager,bean,to,use,for,annotation,driven,database,transaction,management,i,e,when,processing,code,transactional,methods,p,there,are,two,basic,approaches,to,implementing,this,method,h3,1,implement,the,method,and,annotate,it,with,code,bean,h3,in,this,case,the,implementing,code,configuration,class,implements,this,method,marks,it,with,code,bean,and,configures,and,returns,the,transaction,manager,directly,within,the,method,body,pre,class,code,064,bean,064,override,public,platform,transaction,manager,annotation,driven,transaction,manager,return,new,data,source,transaction,manager,data,source,pre,h3,2,implement,the,method,without,code,bean,and,delegate,to,another,existing,code,bean,method,h3,pre,class,code,064,bean,public,platform,transaction,manager,tx,manager,return,new,data,source,transaction,manager,data,source,064,override,public,platform,transaction,manager,annotation,driven,transaction,manager,return,tx,manager,reference,the,existing,code,bean,method,above,pre,if,taking,approach,2,be,sure,that,em,only,one,em,of,the,methods,is,marked,with,code,bean,p,in,either,scenario,1,or,2,it,is,important,that,the,code,platform,transaction,manager,instance,is,managed,as,a,spring,bean,within,the,container,as,all,code,platform,transaction,manager,implementations,take,advantage,of,spring,lifecycle,callbacks,such,as,code,initializing,bean,and,code,bean,factory,aware;platform,transaction,manager,annotation,driven,transaction,manager
TransactionManagementConfigurer -> PlatformTransactionManager annotationDrivenTransactionManager()_;1467376008;Return the default transaction manager bean to use for annotation-driven database_transaction management, i.e. when processing {@code @Transactional} methods._<p>There are two basic approaches to implementing this method:_<h3>1. Implement the method and annotate it with {@code @Bean}</h3>_In this case, the implementing {@code @Configuration} class implements this method,_marks it with {@code @Bean} and configures and returns the transaction manager_directly within the method body:_<pre class="code">_&#064_Bean_&#064_Override_public PlatformTransactionManager annotationDrivenTransactionManager() {_return new DataSourceTransactionManager(dataSource())__}</pre>_<h3>2. Implement the method without {@code @Bean} and delegate to another existing_{@code @Bean} method</h3>_<pre class="code">_&#064_Bean_public PlatformTransactionManager txManager() {_return new DataSourceTransactionManager(dataSource())____&#064_Override_public PlatformTransactionManager annotationDrivenTransactionManager() {_return txManager()_ // reference the existing {@code @Bean} method above_}</pre>_If taking approach #2, be sure that <em>only one</em> of the methods is marked_with {@code @Bean}!_<p>In either scenario #1 or #2, it is important that the_{@code PlatformTransactionManager} instance is managed as a Spring bean within the_container as all {@code PlatformTransactionManager} implementations take advantage_of Spring lifecycle callbacks such as {@code InitializingBean} and_{@code BeanFactoryAware}.;PlatformTransactionManager annotationDrivenTransactionManager()_;return,the,default,transaction,manager,bean,to,use,for,annotation,driven,database,transaction,management,i,e,when,processing,code,transactional,methods,p,there,are,two,basic,approaches,to,implementing,this,method,h3,1,implement,the,method,and,annotate,it,with,code,bean,h3,in,this,case,the,implementing,code,configuration,class,implements,this,method,marks,it,with,code,bean,and,configures,and,returns,the,transaction,manager,directly,within,the,method,body,pre,class,code,064,bean,064,override,public,platform,transaction,manager,annotation,driven,transaction,manager,return,new,data,source,transaction,manager,data,source,pre,h3,2,implement,the,method,without,code,bean,and,delegate,to,another,existing,code,bean,method,h3,pre,class,code,064,bean,public,platform,transaction,manager,tx,manager,return,new,data,source,transaction,manager,data,source,064,override,public,platform,transaction,manager,annotation,driven,transaction,manager,return,tx,manager,reference,the,existing,code,bean,method,above,pre,if,taking,approach,2,be,sure,that,em,only,one,em,of,the,methods,is,marked,with,code,bean,p,in,either,scenario,1,or,2,it,is,important,that,the,code,platform,transaction,manager,instance,is,managed,as,a,spring,bean,within,the,container,as,all,code,platform,transaction,manager,implementations,take,advantage,of,spring,lifecycle,callbacks,such,as,code,initializing,bean,and,code,bean,factory,aware;platform,transaction,manager,annotation,driven,transaction,manager
