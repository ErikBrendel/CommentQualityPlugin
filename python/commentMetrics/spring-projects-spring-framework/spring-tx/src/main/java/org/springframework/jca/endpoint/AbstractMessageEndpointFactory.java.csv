commented;modifiers;parameterAmount;loc;comment;code
true;public;1;13;/**  * Set the XA transaction manager to use for wrapping endpoint  * invocations, enlisting the endpoint resource in each such transaction.  * <p>The passed-in object may be a transaction manager which implements  * Spring's {@link org.springframework.transaction.jta.TransactionFactory}  * interface, or a plain {@link javax.transaction.TransactionManager}.  * <p>If no transaction manager is specified, the endpoint invocation  * will simply not be wrapped in an XA transaction. Check out your  * resource provider's ActivationSpec documentation for local  * transaction options of your particular provider.  * @see #setTransactionName  * @see #setTransactionTimeout  */ ;/**  * Set the XA transaction manager to use for wrapping endpoint  * invocations, enlisting the endpoint resource in each such transaction.  * <p>The passed-in object may be a transaction manager which implements  * Spring's {@link org.springframework.transaction.jta.TransactionFactory}  * interface, or a plain {@link javax.transaction.TransactionManager}.  * <p>If no transaction manager is specified, the endpoint invocation  * will simply not be wrapped in an XA transaction. Check out your  * resource provider's ActivationSpec documentation for local  * transaction options of your particular provider.  * @see #setTransactionName  * @see #setTransactionTimeout  */ public void setTransactionManager(Object transactionManager) {     if (transactionManager instanceof TransactionFactory) {         this.transactionFactory = (TransactionFactory) transactionManager.     } else if (transactionManager instanceof TransactionManager) {         this.transactionFactory = new SimpleTransactionFactory((TransactionManager) transactionManager).     } else {         throw new IllegalArgumentException("Transaction manager [" + transactionManager + "] is neither a [org.springframework.transaction.jta.TransactionFactory} nor a " + "[javax.transaction.TransactionManager]").     } }
true;public;1;3;/**  * Set the Spring TransactionFactory to use for wrapping endpoint  * invocations, enlisting the endpoint resource in each such transaction.  * <p>Alternatively, specify an appropriate transaction manager through  * the {@link #setTransactionManager "transactionManager"} property.  * <p>If no transaction factory is specified, the endpoint invocation  * will simply not be wrapped in an XA transaction. Check out your  * resource provider's ActivationSpec documentation for local  * transaction options of your particular provider.  * @see #setTransactionName  * @see #setTransactionTimeout  */ ;/**  * Set the Spring TransactionFactory to use for wrapping endpoint  * invocations, enlisting the endpoint resource in each such transaction.  * <p>Alternatively, specify an appropriate transaction manager through  * the {@link #setTransactionManager "transactionManager"} property.  * <p>If no transaction factory is specified, the endpoint invocation  * will simply not be wrapped in an XA transaction. Check out your  * resource provider's ActivationSpec documentation for local  * transaction options of your particular provider.  * @see #setTransactionName  * @see #setTransactionTimeout  */ public void setTransactionFactory(TransactionFactory transactionFactory) {     this.transactionFactory = transactionFactory. }
true;public;1;3;/**  * Specify the name of the transaction, if any.  * <p>Default is none. A specified name will be passed on to the transaction  * manager, allowing to identify the transaction in a transaction monitor.  */ ;/**  * Specify the name of the transaction, if any.  * <p>Default is none. A specified name will be passed on to the transaction  * manager, allowing to identify the transaction in a transaction monitor.  */ public void setTransactionName(String transactionName) {     this.transactionName = transactionName. }
true;public;1;3;/**  * Specify the transaction timeout, if any.  * <p>Default is -1: rely on the transaction manager's default timeout.  * Specify a concrete timeout to restrict the maximum duration of each  * endpoint invocation.  */ ;/**  * Specify the transaction timeout, if any.  * <p>Default is -1: rely on the transaction manager's default timeout.  * Specify a concrete timeout to restrict the maximum duration of each  * endpoint invocation.  */ public void setTransactionTimeout(int transactionTimeout) {     this.transactionTimeout = transactionTimeout. }
true;public;1;4;/**  * Set the name of this message endpoint. Populated with the bean name  * automatically when defined within Spring's bean factory.  */ ;/**  * Set the name of this message endpoint. Populated with the bean name  * automatically when defined within Spring's bean factory.  */ @Override public void setBeanName(String beanName) {     this.beanName = beanName. }
true;public;0;5;/**  * Implementation of the JCA 1.7 {@code #getActivationName()} method,  * returning the bean name as set on this MessageEndpointFactory.  * @see #setBeanName  */ ;/**  * Implementation of the JCA 1.7 {@code #getActivationName()} method,  * returning the bean name as set on this MessageEndpointFactory.  * @see #setBeanName  */ @Override @Nullable public String getActivationName() {     return this.beanName. }
true;public;0;5;/**  * Implementation of the JCA 1.7 {@code #getEndpointClass()} method,  * returning {@code} null in order to indicate a synthetic endpoint type.  */ ;/**  * Implementation of the JCA 1.7 {@code #getEndpointClass()} method,  * returning {@code} null in order to indicate a synthetic endpoint type.  */ @Override @Nullable public Class<?> getEndpointClass() {     return null. }
true;public;1;4;/**  * This implementation returns {@code true} if a transaction manager  * has been specified. {@code false} otherwise.  * @see #setTransactionManager  * @see #setTransactionFactory  */ ;/**  * This implementation returns {@code true} if a transaction manager  * has been specified. {@code false} otherwise.  * @see #setTransactionManager  * @see #setTransactionFactory  */ @Override public boolean isDeliveryTransacted(Method method) throws NoSuchMethodException {     return (this.transactionFactory != null). }
true;public;1;6;/**  * The standard JCA 1.5 version of {@code createEndpoint}.  * <p>This implementation delegates to {@link #createEndpointInternal()},  * initializing the endpoint's XAResource before the endpoint gets invoked.  */ ;/**  * The standard JCA 1.5 version of {@code createEndpoint}.  * <p>This implementation delegates to {@link #createEndpointInternal()},  * initializing the endpoint's XAResource before the endpoint gets invoked.  */ @Override public MessageEndpoint createEndpoint(XAResource xaResource) throws UnavailableException {     AbstractMessageEndpoint endpoint = createEndpointInternal().     endpoint.initXAResource(xaResource).     return endpoint. }
true;public;2;6;/**  * The alternative JCA 1.6 version of {@code createEndpoint}.  * <p>This implementation delegates to {@link #createEndpointInternal()},  * ignoring the specified timeout. It is only here for JCA 1.6 compliance.  */ ;/**  * The alternative JCA 1.6 version of {@code createEndpoint}.  * <p>This implementation delegates to {@link #createEndpointInternal()},  * ignoring the specified timeout. It is only here for JCA 1.6 compliance.  */ @Override public MessageEndpoint createEndpoint(XAResource xaResource, long timeout) throws UnavailableException {     AbstractMessageEndpoint endpoint = createEndpointInternal().     endpoint.initXAResource(xaResource).     return endpoint. }
true;protected,abstract;0;1;/**  * Create the actual endpoint instance, as a subclass of the  * {@link AbstractMessageEndpoint} inner class of this factory.  * @return the actual endpoint instance (never {@code null})  * @throws UnavailableException if no endpoint is available at present  */ ;/**  * Create the actual endpoint instance, as a subclass of the  * {@link AbstractMessageEndpoint} inner class of this factory.  * @return the actual endpoint instance (never {@code null})  * @throws UnavailableException if no endpoint is available at present  */ protected abstract AbstractMessageEndpoint createEndpointInternal() throws UnavailableException.
true;;1;3;/**  * Initialize this endpoint's TransactionDelegate.  * @param xaResource the XAResource for this endpoint  */ ;/**  * Initialize this endpoint's TransactionDelegate.  * @param xaResource the XAResource for this endpoint  */ void initXAResource(XAResource xaResource) {     this.transactionDelegate = new TransactionDelegate(xaResource). }
true;public;1;14;/**  * This {@code beforeDelivery} implementation starts a transaction,  * if necessary, and exposes the endpoint ClassLoader as current  * thread context ClassLoader.  * <p>Note that the JCA 1.7 specification does not require a ResourceAdapter  * to call this method before invoking the concrete endpoint. If this method  * has not been called (check {@link #hasBeforeDeliveryBeenCalled()}), the  * concrete endpoint method should call {@code beforeDelivery} and its  * sibling {@link #afterDelivery()} explicitly, as part of its own processing.  */ ;/**  * This {@code beforeDelivery} implementation starts a transaction,  * if necessary, and exposes the endpoint ClassLoader as current  * thread context ClassLoader.  * <p>Note that the JCA 1.7 specification does not require a ResourceAdapter  * to call this method before invoking the concrete endpoint. If this method  * has not been called (check {@link #hasBeforeDeliveryBeenCalled()}), the  * concrete endpoint method should call {@code beforeDelivery} and its  * sibling {@link #afterDelivery()} explicitly, as part of its own processing.  */ @Override public void beforeDelivery(@Nullable Method method) throws ResourceException {     this.beforeDeliveryCalled = true.     Assert.state(this.transactionDelegate != null, "Not initialized").     try {         this.transactionDelegate.beginTransaction().     } catch (Throwable ex) {         throw new ApplicationServerInternalException("Failed to begin transaction", ex).     }     Thread currentThread = Thread.currentThread().     this.previousContextClassLoader = currentThread.getContextClassLoader().     currentThread.setContextClassLoader(getEndpointClassLoader()). }
true;protected,abstract;0;1;/**  * Template method for exposing the endpoint's ClassLoader  * (typically the ClassLoader that the message listener class  * has been loaded with).  * @return the endpoint ClassLoader (never {@code null})  */ ;/**  * Template method for exposing the endpoint's ClassLoader  * (typically the ClassLoader that the message listener class  * has been loaded with).  * @return the endpoint ClassLoader (never {@code null})  */ protected abstract ClassLoader getEndpointClassLoader().
true;protected,final;0;3;/**  * Return whether the {@link #beforeDelivery} method of this endpoint  * has already been called.  */ ;/**  * Return whether the {@link #beforeDelivery} method of this endpoint  * has already been called.  */ protected final boolean hasBeforeDeliveryBeenCalled() {     return this.beforeDeliveryCalled. }
true;protected;1;5;/**  * Callback method for notifying the endpoint base class  * that the concrete endpoint invocation led to an exception.  * <p>To be invoked by subclasses in case of the concrete  * endpoint throwing an exception.  * @param ex the exception thrown from the concrete endpoint  */ ;/**  * Callback method for notifying the endpoint base class  * that the concrete endpoint invocation led to an exception.  * <p>To be invoked by subclasses in case of the concrete  * endpoint throwing an exception.  * @param ex the exception thrown from the concrete endpoint  */ protected void onEndpointException(Throwable ex) {     Assert.state(this.transactionDelegate != null, "Not initialized").     this.transactionDelegate.setRollbackOnly().     logger.debug("Transaction marked as rollback-only after endpoint exception", ex). }
true;public;0;14;/**  * This {@code afterDelivery} implementation resets the thread context  * ClassLoader and completes the transaction, if any.  * <p>Note that the JCA 1.7 specification does not require a ResourceAdapter  * to call this method after invoking the concrete endpoint. See the  * explanation in {@link #beforeDelivery}'s javadoc.  */ ;/**  * This {@code afterDelivery} implementation resets the thread context  * ClassLoader and completes the transaction, if any.  * <p>Note that the JCA 1.7 specification does not require a ResourceAdapter  * to call this method after invoking the concrete endpoint. See the  * explanation in {@link #beforeDelivery}'s javadoc.  */ @Override public void afterDelivery() throws ResourceException {     Assert.state(this.transactionDelegate != null, "Not initialized").     this.beforeDeliveryCalled = false.     Thread.currentThread().setContextClassLoader(this.previousContextClassLoader).     this.previousContextClassLoader = null.     try {         this.transactionDelegate.endTransaction().     } catch (Throwable ex) {         logger.warn("Failed to complete transaction after endpoint delivery", ex).         throw new ApplicationServerInternalException("Failed to complete transaction", ex).     } }
false;public;0;12;;@Override public void release() {     if (this.transactionDelegate != null) {         try {             this.transactionDelegate.setRollbackOnly().             this.transactionDelegate.endTransaction().         } catch (Throwable ex) {             logger.warn("Could not complete unfinished transaction on endpoint release", ex).         }     } }
false;public;0;6;;public void beginTransaction() throws Exception {     if (transactionFactory != null && this.xaResource != null) {         this.transaction = transactionFactory.createTransaction(transactionName, transactionTimeout).         this.transaction.enlistResource(this.xaResource).     } }
false;public;0;5;;public void setRollbackOnly() {     if (this.transaction != null) {         this.rollbackOnly = true.     } }
false;public;0;16;;public void endTransaction() throws Exception {     if (this.transaction != null) {         try {             if (this.rollbackOnly) {                 this.transaction.rollback().             } else {                 this.transaction.commit().             }         } finally {             this.transaction = null.             this.rollbackOnly = false.         }     } }
