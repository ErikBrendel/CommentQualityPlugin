commented;modifiers;parameterAmount;loc;comment;code
true;public;0;4;/**  * Return the underlying transaction object.  * @throws IllegalStateException if no transaction is active  */ ;/**  * Return the underlying transaction object.  * @throws IllegalStateException if no transaction is active  */ public Object getTransaction() {     Assert.state(this.transaction != null, "No transaction active").     return this.transaction. }
true;public;0;3;/**  * Return whether there is an actual transaction active.  */ ;/**  * Return whether there is an actual transaction active.  */ public boolean hasTransaction() {     return (this.transaction != null). }
false;public;0;4;;@Override public boolean isNewTransaction() {     return (hasTransaction() && this.newTransaction). }
true;public;0;3;/**  * Return if a new transaction synchronization has been opened  * for this transaction.  */ ;/**  * Return if a new transaction synchronization has been opened  * for this transaction.  */ public boolean isNewSynchronization() {     return this.newSynchronization. }
true;public;0;3;/**  * Return if this transaction is defined as read-only transaction.  */ ;/**  * Return if this transaction is defined as read-only transaction.  */ public boolean isReadOnly() {     return this.readOnly. }
true;public;0;3;/**  * Return whether the progress of this transaction is debugged. This is used by  * {@link AbstractPlatformTransactionManager} as an optimization, to prevent repeated  * calls to {@code logger.isDebugEnabled()}. Not really intended for client code.  */ ;/**  * Return whether the progress of this transaction is debugged. This is used by  * {@link AbstractPlatformTransactionManager} as an optimization, to prevent repeated  * calls to {@code logger.isDebugEnabled()}. Not really intended for client code.  */ public boolean isDebug() {     return this.debug. }
true;public;0;4;/**  * Return the holder for resources that have been suspended for this transaction,  * if any.  */ ;/**  * Return the holder for resources that have been suspended for this transaction,  * if any.  */ @Nullable public Object getSuspendedResources() {     return this.suspendedResources. }
true;public;0;5;/**  * Determine the rollback-only flag via checking the transaction object, provided  * that the latter implements the {@link SmartTransactionObject} interface.  * <p>Will return {@code true} if the global transaction itself has been marked  * rollback-only by the transaction coordinator, for example in case of a timeout.  * @see SmartTransactionObject#isRollbackOnly()  */ ;// --------------------------------------------------------------------- // Enable functionality through underlying transaction object // --------------------------------------------------------------------- /**  * Determine the rollback-only flag via checking the transaction object, provided  * that the latter implements the {@link SmartTransactionObject} interface.  * <p>Will return {@code true} if the global transaction itself has been marked  * rollback-only by the transaction coordinator, for example in case of a timeout.  * @see SmartTransactionObject#isRollbackOnly()  */ @Override public boolean isGlobalRollbackOnly() {     return ((this.transaction instanceof SmartTransactionObject) && ((SmartTransactionObject) this.transaction).isRollbackOnly()). }
true;public;0;6;/**  * Delegate the flushing to the transaction object, provided that the latter  * implements the {@link SmartTransactionObject} interface.  * @see SmartTransactionObject#flush()  */ ;/**  * Delegate the flushing to the transaction object, provided that the latter  * implements the {@link SmartTransactionObject} interface.  * @see SmartTransactionObject#flush()  */ @Override public void flush() {     if (this.transaction instanceof SmartTransactionObject) {         ((SmartTransactionObject) this.transaction).flush().     } }
true;protected;0;9;/**  * This implementation exposes the {@link SavepointManager} interface  * of the underlying transaction object, if any.  * @throws NestedTransactionNotSupportedException if savepoints are not supported  * @see #isTransactionSavepointManager()  */ ;/**  * This implementation exposes the {@link SavepointManager} interface  * of the underlying transaction object, if any.  * @throws NestedTransactionNotSupportedException if savepoints are not supported  * @see #isTransactionSavepointManager()  */ @Override protected SavepointManager getSavepointManager() {     Object transaction = this.transaction.     if (!(transaction instanceof SavepointManager)) {         throw new NestedTransactionNotSupportedException("Transaction object [" + this.transaction + "] does not support savepoints").     }     return (SavepointManager) transaction. }
true;public;0;3;/**  * Return whether the underlying transaction implements the {@link SavepointManager}  * interface and therefore supports savepoints.  * @see #getTransaction()  * @see #getSavepointManager()  */ ;/**  * Return whether the underlying transaction implements the {@link SavepointManager}  * interface and therefore supports savepoints.  * @see #getTransaction()  * @see #getSavepointManager()  */ public boolean isTransactionSavepointManager() {     return (this.transaction instanceof SavepointManager). }
