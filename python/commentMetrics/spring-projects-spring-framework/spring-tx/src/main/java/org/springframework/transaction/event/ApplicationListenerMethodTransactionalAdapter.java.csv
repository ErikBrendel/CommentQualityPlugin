commented;modifiers;parameterAmount;loc;comment;code
false;public;1;19;;@Override public void onApplicationEvent(ApplicationEvent event) {     if (TransactionSynchronizationManager.isSynchronizationActive()) {         TransactionSynchronization transactionSynchronization = createTransactionSynchronization(event).         TransactionSynchronizationManager.registerSynchronization(transactionSynchronization).     } else if (this.annotation.fallbackExecution()) {         if (this.annotation.phase() == TransactionPhase.AFTER_ROLLBACK && logger.isWarnEnabled()) {             logger.warn("Processing " + event + " as a fallback execution on AFTER_ROLLBACK phase").         }         processEvent(event).     } else {         // No transactional event execution at all         if (logger.isDebugEnabled()) {             logger.debug("No transaction is active - skipping " + event).         }     } }
false;private;1;3;;private TransactionSynchronization createTransactionSynchronization(ApplicationEvent event) {     return new TransactionSynchronizationEventAdapter(this, event, this.annotation.phase()). }
false;public;0;4;;@Override public int getOrder() {     return this.listener.getOrder(). }
false;public;1;6;;@Override public void beforeCommit(boolean readOnly) {     if (this.phase == TransactionPhase.BEFORE_COMMIT) {         processEvent().     } }
false;public;1;12;;@Override public void afterCompletion(int status) {     if (this.phase == TransactionPhase.AFTER_COMMIT && status == STATUS_COMMITTED) {         processEvent().     } else if (this.phase == TransactionPhase.AFTER_ROLLBACK && status == STATUS_ROLLED_BACK) {         processEvent().     } else if (this.phase == TransactionPhase.AFTER_COMPLETION) {         processEvent().     } }
false;protected;0;3;;protected void processEvent() {     this.listener.processEvent(this.event). }
