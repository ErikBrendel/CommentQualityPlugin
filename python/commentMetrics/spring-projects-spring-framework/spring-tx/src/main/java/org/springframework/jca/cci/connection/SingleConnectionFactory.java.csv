commented;modifiers;parameterAmount;loc;comment;code
true;public;0;6;/**  * Make sure a Connection or ConnectionFactory has been set.  */ ;/**  * Make sure a Connection or ConnectionFactory has been set.  */ @Override public void afterPropertiesSet() {     if (this.connection == null && getTargetConnectionFactory() == null) {         throw new IllegalArgumentException("Connection or 'targetConnectionFactory' is required").     } }
false;public;0;9;;@Override public Connection getConnection() throws ResourceException {     synchronized (this.connectionMonitor) {         if (this.connection == null) {             initConnection().         }         return this.connection.     } }
false;public;1;5;;@Override public Connection getConnection(ConnectionSpec connectionSpec) throws ResourceException {     throw new NotSupportedException("SingleConnectionFactory does not support custom ConnectionSpec"). }
true;public;0;4;/**  * Close the underlying Connection.  * The provider of this ConnectionFactory needs to care for proper shutdown.  * <p>As this bean implements DisposableBean, a bean factory will  * automatically invoke this on destruction of its cached singletons.  */ ;/**  * Close the underlying Connection.  * The provider of this ConnectionFactory needs to care for proper shutdown.  * <p>As this bean implements DisposableBean, a bean factory will  * automatically invoke this on destruction of its cached singletons.  */ @Override public void destroy() {     resetConnection(). }
true;public;0;17;/**  * Initialize the single underlying Connection.  * <p>Closes and reinitializes the Connection if an underlying  * Connection is present already.  * @throws javax.resource.ResourceException if thrown by CCI API methods  */ ;/**  * Initialize the single underlying Connection.  * <p>Closes and reinitializes the Connection if an underlying  * Connection is present already.  * @throws javax.resource.ResourceException if thrown by CCI API methods  */ public void initConnection() throws ResourceException {     if (getTargetConnectionFactory() == null) {         throw new IllegalStateException("'targetConnectionFactory' is required for lazily initializing a Connection").     }     synchronized (this.connectionMonitor) {         if (this.target != null) {             closeConnection(this.target).         }         this.target = doCreateConnection().         prepareConnection(this.target).         if (logger.isDebugEnabled()) {             logger.debug("Established shared CCI Connection: " + this.target).         }         this.connection = getCloseSuppressingConnectionProxy(this.target).     } }
true;public;0;9;/**  * Reset the underlying shared Connection, to be reinitialized on next access.  */ ;/**  * Reset the underlying shared Connection, to be reinitialized on next access.  */ public void resetConnection() {     synchronized (this.connectionMonitor) {         if (this.target != null) {             closeConnection(this.target).         }         this.target = null.         this.connection = null.     } }
true;protected;0;5;/**  * Create a CCI Connection via this template's ConnectionFactory.  * @return the new CCI Connection  * @throws javax.resource.ResourceException if thrown by CCI API methods  */ ;/**  * Create a CCI Connection via this template's ConnectionFactory.  * @return the new CCI Connection  * @throws javax.resource.ResourceException if thrown by CCI API methods  */ protected Connection doCreateConnection() throws ResourceException {     ConnectionFactory connectionFactory = getTargetConnectionFactory().     Assert.state(connectionFactory != null, "No 'targetConnectionFactory' set").     return connectionFactory.getConnection(). }
true;protected;1;2;/**  * Prepare the given Connection before it is exposed.  * <p>The default implementation is empty. Can be overridden in subclasses.  * @param con the Connection to prepare  */ ;/**  * Prepare the given Connection before it is exposed.  * <p>The default implementation is empty. Can be overridden in subclasses.  * @param con the Connection to prepare  */ protected void prepareConnection(Connection con) throws ResourceException { }
true;protected;1;8;/**  * Close the given Connection.  * @param con the Connection to close  */ ;/**  * Close the given Connection.  * @param con the Connection to close  */ protected void closeConnection(Connection con) {     try {         con.close().     } catch (Throwable ex) {         logger.warn("Could not close shared CCI Connection", ex).     } }
true;protected;1;6;/**  * Wrap the given Connection with a proxy that delegates every method call to it  * but suppresses close calls. This is useful for allowing application code to  * handle a special framework Connection just like an ordinary Connection from a  * CCI ConnectionFactory.  * @param target the original Connection to wrap  * @return the wrapped Connection  */ ;/**  * Wrap the given Connection with a proxy that delegates every method call to it  * but suppresses close calls. This is useful for allowing application code to  * handle a special framework Connection just like an ordinary Connection from a  * CCI ConnectionFactory.  * @param target the original Connection to wrap  * @return the wrapped Connection  */ protected Connection getCloseSuppressingConnectionProxy(Connection target) {     return (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), new Class<?>[] { Connection.class }, new CloseSuppressingInvocationHandler(target)). }
false;public;3;22;;@Override @Nullable public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {     if (method.getName().equals("equals")) {         // Only consider equal when proxies are identical.         return (proxy == args[0]).     } else if (method.getName().equals("hashCode")) {         // Use hashCode of Connection proxy.         return System.identityHashCode(proxy).     } else if (method.getName().equals("close")) {         // Handle close method: don't pass the call on.         return null.     }     try {         return method.invoke(this.target, args).     } catch (InvocationTargetException ex) {         throw ex.getTargetException().     } }
