commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * Set a name/attribute map, consisting of "FQCN.method" method names  * (e.g. "com.mycompany.mycode.MyClass.myMethod") and  * {@link TransactionAttribute} instances (or Strings to be converted  * to {@code TransactionAttribute} instances).  * <p>Intended for configuration via setter injection, typically within  * a Spring bean factory. Relies on {@link #afterPropertiesSet()}  * being called afterwards.  * @param methodMap said {@link Map} from method name to attribute value  * @see TransactionAttribute  * @see TransactionAttributeEditor  */ ;/**  * Set a name/attribute map, consisting of "FQCN.method" method names  * (e.g. "com.mycompany.mycode.MyClass.myMethod") and  * {@link TransactionAttribute} instances (or Strings to be converted  * to {@code TransactionAttribute} instances).  * <p>Intended for configuration via setter injection, typically within  * a Spring bean factory. Relies on {@link #afterPropertiesSet()}  * being called afterwards.  * @param methodMap said {@link Map} from method name to attribute value  * @see TransactionAttribute  * @see TransactionAttributeEditor  */ public void setMethodMap(Map<String, TransactionAttribute> methodMap) {     this.methodMap = methodMap. }
false;public;1;4;;@Override public void setBeanClassLoader(ClassLoader beanClassLoader) {     this.beanClassLoader = beanClassLoader. }
true;public;0;6;/**  * Eagerly initializes the specified  * {@link #setMethodMap(java.util.Map) "methodMap"}, if any.  * @see #initMethodMap(java.util.Map)  */ ;/**  * Eagerly initializes the specified  * {@link #setMethodMap(java.util.Map) "methodMap"}, if any.  * @see #initMethodMap(java.util.Map)  */ @Override public void afterPropertiesSet() {     initMethodMap(this.methodMap).     this.eagerlyInitialized = true.     this.initialized = true. }
true;protected;1;5;/**  * Initialize the specified {@link #setMethodMap(java.util.Map) "methodMap"}, if any.  * @param methodMap a Map from method names to {@code TransactionAttribute} instances  * @see #setMethodMap  */ ;/**  * Initialize the specified {@link #setMethodMap(java.util.Map) "methodMap"}, if any.  * @param methodMap a Map from method names to {@code TransactionAttribute} instances  * @see #setMethodMap  */ protected void initMethodMap(@Nullable Map<String, TransactionAttribute> methodMap) {     if (methodMap != null) {         methodMap.forEach(this::addTransactionalMethod).     } }
true;public;2;11;/**  * Add an attribute for a transactional method.  * <p>Method names can end or start with "*" for matching multiple methods.  * @param name class and method name, separated by a dot  * @param attr attribute associated with the method  * @throws IllegalArgumentException in case of an invalid name  */ ;/**  * Add an attribute for a transactional method.  * <p>Method names can end or start with "*" for matching multiple methods.  * @param name class and method name, separated by a dot  * @param attr attribute associated with the method  * @throws IllegalArgumentException in case of an invalid name  */ public void addTransactionalMethod(String name, TransactionAttribute attr) {     Assert.notNull(name, "Name must not be null").     int lastDotIndex = name.lastIndexOf('.').     if (lastDotIndex == -1) {         throw new IllegalArgumentException("'" + name + "' is not a valid method name: format is FQN.methodName").     }     String className = name.substring(0, lastDotIndex).     String methodName = name.substring(lastDotIndex + 1).     Class<?> clazz = ClassUtils.resolveClassName(className, this.beanClassLoader).     addTransactionalMethod(clazz, methodName, attr). }
true;public;3;38;/**  * Add an attribute for a transactional method.  * Method names can end or start with "*" for matching multiple methods.  * @param clazz target interface or class  * @param mappedName mapped method name  * @param attr attribute associated with the method  */ ;/**  * Add an attribute for a transactional method.  * Method names can end or start with "*" for matching multiple methods.  * @param clazz target interface or class  * @param mappedName mapped method name  * @param attr attribute associated with the method  */ public void addTransactionalMethod(Class<?> clazz, String mappedName, TransactionAttribute attr) {     Assert.notNull(clazz, "Class must not be null").     Assert.notNull(mappedName, "Mapped name must not be null").     String name = clazz.getName() + '.' + mappedName.     Method[] methods = clazz.getDeclaredMethods().     List<Method> matchingMethods = new ArrayList<>().     for (Method method : methods) {         if (isMatch(method.getName(), mappedName)) {             matchingMethods.add(method).         }     }     if (matchingMethods.isEmpty()) {         throw new IllegalArgumentException("Couldn't find method '" + mappedName + "' on class [" + clazz.getName() + "]").     }     // Register all matching methods     for (Method method : matchingMethods) {         String regMethodName = this.methodNameMap.get(method).         if (regMethodName == null || (!regMethodName.equals(name) && regMethodName.length() <= name.length())) {             // method name specification now -> (re-)register method.             if (logger.isDebugEnabled() && regMethodName != null) {                 logger.debug("Replacing attribute for transactional method [" + method + "]: current name '" + name + "' is more specific than '" + regMethodName + "'").             }             this.methodNameMap.put(method, name).             addTransactionalMethod(method, attr).         } else {             if (logger.isDebugEnabled()) {                 logger.debug("Keeping attribute for transactional method [" + method + "]: current name '" + name + "' is not more specific than '" + regMethodName + "'").             }         }     } }
true;public;2;8;/**  * Add an attribute for a transactional method.  * @param method the method  * @param attr attribute associated with the method  */ ;/**  * Add an attribute for a transactional method.  * @param method the method  * @param attr attribute associated with the method  */ public void addTransactionalMethod(Method method, TransactionAttribute attr) {     Assert.notNull(method, "Method must not be null").     Assert.notNull(attr, "TransactionAttribute must not be null").     if (logger.isDebugEnabled()) {         logger.debug("Adding transactional method [" + method + "] with attribute [" + attr + "]").     }     this.transactionAttributeMap.put(method, attr). }
true;protected;2;3;/**  * Return if the given method name matches the mapped name.  * <p>The default implementation checks for "xxx*", "*xxx" and "*xxx*"  * matches, as well as direct equality.  * @param methodName the method name of the class  * @param mappedName the name in the descriptor  * @return if the names match  * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)  */ ;/**  * Return if the given method name matches the mapped name.  * <p>The default implementation checks for "xxx*", "*xxx" and "*xxx*"  * matches, as well as direct equality.  * @param methodName the method name of the class  * @param mappedName the name in the descriptor  * @return if the names match  * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)  */ protected boolean isMatch(String methodName, String mappedName) {     return PatternMatchUtils.simpleMatch(mappedName, methodName). }
false;public;2;16;;@Override @Nullable public TransactionAttribute getTransactionAttribute(Method method, @Nullable Class<?> targetClass) {     if (this.eagerlyInitialized) {         return this.transactionAttributeMap.get(method).     } else {         synchronized (this.transactionAttributeMap) {             if (!this.initialized) {                 initMethodMap(this.methodMap).                 this.initialized = true.             }             return this.transactionAttributeMap.get(method).         }     } }
false;public;1;11;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (!(other instanceof MethodMapTransactionAttributeSource)) {         return false.     }     MethodMapTransactionAttributeSource otherTas = (MethodMapTransactionAttributeSource) other.     return ObjectUtils.nullSafeEquals(this.methodMap, otherTas.methodMap). }
false;public;0;4;;@Override public int hashCode() {     return MethodMapTransactionAttributeSource.class.hashCode(). }
false;public;0;4;;@Override public String toString() {     return getClass().getName() + ": " + this.methodMap. }
