commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Specify the JCA WorkManager instance to delegate to.  */ ;/**  * Specify the JCA WorkManager instance to delegate to.  */ public void setWorkManager(WorkManager workManager) {     Assert.notNull(workManager, "WorkManager must not be null").     this.workManager = workManager. }
true;public;1;3;/**  * Set the JNDI name of the JCA WorkManager.  * <p>This can either be a fully qualified JNDI name,  * or the JNDI name relative to the current environment  * naming context if "resourceRef" is set to "true".  * @see #setWorkManager  * @see #setResourceRef  */ ;/**  * Set the JNDI name of the JCA WorkManager.  * <p>This can either be a fully qualified JNDI name,  * or the JNDI name relative to the current environment  * naming context if "resourceRef" is set to "true".  * @see #setWorkManager  * @see #setResourceRef  */ public void setWorkManagerName(String workManagerName) {     this.workManagerName = workManagerName. }
true;public;1;5;/**  * Specify the JCA BootstrapContext that contains the  * WorkManager to delegate to.  */ ;/**  * Specify the JCA BootstrapContext that contains the  * WorkManager to delegate to.  */ @Override public void setBootstrapContext(BootstrapContext bootstrapContext) {     Assert.notNull(bootstrapContext, "BootstrapContext must not be null").     this.workManager = bootstrapContext.getWorkManager(). }
true;public;1;3;/**  * Set whether to let {@link #execute} block until the work  * has been actually started.  * <p>Uses the JCA {@code startWork} operation underneath,  * instead of the default {@code scheduleWork}.  * @see javax.resource.spi.work.WorkManager#startWork  * @see javax.resource.spi.work.WorkManager#scheduleWork  */ ;/**  * Set whether to let {@link #execute} block until the work  * has been actually started.  * <p>Uses the JCA {@code startWork} operation underneath,  * instead of the default {@code scheduleWork}.  * @see javax.resource.spi.work.WorkManager#startWork  * @see javax.resource.spi.work.WorkManager#scheduleWork  */ public void setBlockUntilStarted(boolean blockUntilStarted) {     this.blockUntilStarted = blockUntilStarted. }
true;public;1;3;/**  * Set whether to let {@link #execute} block until the work  * has been completed.  * <p>Uses the JCA {@code doWork} operation underneath,  * instead of the default {@code scheduleWork}.  * @see javax.resource.spi.work.WorkManager#doWork  * @see javax.resource.spi.work.WorkManager#scheduleWork  */ ;/**  * Set whether to let {@link #execute} block until the work  * has been completed.  * <p>Uses the JCA {@code doWork} operation underneath,  * instead of the default {@code scheduleWork}.  * @see javax.resource.spi.work.WorkManager#doWork  * @see javax.resource.spi.work.WorkManager#scheduleWork  */ public void setBlockUntilCompleted(boolean blockUntilCompleted) {     this.blockUntilCompleted = blockUntilCompleted. }
true;public;1;3;/**  * Specify a JCA WorkListener to apply, if any.  * <p>This shared WorkListener instance will be passed on to the  * WorkManager by all {@link #execute} calls on this TaskExecutor.  */ ;/**  * Specify a JCA WorkListener to apply, if any.  * <p>This shared WorkListener instance will be passed on to the  * WorkManager by all {@link #execute} calls on this TaskExecutor.  */ public void setWorkListener(@Nullable WorkListener workListener) {     this.workListener = workListener. }
true;public;1;3;/**  * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}  * about to be executed.  * <p>Note that such a decorator is not necessarily being applied to the  * user-supplied {@code Runnable}/{@code Callable} but rather to the actual  * execution callback (which may be a wrapper around the user-supplied task).  * <p>The primary use case is to set some execution context around the task's  * invocation, or to provide some monitoring/statistics for task execution.  * @since 4.3  */ ;/**  * Specify a custom {@link TaskDecorator} to be applied to any {@link Runnable}  * about to be executed.  * <p>Note that such a decorator is not necessarily being applied to the  * user-supplied {@code Runnable}/{@code Callable} but rather to the actual  * execution callback (which may be a wrapper around the user-supplied task).  * <p>The primary use case is to set some execution context around the task's  * invocation, or to provide some monitoring/statistics for task execution.  * @since 4.3  */ public void setTaskDecorator(TaskDecorator taskDecorator) {     this.taskDecorator = taskDecorator. }
false;public;0;11;;@Override public void afterPropertiesSet() throws NamingException {     if (this.workManager == null) {         if (this.workManagerName != null) {             this.workManager = lookup(this.workManagerName, WorkManager.class).         } else {             this.workManager = getDefaultWorkManager().         }     } }
true;protected;0;3;/**  * Obtain a default WorkManager to delegate to.  * Called if no explicit WorkManager or WorkManager JNDI name has been specified.  * <p>The default implementation returns a {@link SimpleTaskWorkManager}.  * Can be overridden in subclasses.  */ ;/**  * Obtain a default WorkManager to delegate to.  * Called if no explicit WorkManager or WorkManager JNDI name has been specified.  * <p>The default implementation returns a {@link SimpleTaskWorkManager}.  * Can be overridden in subclasses.  */ protected WorkManager getDefaultWorkManager() {     return new SimpleTaskWorkManager(). }
false;private;0;4;;private WorkManager obtainWorkManager() {     Assert.state(this.workManager != null, "No WorkManager specified").     return this.workManager. }
false;public;1;4;;// ------------------------------------------------------------------------- // Implementation of the Spring SchedulingTaskExecutor interface // ------------------------------------------------------------------------- @Override public void execute(Runnable task) {     execute(task, TIMEOUT_INDEFINITE). }
false;public;2;41;;@Override public void execute(Runnable task, long startTimeout) {     Work work = new DelegatingWork(this.taskDecorator != null ? this.taskDecorator.decorate(task) : task).     try {         if (this.blockUntilCompleted) {             if (startTimeout != TIMEOUT_INDEFINITE || this.workListener != null) {                 obtainWorkManager().doWork(work, startTimeout, null, this.workListener).             } else {                 obtainWorkManager().doWork(work).             }         } else if (this.blockUntilStarted) {             if (startTimeout != TIMEOUT_INDEFINITE || this.workListener != null) {                 obtainWorkManager().startWork(work, startTimeout, null, this.workListener).             } else {                 obtainWorkManager().startWork(work).             }         } else {             if (startTimeout != TIMEOUT_INDEFINITE || this.workListener != null) {                 obtainWorkManager().scheduleWork(work, startTimeout, null, this.workListener).             } else {                 obtainWorkManager().scheduleWork(work).             }         }     } catch (WorkRejectedException ex) {         if (WorkException.START_TIMED_OUT.equals(ex.getErrorCode())) {             throw new TaskTimeoutException("JCA WorkManager rejected task because of timeout: " + task, ex).         } else {             throw new TaskRejectedException("JCA WorkManager rejected task: " + task, ex).         }     } catch (WorkException ex) {         throw new SchedulingException("Could not schedule task on JCA WorkManager", ex).     } }
false;public;1;6;;@Override public Future<?> submit(Runnable task) {     FutureTask<Object> future = new FutureTask<>(task, null).     execute(future, TIMEOUT_INDEFINITE).     return future. }
false;public;1;6;;@Override public <T> Future<T> submit(Callable<T> task) {     FutureTask<T> future = new FutureTask<>(task).     execute(future, TIMEOUT_INDEFINITE).     return future. }
false;public;1;6;;@Override public ListenableFuture<?> submitListenable(Runnable task) {     ListenableFutureTask<Object> future = new ListenableFutureTask<>(task, null).     execute(future, TIMEOUT_INDEFINITE).     return future. }
false;public;1;6;;@Override public <T> ListenableFuture<T> submitListenable(Callable<T> task) {     ListenableFutureTask<T> future = new ListenableFutureTask<>(task).     execute(future, TIMEOUT_INDEFINITE).     return future. }
false;public;1;4;;// ------------------------------------------------------------------------- // Implementation of the JCA WorkManager interface // ------------------------------------------------------------------------- @Override public void doWork(Work work) throws WorkException {     obtainWorkManager().doWork(work). }
false;public;4;6;;@Override public void doWork(Work work, long delay, ExecutionContext executionContext, WorkListener workListener) throws WorkException {     obtainWorkManager().doWork(work, delay, executionContext, workListener). }
false;public;1;4;;@Override public long startWork(Work work) throws WorkException {     return obtainWorkManager().startWork(work). }
false;public;4;6;;@Override public long startWork(Work work, long delay, ExecutionContext executionContext, WorkListener workListener) throws WorkException {     return obtainWorkManager().startWork(work, delay, executionContext, workListener). }
false;public;1;4;;@Override public void scheduleWork(Work work) throws WorkException {     obtainWorkManager().scheduleWork(work). }
false;public;4;6;;@Override public void scheduleWork(Work work, long delay, ExecutionContext executionContext, WorkListener workListener) throws WorkException {     obtainWorkManager().scheduleWork(work, delay, executionContext, workListener). }
